(function() {
    
    mstrmojo.StringBuffer = mstrmojo.declare(
        null, 
        null,
        
        {
            scriptClass: 'mstrmojo.StringBuffer',
            
            
            append: function append(txt) {
                if (!this.buf) {
                    this.reset();
                }
                this.buf[++this.len] = txt;
                return this; 
            },
            
            
            reset: function reset() {
                this.buf = [];
                this.len = -1;
            }
        }
    );

        
    mstrmojo.StringBuffer.prototype.toString = function(sep) {
        var buf = this.buf;
        return (buf && buf.join(sep || '')) || '';         
    }
})();
mstrmojo.android.EnumOrientationTypes = {
    PORTRAIT: 1,
    LANDSCAPE: 2
};
(function() {
	mstrmojo._Fetchable = mstrmojo.provide(
			'mstrmojo._Fetchable',
			{
				_mixinName: 'mstrmojo._Fetchable',
				
				blockBegin: 1,
				
				blockCount: -1,
				
				concat: false,
				
				items: null,
				
				size: function size() {
					return this.items == null ? 0 : this.items.length;
				},
				
				totalSize: function totalSize() {
					return this.totalSize;
				},
				
				next: function(callbacks) {
					
					if (this.hasNext()) {
						this.getItems(this.blockBegin + this.blockCount, callbacks);
					}
					
				},
				
				previous: function(callbacks) {
					
					if (this.hasPrevious()) {
						var bb = this.blockBegin - this.blockCount;
						bb = bb < 0 ? 0 : bb;
						this.getItems(bb, callbacks);
					}
					
				},
				
				getItems: function(bb, callbacks){
                    callbacks = callbacks || {};
					var me = this,
					    fnEmpty = mstrmojo.emptyFn,
					    fnSuccess = callbacks.success || fnEmpty,
					    fnFail = callbacks.failure || fnEmpty;
					
					this._retrieveItems(bb, {
						
						success: function(res){
							me.blockBegin = bb;
							
							me.set('items', (me.concat? (me.items || []).concat(res.items) : res.items));
							if (res.totalSize) {
								me.totalSize = res.totalSize;
							}
							fnSuccess(me, res.items);
						},
						failure: function(res){
						    fnFail(res);
						}
					});
				},
				
				_retrieveItems: function() {
					alert("Object which mixes in this mixin has not implemented this method - _retrieveItems().");
				},
				
				hasNext: function() {
					return (((this.concat? 1 : this.blockBegin) + (this.items && this.items.length || 0)) < (this.totalSize + 1));
				},
				
				hasPrevious: function() {
					return this.blockBegin > 1;
				}
			}
	);
})();

(function(){


	mstrmojo._IsGraphDataService = mstrmojo.provide(
			"mstrmojo._IsGraphDataService",

			
			{
				handleUserSingleTap: function handleUserSingleTap(sliceID, nodekey, x, y, selectable, callback) {
					if(mstrApp.onMobileDevice()) {
						mstrApp.serverRequest({
							taskId: 'handleUserSingleTap',
							sliceID: sliceID,
							nodekey: nodekey,
							x: x,
							y: y,
							selectable: selectable
						}, callback);
					}
				}

			});
}());
(function () {
    
    function _shouldRenderSec(x, y, left, right, top, bottom, orH) {
        if (y > bottom) {
            return false;
        }
        return (!orH) ||
            (x === 0) ||
            
            
            
            ((x < right) && (y >= top - (bottom - top)));
    }

    
    function _shouldRenderSub(ss, x, y, left, right, top, bottom, orH) {
        if (y > bottom) {
            return false;
        }

        
        return (!orH) || ((x < right) && (y >= top - ss.height()));
    }

    
    function _fireRender(w, parent, bBuildCh) {
        
        w.renderMode = "scroll";
        w.render();
        w.numChildrenRendered = 0;
        parent.numChildrenRendered++;

        
        if (bBuildCh && !w.builtChildren) {
            w.buildChildren();
        }
    }

    
    function getScrollBuffer() {
        return this.useScrollBuffer ? this.scrollBuffer : 0;
    }

    
    mstrmojo._CanRenderDocOnScroll = mstrmojo.provide(
        "mstrmojo._CanRenderDocOnScroll",
        {
            _mixinName: 'mstrmojo._CanRenderDocOnScroll',

            
            renderMode: 'scroll',

            
            scrollBuffer: 0,

            
            postBuildRendering: function postBuildRendering() {
                if (this.renderMode === null) {
                    return this._super();
                } else {
                    this.renderChildren();
                    return true;
                }
            },

            
            childRenderOnAddCheck: function (children) {
                if (this.renderMode === null) {
                    return this._super(children);
                } else {
                    return false;
                }
            },

            
            renderChildren: function renderChildren() {

                var own;

                if (this.renderMode === "scroll") {
                    
                    
                    var anc = this;
                    while (anc) {
                        if (anc.scrollboxNode && (anc.scrollboxWidthFixed || anc.scrollboxHeightFixed) && anc.connectScrollbox) {
                            own = anc;
                            break;
                        }
                        anc = anc.parent;
                    }
                }

                
                
                if ((this.renderMode !== "scroll") || !own) {
                    this._super();
                    return;
                }

                if (this.containerNode) {
                    
                    
                    this.scrollboxOwner = own;
                    own.connectScrollbox(this);

                    
                    this.numChildrenRendered = 0;
                    var len = this.numChildren;
                    if (len === undefined) {
                        
                        this.numChildren = len = this._getModelChildNodes(this.node, false, 0, 0, true).total;
                    }

                    
                    
                    this.sectionsToRender = len;
                    this.subsectionsToRender = 0;

                    
                    if (len) {
                        this._startSubsectionThread(false);
                    }
                }
                if (this.resizeOrReposition) {
                    this.resizeOrReposition();
                }
            },

            
            onscroll: function onscroll() {
                if (!this.renderingSubsections) {
                    
                    this.useScrollBuffer = true;

                    this._startSubsectionThread(true);
                }
            },

            
            _startSubsectionThread: function _stSbsThd( bPauseBeforeCtls) {
                
                var me = this;

                
                var fnClearIntv = function (n, bIsTimeout) {
                    if (me[n]) {
                        if (bIsTimeout) {
                            self.clearTimeout(me[n]);
                        } else {
                            self.clearInterval(me[n]);
                        }
                        delete me[n];
                    }
                };

                
                
                var fnCleanUp = function ( bPause) {
                    me.renderingSubsections = false;
                    var fn = function () {
                            fnClearIntv('renderCtlsTimer');
                            me.showRenderStatus(false);
                            me.renderCtrlsInViewport();
                            
                            
                            me.raiseEvent({name: 'afterScroll'});
                            me = null;
                        };
                    if (bPause) {
                        me.renderCtlsTimer = self.setTimeout(
                            fn,
                            me.scrollboxOwner.scrollInterval + 1
                        );
                    } else {
                        fn();
                    }
                };

                
                fnClearIntv('renderSubsTimer');
                fnClearIntv('renderCtlsTimer', true);

                this.renderingSubsections = true;

                
                
                if ((this.sectionsToRender || this.subsectionsToRender) && !this._renderSubsectionsToScroll()) {
                    this.showRenderStatus(true);
                    this.renderSubsTimer = self.setInterval(
                        function () {
                            if (me._renderSubsectionsToScroll()) {
                                fnClearIntv('renderSubsTimer');
                                fnCleanUp(bPauseBeforeCtls);
                            } else {
                                me.showRenderStatus(true);
                            }
                        },
                        this.scrollboxOwner.scrollInterval
                    );
                } else {

                    fnCleanUp(bPauseBeforeCtls);
                }
            },

            
            showRenderStatus: function shwRndrSts(show, msg) {
                var p = this.parent;
                if (!p || !p.showStatus) {
                    return;
                }

                var txt = msg,
                    per;
                if (show) {
                    
                    var num = this.numChildrenRendered,
                        tot = this.numChildren;

                    per = tot && parseInt(100 * num / tot, 10);
                    txt = "*Rendering section " + num + " of " + tot + ".*";    
                }
                p.showStatus(show, txt, per);
            },

            
            _renderSubsectionsToScroll: function rndSubs2Scll() {
                var own = this.scrollboxOwner,
                    top = own.scrollboxTop,
                    left = own.scrollboxLeft,
                    bottom = own.scrollboxBottom + getScrollBuffer.call(this),
                    right = own.scrollboxRight,
                    height = bottom - top,
                    x = 0,
                    y = 0,
                    yStart = null,
                    yStop = null,
                    forcedH, sidx;

                
                function _updateStart() {
                    yStart = y;
                    yStop = yStart + height;
                }

                var secsCount = this.numChildren,
                    secs = this.children || [],
                    model = this.model,
                    node = this.node,
                    orH = false;        

                
                for (sidx = 0; sidx < secsCount; sidx++) {

                    
                    var sec = secs[sidx];
                    if (!sec) {
                        
                        sec = this.addChildren(this.builder.build(
                            this._getModelChildNodes(node, false, sidx, 1, true).nodes,
                            model
                        ))[0];
                        
                        secs = this.children || [];
                    }

                    
                    var orWas = orH;

                    
                    orH = !!sec.defn.horiz;

                    
                    
                    forcedH = (sidx > 0 && sec.node.data.bh);

                    
                    
                    if ((!orH && orWas) || (forcedH && orWas)) {
                        
                        x = 0;

                        
                        y += secs[sidx - 1].height();

                        
                        if (y > bottom) {
                            
                            return true;

                        } else if ((yStop !== null) && (y > yStop)) {
                            
                            
                            return false;
                        }
                    }

                    
                    if (!sec.hasRendered) {
                        
                        if (!_shouldRenderSec(x, y, left, right, top, bottom, orH)) {
                            
                            if (orH) {
                                
                                continue;
                            } else {
                                
                                return true;
                            }
                        }

                        this._renderSection(sec, sidx);

                        this.sectionsToRender--;
                        this.subsectionsToRender += (sec.children && sec.children.length) || 0;

                        
                        if (yStart === null) {
                            _updateStart();
                        }
                    }

                    
                    var ssch = sec.children || [],
                        ss = null,
                        ssidx, sslen;

                    for (ssidx = 0, sslen = ssch.length; ssidx < sslen; ssidx++) {
                        
                        ss = ssch[ssidx];
                        
                        if (!ss.hasRendered) {
                            if (!_shouldRenderSub(ss, x, y, left, right, top, bottom, orH)) {
                                
                                if (orH) {
                                    
                                    break;
                                } else {
                                    
                                    return true;
                                }
                            }
                            
                            _fireRender(ss, sec);
                            this.subsectionsToRender--;
                            
                            if (yStart === null) {
                                _updateStart();
                            }
                        }
                        
                        
                        
                        if (orH) {
                            x += ss.width();
                            
                            
                            if (x > right) {
                                break;
                            }
                        } else {
                            y += ss.height();
                            
                            if (y > bottom) {
                                
                                return true;
                            } else if ((yStop !== null) && (y > yStop)) {
                                
                                
                                return false;
                            }
                        }
                    }    
                } 

                
                return true;
            },

            _renderSection: function _renderSection(sec, sidx) {
                
                _fireRender(sec, this, true);
            },

            
            _getModelChildNodes: function (node, isPartial, start, count, includeTotal) {
                return this.model.getChildren(node, isPartial, start, count, includeTotal);
            },
            
            renderCtrlsInViewport: function rnCtlsInVw() {
                var own = this.scrollboxOwner,
                    top = own.scrollboxTop,
                    left = own.scrollboxLeft,
                    bottom = own.scrollboxBottom + getScrollBuffer.call(this),
                    right = own.scrollboxRight,
                    x = 0,
                    y = 0,
                    orH = false,
                    secs = this.children || [],
                    orWas,
                    forcedH, sidx, secCount;

                
                var fnIncSize = function (ss) {
                    if (orH) {
                        x += ss.width();
                    } else {
                        y += ss.height();
                    }
                };

                
                var fnCtlInt = function (s, cx, cs, vs, ve) {
                    
                    cx = parseInt(cx, 10) || 0;
                    cs = parseInt(cs, 10);

                    return (isNaN(cs)) ? (s + cx <= ve) : mstrmojo.boxmodel.rangeIntersect(s + cx, s + cx + cs, vs, ve);
                };

                
                for (sidx = 0, secCount = (secs && secs.length) || 0; sidx < secCount; sidx++) {
                    var sec = secs[sidx];
                    
                    orWas = orH;

                    
                    orH = !!sec.defn.horiz;

                    
                    
                    forcedH = (sidx > 0 && sec.node.data.bh);

                    
                    
                    if ((!orH && orWas) || (forcedH && orWas)) {
                        
                        x = 0;
                        
                        y += secs[sidx - 1].height();
                        
                        if (y > bottom) {
                            
                            return;
                        }
                    }

                    
                    if (!sec.hasRendered) {
                        if (!orH) {
                            return;    
                        } else {
                            continue;    
                        }
                    }
                    
                    var subs = sec.children,
                        ssCount = (subs && subs.length) || 0,
                        ssidx,
                        ss;

                    
                    for (ssidx = 0; ssidx < ssCount; ssidx++) {
                        ss = subs[ssidx];
                        if (!ss.hasRendered) {
                            break;    
                        }

                        
                        if (ss.builtChildren && (ss.numChildrenRendered === ((ss.children && ss.children.length) || 0))) {
                            
                            fnIncSize(ss);

                        } else {
                            
                            if ((y + ss.height() >= top) && (!orH || (x + ss.width() >= left))) {

                                
                                var chdn = ss.children,
                                    chLen = (chdn && chdn.length) || 0;

                                if (!chLen && !ss.builtChildren) {
                                    ss.buildChildren();
                                    chdn = ss.children;    
                                    chLen = (chdn && chdn.length) || 0; 
                                }

                                
                                var rc = [],
                                    i;

                                
                                for (i = 0; i < chLen; i++) {
                                    var c = chdn[i];
                                    if (c.hasRendered) {
                                        continue;
                                    }

                                    var cf = c.getFormats() || {};
                                    
                                    if (fnCtlInt(y, cf.top, cf.height, top, bottom) && fnCtlInt(x, cf.left, cf.width, left, right)) {
                                        c.render();
                                        rc.push(c);
                                    }
                                }

                                
                                ss.performCanGrowCanShrink(rc, true);
                            }

                            
                            fnIncSize(ss);
                        }

                        if ((orH && x > right) || (!orH && y > bottom)) {
                            break;    
                        }
                    }
                }
            },

            
            unrender: function unrdr(ignoreDom) {
                var own = this.scrollboxOwner;
                if (own) {
                    own.disconnectScrollbox(this);
                }
                this._super(ignoreDom);
            }
        }
    );
}());
(function () {

    
    mstrmojo.android._HasLingeringListSelections = mstrmojo.provide(

        "mstrmojo.android._HasLingeringListSelections",

        
        {
            _mixinName: 'mstrmojo.android._HasLingeringListSelections',

            
            selectionPolicy: 'reselect',

            
            noLinger: false,

            
            canItemLinger: function canItemLinger(item) {
                return true;
            },

            
            setClearHandler: function setClearHandler(delay) {
                
                if (this.noLinger) {
                    
                    return;
                }
                
                var idx = this.selectedIndex,
                    id = this.id;

                
                if (idx > -1 && this.canItemLinger(this.items[idx])) {
                    
                    this._clearHandler = window.setTimeout(function () {
                        var list = mstrmojo.all[id];

                        
                        if (list) {
                            
                            if (list.selectedIndex === idx) {
                                
                                list.clearSelect();
                            }
                            
                            delete list._clearHandler;
                        }

                    }, delay);
                }
            },

            
            postBuildRendering: function postBuildRendering() {
                this._super();

                
                this.setClearHandler(800);
            },

            
            preselectionChange: function preselectionChange(evt) {
                
                var selectionHandler = this._clearHandler;
                if (selectionHandler) {
                    
                    window.clearTimeout(selectionHandler);

                    
                    delete this._clearHandler;
                }
            }
        }
    );
}());
(function() {

	var DefaultColor = {
			Min: 0xf23225,
			Max: 0x16b932,
			
			Invalid: 0x000000,
            NoColorMetric: 0xf5f5f7
		};
	var BandDirection = {
			LeftToRight: 0,
			RightToLeft: 1,
			Center: 2,
			None: 3
		};

	function getColorInRange(i, s, e){
		if(i < 0 || i > 1){
			return 0x000000;
		}
		var range = 256,
			index = i*range,
			r, g, b,
			sR = s>>16,
			eR = e>>16,
			sG = (s&0xff00)>>8,
			eG = (e&0xff00)>>8,
			sB = (s&0x00ff),
			eB = (e&0x00ff);
		r = sR+Math.floor((index*(eR-sR)/range));
		g = sG+Math.floor((index*(eG-sG)/range));
		b = sB+Math.floor((index*(eB-sB)/range));
		return	b + (g<<8) + (r<<16);
	}

	function darkerHex(h, p){
		var r = h>>16,
			g = (h&0x00ff00)>>8,
			b = (h&0x0000ff);

		r = Math.floor((1-p)*r);
		g = Math.floor((1-p)*g);
		b = Math.floor((1-p)*b);
		return b + (g<<8) + (r<<16);
	}


	function convertBlendToBand(bl){
		var ba = [],
			blc, bac,
			dp = bl.dp,
			l = dp.length,
			blp, bln;
		if(bl == null || bl.length == 0) return [];
		for(var i = 0; i < l; i++){
			bac = {};
			var blp, bap;
			if(i > 0){
				blp = blc;
				blc = bln;
			}
			else{
				blc = dp[i];
			}
			if(i < l - 1){
				bln = dp[i+1];
			}
			bac.sv = (i==0)?blc.v:(blp.v+blc.v)/2;
			bac.ev = (i==l-1)?blc.v:(bln.v+blc.v)/2;
			bac.c = blc.c;
			bac.d = (i==0)?BandDirection.LeftToRight:(i==l-1?BandDirection.RightToLeft:BandDirection.Center);
			ba[i] = bac;
		}
		return ba;
	}

	function convertBandToBlend(ba){
		var bl = [],
			blc, bac,
			dp = ba.dp,
			l = dp.length;
		if(ba == null || ba.length == 0) return [];
		for(var i = 0; i < l; i++){
			blc = {};
			bac = dp[i];
			var s = bac.s,
				e = bac.e;
			blc.c = bac.c;
			switch (bac.d) {

				case BandDirection.LeftToRight:
					blc.v = bac.s;
					break;
				case BandDirection.RightToLeft:
					blc.v = bac.e;
				case BandDirection.Center:
				case BandDirection.None:
				default:
					var avg = (bac.s + bac.e)/2;
					blc.v = avg;
					break;
			}
			bl[i] = blc;
		}
		return bl;
	}


	function getBlendFillInfo(min, max){
		var colors = [],
			alphas = [],
			ratios = [];
		if(this.min == this.max || isNaN(min) || isNaN(max) || min == max){
			colors[0] = getBlendColor.call(this, min);
			colors[1] = getBlendColor.call(this, max);
			alphas[0] = 1;
			alphas[1] = 1;
			ratios[0] = 0;
			ratios[1] = 1;
		}else if (this.min < this.max){
			var c,
				dp = this.blend.dp,
				l = dp.length,
				index = 0;
			colors[index] = getBlendColor.call(this, min);
			alphas[index] = 1;
			ratios[index] = 0;
			index ++;
			for(var i = 0; i < l; i++){
				c = dp[i];
				if(c.v >= min && c.v <= max){
					colors[index] = c.c;
					alphas[index] = 1;
					ratios[index] = (c.v-min)/(max-min);
					index++;
				}
			}
			colors[index] = getBlendColor.call(this, max);
			alphas[index] = 1;
			ratios[index] = 1;
		}
		return {c:colors, a:alphas, r:ratios};
	}
	function getBandFillInfo(min, max){
		var colors = [],
			alphas = [],
			ratios = [];
		if(this.min == this.max || isNaN(min) || isNaN(max) || min == max){
			colors[0] = getBandColor.call(this, min);
			colors[1] = getBandColor.call(this, max);
			alphas[0] = 1;
			alphas[1] = 1;
			ratios[0] = 0;
			ratios[1] = 1;
		}else if (this.min < this.max){
			var dp = this.band.dp,
				l = dp.length,
				a = 0.4,
				c, co, dc,
				index = 0;
			if(min < 0){
				colors[index] = getBandColor(min);
				alphas[index] = 1;
				ratios[index] = 0;
				index++;
				if(max < 1){
					colors[index] = getBandColor(max);
					alphas[index] = 1;
					ratios[index] = 1;
					index ++;
				}
			}
			for(var i = 0; i < l; i++){
				c = dp[i];
				if(c.s > max || c.e < min){
					continue;
				}
				co = c.c;
				dc = darkerHex(co, a);
				var sv = Math.max(c.s, min),
					ev = Math.min(c.e, max);

				if(ev != sv){
					switch (c.d) {
						case BandDirection.LeftToRight:
						case BandDirection.RightToLeft:
						case BandDirection.Center:
							if(sv == c.s){
								colors[index] = (c.d!=BandDirection.LeftToRight) ? dc : co;
							}else{
								colors[index] = getBandColor.call(this, sv);
							}
							ratios[index] = (sv-min)/(max-min);
							alphas[index] = 1;
							index++;
							if(c.d == BandDirection.Center){
								var avg = (c.s+c.e)/2;
								if(avg > sv && avg < ev){
									colors[index] = co;
									ratios[index] = (avg-min)/(max-min);
									alphas[index] = 1;
									index++;
								}
							}

							if(ev == c.e){
								colors[index] = (c.d!=BandDirection.RightToLeft) ? dc : co;
							}else{
								colors[index] = getBandColor.call(this, ev);
							}
							ratios[index] = (ev-min)/(max-min);
							alphas[index] = 1;
							index++;
							break;
						case BandDirection.None:
						default:
							colors[index] = co;
							ratios[index] = (sv-min)/(max-min);
							alphas[index] = 1;
							index++;
							colors[index] = co;
							ratios[index] = (ev-min)/(max-min);
							alphas[index] = 1;
							index++;
							break;
					}
				}
			}
			if(max > 1){
				if(min > 1){
					colors[index] = getBandColor.call(this, min);
					ratios[index] = 0;
					alphas[index] = 1;
					index++;
				}
				colors[index] = getBandColor.call(this, max);
				ratios[index] = 1;
				alphas[index] = 1;
			}

		}
		return {c:colors, a:alphas, r:ratios};
	}


	function getBandColorFromData(v, d){
		var r = 0.4,
			dc = darkerHex(d.c, r),
			mv, p;
		switch(d.d){
			case BandDirection.LeftToRight:
				if(v < d.s)	return d.c;
				if(v > d.e) return dc;
				if(d.s == d.e) return getColorInRange(0.5, d.c, dc);
				p = (v-d.s)/(d.e-d.s);
				return getColorInRange(p, d.c, dc);
			case BandDirection.RightToLeft:
				if(v < d.s)	return dc;
				if(v > d.e)	return d.c;
				if(d.s == d.e) return getColorInRange(0.5, dc, d.c);
				p = (v-d.s)/(d.e-d.s);
				return getColorInRange(p, dc, d.c);
			case BandDirection.Center:
				mv = (d.s+d.e)/2;
				if(v < d.s || v > d.e) return dc;
				if(d.s == d.e) return dc;
				if(v <= mv) {
					p = (v-d.s)/(mv-d.s);
					return getColorInRange(p, dc, d.c);
				}
				p = (v-mv)/(d.e-mv);
				return getColorInRange(p, d.c, dc);
			case BandDirection.None:
			default:
				return d.c;
		}
	}
	function getBlendColor(v){
		if(isNaN(v)){
			return DefaultColor.Invalid;
		}
		if(this.max == this.min){
			return this.blendEqualColor;
		}
		var dp = this.blend.dp,
			l = dp.length;
		if(!this.valid){
			var s = dp[0],
				e = dp[l-1];
			if(v < this.min){
				return s.c;
			}
			return e.c;
		}
		var i, c = dp[0],
			sv = c.v,
			sc = c.c,
			ev, ec;
		for(i = 1; i < l; i++){
			c = dp[i];
			if(c.v >= v) break;
			sv = c.v;
			sc = c.c;
		}
		i = Math.min(i, l-1);
		c = dp[i];
		ev = c.v;
		ec = c.c;
		if(v < sv) return sc;
		if(v > ev) return ec;
		if(sv == ev) return getColorInRange(0.5, sc, ec);
		
				
				
		
		

		var p = (v-sv)/(ev-sv);
		return getColorInRange(p, sc, ec);
		

	}

	function getBandColor(v){
		if(isNaN(v)) return DefaultColor.Invalid;
		if(this.min == this.max) return this.bandEqualColor;
		var dp = this.band.dp,
			l = dp.length;
		if(!this.valid){
			var s = dp[0],
				e = dp[l-1];
			if(v < this.min){
				return getBandColorFromData(e.s, s);
			}else{
				return getBandColorFromData(e.e, e);
			}
		}
		for(var i = 0; i < l; i++){
			c = dp[i];
            if(c.s === c.e) {
                continue;
            }
			if(c.s <= v && v <= c.e){
				return getBandColorFromData(v, c);
			}
		}
	}



	function createDefaultBlendDataProvider(min, max){
		this.blend.dp = [];
		var dp = this.blend.dp,
			bc;
		bc = {};
		bc.c = min;
		bc.v = 0;
		dp[0] = bc;

		bc = {};
		bc.c = max;
		bc.v = 1;
		dp[1] = bc;
	}

	function createDefaultBandDataProvider(min, max){
		this.band.dp = [];
		var dp = this.band.dp,
			bc;
		bc = {};
		bc.d = BandDirection.LeftToRight;
		bc.s = 0;
		bc.e = 0.5;
		bc.c = min;
		dp[0] = bc;

		bc = {};
		bc.d = BandDirection.LeftToRight;
		bc.s = 0.5;
		bc.e = 1;
		bc.c = max;
		dp[1] = bc;
	}
	function createBlendTooltipInfo(c, w, d){
		var ar = [],
			sx = 0,
			sv, ev,
			min = this.min,
			max = this.max,
			tc = d.legendTickCount,
			rt = {}, 
			co,
			valid = !isNaN(this.min) && !isNaN(this.max);

		if(this.min >= this.max || this.blend.dp.length <= 2){
			var f = (max-min)/tc;
			for(var i = 0; i < c; i++){
				rt = {x:sx, w:Math.floor(w/tc)};
				sx += rt.w;
				if(valid){
					sv = min + i*f;
					ev = sv + f;
					co = this.getColor((sv+ev)/2);
				}else{
					sv = "Null";
					ev = "Null";
					co = 0x000000; 
				}
				ar.push({r:rt, c:co, sv:sv, ev:ev});
			}
		}else{
			var dp = this.blend.dp,
				l = dp.length;
			for(var i = 0; i < l; i++){
				var item = dp[i],
					p, n;
				if(i == 0){
					sv = min;
				}else{
					p = dp[i-1];
					sv = min + (max-min)*(item.v+p.v)/2;
				}
				if(i == l-1){
					ev = max;
				}else{
					n = dp[i+1];
					ev = min + (max-min)*(item.v+n.v)/2;
				}
				rt = {x:sx, w:Math.floor(w*(ev-sv)/(max-min))};
				sx += rt.w;
				if(valid){
					co = this.getColor((sv+ev)/2);
				}else{
					sv = "Null";
					ev = "Null";
					co = 0x000000; 
				}
				ar.push({r:rt, c:co, sv:sv, ev:ev});
			}
		}
		this.tooltipInfo = ar;
	}
	function createBandTooltipInfo(c, w, d){
		var ar = [],
			sx = 0,
			sv, ev,
			min = this.min,
			max = this.max,
			tc = d.legendTickCount,
			rt = {}, 
			co,
			st, 
			valid = !isNaN(this.min) && !isNaN(this.max);
		if(this.min >= this.max){
			for(var i = 0; i < c; i++){
				rt = {x:sx, w:Math.floor(w/tc)};
				st += rt.w;
				if(valid){
					st = sv + " < " + ms + " < " + ev;
					co = this.getColor(min);
				}else{
					sv = "Null";
					ev = "Null";
					co = 0x000000; 
				}
				ar.push({r:rt, c:co, sv:sv, ev:ev});
			}
		}else{
            var imax, imin;
            if(this.isFixedColorBanding) {
                imax = this.initMax;
                imin = this.initMin;
            } else {
                imax = max;
                imin = min;
            }
			var dp = this.band.dp,
				l = dp.length;
			if(l <= 2){
				for(var i = 0; i < l; i++){
					var item = dp[i];
					if(i == 0){
						sv = imin;
					}else{
						sv = imin + (imax-imin)*item.s;
					}
					if(i == l-1){
						ev = imax;
					}else{
						ev = imin + (imax-imin)*item.e;
					}
                    if(sv < min) {
                        sv = min;
                    }
                    if(ev > max) {
                        ev = max;
                    }
                    if(sv > ev && ev >= max) {
                        sv = max;
                        ev = max;
                    } else if(ev < sv && sv <= min) {
                        sv = min;
                        ev = min;
                    }
					rt = {x:sx, w:Math.floor(w*(ev-sv)/(max-min)/2)};
					sx += rt.w;
					if(valid){
						ev = (sv+ev)/2;
						co = this.getColor((sv+ev)/2);
					}else{
						sv = "Null";
						ev = "Null";
						co = 0x000000; 
					}
					ar.push({r:rt, c:co, sv:sv, ev:ev});

					sx += rt.w;
					var bw = w*(ev-sv)/(max-min)/2;
					rt = {x:sx, w:Math.ceil(bw)};
					if(i > 0){
						var pr = ar[ar.length-1].r;
						if(rt.x < pr.x + pr.w+1){
							pr.w = rt.x - pr.x;
						}
					}
					sx += Math.floor(bw);
					if(valid){
						sv = (sv+ev)/2;
						co = this.getColor((sv+ev)/2);
					}else{
						sv = "Null";
						ev = "Null";
						co = 0x000000; 
					}
					ar.push({r:rt, c:co, sv:sv, ev:ev});
				}
			}
			else{
				for(var i = 0; i < l; i++){
					var item = dp[i];
					if(i == 0){
						sv = d.props.legendAsc ? imin : imax;
					}else{
						sv = d.props.legendAsc ? imin + (imax-imin)*item.s
								: imax + (imin-imax)*item.s;
					}
					if(i == l-1){
						ev = d.props.legendAsc ? imax : imin;
					}else{
						ev = d.props.legendAsc ? imin + (imax-imin)*item.e
								: imax + (imin-imax)*item.e;
					}
                    if(sv < min) {
                        sv = min;
                    }
                    if(ev > max) {
                        ev = max;
                    }
                    if(sv > ev && ev >= max) {
                        sv = max;
                        ev = max;
                    } else if(ev < sv && sv <= min) {
                        sv = min;
                        ev = min;
                    }
					var bw = w*(ev-sv)/(max-min);

					rt = {x:sx, w:Math.ceil(bw)};
					if(i > 0){
						var pr = ar[ar.length-1].r;
						if(rt.x < pr.x + pr.w+1){
							pr.w = rt.x - pr.x;
						}
					}
					if(i == l - 1){
						rt.w = w - sx;
					}
					sx += Math.floor(bw);
					var sign = d.props.legendAsc ? " < " : " > ";
					if(valid){
						co = this.getColor((sv+ev)/2);
					}else{
						sv = "Null";
						ev = "Null";
						co = 0x000000; 
					}
					if(sign){
						ar.push({r:rt, c:co, sv:sv, ev:ev});
					}else{
						ar.push({r:rt, c:co, sv:sv, ev:ev, sign:">"});
					}

				}
			}
		}
		this.tooltipInfo = ar;
	}
	mstrmojo.VisHeatMapColorTheme = {
		newInstance:function(){
			return {
				initialize : function prepareData(){
					this.blend = {};
					this.band = {};
					this.valid = true;
					this.blendEqualColor = 0;
					this.bandEqualColor = 0;
					this.isBlend = true;
					this.setDefaultDataProvider();
					this.checkMinMax();
				},


				getGradientFillInfo: function getGradientFillInfo(min, max){
					var tmin, tmax;
					if(isNaN(min) || isNaN(max)){
						if(this.isBlend){
							return getBlendFillInfo.call(this, min, max);
						}else{
							return getBandFillInfo.call(this, min, max);
						}
					}
					if(this.min == this.max){
						if(min < this.min){
							tmin = 0;
						}else{
							tmin = 1;
						}
						if(max < this.max){
							tmax = 0;
						}else{
							tmax = 1;
						}
					}else{
						if(this.isFixedColorBanding){
								var d = this.initMax - this.initMin;
								tmin = (min-this.initMin)/d;
								tmax = (max-this.initMin)/d;
						}
						else{
								var d = this.max-this.min;
								tmin = (min-this.min)/d;
								tmax = (max-this.min)/d;
						}
					}
					if(this.isBlend){
						return getBlendFillInfo.call(this, tmin, tmax);
					}else{
						return getBandFillInfo.call(this, tmin, tmax);
					}
				},

				checkMinMax: function checkValid(){
					var cmin = this.min,
						cmax = this.max;
					if(cmin > cmax){
						this.valid = false;
					}else if(cmin == cmax){
						cmin = cmax = 1; 
						var dp = this.blend.dp,
							l = dp.length,
							c,
							index;

						for(var i = l - 1; i >= 0; i--){
							c = dp[i];
							if(i == l - 1 && c.v <= cmin){
								this.blendEqualColor = c.c;
								break;
							}
							if(i == 0 && c.c >= cmin){
								this.blendEqualColor = c.c;
								break;
							}
							if(i > 0 && c.c >= cmin){
								var pc = dp[i-1];
								if(pc.c < cmin){
									index = (cmin-pc.v)/(c.v-pc.v);
									this.blendEqualColor = getColorInRange(index, pc.c, c.c);
									break;
								}
							}
						}
						dp = this.band.dp;
						l = dp.length;
						for(var i = 0; i < l; i++){
							c = dp[i];
							if((i == 0 && c.s >= cmin)
								||(i == l - 1 && c.e <= cmin)
								||(c.s <= cmin && c.e >= cmin)){
								this.bandEqualColor = c.c;
								break;
							}
						}
					}
					
						
						

					
				},

				setDefaultDataProvider: function setDefaultData(){
					createDefaultBlendDataProvider.call(this, DefaultColor.Min, DefaultColor.Max);
					createDefaultBandDataProvider.call(this, DefaultColor.Min, DefaultColor.Max);
					this.useDefault = true;
				},
				getColor: function getColorForValue(v){
                    if(this.hasNoColorMetric)
                            return DefaultColor.NoColorMetric;
					var value = NaN;
					if(isNaN(v)) value == 0;
					else if(this.min == this.max){
						value = v < this.min ? 0 : 1;
					}else{
						if(this.isFixedColorBanding)
							value = (v-this.initMin)/(this.initMax-this.initMin);
						else
							value = (v-this.min)/(this.max-this.min);
					}
					if(this.isBlend){
						return getBlendColor.call(this, value);
					}else{
						return getBandColor.call(this, value);
					}
				},

				isBrightColor: function isBrightColor(c){
					var r = c>>16,
						g = (c&0x00ff00)>>8,
						b = (c&0x0000ff),
						bright = (r*299+g*587+b*114)/1000;
					if(bright>150) return true;
					return false;
				},
				getContrastColor: function getContrastColor(c){
					if(this.isBrightColor(c)){
						return 0x000000;
					}
					return 0xffffff;
				},
				
				createTooltipInfo: function createTooltipInfo (t, w, d){
					var count = 0;
					if(this.min >= this.max){
						count = 1;
					}else {
						var l;
						if(this.isBlend){
							l = this.blend.dp.length;
							count = (l <= 2) ? 5 : l;
						}else{
							l = this.band.dp.length;
							count = (l <= 2) ? 4 : l;
						}
					}
					if(this.isBlend){
						createBlendTooltipInfo.call(this, count, w, d);
					}else{
						createBandTooltipInfo.call(this, count, w, d);
					}
				},

				getTooltipInfo: function getTooltip(v){
					var t = this.tooltipInfo;
					for(var i = 0; i < t.length; i++){
						var item = t[i],
							rect = item.r;
						if(v >= rect.x && v < rect.x + rect.w){
							return i;
						}
					}
					return i-1;
				},

				getMaxMinByMetricID: function(model,id){
						var col = model.gts.col,
						len = col.length,
						i = 0,
						index = null
						range = {min:null,max:null};

						for(i = 0; i < len && index == null; i++){
							var es = col[i].es,
								lenes = es.length,
								j;
							for(j = 0; j < lenes; j++){
								if(es[j].oid == id){
									index = j;
									break;
								}
							}
						}
						if(index == null)
							return range;
						var gvs = model.gvs.items,
							len = gvs.length;
						for(i = 0; i < len; i++){
							var value = parseFloat(gvs[i].items[index].rv);
							if(range.min == null)
								range.min = value;
							if(range.max == null)
								range.max = value;
							if(range.min > value)
								range.min = value;
							if(range.max < value)
								range.max = value;
						}
						return range;
				},
				convertFixedValueToBlendString: function(fixedBandingArray,range){
						var convertedBlend = "";
						if(fixedBandingArray.length%2 == 0){
								var length = fixedBandingArray.length,
								min = range.min,
								max = range.max,
								i = 0;

								
								
								
								
								var delta = max - min;
								convertedBlend = '0,'+fixedBandingArray[1];
								for(i = 2; i < length-2; i += 2){
										var value = parseInt(fixedBandingArray[i]);
										if(value < min || value > max)
												continue;
										else{
												var colorIndex = (value-min)/delta;
												convertedBlend += ',' + colorIndex + ',' + fixedBandingArray[i+1];
										}
								}
								convertedBlend += ',1,' + fixedBandingArray[length-1];

								
								
								
						
								
								
						}
						return convertedBlend;
				},

                convertFixedValueToBandString: function(string, range) {
                        var a = string.split(','),
                            len = a.length,
                            i,
                            d = range.max - range.min;
                        var ret = '';
                        if(len % 4 === 0) {
                            for(i = 0; i < len; i+=4){
                                var j = 0;
                                for(j = 0; j < 2; j++) {
                                    var v,
                                        str = a[i + j];
                                    if(str === 'min') {
                                        v = range.min;
                                    } else if(str === 'max') {
                                        v = range.max;
                                    } else {
                                        v = parseFloat(a[i + j]);
                                    }
                                    if(!isNaN(v)) {
                                        a[i + j] = String((v - range.min) / d);
                                    } else {
                                        console.log('warning: invalid band string. In heatmap color theme');
                                    }
                                }
                            }
                            for(i = 0; i < len; i++) {
                                ret += (a[i] + ',');
                            }
                            ret = ret.substring(0, ret.length - 1);
                        } else {
                            console.log('warning: Invalid band color string. In heatmap color theme');
                        }
                        return ret;
                },

				convertAbsoluteToBlend: function(heatMap,propValue){
						this.useDefault = false;
						this.isColorBanding = true;
						var abs = propValue.abs.replace(/&quot;/g, '"')
												.replace(/&gt;/g, '>')
												.replace(/&lt;/g, '<')
												.replace(/&amp;/g, '&');
						abs = (new window.DOMParser()).parseFromString(abs,"text/xml");
						var absM = abs.getElementsByTagName('m')[0];
						
						heatMap.absoluteColorID = absM.getAttribute('id');
						this.isFixedColorBanding = true;
						this.fixedBandingArray= absM.getAttribute('bl').split(',');
						var	range;
						
						
						
						
						if(!isNaN(this.min) && !isNaN(this.max))
							range = {max: this.max, min: this.min};
						else{
								range = this.getMaxMinByMetricID(heatMap.model,heatMap.absoluteColorID);
								this.max = range.max;
								this.min = range.min;
						}
						if(isNaN(this.initMax) || isNaN(this.initMin)){
								range = this.getMaxMinByMetricID(heatMap.model,heatMap.absoluteColorID);
								this.max = range.max;
								this.min = range.min;
								this.initMax = range.max;
								this.initMin = range.min;
						}
						
								
						
                        propValue.bandColors = this.convertFixedValueToBandString(absM.getAttribute('ba'), range);
						propValue.gradientColors = this.convertFixedValueToBlendString(this.fixedBandingArray,range);
				},


				createDataProviderFromString: function createDataProvider(bl, ba){
					var arr = bl.split(','),
						i = 0,
						dp;
					this.blend.dp = [];
					this.useDefault = false;
					dp = this.blend.dp;
					if(arr.length % 2 == 0){
						while(i < arr.length){
							var c = {};
							c.v = parseFloat(arr[i]);
							i++;
							c.c = parseInt(arr[i]);
							i++;
							dp[dp.length] = c;
						}
					}
					i = 0;
					arr = ba.split(',');
					this.band.dp = [];
					dp = this.band.dp;
					if(arr.length % 4 == 0){
						while(i < arr.length){
							var c = {};
							c.s = parseFloat(arr[i]);
							i++;
							c.e = parseFloat(arr[i]);
							i++;
							c.c = parseInt(arr[i]);
							i++;
							var str = arr[i];
							switch(str){
								case "leftToRight":
									c.d = BandDirection.LeftToRight;
									break;
								case "rightToLeft":
									c.d = BandDirection.RightToLeft;
									break;
								case "center":
									c.d = BandDirection.Center;
									break;
								default:
									c.d = BandDirection.None;
							}
							i++;
							dp[dp.length] = c;
						}
					}
				}
			};
		}
	}

})();

(function(){
    
    
    mstrmojo._CanRenderChildrenOnShow = mstrmojo.provide(
        "mstrmojo._CanRenderChildrenOnShow",
        
        {
            
            _subs_renderOnShow: null,
            
            
            childRenderCheck: function chRnCk(c) {
                if (this.renderMode !== "onshow") {
                    return this._super(c);
                } else if (c.visible) {
                    return this._super(c);
                } else {
                    
                    var sbs = this._subs_renderOnShow;
                    if (!sbs) {
                        sbs = {};
                        this._subs_renderOnShow = sbs;
                    }
                    
                    if (!sbs[c.id]) {
                        sbs[c.id] = c.attachEventListener("visibleChange", this.id, "_on_child_visibleChange");
                    }
                    return false;       
                }
            },
            
            
            _on_child_visibleChange: function chVisChg(evt) {
                if (this.hasRendered) {
                    var c = evt && evt.src;
                    if (c && this.childRenderCheck(c)) {
                        var sbs = this._subs_renderOnShow;
                        if (sbs) {
                            c.detachEventListener(sbs[c.id]);
                            delete sbs[c.id];
                        }
                        c.render();
                    }
                }
            }
        });
})();
(function() {
    
    
    mstrmojo._HasRelativeUrls = 
        
        {
            _mixinName: 'mstrmojo._HasRelativeUrls', 
            
            
            relativeUrls: [], 
            
            
            update: function update(node) {
                this._super(node);
                
                var me = this,
                    doc = me.builder.parent,
                    hostUrl = mstrApp.getConfiguration().getHostUrlByProject(mstrApp.getCurrentProjectId());

                
                mstrmojo.array.forEach(this.relativeUrls, function (p) {
                    
                    var url = me[p];
                    
                    
                    if (url && (url.indexOf('://') === -1 && url.indexOf('data:') !== 0)) {
                        
                        me[p] = hostUrl + url;
                    }
                });
            }
                
        };
    
})();

 
mstrmojo.mstr.EnumWebAPIErrorCodes = {
    	MSI_INBOX_MSG_NOT_FOUND:                    -2147468986, 
		E_MSI_USERMGR_USER_NOTFOUND:                -2147209051, 
		AUTHEN_E_LOGIN_FAIL_EXPIRED_PWD:            -2147216963, 
		AUTHEN_E_LOGIN_FAILED_NEW_PASSWORD_REQD:    -2147216960, 
		AUTHEN_E_LOGIN_FAIL:						-2147216959, 

		
		E_UNUSED: 0xFFFFFFFF
};
(function () {
    
    
    function measureDimension(d, w) {
        
        if (!w.domNode) {
            return 0;
        }
        
        
        var cn = '_fixed' + d;
        
        
        if (w[cn]) {
            return w[cn];
        }
        
        
        var f = w.getFormats();
        
        
        var p = d.toLowerCase();
        
        
        if (f && p in f) {
            
            var v = f[p];
            
            
            if (v.charAt(v.length - 1) !== '%') {
                
                var px = parseInt(v, 10);
                
                
                if (!isNaN(px)) {
                    w[cn] = px;
                    return px;
                }
            }
        }
        
        
        return (w.domNode['client' + d] || 0);
    }    

    
    mstrmojo._ContainsDocObjects =
    
    {
        
        height: function height() {
            return measureDimension('Height', this);
        },
        
        
        width: function width() {
            return measureDimension('Width', this);
        },
        
        
        getMaxZIndex: function getMaxZIndex() {
            var mx = 0;
            mstrmojo.array.forEach(this.children, function (c) {
                mx = Math.max(mx, c.getFormats()['z-index']);
            });
            
            return mx;
        }
    };
})();
(function () {

    
    mstrmojo._HasDrillLinks = mstrmojo.provide(
        'mstrmojo._HasDrillLinks',

        
        {
        	_mixinName: 'mstrmojo._HasDrillLinks',
        	
            update: function update(node) {
                this._super(node);

                var fdl = node.defn.dl,
                    ddl = node.data.dl,
                    dliRef = this.drillLinkItems = ((fdl && fdl.items) || []).concat((ddl && ddl.items) || []).sort(function (a, b) {
                        return a.index - b.index;
                    }),
                    i;

                
                
                for (i = dliRef.length - 1; i >= 0; i--) {
                    if (i && dliRef[i].index === dliRef[i - 1].index) {
                        dliRef.splice(i, 1);
                    }
                }

                if (fdl && fdl.target) {
                    for (i = 0; i < dliRef.length; i++) {
                        dliRef[i].target = fdl.target;
                    }
                }
            }
        }
    );
}());
(function(){

	
	var _instanceMap = {};

	
	mstrmojo.NumberFormat =
		
		{
			
			getInstance: function getInstance(decimalSeparator, thousandSeparator) {
				
				var instanceKey = decimalSeparator + "--" + thousandSeparator;
				
				
				if (instanceKey in _instanceMap) {
					
					return _instanceMap[instanceKey];
				}

				
				var formatterObj =  {
										
					parse: function(s) {},
					
					
					format: function(n) {}
				};
				
				
				if (decimalSeparator === "." && thousandSeparator === ",") {
					formatterObj.parse = function (s) {
						if (!s) {
							return NaN;
						}
						
						
						var simplifiedStr = s.replace(/,/g, "");
						
						return Number(simplifiedStr);
					};
					
					formatterObj.format = function (n) {
						return Number(n).toString();
					};
				} else {	
					
					var thouRE = new RegExp("\\" + thousandSeparator, "g");
						
					formatterObj.parse = function (s) {
						if (!s) {
							return NaN;
						}
						
						
						var englishStr = s.replace(thouRE, "").replace(decimalSeparator, ".");
						
						
						return Number(englishStr);
					};
					
					formatterObj.format = function (n) {
						
						var englishStr = Number(n).toString();
						
						
						return englishStr.replace(".", decimalSeparator);
					};
				}
				
				
				_instanceMap[instanceKey] = formatterObj;
				
				return formatterObj;
			}
		};
})();
(function() {
	var cachedCalls = [];
	function cacheCall (func, args) {
		cachedCalls.push({n: func, args: args});
	}
	function checkLoadingStatus (geo, func, args) {
		var ok = false;
		switch (geo._loadingStatus) {
		case 0: 
			if (google && google.maps && google.maps.Geocoder) {
				
				geo._loadingStatus = 2;
				ok = true;
			} else {
				cacheCall(func, args);
				geo._loadScript();
			}
			break;
		case 1: 
			cacheCall(func, args);
			break;
		case 2:
			ok = true;
			break;
		}
		return ok;
	}
	mstrmojo.GeoLocation = mstrmojo.provide(
		'mstrmojo.GeoLocation',
		{
			
			_altitude: null,
			 
			_latitude: null,
			
			_longitude: null,
			
			_callbacks: [],
			_getPos: function(){
				if (mstrMobileApp && mstrMobileApp.getGeoLocation){
					mstrmojo.GeoLocation._getPos = function() {
						mstrMobileApp.getGeoLocation('mstrmojo.GeoLocation.updateLocation');
					};
				} else if (navigator && navigator.geolocation) {
					mstrmojo.GeoLocation._getPos = function() {
						navigator.geolocation.getCurrentPosition(
							function(position) {  
								mstrmojo.GeoLocation.updateLocation(position);
							},
							function(error) {
								switch(error.code){
									case error.TIMEOUT :
										alert( "Retrieve Geo Position: Timeout, please try it again " );
										break;
									case error.PERMISSION_DENIED :
										alert( "Retrieve Geo Position: Permission to use location service has been denied " );
										break;
									case error.POSITION_UNAVAILABLE : 
										alert( "Retrieve Geo Position: Position unavaiable " );
										break;
								}
								mstrmojo.GeoLocation.updateLocation(error);
							},
							
							{maximumAge:10000, timeout:10000}
						);
					};
				} else {
					mstrmojo.GeoLocation._getPos = function() {
						alert("no available Geo Location service");
					};
				}
				mstrmojo.GeoLocation._getPos();
			},
			
			getCurrentLocation: function(callbacks){
				
				this._callbacks.push(callbacks);
				if (!this._pending) {
					this._pending = true;
					this._getPos();
				}
			},
			
			updateLocation: function(info){
				var me = mstrmojo.GeoLocation;
                var i,cbs;





				var p = info && info.coords;
				var e = info && info.err;
				if (p){
					
					me._latitude = p.latitude;
					me._longitude = p.longitude;
					
					
                    cbs = me._callbacks;
                    
                    for (i = 0; i < cbs.length; i ++ ){
						cbs[i].success(p.latitude, p.longitude);
					}
				} else if (e){
					
                    cbs = me._callbacks;
                    for (i = 0; i < cbs.length; i ++ ){
						cbs[i].failure('Error in updating geo location information.'+e);
					}
				} else {
					
                    cbs = me._callbacks;
                    for (i = 0; i < cbs.length; i ++ ){
						cbs[i].failure('Error in updating geo location information.');
					}
				}				
				
				me._callbacks = [];
				
				
				me._pending = false;
			},
			getCurrentAddress: function(callbacks){
				this.getCurrentLocation({
					success: function(la, lo, al){
						mstrmojo.GeoLocation.findAddress(
								{lat: la, lng: lo}, 
								{
									success: callbacks.success && callbacks.success || mstrmojo.emptyFn,
									failure: callbacks.failure && callbacks.failure || mstrmojo.emptyFn 
							
								}
						);
					}, 
					failure: callbacks.failure && callbacks.failure || mstrmojo.emptyFn
				});
			},
            count:null,
            cbs:null,
            getUniqId:function getUniqId() {
                var c;
                if (!this.count) {
                    c = this.count = 1;
                } else {
                    c = this.count++;
                }
                return "fa"+c;
            },
            findAddress: function findAddress(latlng, callbacks) {
            	if (!mstrMobileApp || !mstrMobileApp.useNativeMap || !mstrMobileApp.useNativeMap()) {
            		this.findAddressUsingJsAPI(latlng,callbacks);
            	} else {
            		this.findAddressUsingNativeAPI(latlng,callbacks);
                }
            },
            findAddressUsingJsAPI:function findAddressUsingJsAPI(latlng,callbacks) {
            	if (checkLoadingStatus(this, 'findAddress', [latlng, callbacks])) {
			    	var geocoder = new google.maps.Geocoder();          
			    	geocoder.geocode(
			    			{location:new google.maps.LatLng(latlng.lat, latlng.lng)}, 
			    			function(results, status) {            
			    				if (status == google.maps.GeocoderStatus.OK && results[0]) {
			    					callbacks.success(results);
			    				} else {
			    					callbacks.failure(results, status);
			    				}
			    			}
			    	);        
				}
            },
            findAddressUsingNativeAPI:function findAddressUsingNativeAPI(latlng,callbacks) {
                var id = this.getUniqId();
                if (this.cbs == null) {
                	this.cbs = {};
                }
                this.cbs[id] = function(result) {
                    if (result.status == "OK") {
                        callbacks.success(result.results);
                    } else {
                        callbacks.failure(result.results, result.status);
                    }
                };
                mstrMobileApp.findAddress(latlng.lat,latlng.lng,'mstrmojo.GeoLocation.findAddressCallback',id);
            },
            findAddressCallback : function findAddressCallback(res,status,id) {
            	this.cbs[id].apply(mstrmojo.GeoLocation,[res]);
            },
		    
		    
			_loadingStatus: 0,	
			
			_loadScriptCallBack: function _loadScriptCallBack() { 
				this._loadingStatus = 2;
				
				
				for (var i = 0; i < cachedCalls.length; i ++) {
					var c = cachedCalls[i];
					mstrmojo.GeoLocation[c.n].apply(mstrmojo.GeoLocation, c.args);
				}
			}, 
			_loadScript: function _loadScript() {
				this._loadingStatus = 1;
				var script = document.createElement("script"); 
				script.type = "text/javascript"; 
				script.src = "http://maps.google.com/maps/api/js?sensor=false&callback=mstrmojo.GeoLocation._loadScriptCallBack"; 
				document.body.appendChild(script); 
			}
			
		}
	);
	

})();
(function () {
    
    
    
    function measureDimension(node, dim, ch) {
        var x = 0,
            i = 0,
            len = (ch && ch.length) || 0;
        
        
        if (!node || !ch) {
            return x;
        }
        
        
        for (; i < len; i++) {
            x += ch[i][dim]();
        }
        
        
        return x;
    }
    
    
    function resolveChildrenToMeasure(ch, count) {
        if (count === undefined || isNaN(count)) {
            return ch;
        }
        
        
        return (ch && [ ch[count - 1] ]);
    }

    
    mstrmojo._CanMeasureChildren = 
        
        {
            
            
            height: function height(count) {
                return measureDimension(this.domNode, 'height', resolveChildrenToMeasure(this.children, count));
            },
            
            
            width: function width(count) {
                return measureDimension(this.domNode, 'width', resolveChildrenToMeasure(this.children, count));
            }
            
        };
    
}());
mstrmojo.EnumReadystate = {
    IDLE: 1,
    WAITING: 3,
    ERROR: 4,
    SUCCESS: 5,
    CANCELLED: 6,
    TIMEOUT: 7
};
(function(){
    
    
    mstrmojo.url = mstrmojo.provide(
    "mstrmojo.url", 
    {
        
        isAbsoluteURL: function(url) {
            return /^(http|https|ftp|file):\/\//i.test(url);
        },    
        
        
        getAbsoluteURL: function(url, baseUrl) {
            if(this.isAbsoluteURL(url)) {
                return url;
            } else {
                if(baseUrl) {
                    return baseUrl + (/\/$/.test(baseUrl) ? '' : '/') + url;
                } else {
                    return 'http://' + url;
                }
            }
        }
    });
})();
(function () {

    
    function setFullScreenStatus(isEnter, animate, isFlash) {
        
        if (!isFlash && isEnter === !!this._inFullScreen) {
            
            return;
        }

        
        delete this._inFlash;

        
        var domNode = this.domNode;
        if (!domNode) {
            
            return;
        }

        var domNodeStyle = domNode.style,
            isMain = !!this.controller,
            me = this,
            styleProp = (this.fullscreenDirection === 'up') ? 'top' : 'bottom',
            fnPosition = function () {
                
                domNodeStyle.position = isEnter ? 'absolute' : 'static';

                
                if (isMain) {
                    
                    mstrApp.rootView.doLayout();
                }
            },
            fnStatusBar = function () {
                
                if (isMain) {
                    
                    mstrMobileApp[(isEnter ? 'enter' : 'exit') + 'FullScreen']();
                }
            };

        
        if (!isFlash) {
            
            this._inFullScreen = isEnter;

            
            if (isEnter || !animate) {
                
                fnPosition();
            }
        }

        
        if (!isEnter) {
            
            if (parseInt(domNodeStyle[styleProp], 10) === 0) {
                
                fnPosition();

                
                fnStatusBar();

                return;
            }

            
            if (isFlash) {
                
                this._inFlash = true;
            }
        }

        
        if (animate) {
            
            mstrmojo.dom.attachOneTimeEvent(domNode, 'webkitTransitionEnd', function () {
                
                if (!isEnter) {
                    
                    if (!isFlash) {
                        
                        fnPosition();

                    } else {
                        
                        me._flashHandle = window.setTimeout(function () {
                            
                            delete me._flashHandle;

                            
                            setFullScreenStatus.call(me, true, true, true);
                        }, 3000);

                    }
                }else{
                	if(me.onEnterFullScreenEnd){
                		me.onEnterFullScreenEnd();
                	}
                }

                
                if (!isFlash) {
                    
                    fnStatusBar();
                }
            });
        } else {
            
            fnStatusBar();
        }


        
        this['on' + (isEnter ? 'Enter' : 'Exit') + 'FullScreen']();

        
        domNodeStyle.webkitTransitionDuration = animate ? '' : 0;

        
        domNodeStyle[styleProp] = isEnter ? -domNode.offsetHeight + 'px' : 0;


    }

    
    function clearFlashHandle() {
        
        var handle = this._flashHandle;
        if (handle) {
            
            window.clearTimeout(handle);

            
            delete this._flashHandle;
        }
    }

    
    mstrmojo.android.ui._CanBeFullScreen = mstrmojo.provide(

        "mstrmojo.android.ui._CanBeFullScreen",

        
        {
            
            fullscreenDirection: 'up',

            
            onEnterFullScreen: mstrmojo.emptyFn,

            
            onExitFullScreen: mstrmojo.emptyFn,

            
            resetFullScreen: function resetFullScreen() {
                
                if (this._inFullScreen) {
                    
                    delete this._inFullScreen;

                    
                    setFullScreenStatus.call(this, true, false);
                }
            },

            
            enterFullScreen: function enterFullScreen() {
                
                setFullScreenStatus.call(this, true, true);
            },

            
            flashFullScreen: function flashFullScreen() {
                
                if (this._inFullScreen && !this._inFlash) {
                    
                    setFullScreenStatus.call(this, false, true, true);
                }
            },

            
            exitFullScreen: function exitFullScreen(animate) {
                
                clearFlashHandle.call(this);

                
                setFullScreenStatus.call(this, false, animate);
            },

            
            cancelFlashFullScreen: function cancelFlashFullScreen() {
                
                if (this._inFullScreen && this._inFlash) {
                    
                    clearFlashHandle.call(this);

                    
                    setFullScreenStatus.call(this, true, false, true);
                }
            }
        }
    );
}());
(function() {
    
    
    mstrmojo._IsSelectorTarget = 
        
        {
            _mixinName: 'mstrmojo._IsSelectorTarget', 
            
            
            setDirty: function setDirty(isDirty) {
                
                var mth = ((isDirty) ? 'add' : 'remove') + 'DirtyKey';
                if (this.parent && this.parent[mth]) {
                    this.parent[mth](this.k);
                }
            }
                
        };
    
})();
mstrmojo.android.EnumMenuOptions = mstrmojo.provide(
    "mstrmojo.android.EnumMenuOptions",

    {
        
        HOME: 1,
        SETTINGS: 2,
        HELP: 4,
        LEARN: 8,

        ALL: 255,    

        

        
        
        
        REFRESH:               0x0100,
        FULL_SCREEN:           0x0200,
        GROUP_BY:              0x0300,
        PAGE_BY:               0x0400,
        REPROMPT:              0x0500,
        DELETE:                0x0600,
        SEARCH:                0x0700,
        SCAN:                  0x0800,
        MAP_ROADMAP:           0x0900,
        MAP_SAT:               0x0A00,
        MAP_HYBRID:            0x0B00,
        MAP_TERRAIN:           0x0C00,
        DOC_LAYOUTS:           0x0D00,
        TRANSACTIONS_QUEUE:    0x0E00,
        ADD_SERVER:            0x0F00,
        ADD_PROJECT:           0x1000,
        ABOUT:                 0x1100,
        SHARE:                 0x1200,
        ABOUT_RESULTSET:       0x1300,
        ANNOTATION:			   0x1400
    }
);
(function() {
    mstrmojo.BarcodeReader = mstrmojo.provide(
        'mstrmojo.BarcodeReader',
        {
            
            _callback: null,
            _callbackId: 0,
            
            
            readBarcodes: function readBarcodes(params, callback, name, selectedPrompts, displayKeypadView) {
                this._callbackId++;
                var id = '' + this._callbackId;
                this._callback = callback;
                var callbackStr = 'mstrmojo.BarcodeReader.onBarcodeResult';
                if ( params ) {
                    params.blockBegin = 0;
                    params.blockCount = -1;
                    params.serverUrl = mstrApp.getConfiguration().getTaskUrlByProject(mstrApp.getCurrentProjectId());
                    params.sessionState = mstrApp.getSessionState();
                }
               
                mstrMobileApp.readBarcodes(id, name, (params && JSON.stringify(params)) || null, (selectedPrompts && JSON.stringify(selectedPrompts)) || null, displayKeypadView || null, callbackStr);
            },
            
            onBarcodeResult: function onBarcodeResult(id, resCode, value) {
                
                var callback = this._callback;
                if ( id != this._callbackId || (! callback)) {
                    return;
                }
                delete this._callback;
                if ( resCode == -1 ) { 
                    callback.success(value);
                } else if ( resCode != 0 ) {
                    callback.failure(value || 'Error reading bare code.');
                }
            }
        }
    );
    

})();

mstrmojo.EnumRWUnitType = {
	LAYOUT: 0,			
	HEADER: 2,
	FOOTER: 3,
	SUBSECTION: 4,		
	DETAILS: 5,
	PAGEHEADER: 6,
	PAGEFOOTER: 7,
	PANELSTACK: 8,
	PANEL: 9,

    
    
	GRID: 521,
	GRAPH: 522,
	GRIDGRAPH: 527,
    
	RECTANGLE: 101,
	IMAGE: 102,
	LINE: 105,
	TEXTFIELD: 106,
	HTMLCONTAINER: 107,
	SELECTOR: 111,
    ROUNDEDRECTANGLE: 112,
	VISUALIZATION: 114,
	MOJOVISUALIZATION: 115
};
(function () { 

    mstrmojo.requiresCls("mstrmojo.array", "mstrmojo.hash");
    
    var _A = mstrmojo.array,
        _H = mstrmojo.hash;
    
     
    function _add( me,  idxs) {
        var added = [],
            sel = me.selectedIndices,
            allIdx = me.allIdx;

        
        var i, len,
            items = me.items;
        if (me.multiSelect && (allIdx > -1) && (_A.indexOf(idxs, me.allIdx) > -1)) {
            for (i = 0, len=items.length; i < len; i++) {
                if (!sel[i]){
                    added.push(i);
                    sel[i] = true;
                    me.selectedIndex = i;
                    me.selectedItem = items[i];
                }
            }
        } else {
            for (i=0, len=idxs.length; i<len; i++) {
                var idx = idxs[i];
                if (!sel[idx]){
                    sel[idx] = true;
                    added.push(idx);
                    me.selectedIndex = idx;
                    me.selectedItem = items[idx];
                }
            }
        }
        return added;
    }

     
    function _rmvAll( me) {
        var rmv = [],
            sel = me.selectedIndices;
        for (var i in sel) {
            delete sel[i];
            rmv.push(parseInt(i,10));  
        }
        me.selectedIndex = -1;
        me.selectedItem = null;
        return rmv;
    }
        
     
    function _rmv( me,  idxs) {
        var removed = [],
            sel = me.selectedIndices,
            arrIdx = _A.indexOf,
            allIdx = me.allIdx;
                
        
        if (me.multiSelect && (allIdx > -1) && (arrIdx(idxs, allIdx) > -1)) {
            return _rmvAll(me);
        }
        
        
        if (idxs.length > 0 && sel[allIdx]) {
            if (arrIdx(idxs, allIdx) < 0) {
                idxs.push(allIdx);
            }
        }
        for (var i=0, len=idxs.length; i<len; i++) {
            var idx = idxs[i];
            if (sel[idx]){
                delete sel[idx];
                removed.push(idx);
                if (me.selectedIndex == idx) {
                    me.selectedIndex = -1;
                    me.selectedItem = null;
                }
            }
        }
        return removed;
    }
        
    
    function _apply( me, h) {
        var sel = me.selectedIndices;
        if (!sel) {
            sel = {};
            me.selectedIndices = sel;
        }
        
        if (!h) {
            h = {};
        }
        
        
        var sidx = me.selectedIndex,
            rmv = [],
            idx;
        for (var i in sel) {
            if (!h[i]) {
                idx = parseInt(i,10);
                delete sel[i];
                rmv.push(idx);
                if (sidx == idx) {
                    me.selectedIndex = -1;
                    me.selectedItem = null;
                }
            }
        }
        
        var add = [],
            itms = me.items;
        for (i in h) {
            if (!sel[i]) {
                idx = parseInt(i,10);
                sel[i] = true;
                add.push(idx);
                me.selectedIndex = idx;
                me.selectedItem = itms && itms[idx];
            }
        }
        return {add: add, rmv: rmv};
    }
    
    
    function _raise( me,  added,  removed) {
        if (me.raiseEvent && 
            ((added && added.length) || (removed && removed.length)) ) {
                me.raiseEvent({
                    name: 'change',
                    added: added,
                    removed: removed
                });
        }
    }
    
        
    mstrmojo._ListBase2Selections = mstrmojo.provide(
        "mstrmojo._ListBase2Selections",
        
        {
            
            multiSelect: false,
            
            
            selectedIndices: null,
            
            
            selectedIndex: -1,

            
            selectedItem: null,

            
            selectedIndices_bindEvents: "change",
            selectedIndex_bindEvents: "change",
            selectedItem_bindEvents: "change",

            
            allowUnlistedValues: true,

            
            insertUnlistedValuesAt: -1,

            
            allIdx : -1,
            
            
            singleSelect: function ss(idx, silent){
                
                
                if (!this.selectedIndices[idx] || (this.selectionPolicy === 'reselect') || (idx !== this.allIdx && this.selectedIndices[this.allIdx])) {    
                    var rmv = _rmvAll(this),
                        add = _add(this, [idx]);
                    if (silent !== true) {
                        _raise(this, add, rmv);
                    }
                }    
            },
            
            
            toggleSelect: function ts(idx, silent) {
                var add, rmv;
                if (this.selectedIndices[idx]) { 
                    rmv = _rmv(this, [idx]);
                } else {
                    add = _add(this, [idx]);
                }
                if (silent !== true) {
                    _raise(this, add, rmv);
                }
            },

            
            rangeSelect: function rs(idx, silent) {
                 
                 this.singleSelect(idx, silent);
            },
            
            
            clearSelect: function cs(silent){
                var ret = _rmvAll(this);
                if (silent !== true) {
                    _raise(this, null, ret);
                }
            }, 

            
            select: function sel(idxs, silent){
                
                var ret = _apply(this, _A.hash(idxs));
                if ((silent !== true) && (ret.add.length || ret.rmv.length)) {
                    _raise(this, ret.add, ret.rmv);
                }
            },
            
            
            addSelect: function add(idxs, silent) {
                if (idxs == null){    
                    return;
                }
                if (idxs.constructor !== Array) {
                    idxs = [idxs];
                }
                var ret = _add(this, idxs);
                if (silent !== true) {
                    _raise(this, ret, null);
                }
                return ret;
            },
            
            
            removeSelect: function rmv(idxs, silent) {
                if (idxs == null) {   
                    return;
                }
                if (idxs.constructor != Array) {
                    idxs = [idxs];
                }
                var ret = _rmv(this, idxs);
                if (silent !== true) {
                     _raise(this, null, ret);
                }
                return ret;
            },
            
            
            _set_selectedIndices: function(n, v, silent) {
                if (this.selectedIndices === v){
                    return false;
                }
                var ret = _apply(this, v);

                
                if (ret.add.length || ret.rmv.length) {
                    if (silent !== true) {
                        _raise(this, ret.add, ret.rmv);
                    }
                }
                
                return false;
            },
            
            
            _set_selectedIndex: function(n, v, silent){
                var idxs = {};
                if (v >-1) {
                    idxs[v] = true;
                }
                return this._set_selectedIndices(null, idxs, silent);
            },
                        
            
            _set_selectedItem: function(n, v, silent){
                
                var isObject = v && (typeof(v) == 'object'),
                    idf = this.itemIdField,
                    idx = -1,
                    its = this.items;
                if (isObject && idf != null) {  
                    
                    
                    idx = _A.find(its, idf, v[idf]);
                } else if (v != null) {  
                    
                    
                    
                    idx = _A.indexOf(its, v);
                }
                if ((idx === -1) && (v != null) && this.allowUnlistedValues) {   
                    
                    
                    var at = this.insertUnlistedValuesAt;
                    if (at == null || at < 0) {
                        at = (its && its.length) || 0;
                    }
                    idx = at;
                    this.add([v], idx);
                }
                return this._set_selectedIndex(null, idx, silent);
            },

            
            initSelections: function ints(hash, arr, idx, item, silent) {
                
                if (!this.selectedIndices) {
                    this.selectedIndices = {};
                    this.selectedIndex = -1;
                }
                if (hash) {
                    
                    this._set_selectedIndices(null, hash, silent);
                } else if (arr) {
                    
                    this.select(arr, silent);
                } else if (item) {
                    
                    this._set_selectedItem(null, item, silent);                    
                } else if (idx != null) {   
                    
                    this._set_selectedIndex(null, idx, silent);
                }
            },
            
            sortSelectedIndices: function(){
                return _H.keyarray(
                                    this.selectedIndices, 
                                    true
                                ).sort(_A.numSorter);
            },
            
            
            removeSelectedItems: function(){
                var idxs = this.sortSelectedIndices(),
                    len = idxs.length,
                    last = idxs[len-1],
                    ret = this.remove(idxs);
                last = Math.min(last + 1 - len, this.items.length -1);
                if (last >= 0) {
                    this.singleSelect(last);
                }
                return ret;
            },
            
            
            getSelectedItems: function(){
                return _A.get(this.items, this.sortSelectedIndices()) || [];
            },
            
            
            setSelectedItems: function(arr, dontClear) {
                if (!arr || !arr.length) {
                    return;
                }
                var its = this.items || [],
                    ret = this.itemIdField != null ?
                            _A.findMulti(its, this.itemIdField, arr) :
                            _A.indexOfMulti(its, arr),
                    arrLen = arr.length,
                    missed = arrLen - ret.count,
                    alw = this.allowUnlistedValues,
                    at = this.insertUnlistedValuesAt,
                    offset = (alw && (at > -1)) ?
                                missed : 0;
                if (at<0) {
                    at = its.length;
                }
                var appIts = [],  
                    appIdxs = [],   
                    m = ret.map;
                if (missed && alw) {
                    
                    var c = 0;
                    for (var n=0; n<arrLen; n++){
                        if (m[n] == null) { 
                            appIts.push(arr[n]);
                            appIdxs.push(at + c++);
                        }
                    }
                    
                    this.add(appIts, at);
                }
                var addIdxs = [];   
                for (var k in m) {
                    var i = m[k];
                    if (i >= at) {
                        i += offset;
                    }
                    addIdxs.push(i);
                }
                var toAdd = addIdxs.concat(appIdxs),
                    added = this.addSelect(toAdd, !dontClear);
                if (!dontClear){
                    
                    
                    var ha = _A.hash(added),
                        sel = this.selectedIndices,
                        toRem = [];
                    
                    for (var j in sel){
                        if (!ha[j]) {
                            
                            toRem.push(parseInt(j,10));
                        }
                    }
                    
                    
                    var rmd = this.removeSelect(toRem, true);
                    _raise(this, added, rmd);
                }
                
            }
        });
})();

(function () {

    mstrmojo.requiresCls("mstrmojo.array");

    var $ARR = mstrmojo.array;

    
    mstrmojo._IsPanelStack = mstrmojo.provide(

        "mstrmojo._IsPanelStack",

        
        {
            _mixinName: 'mstrmojo._IsPanelStack',
            
            TTL_SRC_PANEL: 0,

            init: function init(props) {
                this._super(props);

                
                var defn = this.defn;

                
                if (!defn) {
                    
                    defn = this.defn = this.node && this.node.defn;

                    
                    this.titleSrc = this.titleSrc || defn.ttlSrc;
                }

                
                var key = this.selectedKey = this.defn.selKey = this.node.data.selKey;

                
                this.set('selectedIdx', $ARR.find(this.node.data.panels, 'k', key));

                
                defn.attachEventListener('selKeyChange', this.id, function (evt) {
                    this.set('selectedKey', evt.value);
                });
            },

            
            addChildren: function addChildren(panels, idx, silent) {
                var fmts = this.getFormats(),
                    overflow = fmts && fmts.overflow;

                if (overflow) {
                    $ARR.forEach(panels, function (panel) {
                        var pnlFmts = panel.getFormats();
                        if (pnlFmts) {
                            pnlFmts.overflow = overflow;
                        }
                    });
                }

                return this._super(panels, idx, silent);
            },

            
            refresh: function refresh() {
                
                if (this.hasRendered) {
                    
                    var refreshKey = this.defn.newSelKey || this.selectedKey;
                    
                    
                    $ARR.forEach(this.children, function (child) {
                        
                        child._delayRefresh = (child.k !== refreshKey);

                        
                        if (!child._delayRefresh) {
                            
                            child.refresh();
                        }
                    });
                    
                }
                delete this.defn.newSelKey;
            },

            
            selectPanel: function selectPanel(key, hasLoader) {
                
                if (key !== this.selectedKey) {
                    
                    this.defn.set('selKeyChange', key);

                    
                    this.model.slice({
                        type: 3,
                        tks: this.k,
                        eid: key,
                        sid: this.node.data.wid,
                        ck: this.k,
                        hasLoader: hasLoader
                    });
                }
            },

            
            onselectedKeyChange: function onselKeyChg(evt) {
                var off, on, selectedIdx;

                
                $ARR.forEach(this.children, function (panel, idx) {
                    var panelKey = panel.k;

                    
                    if (evt.value === panelKey) {
                        
                        on = panel;
                        selectedIdx = idx;

                        
                        panel.set('selected', true);

                    
                    } else if (evt.valueWas === panelKey) {
                        
                        off = panel;

                        
                        panel.set('selected', false);
                    }

                    
                    if (on && off) {
                        
                        return false;
                    }
                });

                
                if (this.titleSrc === this.TTL_SRC_PANEL && this.title) {
                    this.set('title', on.title);

                    
                    this.defn.ttl = on.title;
                }

                
                this.prevSelectIdx = this.selectedIdx;
                this.set('selectedIdx', selectedIdx);

                
                this.raiseEvent({
                    name: 'panelSelected',
                    key: on.k
                });

                
                return {
                    on: on,
                    off: off
                };
            },

            
            setDirty: function setDirty(isDirty) {
                
                if (isDirty) {
                    
                    this.setDirtyChildren(true);
                }

                this._super(isDirty);
            },

            
            setDirtyChildren: function setDirtyChildren(includeAll) {
                
                var selectedKey = this.selectedKey;

                
                $ARR.forEach(this.children, function (child) {
                    
                    var key = child.k;
                    child[((includeAll || key !== selectedKey) ? 'add' : 'remove') + 'DirtyKey'](key);
                });
            },

            
            clearDirtyChild: function clearDirtyChild(key) {
                var panels = this.children,
                    panel = panels[$ARR.find(panels, 'k', key)];

                if (panel) {
                    panel.removeDirtyKey(panel.k);
                }
            },
            
            isPanelStack: true,
            
            checkRequiredObjects: function checkRequiredObjects() {
                var txWidgets = this.txWidgets || {}, 
                    i, w, flag = true;

                for (i in txWidgets){
                    
                    flag &= !!txWidgets[i].checkRequiredObjects();
                }
                
                return flag;
            },
            
            
            updateSelectedIdx: mstrmojo.emptyFn,
            
            
            switchToPanel: function switchToPanel(dir, selectedIdx) {
             
                if (selectedIdx !== undefined) {
                    
                    this.set('selectedIdx', selectedIdx);
                } else {
                    
                    this.updateSelectedIdx(dir);
                }

                
                this.children[this.selectedIdx] && this.selectPanel(this.children[this.selectedIdx].k);
            }
        }
    );
}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.array");
    
    
    function createInput(doc, n, v) {
        var el = doc.createElement('input');
        el.name = n;
        el.type = 'hidden'; 
        el.value = v;

        return el;
    }
    
    
    function _addURLAsHiddenInputsToForm(oForm, URL){
        URL = URL.substring(URL.indexOf("?") + 1,URL.length);
        var URLParameters = URL.split("&"),
            parameterName = "",
            parameterValue = "";

        
        
        
        var myRegExp = /\+/g;

        for (var i = 0, cnt = URLParameters.length; i < cnt; i++) {
            var p = URLParameters[i].split("=");
            parameterName = p[0];
            parameterValue = p[1];

            if (parameterValue) {
                parameterValue = decodeURIComponent(parameterValue.replace(myRegExp, ' '));
            }

            var oNewItem = document.createElement("INPUT");
            oNewItem.type="HIDDEN";
            oNewItem.name = parameterName;
            oNewItem.value = parameterValue;

            oForm.appendChild(oNewItem);
        }
        return false;
    }

    
    mstrmojo.form = {
            
        
        createDynamicForm:function createDynamicForm(sAction) {
            var oNewForm = document.createElement("FORM") ,
                hasParameters = sAction.indexOf('?') > 0;

            oNewForm.name = "dynamic_form";
            oNewForm.method = "POST";

            var formAction =  ((hasParameters) ? sAction.substring(0, sAction.indexOf('?')) : sAction);

            
            oNewForm.action = formAction;

            
            if (hasParameters) {
                
                _addURLAsHiddenInputsToForm(oNewForm, sAction);
            }

            
            document.body.appendChild(oNewForm);

            return oNewForm;
        },
        
        
        send: function send(params, action, method, target, config, addUxts) {
            
            var doc = ((config && config.hWin) || window).document,
                f = doc.createElement('form'),
                app = mstrApp;
            
            
            f.method = method || "GET";
            
            
            if (target) {
                
                f.target = target;
            }
            
            
            f.action = action || app.name;
            
            
            addUxts = (addUxts !== undefined )? addUxts:!(f.action && f.action.indexOf("aspx") > 0);
            
            
            if (app.sessionId) {
                
                f.action += ';jsessionid=' + app.sessionId;
            }

            
            
            if (addUxts) { 
                f.action += ';uxts' + mstrmojo.now();
            }
            
            
            f.appendChild(createInput(doc, 'xts', mstrmojo.now()));
            
            
            for (var key in app.persistTaskParams) {
            	params[key] = app.persistTaskParams[key];
            }
            
            
            if (app.servletState && app.name){
            	params[app.name] = app.servletState;
            }

            
            if (params) {
                
                for (var n in params) {
                    
                    if (params[n].constructor == Array) {
                        
                        mstrmojo.array.forEach(params[n], function (item) {
                            f.appendChild(createInput(doc, n, item));
                        });
                    } else {
                        
                        f.appendChild(createInput(doc, n, params[n]));
                    }
                }
            }
            
            
            doc.body.appendChild(f);

            
            try {
                f.submit();
            } catch (ex) {
                
                if (target && ex.result === 2147500037 && !window.open('', '', 'width=1,height=1,left=0,top=0,scrollbars=no')) {
                    mstrmojo.alert('*This action requires popups to be allowed in the browser.*');    
                } else {
                    mstrmojo.err('Form submission failed for an unknown reason.');         
                }
            }
            
            
            doc.body.removeChild(f);
        }
    };
})();
(function(){

	mstrmojo.requiresCls("mstrmojo.array");
	
    
    mstrmojo._HasBuilder = 
        
        {
            
            postBuildRendering: function postBldRndr() {
                if (!this.builtChildren) {
                    this.buildChildren();
                }
                return this._super();
            },

            getChildren: function getChildren(){
                return this.model.getChildren(this.node, false);
            },
            
                        
            buildChildren: function bldChdn(noAddChildren) {
                if (!this.builder || !this.model) {
                    return false;
                }

                
                
                if (this.children && this.children.length) {
                    this.set("children", []);
                }
                
                
                var m = this.model,
                    children = this.builder.build(
                        this.getChildren(),
                        m,
                        this.buildConfig
                );
                
                
                if (!noAddChildren) {
                    
                    this.addChildren(children);
                }
                
                
                this.builtChildren = true;
                
                
                return (noAddChildren) ? children : true;
            }            
    };
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.StringBuffer");

    var $D = mstrmojo.dom,
        $H = mstrmojo.hash,
        $A = mstrmojo.array;

    
    function destroyInfoWindows() {
        
        $H.forEach(this.ifwMap, function (infoWindow) {
            infoWindow.destroy();
        });

        
        this.ifwMap = {};
    }

    
    function recordInfoWins() {
        var ifwrds = [],
            sellyt = null,
            docScroll = null;
        $H.forEach(this.ifwMap, function (ifw) {
            if (ifw.visible) {
                ifwrds.push({
                    psId: ifw.psId,
                    psKey: ifw.psKey,
                    anchorPos: ifw.anchorPosition || $D.position(ifw.anchor, true),
                    anchorOrn: ifw.anchorOrientation
                });
            }
        });
        
        if (ifwrds.length > 0) {
            sellyt = this.getSelectedLayoutWidget();
            docScroll = sellyt && sellyt.getScrollPos();
        }
        
        return {ifwRecords: ifwrds, docScrollRecord: docScroll};
    }
    
    
    function restoreInfoWins(rd) {
        var ifwrds = (rd && rd.ifwRecords) || [],
            docScroll = rd && rd.docScrollRecord,
            sellyt = this.getSelectedLayoutWidget(),
            me = this,
            fakeAnchor= {};
        
        if (ifwrds.length > 0) {
            if (docScroll && sellyt) {
                sellyt.scrollTo(docScroll);
            }
            
            $A.forEach(ifwrds, function (rd) {
                me.showInfoWindow(rd.psId, rd.psKey, fakeAnchor, null, rd.anchorOrn, rd.anchorPos)
            })
        }
    }

    
    function destroyPopups() {
        mstrmojo.DICPopup && mstrmojo.DICPopup.cancel && mstrmojo.DICPopup.cancel();
    }
    
    function clearXtabStyleSheet() {
        
        if (this.xtabStyleSheets) {
            var stylesheet, i, parentNode;
            for (i = 0; stylesheet = this.xtabStyleSheets[i]; i++) {
                parentNode = stylesheet.parentNode;
                if (parentNode) {
                    parentNode.removeChild(stylesheet);
                }
            }
        }
    }

    function updateDocGroupBy(layoutKey, gbys) {
    	var layout = this.getLayout(layoutKey),
            docGB = layout.docGroupBy,
            ctrl = this.controller;

    	if (docGB) {
    		docGB.set('data', gbys.groupbys);
    		layout.gb = gbys;
    	}

        if (ctrl.getPageByTree) {  
            ctrl.getPageByTree(true);
        }
    }

    
    mstrmojo._IsRwDocument = {

        _mixinName: 'mstrmojo._IsRwDocument',

        
        updateXtabStyles: function updateXtabStyles(layoutKey, newStyles) {
            var styleSheet = this.xtabStyleSheets && this.xtabStyleSheets[0],
                styleList = this.styleList || {},    
                fnAddStyles = function (tgt, src) {  
                    var srcKey;

                    
                    for (srcKey in src) {
                        
                        var newCss = src[srcKey].css || '';

                        
                        if (src[srcKey].app) {
                            
                            newCss = (tgt[srcKey] || '') + newCss;
                        }

                        
                        tgt[srcKey] = newCss;
                    }

                    return tgt;
                },
                doc = document;

            
            if (!styleList[layoutKey]) {
                
                styleList[layoutKey] = fnAddStyles({}, this.model.getSelectedXtabStyles(layoutKey));
            }

            
            fnAddStyles(styleList[layoutKey], newStyles);

            
            if (!styleSheet) {
                
                this.xtabStyleSheets = [];
                styleSheet = this.xtabStyleSheets[0] = doc.getElementsByTagName('head')[0].appendChild(doc.createElement('style'));
            }

            
            var cssText = new mstrmojo.StringBuffer(),
                tgt,
                css;
            for (tgt in styleList) {
                for (css in styleList[tgt]) {
                    cssText.append(styleList[tgt][css]);
                }
                cssText.append('\n');
            }

            
            cssText = cssText.toString();

            
            if (styleSheet && cssText) {
                
                
                styleSheet = styleSheet.styleSheet || styleSheet;

                
                if ($D.isWK) {
                    
                    var firstChild = styleSheet.firstChild;
                    if (firstChild) {
                        
                        firstChild.nodeValue = cssText;
                    } else {
                        
                        styleSheet.appendChild(doc.createTextNode(cssText));
                    }
                } else if ($D.isIE) {
                    
                    styleSheet.cssText = cssText;
                    
                    
                    
                    
                    
                    var count, lastRule, selectorText, index;
                    for (count = 1; styleSheet.rules.length === 4095 && doc.styleSheets.length < 31; count++) {
                        lastRule = styleSheet.rules[4094];
                        selectorText = new RegExp(lastRule.selectorText, 'i');
                        index = cssText.search(selectorText);
                        if (index === -1) {
                            break;
                        }
                        index = cssText.indexOf('}', index + 1);
                        
                        cssText = cssText.slice(index + 1);
                        if (!this.xtabStyleSheets[count]) {
                            this.xtabStyleSheets[count] = doc.getElementsByTagName('head')[0].appendChild(doc.createElement('style'));
                        }
                        styleSheet = this.xtabStyleSheets[count].styleSheet;
                        styleSheet.cssText = cssText;
                    }
                } else {
                    
                    styleSheet.innerHTML = cssText;
                }
            }

            
            this.styleList = styleList;
        },

        
        postBuildRendering: function postBuildRendering() {
            
            if (this.xtabStyleSheets) {
                for (var stylesheet, i = 0; stylesheet = this.xtabStyleSheets[i]; i++) {
                    if (!stylesheet.parentNode) {
                        document.getElementsByTagName('head')[0].appendChild(stylesheet);
                    }
                }
            }
            return this._super();
        },

        
        buildChildren: function buildChildren(noAddChildren) {
            var rtn;

            try {
                var m = this.model;
                if (m) {
                    var subs = this.buildSubs || {},
                        s = m.id + '-partialUpdate',
                        r = m.id + '-rebuildLayout',
                        u = m.id + '-updateStyles',
                        ifw = m.id + '-showInfoWin',
                        id = this.id;
                    
                    
                    var me = this,
                        unloadLayoutCache = function() {
                            $A.forEach(me.getLayouts(), function(l) {
                                if (l.k !== m.currlaykey) {
                                    l.defn.loaded = false;
                                }
                            });
                        };

                    
                    if (subs[s] === undefined) {

                        
                        var fnUpdate = function updateDescendants(evt) {
                            var m = this.model,
                                dataCache = m && m.getLayoutDataCache(m.getCurrentLayoutKey()),
                                ids = evt && evt.ids;

                            
                            if ($H.isEmpty(dataCache) || !ids) {
                                
                                return;
                            }

                            
                            $A.forEach(evt.tree.layouts, function (l) {
                                
                                if (l.k === m.currlaykey) {
                                    
                                    this.updateXtabStyles(l.k, l.xtabStyles);

                                    
                                    if (l.gbys) updateDocGroupBy.call(this, l.k, l.gbys);

                                    
                                    return false;
                                }
                            }, this);

                            var $FE = $H.forEach,
                                shouldNotifyScrollListeners = false,
                                ups = {
                                    update: ids.upd,
                                    refresh: ids.tgts,
                                    adjustSectionSize: ids.secs
                                };

                             





                            
                            
                            $FE(ids.ifws, function (psId, psKey) {
                                var infoWindow = mstrmojo.all[psId + '_ifw'];

                                
                                if (infoWindow && infoWindow.visible) {
                                    this.updateInfoWindowPS(psId, psKey);
                                }
                            }, this);

                            
                            $FE(ups, function (col, meth) {
                                
                                $FE(col, function (v, id) {
                                    
                                    var w = mstrmojo.all[id],
                                        rtn;

                                    
                                    if (w && w[meth] !== undefined) {
                                        
                                        
                                        rtn = w[meth](meth === 'update' ? dataCache[id] : null);

                                        
                                        if (meth === 'adjustSectionSize' && rtn) {
                                            
                                            shouldNotifyScrollListeners = shouldNotifyScrollListeners || (!!rtn.heightReduced);
                                        }
                                    }
                                }, this);
                            }, this);

                            var selectedLayout = this.getSelectedLayoutWidget();

                            
                            if (shouldNotifyScrollListeners) {
                                selectedLayout.notifyScrollListeners();
                            }

                            
                            
                            var docLayout = selectedLayout.docLayout;
                            if (docLayout) {
                                docLayout.resizeOrReposition();
                            }
                            
                            
                            if(evt && evt.unloadCache) {
                                unloadLayoutCache();
                            }
                        };

                        subs[s] = m.attachEventListener('partialUpdate', id, fnUpdate);
                    }

                    
                    subs[r] = subs[r] || m.attachEventListener('rebuildLayout', id, function (evt) {
                        var restoreIW = evt && evt.restoreIW,
                            ifwRecords;
                        
                        if (restoreIW) { 
                            ifwRecords = recordInfoWins.call(this);
                            this.model.aws = null; 
                        }
                        
                        
                        this.onLayoutRebuilt(this.rebuildLayout(evt.src.currlaykey, this.getLayouts()));
    
                        
                        if (evt && evt.unloadCache) {
                            unloadLayoutCache();
                        }
                        
                        if (restoreIW) { 
                            restoreInfoWins.call(this, ifwRecords);
                        }
                    });

                    
                    subs[u] = subs[u] || m.attachEventListener('updateStyles', id, function (evt) {
                        this.updateXtabStyles(evt.key, evt.updatedStyles);
                    });

                    subs[ifw] = subs[ifw] || m.attachEventListener('showInfoWin', id, function (evt) {
                        this.showInfoWindow(evt.psId, evt.psKey, evt.anchor, evt.invalidate, evt.anchorOrientation, evt.anchorPosition);
                    });

                    this.updateXtabStyles(m.getCurrentLayoutKey());

                    
                    m.attachEventListener('refresh', this.id, function () {
                        this.refresh();
                    });
                }

                rtn = this._super(noAddChildren);


            } catch (ex) {
                mstrmojo.err(ex);
            }

            return rtn;
        },

        
        updateInfoWindowPS: mstrmojo.emptyFn,

        
        showInfoWindow: function showInfoWindow(psId, psKey, anchor, invalidate, anchorOrientation, anchorPosition) {
            var model = this.model,
                dataCache = model.getLayoutDataCache(model.getCurrentLayoutKey()),
                builder = this.builder,
                ifwDefn = dataCache[psId] && dataCache[psId].defn,
                infoPlacement = ifwDefn && ifwDefn.iwpl,
                id = psId + "_ifw",
                infoWindow = mstrmojo.all[id],
                domNode = this.domNode,
                ENUM_FIXED_PLACEMENT = mstrmojo.DocInfoWindow.PLACEMENT.FIXED,
                updatePopupPosition = function (infoWindowObj, parentDomNode, layoutNode, left, top) {
                    if (infoPlacement === ENUM_FIXED_PLACEMENT) {
                        if(parentDomNode){
                        var parentPosition = $D.delta(parentDomNode, domNode); 

                        
                        infoWindowObj.popPosition = {
                            left: (parentPosition && parentPosition.x) ? left + parentPosition.x : left,
                            top: (parentPosition && parentPosition.y) ? top + parentPosition.y : top
                        };
                        }else if(layoutNode){
                            infoWindowObj.popPosition = {
                                    left: (layoutNode.scrollboxLeft) ? left - layoutNode.scrollboxLeft : left,
                                    top: (layoutNode.scrollboxTop) ? top - layoutNode.scrollboxTop : top
                                };
                        }else{
                            infoWindowObj.popPosition = {
                                    left: left,
                                    top: top
                                };
                        }
                    }
                };

            var layoutNode = this.getLayout(model.getCurrentLayoutKey());
            
            if (infoWindow) {
                if (invalidate) {
                    
                    infoWindow.refresh();
                }

                infoWindow.anchorOrientation = anchorOrientation;
                infoWindow.anchorPosition = anchorPosition;

                
                updatePopupPosition(infoWindow, infoWindow._ifwpdn, layoutNode, infoWindow._ifwfl, infoWindow._ifwft);

                
                infoWindow.open(this, {
                    anchor: anchor,
                    boundary: domNode
                });

            } else {
                var cfg = {
                        opener: this,
                        anchor: anchor,
                        anchorOrientation: anchorOrientation,
                        boundary: domNode,
                        parent: this,
                        builder: builder,
                        model: this.model,
                        psKey: psKey,
                        psId: psId,
                        id: id,
                        autoCloses: true,
                        locksHover: true,
                        closeOnClick: false,
                        anchorPosition: anchorPosition
                    };

                if (infoPlacement) {
                    infoPlacement = parseInt(infoPlacement, 10);
                    cfg.placement = infoPlacement;

                    
                    if (infoPlacement === ENUM_FIXED_PLACEMENT) {
                        var formats = ifwDefn.fmts,
                            left = cfg._ifwfl = formats && formats.left && parseInt(formats.left.replace('px', ''), 10), 
                            top = cfg._ifwft = formats && formats.top && parseInt(formats.top.replace('px', ''), 10),  
                            infoWindowParent = dataCache[psId] && dataCache[psId].p,
                            parentObject = infoWindowParent && model.getUnitInstance(infoWindowParent.k, infoWindowParent.wid),
                            parentDomNode = cfg._ifwpdn = parentObject && parentObject.domNode;

                        
                        updatePopupPosition(cfg, parentDomNode, layoutNode, left, top);
                    }
                }

                
                infoWindow = builder.newInfoWindow(cfg);

                
                this.renderInfoWindow(infoWindow);

                
                var infoMap = this.ifwMap = (this.ifwMap || {});
                infoMap[psId] = infoWindow;
            }
        },

        
        renderInfoWindow: function renderInfoWindow(infoWindow) {
            infoWindow.render();
        },

        _lockInfoWinContainer: function lockInfoWinContainer(config) {
            var ifwm = this.ifwMap,
                k;
            for (k in ifwm) {
                var ifw = ifwm[k],
                    xtab = config.xtab;
                if (ifw && xtab &&
                        $D.contains(ifw.infoNode, xtab.domNode, true, document.body)) {
                    ifw.autoCloseLocked = true;
                    config.onClose = function () {
                        ifw.autoCloseLocked = false;
                    };
                    break;
                }
            }
        },

        
        unrender: function unrender(ignoreDom) {
            
            destroyInfoWindows.call(this);

            this._super(ignoreDom);

            clearXtabStyleSheet.call(this);
        },

        getLayouts: function getLayouts() {
            return this._layouts;
        },

        
        getLayout: function getLayout(key) {
            key = key || this.model.getCurrentLayoutKey();
            var layouts = this.getLayouts();
            return layouts[$A.find(layouts, 'k', key)];
        },

        getNewLayout: function getNewLayout(params, layouts, isSelected, callback) {
            var me = this,
                model = me.model,
                dataService = model.getDataService(),
                key = params.layoutKey,
                layout = layouts[$A.find(layouts, 'k', key)];  

            
            if (layout.defn && (params.reload || layout.defn.loaded === false || (model.zt && (window.mstrMobileApp !== undefined) && (layout.defn.lastOrientation !== mstrMobileApp.getOrientation())))) {
                
                var fnSuccess = callback.success;
                callback.success = function (res) {

                    
                    model.replaceLayout(key, res);

                    
                    
                    model.currlaykey = key;

                    
                    if (isSelected) {
                        
                        layout.zf = res.zf;

                        
                        me.selectLayout(layout, false);
                    }


                    var newLayout = me.rebuildLayout(key, layouts);

                    if (me.controller.getPageByTree) {  
                        me.controller.getPageByTree(true);
                    }

                    
                    fnSuccess(newLayout);
                };

                
                dataService.loadDocLayout(params, callback);

            } else {
                
                callback.success(layout);

                
                if (isSelected) {
                    
                    this.selectLayout(layout, true, {
                        success: function (res) {
                            $H.copyProps(['bs'], res, model);
                        }
                    });
                }

            }
        },

        selectLayout: function selectLayout(layout, updateServer, callback) {
            
            var model = this.model,
                key = layout.k,
                isNewKey = (key !== model.currlaykey);

            
            model.currlaykey = key;

            
            this.restoreLayoutState(layout);

            
            if (updateServer && isNewKey) {
                
                model.getDataService().setCurrentDocLayout(key, callback);

            
            } else if (callback && callback.complete) {
                
                callback.complete();
            }

            
            return layout;
        },

        
        rebuildLayout: function rebuildLayout(k, layouts) {
            var model = this.model,
                findLayout = $A.find,
                oldLayout = layouts[findLayout(layouts, "k", k)],
                nodes = model.getChildren(this.node, false);

            var newLayout = nodes[findLayout(nodes, 'k', k)];

            
            if (window.mstrMobileApp !== undefined) {
                newLayout.defn.lastOrientation = mstrMobileApp.getOrientation();
            }

            
            var c = this.replaceLayout(oldLayout, newLayout);

            
            this.updateXtabStyles(k, model.getSelectedXtabStyles(k));

            
            destroyInfoWindows.call(this);

            destroyPopups();
            
            return c;
        },



        
        destroy: function destroy() {

            
            destroyInfoWindows.call(this);

            
            if (this._super) {
                this._super();
            }

            clearXtabStyleSheet.call(this);
        },

        
        replaceLayout: mstrmojo.emptyFn,

        
        restoreLayoutState: mstrmojo.emptyFn,

        
        onLayoutRebuilt: mstrmojo.emptyFn,

        
        unloadGbLayuts: function unloadGbLayuts(groupbyKey) {
            var layouts = this.getLayouts(),
                curLayoutKey = this.model.getCurrentLayoutKey(),
                layout,
                i,
                gb,
                groupbys,
                k,
                gbDssId;

            
            layout = this.getLayout();
            groupbys = layout.gb && layout.gb.groupbys;
            for (k = 0; k < groupbys.length; k++) {
                gb = groupbys[k];
                if (gb.k === groupbyKey) {
                    gbDssId = gb.unit.target.did;
                    break;
                }
            }

            
            for (i = 0; i < layouts.length; i++) {
                layout = layouts[i];
                if (layout.k === curLayoutKey) {
                    continue;
                }
                groupbys = layout.gb && layout.gb.groupbys;
                if (groupbys && groupbys.length) {
                    for (k = 0; k < groupbys.length; k++) {
                        gb = groupbys[k];
                        if (gb.unit.target.did === gbDssId) {
                            
                            
                            layout.defn.loaded = false;
                            break;
                        }
                    }
                }
            }
        }
    };
}());
(function(){
    mstrmojo.requiresCls("mstrmojo.array");
    
    mstrmojo.requiresDescs(4891);
    var _A = mstrmojo.array,
        ELEM_ALL_ID = 'u;',
        ELEM_DUMMY_ID = '-1';
    
    
    mstrmojo.elementHelper = mstrmojo.provide(
        "mstrmojo.elementHelper",
        {
            
            
            buildElemsTerseID: function buildElemsTerseID(elems, attrId, delDN) {
                var item;
                for (var i in elems) {
                    item = elems[i];
                    if (item.v) {
                        var vs = item.v.split(';');
                        if (vs && vs.length > 1) {
                            vs[1] = attrId;
                            
                            
                            if (delDN && vs.length > 2) {
                                vs.pop();
                            }
                            item.v = vs.join(';');
                        }
                    }
                }
                
                return elems;
            },
            
            buildElemsCountStr: function buildElemsCountStr(ces, elems) {
                if (!ces || !ces.length || !elems || !elems.length) {
                    return '';
                }
                
                var sc = ces.length, 
                    tc = elems.length;
                
                
                if (_A.find(elems, 'v', ELEM_ALL_ID) > -1) {
                    tc -= 1;
                }
                
                if (_A.find(elems, 'v', ELEM_DUMMY_ID) > -1) {
                    tc -= 1; 
                }
                
                
                if (_A.find(ces, 'v', ELEM_ALL_ID) > -1 || _A.indexOf(ces, ELEM_ALL_ID) > -1) {
                    sc = tc;
                }
                
                
                if (sc >= tc) {
                    return '(' + tc + ')';
                } else {
                	
                    return mstrmojo.desc('4891').replace('##', sc).replace('###', tc);
                }
            }               
        });
})();
(function() {
	mstrmojo.requiresCls("mstrmojo.array");
	
	var $ARR = mstrmojo.array;
	
	
	function _registerEllipsize(widget) {
		
		if(widget.parent) {
	        if (widget.parent.shouldEllipsizeChildren === undefined) {
	            mstrmojo.mixin(mstrmojo._HasEllipsis, widget.parent);
	        }
	        
	        widget.parent.set('shouldEllipsizeChildren', true);
		}
	};
	
	
	mstrmojo._HasEllipsis = mstrmojo.provide (
			'mstrmojo._HasEllipsis',
			{
			
			shouldEllipsize: false,
			
			
			shouldEllipsizeChildren: false,
			
			
			doEllipsize: function() {
			    if(this.shouldEllipsizeChildren) {
    				$ARR.forEach(this.children, function(ch, idx) {
    					if(ch.shouldEllipsize) {
    						ch.doEllipsize();
    					}
    				});
			    }
			},
			
			
			onshouldEllipsizeChange: function() {
		        if (this.shouldEllipsize) {
		        	_registerEllipsize(this);
		        	
		        	mstrmojo.mixin({
		        					onvisibleChange: function() {
						        		if (this._super) {
						                	this._super();
						                }
		                            	if (this.visible && this.hasRendered && this.shouldEllipsize) {
		                            		this.doEllipsize();
		                                }
		        					}
		            }, this.markupMethods);
		        }
			}
	});
})();

(function () {

    mstrmojo.requiresCls("mstrmojo.array");

    var MAX_TOOLTIPS = 10, 
        TOOLTIP_PADDING = 20,
        tooltipPositionChanged = false,
        rightTooltipPositionChanged = false,
        maxAreasToShow = MAX_TOOLTIPS,
        tooltipsToPosition = [],
        $ARR = mstrmojo.array,
        hasLargeTooltip = false,    
        TOOLTIP_PADDING_LEFT_RIGHT, 
        topTitleHeight;


    
    var AreaShapePolygon = 6,
        AreaShapeRectangle = 7,
        AreaShapeCircle = 100,
        AreaShapeRingSector = 101,
        AreaShapeNormalSector = 102,
        AreaShapeCylinder = 103;

    function drawPoly(ctx, pointsArray, clr) {
        
        var startX = pointsArray[0],
            startY = pointsArray[1],
            j;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        for (j = 2; j < pointsArray.length - 1; j = j + 2) {
            ctx.lineTo(pointsArray[j], pointsArray[j + 1]);
        }
        ctx.lineTo(startX, startY); 

        
        ctx.fillStyle = clr;

        ctx.stroke();

        ctx.fill();
    }

    function drawRectangle(ctx, pointsArray, clr) {
        var x = pointsArray[0],
            y = pointsArray[1],
            width = pointsArray[2] - x,
            height = pointsArray[3] - y;

        ctx.fillStyle = clr;

        ctx.strokeRect(x, y, width, height);
        ctx.fillRect(x, y, width, height);
    }

    function drawRingSector(ctx, pointsArray, clr) {
        var centerX = pointsArray[0],
            centerY = pointsArray[1],
            innerRadius = pointsArray[2],
            outerRadius = pointsArray[3],
            startAngle = pointsArray[4],
            endAngle = pointsArray[5];

        ctx.beginPath();
        
        ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
        
        ctx.lineTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
        
        ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);

        ctx.closePath();

        
        ctx.fillStyle = clr;
        ctx.stroke();
        ctx.fill();

    }

    function drawNormalSector(ctx, pointsArray, clr) {
        var centerX = pointsArray[0],
            centerY = pointsArray[1],
            radius = pointsArray[2],
            startAngle = pointsArray[3],
            endAngle = pointsArray[4],
            scale = pointsArray[5];
        ctx.scale(1, scale);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
        ctx.lineTo(centerX, centerY);
        ctx.arc(centerX, centerY, 0, endAngle, startAngle, true);
        ctx.closePath();
        
        
        ctx.fillStyle = clr;
        ctx.stroke();
        ctx.fill();
        ctx.scale(1, 1/scale);
    }

    function drawCylinder(ctx, pointsArray, clr) {
        var centerX = pointsArray[0],
            centerY = pointsArray[1],
            radius = pointsArray[2],
            startAngle = pointsArray[3],
            endAngle = pointsArray[4],
            depth = pointsArray[5],
            scale = pointsArray[6];
        ctx.scale(1, scale);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
        ctx.lineTo(centerX+radius*Math.cos(endAngle), centerY+radius*Math.sin(endAngle)-depth);
        ctx.arc(centerX, centerY - depth, radius, endAngle, startAngle, true);
        ctx.closePath();
        
        
        ctx.fillStyle = clr;
        ctx.stroke();
        ctx.fill();
        ctx.scale(1, 1/scale);
    }
    
    function drawCircle(ctx, pointsArray, clr) {
        
        ctx.fillStyle = clr;
        ctx.beginPath();
        ctx.arc(pointsArray[0], pointsArray[1], pointsArray[2], 0, Math.PI * 2, true);
        ctx.stroke();
        ctx.fill();
    }

    function sortAreaElements(a, b) {
        return a.Point.X - b.Point.X;
    }

    function setTooltipInfo(area, ep, tooltipPosition) {
        var tooltip = this.tooltipArr[tooltipPosition],
            ttl = area.Text,
            borderColor = area.SC,
            style = tooltip.style,
            zoom = (this.model.zf || 1),
            deviceDPI = mstrMobileApp.getDeviceDPI() / 160,
            padding = 2 * deviceDPI,
            tooltipMaxWidth = mstrApp.getScreenDimensions().w - (TOOLTIP_PADDING_LEFT_RIGHT * 2); 
            

        
        if (mstrApp.isTablet()) {            
            zoom = (zoom * deviceDPI) + 'em';
        } else if (mstrMobileApp.getDeviceDPI() > 240) {  
            zoom = (zoom * 1.5) + 'em';
        } else {
            zoom += 'em';
        }

        
        var cssText = 'font-size:' + zoom + ';';

        
        cssText += 'padding:' +  padding + 'px;';
        
        
        cssText += 'maxWidth:' + tooltipMaxWidth + 'px;';

            
        if (borderColor) { 
            cssText += 'border-color:#' + borderColor;
        }

        tooltip.innerHTML = ttl;
        style.cssText = cssText;

        style.display = 'block';

        
        var top = 0,
            left = 0;

        var offsetHeight = tooltip.offsetHeight,
            offsetWidth = tooltip.offsetWidth;

        
        top = ep.y - offsetHeight - 6;
        left = ep.x - offsetWidth - 6; 

        tooltipsToPosition.push({
            x: area.Point.X,
            y: area.Point.Y,
            clr: borderColor || '#000000',
            top: top,
            left: left,
            width: offsetWidth,
            height: offsetHeight
        });
    }

    function setSingleTooltipPosition(graph, tooltip, posElement) {
        
        var left = posElement.left,
            top = Math.max(posElement.top, topTitleHeight + TOOLTIP_PADDING) 
            width = posElement.width,
            style = tooltip.style,
            newLeft = left + width + 12;

        
        if (newLeft + width <= mstrApp.getScreenDimensions().w) {
            left = newLeft;
        } else if(left < 0) {  
            left = TOOLTIP_PADDING_LEFT_RIGHT;
        }

        style.left = left + 'px';
        style.top = top + 'px';

        graph.showAreaMarker(posElement.x, posElement.y, posElement.clr);
    }

    function positionLeftColumnTooltip(graph, position) {
        var posElement = tooltipsToPosition[position],
            tooltipArr = graph.tooltipArr,
            style = tooltipArr[position].style,
            left = posElement.left,
            top = posElement.top,
            width = posElement.width,
            height = posElement.height,
            screenWidth = mstrApp.getScreenDimensions().w,
            i,
            newLeft;

        if (position > 0) {
            
            var prevPosElem = tooltipsToPosition[position - 1],
                prevTop = prevPosElem.top,
                prevLeft = prevPosElem.left,
                prevRight = prevLeft + prevPosElem.width,
                currRight = prevLeft + width,
                prevTooltip;

            left = prevLeft;
            
            if (currRight > prevRight) {
                left -= (currRight - prevRight);
            } else if (currRight < prevRight) {
                left += (prevRight - currRight);
            }

            if (left < 0) {
            	
                if ((width * 2 ) + 12 > screenWidth) {
                	tooltipPositionChanged = false; 
                    hasLargeTooltip = true;
                    left = TOOLTIP_PADDING_LEFT_RIGHT;
                    
                    
                    for(i = 0; i < position; i++) {
                    	prevTooltip = tooltipArr[i];
                        prevPosElem = tooltipsToPosition[i];
                        newLeft = left + width - prevPosElem.width;
                        prevPosElem.left = newLeft;
                        prevTooltip.style.left = left + width - prevPosElem.width + 'px'; 
                    }
                    
                } else {
                    
                    tooltipPositionChanged = true;
                }
            }

            
            top = prevTop - TOOLTIP_PADDING - height;

            
            if (top < topTitleHeight) {

            	var pushHeight =  Math.abs(top) + topTitleHeight + TOOLTIP_PADDING;

                for (i = 0; i < position; i++) {
                    prevTooltip = tooltipArr[i];
                    prevPosElem = tooltipsToPosition[i];
                    prevTop = prevPosElem.top + pushHeight;

                    
                    prevPosElem.top = prevTop;
                    prevTooltip.style.top = prevTop + 'px';
                }
                top += pushHeight;
            }
        } else {
            
            if (left < 0) {
                
                
                if ((width * 2 ) + 12 > screenWidth) {
                    hasLargeTooltip = true;
                    left = TOOLTIP_PADDING_LEFT_RIGHT;
                } else {
                    
                    tooltipPositionChanged = true;
                }
            }
            
            if (top < topTitleHeight) {
                top = topTitleHeight + TOOLTIP_PADDING;
            }
        }

        
        if (!tooltipPositionChanged) {
            style.left = left + 'px';
            
            posElement.left = left;
        }

        style.top = top + 'px';

        
        posElement.top = top;

        graph.showAreaMarker(posElement.x, posElement.y, posElement.clr);
    }

    function positionRightColumnTooltip(graph, position, adjustCount, left) {
        var style = graph.tooltipArr[position].style,
            posElement = tooltipsToPosition[position],
            top = tooltipsToPosition[position - adjustCount].top,
            width = posElement.width;

        if (left + width > mstrApp.getScreenDimensions().w) {
            rightTooltipPositionChanged = true;
            style.display = 'none'; 
            return;
        }

        style.left = left + 'px';
        style.top = top + 'px';

        graph.showAreaMarker(posElement.x, posElement.y, posElement.clr);
    }

    function setMultiTooltipPositions(graph) {
        var tooltipsSize = tooltipsToPosition.length,
            tooltipArr = graph.tooltipArr,
            halfTooltipsSize = Math.ceil(tooltipsSize / 2),
            i = 0,
            adjustCount = 1,
            maxColTooltipSize = Math.min(tooltipsSize, MAX_TOOLTIPS / 2),
            screenWidth = mstrApp.getScreenDimensions().w,
            posElement,
            left,
            currTooltip;

        
        for (i = 0; i < halfTooltipsSize; i++) {
            positionLeftColumnTooltip(graph, i);
        }

        
        if (tooltipPositionChanged || hasLargeTooltip) {
            
            for (i; i < maxColTooltipSize; i++) {
                positionLeftColumnTooltip(graph, i);
            }

            if(!hasLargeTooltip) {
            	var j = i - 1,
            	    rightMostPosition = 0,
            	    tempPosition = 0,
            	    biggestPosElement,
            	    currentPosElementWidth;
            	posElement = tooltipsToPosition[j];
            	left = posElement.left + posElement.width + 12;  

            	for (j = i - 1; j >= 0; j--) {
            		currTooltip = tooltipArr[j];
            		currentPosElementWidth = tooltipsToPosition[j].width;
            		
            		if(left + currentPosElementWidth > screenWidth) {
            			tempPosition = TOOLTIP_PADDING_LEFT_RIGHT +  currentPosElementWidth;
            			if(tempPosition > rightMostPosition) {
            				rightMostPositon = tempPosition;
            				biggestPosElement = tooltipsToPosition[j];
            			}
            		}
            		currTooltip.style.left = left + 'px';
            	}
            	
            	
            	if(rightMostPosition > 0) {
            		for(j = 0; j < i; j++) {
            			currTooltip = tooltipArr[j];
            			currTooltip.style.left = (TOOLTIP_PADDING_LEFT_RIGHT + biggestPosElement.width -  tooltipsToPosition[j].width) + 'px';
            		}
            	}
            }
        } else {
            
            posElement = tooltipsToPosition[tooltipsSize - 1];
            left = posElement.left + posElement.width + 12;  

            for (i; i < tooltipsSize; i++) {
                positionRightColumnTooltip(graph, i, adjustCount, left);
                adjustCount += 2; 
                if (rightTooltipPositionChanged) {
                    break;
                }
            }

            
            if (rightTooltipPositionChanged && i <= maxColTooltipSize) {
                for (i = halfTooltipsSize; i < tooltipsSize; i++) {
                    positionLeftColumnTooltip(graph, i);
                    tooltipArr[i].style.display = 'block';
                }
            }
        }
    }

    function setTooltipPositions() {
        var me = this,
            numTooltips = tooltipsToPosition.length;

        if (numTooltips === 0) {
            return; 
        }

        topTitleHeight = mstrApp.rootView.getTitleHeight();  

        if (numTooltips === 1) {
            setSingleTooltipPosition(me, me.tooltipArr[0], tooltipsToPosition[0]);
        } else {
            setMultiTooltipPositions(me);
        }

    }

    function drawShape(shapeType, ctx, coords, color) {
        switch (shapeType) {
        case AreaShapeRectangle:
            drawRectangle(ctx, coords, color);
            break;

        case AreaShapeCircle:
            drawCircle(ctx, coords, color);
            break;
        case AreaShapeRingSector:
            drawRingSector(ctx, coords, color);
            break;
        case AreaShapeNormalSector:
            drawNormalSector(ctx, coords, color);
            break;
        case AreaShapeCylinder:
            drawCylinder(ctx, coords, color);
            break;
        default:
            drawPoly(ctx, coords, color);
        }
    }

    
    mstrmojo.graph._MobileGraphAreaHelper = mstrmojo.provide(
        "mstrmojo.graph._MobileGraphAreaHelper",

        
        {

            highlightArea: function highlightArea(animationCanvas, areas) {
                var me = this,
                    ctx = animationCanvas.getContext('2d'),
                    color = 'rgba(255, 255, 255, 0.5)';

                
                me.clearHighlightArea(animationCanvas);

                
                ctx.strokeStyle = "#FFFFFF";

                $ARR.forEach(areas, function (area) {
                    drawShape(area.Shape, ctx, area.Coords, color);
                });

            },

            highlightAreaInInit: function highlightAreaInInit(animationCanvas, selected) {
                var ctx = animationCanvas.getContext('2d'),
                    allAreas = this.graphData.Areas,
                    color = 'rgba(255, 255, 255, 0.5)';

                
                ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);

                
                ctx.strokeStyle = "#FFFFFF";

                var numAreas = allAreas.length,
                    DssGraphRiser = 286,
                    DssGraphDataMarker = 259,
                    DssGraphPieSlice = 341;

                var numOfSelected = selected.length / 2,
                    j,
                    i;
                for (i = 0; i < numAreas; i++) {
                    var area = allAreas[i],
                        areaOID = parseInt(area.OID, 10);

                    if (areaOID !== DssGraphRiser && areaOID !== DssGraphDataMarker && areaOID !== DssGraphPieSlice) {
                        continue;
                    }

                    if (area.SID < 0 || area.GID < 0) {
                        continue;
                    }
                    for (j = 0; j < numOfSelected; j++) {
                        if (area.SID !== selected[2 * j] || area.GID !== selected[2 * j + 1]) {
                            continue;
                        }

                        drawShape(area.Shape, ctx, area.Coords, color);
                    }

                }
            },

            clearHighlightArea: function clearHighlightArea(animationCanvas) {
                if (animationCanvas) {
                    var ctx = animationCanvas.getContext('2d');
                    ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
                    animationCanvas.width = animationCanvas.width;  
                }
            },

            showAreaMarker: function showAreaMarker(x, y, clr) {
                if (x >= 0 && y >= 0) {

                    var ctx = this.highlightNode.getContext('2d');

                    ctx.save();
                    ctx.fillStyle = '#FFFFFF'; 
                    ctx.strokeStyle = clr || '#000000';
                    ctx.lineWidth = 2;

                    
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2, true);
                    ctx.stroke();
                    ctx.fill();

                    
                    ctx.fillStyle = clr || '#000000';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2, true);
                    ctx.stroke();
                    ctx.fill();


                    ctx.restore();
                }

            },

            displayTooltips: function displayTooltips(areas, adjustX, adjustY) {
                
                areas.sort(sortAreaElements);

                var tooltipArr = this.tooltipArr,
                    i;

                tooltipPositionChanged = false;
                rightTooltipPositionChanged = false;
                tooltipsToPosition = [];
                this.clearHighlightArea(this.highlightNode);

                
                if (!tooltipArr) {
                    TOOLTIP_PADDING_LEFT_RIGHT = 8 * (mstrMobileApp.getDeviceDPI() / 160); 

                    tooltipArr = [];
                    for (i = 0; i < MAX_TOOLTIPS; i++) {
                        var divEl = document.createElement('div');

                        divEl.id = 'mstrmojo-mobileGraph-tooltip';
                        divEl.className = mstrmojo.GraphBase.tooltipCLS;
                        document.body.appendChild(divEl);
                        tooltipArr[i] = divEl;
                    }
                    this.tooltipArr = tooltipArr;
                }

                maxAreasToShow = Math.min(areas.length, MAX_TOOLTIPS);

                var touchManager = mstrmojo.touchManager;

                if (maxAreasToShow === 0 && this._touchListener) {
                    
                    touchManager.detachEventListener(this._touchListener);
                    delete this._touchListener;
                } else if (maxAreasToShow > 0 && !this._touchListener) {
                    this._touchListener = touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                    	
                    	
                    	var sourceWidget = mstrmojo.all[evt.srcId];
                    	
                    	if (!(sourceWidget instanceof mstrmojo.android.ui.ActionToolbarButtons 
                    			|| sourceWidget instanceof mstrmojo.android.ui.Menu)) {
	                    	this.displayTooltips([], 0, 0);   
	                    }
                    });
                }

                var area = null,
                    ep = {},
                    style;

                hasLargeTooltip = false; 
                
                
                for (i = 0; i < MAX_TOOLTIPS; i++) {
                    style = tooltipArr[i].style;
                    style.left = -9999; 
                    style.display = 'none';
                }

                
                for (i = 0; i < maxAreasToShow; i++) {
                    area = areas[i];
                    ep.x = area.Point.X + adjustX;
                    ep.y = area.Point.Y + adjustY;
                    
                    setTooltipInfo.call(this, area, ep, i);
                }

                
                setTooltipPositions.call(this);

                
                window.setTimeout(function () {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },

            destroy: function dst(skipCleanup) {
                
                $ARR.forEach(this.tooltipArr, function (tooltip) {
                    
                    document.body.removeChild(tooltip);
                });

                delete this.tooltipArr;

                if (this._super) {
                    this._super(skipCleanup);
                }
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.EnumMenuOptions");

    var $MENUS = mstrmojo.android.EnumMenuOptions,
        TRANSACTIONS_QUEUE = $MENUS.TRANSACTIONS_QUEUE;

    
    function getTransactionNotificationController() {
        return mstrApp.getTransactionNotificationController();
    }

    
    function isDocumentController() {
        return (!this.hsc && (this.st === 14081));
    }

    
    mstrmojo.android.controllers._SupportsQueuedTransactions = mstrmojo.provide(

        "mstrmojo.android.controllers._SupportsQueuedTransactions",

        {
            _mixinName: "mstrmojo.android.controllers._SupportsQueuedTransactions",

            
            getTxnToolbarButton: function getTxnToolbarButton(tbCfg) {
                
                var txController = getTransactionNotificationController();

                
                
                
                if (txController && txController.hasTransactionQueue((isDocumentController.call(this)) ? this.did : null)) { 
                    tbCfg.addToolbarBtn(TRANSACTIONS_QUEUE, mstrmojo.desc(9262, 'Transactions Queue'), TRANSACTIONS_QUEUE, true, 18);
                }

                return tbCfg;
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                
                if (group === TRANSACTIONS_QUEUE) {
                    
                    var did,
                        title;

                    
                    if (isDocumentController.call(this)) {
                        did = this.did;
                        title = this.ttl;
                    }

                    
                    getTransactionNotificationController().showNotificationBoard(this, did, title);
                } else {
                    this._super(group, cmdId);
                }
            }
        }
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.hash");
    
    var $H = mstrmojo.hash;
    
    
    mstrmojo._CanSupportTransaction = {
            
        _mixinName: "mstrmojo._CanSupportTransaction",
        
        
        updatedCellsMap: null,
                        
        
        getUpdates: mstrmojo.emptyFn, 
        
        
        getUpdateObject: mstrmojo.emptyFn, 

        
        getKeyContext: mstrmojo.emptyFn, 
        
        
        autoRefresh: mstrmojo.emptyFn, 
        
        
        editNext: mstrmojo.emptyFn,
        
        
        dataChanged: function dataChanged(k, r, v, d) {
            
            var autoRefresh = this.updateValue(k, v);
            
            this.updatedCellsMap[k] = {r: r, v: v};
            
            
            this.controller.onTransactionUpdates(this, this.getUpdateObject(), autoRefresh);
        },
        
        
        postBuildRendering: function pstBldRnd() {
            if(this._super) {
                this._super();
            }
            
            if (!this.txModel){
            	this.txModel = this.model.docModel || this.model;
            }
            
            this.updatedCellsMap = this.updatedCellsMap || {};           
        },

        
        updateValue: function(k, v) {
            if(this.txModel.deltaUpdate) {
                this.txModel.deltaUpdate(this);
            }
            return false;
        },

        
        getUpdatedValues: function() {
            var um = this.updatedCellsMap,
                i, u, vs = [];
            for(i in um) {
                if(um.hasOwnProperty(i)) {
                    u = {};
                    u.v = um[i].v.v;
                    vs.push($H.copy(this.getKeyContext(i), u));
                }
            }
            return vs;
        },        
        
        
        clear: function() {
            this.updatedCellsMap = {};
        },
        
        
        registerTxWidget: function(){
            function fnRegisterOnPS(w, ps){
                var k = w.node.data.k;
                ps.txWidgets = ps.txWidgets || {};
                ps.txWidgets[k] = w;
                return false;
            }

            var p = this.parent;
            while (p){
                if (p.isPanelStack === true){
                    
                    fnRegisterOnPS(this, p);
                }
                p = p.parent;
            }
        }
    };
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.StringBuffer",
                         "mstrmojo.hash");
    
    var CLASS_NAME = 'AndroidServerTransport';
    
    
    mstrmojo.android.AndroidServerTransport = {
            
        
        serverRequest: function serverRequest(id, requestId, request) {
            
            var url = new mstrmojo.StringBuffer(),
                urlStr, rqst;
            mstrmojo.hash.forEach(request.params, function (v, n) {
                url.append(n + '=' + encodeURIComponent(v));
            });
            urlStr = request.taskURL + '?' + url.toString('&');
            request.params.hostUrl = request.taskURL;
            if ( mstrApp.useBinaryFormat) {
                rqst = JSON.stringify({
                    params: request.params,
                    url: urlStr
                });
            } else {
                rqst = urlStr;
            }
            
            $MAPF(true, CLASS_NAME, 'transportRequest');
            
            
            mstrMobileTransport.serverRequest(id, requestId, rqst, 'response', 'progress');
        },
        
        
        cancelRequest: function cancelRequest(requestId) {
            $MAPF(false, CLASS_NAME, 'transportRequest');
            
            return mstrMobileTransport.cancelRequest(requestId);
        }
    };
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo._HasDrillLinks",
                         "mstrmojo.registry",
                         "mstrmojo.hash",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    
    
    
    function getPopupDelegate(widget) {
        var w = widget;
        while (w) {
            if (w.openDrillLinkMenu) {
                return w;
            }
            w = w.parent;
        }

        return null;
    }


    
    mstrmojo._HasHoverButton = mstrmojo.provide(
        'mstrmojo._HasHoverButton',

        
        mstrmojo.hash.copy(mstrmojo._HasDrillLinks, {
            
            _mixinName: 'mstrmojo._HasHoverButton',

            buttonNodeMarkup: '<div class="mstrmojo-LinkInfo-buttonNode"></div>',

            init: function init(p) {
                this._super(p);

                this.markupSlots.buttonNode = function () { return this.domNode.lastChild; };
            },

            postBuildRendering: function pstBldRnd() {
                if (!this.hoverBtn) {
                    this.addChildren(mstrmojo.registry.ref({
                        scriptClass: "mstrmojo.Button",
                        slot: "buttonNode",
                        alias: "hoverBtn",

                        onclick: function onclick() {
                            this.openPopup();
                        },

                        openPopup: function openPopup() {
                            var dl = getPopupDelegate(this);
                            if (dl) {
                                dl.openDrillLinkMenu({
                                    openerButton: this,
                                    drillLinkItems: this.parent.drillLinkItems,
                                    cmPos: this.cmPos
                                });
                            }
                        },

                        closePopup: function closePopup() {
                            var dl = getPopupDelegate(this);
                            if (dl) {
                                dl.closeDrillLinkMenu();
                            }
                        }

                    }));
                }

                var ret = this._super();

                
                var id = this.id;
                $DOM.attachEvent(this.domNode, 'contextmenu', function (e) {
                    mstrmojo.all[id].oncontextmenu(e, self);
                });

                return ret;
            },

            
            oncontextmenu: function (e, hWin) {
                var btn = this.hoverBtn;
                btn.cmPos = $DOM.getMousePosition(e, hWin);
                btn.openPopup();
                btn.cmPos = null;

                $DOM.preventDefault(hWin, e);
            }
        })
    );
}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo.hash");
    
    var _D = mstrmojo.dom,
        _H = mstrmojo.hash;
    
            
    var MS_PER_FRAME = 100;
    
    
    var SPEED_AMP = _D.supportsTouches ? 0.5 : 1;

    
    var MIN_VELOCITY = 1;
    
    
    
    var DRAG_TIME_LIMIT = 100;

    
    var commonMarkupMethods = {
            onvscrollVisibleChange: function(){
                var v = this.vscrollNode,
                    s = v && v.style;
                if (!s) {
                    return;
                }
                
                if (this.vscrollVisible) {
                    var max = this.maxPos,
                        cz = this.clientSize;
                    s.height = Math.round(cz.y * cz.y / max.y) + 'px';
                    s.left = (cz.x - 5)+'px';
                    s.display = 'block';
                    s.opacity = 0.5;
                } else {
                    s.opacity = 0;
                }
            },
            onhscrollVisibleChange: function(){
                var h = this.hscrollNode,
                    s = h && h.style;
                if (!s) {
                    return;
                }
                
                if (this.hscrollVisible) {
                    var max = this.maxPos,
                        cz = this.clientSize;
                    s.width = Math.round(cz.x * cz.x / max.x) + 'px';
                    s.top = (cz.y - 5)+'px';
                    s.display = 'block';
                    s.opacity = 0.5;
                } else {
                    s.opacity = 0;
                }
            }
    };
        
    
    var webkitMarkupMethods = _H.copy(
        {
            onposChange: function(){
                var cz = this.clientSize,
                    max = this.maxPos,
                    x = 0,
                    y = 0;
                if (this.scrollsVert) {
                    y = this.pos.y;
                    if (this.vscrollVisible) {
                        this.vscrollNode.style[_D.CSS3_TRANSFORM] = 'translateY(' + Math.round((cz.y - (cz.y*cz.y/max.y)) * this.pos.y / max.y) + 'px)';
                    }
                }
                if (this.scrollsHoriz) {
                    x = this.pos.x;
                    if (this.hscrollVisible) {
                        this.hscrollNode.style[_D.CSS3_TRANSFORM] = 'translateX(' + Math.round((cz.x - (cz.y*cz.x/max.x)) * this.pos.x / max.x) + 'px)';
                    }
                }
                this.scrollChild.style[_D.CSS3_TRANSFORM] = 'translate3d(-' + parseInt(x,10) + 'px, -'+ parseInt(y,10) + 'px, 0px)';
            },
            ondeceleratingChange: function(){
                this.scrollChild.style[_D.CSS3_TRANSITION] = this.decelerating ? (_D.CSS3_PREFIX + "transform 0.2s linear") : "";
            }
        },
        _H.copy(commonMarkupMethods)
    );
    
    
    var nonwebkitMarkupMethods = _H.copy(
        {
            onposChange: function(){
                var cz = this.clientSize,
                    max = this.maxPos,
                    x = 0,
                    y = 0,
                    sb = this.scrollboxNode;
                if (this.scrollsVert) {
                    y = this.pos.y;
                    if (this.vscrollVisible) {
                        this.vscrollNode.style.top = Math.round((cz.y - (cz.y*cz.y/max.y)) * this.pos.y / max.y) + 'px';
                    }
                    sb.scrollTop = parseInt(y,10);
                }
                if (this.scrollsHoriz) {
                    x = this.pos.x;
                    if (this.hscrollVisible) {
                        this.hscrollNode.style.left = Math.round((cz.x - (cz.y*cz.x/max.x)) * this.pos.x / max.x) + 'px';
                    }
                    sb.scrollLeft = parseInt(x,10);
                }
            }
        },
        _H.copy(commonMarkupMethods)
    );
    
    
    mstrmojo._TouchScrolling = mstrmojo.provide(
        "mstrmojo._TouchScrolling",
        
        {
            
            FRICTION: 0.65,
            
            
            BOUNCEFRICTION: 0.50,
                        
            
            usesTouches: false,
            
            
            bounces: true,

            
            scrollsHoriz: true,

            
            scrollsVert: true,
                    
            
            pos: null,
            
            
            preBuildRendering: function prbr() {
                
                this.usesTouches = (mstrmojo.dom.supportsTouches && this.usesTouches && (this.scrollsHoriz || this.scrollsVert));

                
                if (this.usesTouches) {
                    this.pos = {
                        x: 0, 
                        y: 0
                    };
                }
                
                if (this._super) {
                    this._super();
                }
            },

            
            postBuildRendering: function psbr() {
                if (this._super) {
                    this._super();
                }
                
                if (this.usesTouches) {
                    
                    var sbn = this.scrollboxNode,
                        sch = this.itemsContainerNode || sbn.firstChild;    

                    
                    if (sbn && sbn !== sch) {
                        
                        
                        this.scrollChild = sch;
                        
                        
                        var ss = sbn.style;
                        ss.position = 'relative';
                        ss.overflow = 'hidden';
                        
                        
                        var cs = sch.style;
                        cs.position = 'absolute';
                        cs.left = 0;
                        cs.top = 0;

                        
                        this.markupMethods = _H.copy(
                            _D.isSafari ? webkitMarkupMethods: nonwebkitMarkupMethods,
                            _H.copy(this.markupMethods)
                        );

                        
                        this.attachTouchEvents();
                    }
                }
            },
            
            
            unrender: function(ignoreDom) {
                
                if (this.usesTouches) {
                    this.detachTouchEvents();
                }
                
                this._super(ignoreDom);
            },
            
            
            attachTouchEvents: function(){
                var n = this.touchNode || this.scrollboxNode;
                if (n) {
                    if (!this._tsCallback) {
                        var me = this;
                        this._tsCallback = function(e){
                            me.touchesBegin(self, e);
                        };
                        this._tmCallback = function(e){
                            me.touchesMoved(self, e);
                        };
                        this._teCallback = function(e){
                            me.touchesEnd(self, e);
                        };
                    }
                    
                    _D.attachEvent(n, _D.TOUCHSTART, this._tsCallback);
                    this._tsNode = n;
                }
            },
            
            
            detachTouchEvents: function(){
                var n = this._tsNode;
                if (n) {
                    _D.detachEvent(n, _D.TOUCHSTART, this._tsCallback);
                    delete this._tsNode;
                }                
            },

            
            touchesBegin: function tb(hWin, e) {
                
                var tagName = e.target && e.target.tagName;
                if (tagName && (tagName === 'SELECT' || tagName === 'INPUT')) {
                    return;
                }
                
                _D.preventDefault(hWin, e);
                this.stopDeceleration();
                this.startTime = new Date();
                this.startTimePos = {
                    x: this.pos.x, 
                    y: this.pos.y
                };
                this.startTouchPos = _D.getMousePosition(_D.firstTouch(hWin, e), hWin);
                this.dragging = false;
                _D.attachEvent(window, _D.TOUCHMOVE, this._tmCallback);
                _D.attachEvent(window, _D.TOUCHEND, this._teCallback);
            },
            
            
            touchesMoved: function touchesMoved(hWin, e) {
                var evtPosition = _D.getMousePosition(_D.firstTouch(hWin, e), hWin);
                _D.preventDefault(hWin, e);

                
                if (!this.dragging) {
                    
                    var MIN_DRAG_DELTA = 5,
                        abs = Math.abs;
                    
                    if ((this.scrollsHoriz && abs(evtPosition.x - this.pos.x) > MIN_DRAG_DELTA)  || (this.scrollsVert && abs(evtPosition.y - this.pos.y) > MIN_DRAG_DELTA)) {
                        
                        this.dragging = true;
                        this.dragStartTime = new Date();
                        this.startTouchPos = evtPosition;
                        var sbn = this.scrollboxNode,
                            cz = {
                                x: sbn.clientWidth,
                                y: sbn.clientHeight
                            },
                            sz = {
                                x: sbn.scrollWidth,
                                y: sbn.scrollHeight
                            };
                        
                        this.clientSize = cz;
                        this.scrollSize = sz;
                        
                        this.maxPos = {
                            x: Math.max(sz.x - cz.x, 0),
                            y: Math.max(sz.y - cz.y, 0)
                        };
                        
                        
                        this.showScroll();
                    }
                }
                
                
                if (this.dragging) {
                    _D.stopPropogation(hWin, e);    
                    var startTimePos = this.startTimePos,
                        startTouchPos = this.startTouchPos,
                        maxPosition = this.maxPos;
                    
                    
                    var newPosition = {
                        x: this.scrollsHoriz ? Math.max(Math.min(startTimePos.x - (evtPosition.x - startTouchPos.x), maxPosition.x), 0) : 0,
                        y: this.scrollsVert ? Math.max(Math.min(startTimePos.y - (evtPosition.y - startTouchPos.y), maxPosition.y), 0) : 0
                    };
                    
                    
                    this.set("pos", newPosition);
                    
                    
                    this.nextLastDragPos = this.lastDragPos;
                    this.lastDragPos = evtPosition;
                    
                    var now = new Date(),
                        last = this.lastDragTime;
                    
                    this.nextLastDragTime = last;
                    this.lastDragTime = now;
                    
                    
                    
                    
                    
                    if ((now - last) > DRAG_TIME_LIMIT) {
                        this.startTime = this.lastDragTime;
                        this.dragStartTime = this.startTime;
                        this.startTimePos = {
                            x: newPosition.x, 
                            y: newPosition.y
                        };
                        this.startTouchPos = evtPosition;
                    }
                }    
            },
            
            
            touchesEnd: function te(hWin, e) {
                _D.preventDefault(hWin, e);
                
                _D.detachEvent(window, _D.TOUCHMOVE, this._tmCallback);
                _D.detachEvent(window, _D.TOUCHEND, this._teCallback);
                
                
                if (this.dragging) {
                    
                    this.dragging = false;
                    
                    _D.stopPropogation(hWin, e);
                    
                    
                    
                    
                    if ((new Date()) - this.lastDragTime <= DRAG_TIME_LIMIT) {
                        this.startDeceleration(hWin, e);
                    } else {
                        this.hideScroll();
                    }
                }               
            },

            
            startDeceleration: function stad(hWin, e){
                var epos = _D.getMousePosition(_D.firstChangedTouch(hWin, e), hWin),
                    
                    lastPos = ((mstrmojo.dom.supportsTouches===null) ? this.lastDragPos : this.nextLastDragPos) || epos,
                    dist = {
                        x: epos.x - lastPos.x,
                        y: epos.y - lastPos.y
                    },
                    
                    lastTime = ((mstrmojo.dom.supportsTouches===null) ? this.lastDragTime : this.nextLastDragTime),
                    tm = lastTime ? (new Date()) - lastTime : 0,
                   
                    velocity = {
                        x: tm ? Number(dist.x * MS_PER_FRAME * SPEED_AMP / tm).toFixed(2) : 0,
                        y: tm ? Number(dist.y * MS_PER_FRAME * SPEED_AMP / tm).toFixed(2) : 0
                    };
                
                var me = this,              
                    fnFastEnough = function(vel){
                        return (me.scrollsHoriz && Math.abs(vel.x) >= MIN_VELOCITY) ||
                                (me.scrollsVert && Math.abs(vel.y) >= MIN_VELOCITY);
                    };
                if (fnFastEnough(velocity)) {
                    
                    
                    this.velocity = velocity;
                    this.friction = {x: this.FRICTION, y: this.FRICTION};
                    this.set("decelerating", true);
                    var fnDecel = function(){
                            me.decelerate();
                            if (!fnFastEnough(me.velocity)) {
                                me.stopDeceleration();
                                me = null;
                            }
                        };
                    fnDecel();
                    
                    if (this.decelerating) {
                        
                        this.decelerationTimer = window.setInterval(fnDecel, MS_PER_FRAME);
                    }
                } else {
                    
                    
                    this.hideScroll();
                }
            },
            
            
            stopDeceleration: function stopDeceleration(){
                this.set("decelerating", false);
                delete this.velocity;
                
                if (this.decelerationTimer) {
                    window.clearTimeout(this.decelerationTimer);                
                    delete this.decelerationTimer;
                }
                
                this.hideScroll();
            },
            
            
            decelerate: function decelerate() {
                var position = this.pos,
                    velocity = this.velocity,
                    friction = this.friction,
                    max = this.maxPos,
                    newpos = {
                        x: position.x - velocity.x,
                        y: position.y - velocity.y
                    },
                    bounces = this.bounces,
                    bounceFriction = this.BOUNCEFRICTION;
                    
                
                var x = newpos.x;
                if (x < 0 || x > max.x) {
                    newpos.x = (x < 0) ? 0 : max.x;
                    velocity.x *= (bounces) ? -bounceFriction : 0;
                    friction.x = bounceFriction;
                }
                
                
                var y = newpos.y;
                if (y < 0 || y > max.y) {
                    newpos.y = (y < 0) ? 0 : max.y;
                    velocity.y *= (bounces) ? -bounceFriction : 0;
                    friction.y = bounceFriction;
                }
                
                
                this.set("pos", newpos);
                
                
                this.velocity = {
                    x: friction.x * velocity.x,
                    y: friction.y * velocity.y
                };
            },
            
            
            hideScroll: function hideScroll(){
                this.set("vscrollVisible", false);
                this.set("hscrollVisible", false);
            },
            
            
            showScroll: function showScroll(){
                var max = this.maxPos;
                if (this.scrollsVert && max.y && this.vscrollNode) {
                    this.set("vscrollVisible", true);
                }
                if (this.scrollsHoriz && max.x && this.hscrollNode) {
                    this.set("hscrollVisible", true);
                }
            }
        });

})();
(function () {
    mstrmojo.requiresCls("mstrmojo.hash");

    var $H = mstrmojo.hash,
        dicPopup = null;
    
    
    
    function _createDICInGroup(o){
        return mstrmojo.DICFactory.createDIC(
                $H.copy({dic: this.dic, owner: this.owner, group: this}, o));
    }
    
    
    mstrmojo.DICFactory = mstrmojo.provide(
        "mstrmojo.DICFactory",
        {
            
            createDIC: function(o) {
                var dic = o.dic,
                    Cls = mstrmojo.DICConfig.getDICClass(dic),
                    w; 
                if(Cls) {
                    
                    if (o.k === undefined){
                        o.k = o.opener && o.opener.id;
                    }
                    
                    
                    o.showByDefault = mstrmojo.DICConfig.showDICByDefault(o.dic, o.openerType);
                    o.hasPreview = mstrmojo.DICConfig.hasDICPreview(o.dic, o.openerType);
                    
                    w = new Cls(o);
                }
                
                return w;
            },
                        
            
            createDICPopup: function(opener, dic) {
                return mstrmojo.DICPopup.getInstance(opener, dic);
            },

            
            createDICGroup: function(gco) {
                var dicGroup = $H.copy(gco, {
                    
                        scriptClass: "mstrmojo.Widget",
                    
                        
                        widgetsMap: {},
                        
                        
                        dic: null,
                        
                        
                        owner: null,
                        
                        
                        groupMembers: {},

                        postCreate: function(){
                            var dic = this.dic, otp = this.openerType, DC = mstrmojo.DICConfig;
                            this.showByDefault = DC.showDICByDefault(dic, otp);
                            this.hasPreview = DC.hasDICPreview(dic, otp);
                        },
                        
                        
                        addDIC: function addDIC(k, o) {
                            this.groupMembers[k] = o;
                        },
                        
                        
                        showPopupDIC: function showPopupDIC(k){
                            if (!this.showByDefault){
                                var w = this.widgetsMap[k],
                                    o = this.groupMembers[k];
                                
                                if (!o){
                                    return;
                                }
                                
                                
                                if (!w){
                                    w = this.widgetsMap[k] = _createDICInGroup.call(this, o);

                                }
                                
                                
                                w.showInPopup();
                            }
                        },
                        
                        
                        render: function render() {
                            
                            if (this.showByDefault || this.hasPreview){ 
                                var gms = this.groupMembers, me = this, dicWidget;

                                $H.forEach(gms, function (go, k) {
                                    if (!go.hasRendered){
                                        me.widgetsMap[k] = dicWidget = _createDICInGroup.call(me, go);
                                        
                                        
                                        if (me.showByDefault){
                                            dicWidget.render();
                                        
                                        }else if (me.hasPreview){
                                            dicWidget.renderPreview();
                                        }
                                        
                                        go.hasRendered = true;
                                    }
                                });
                            }
                        },
                        
                        destroy: function destroy() {
                            $H.forEach(this.widgetsMap, function (w) {
                                w.destroy();
                            });
                            this.widgetsMap = {};
                        }
                    });
                
                return mstrmojo.insert(dicGroup);
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.func",
                         "mstrmojo.hash");
    
	var $WRAP = mstrmojo.func.wrapMethods;
	function wrapCallback(callback, argv, method, idx, me) {
		return $WRAP({
            success: function (res) {
                if (mstrMobileApp && mstrMobileApp.sendCallback) {
                    mstrMobileApp.sendCallback('success', argv.target, JSON.stringify(argv.memo), JSON.stringify(res));
                }
            },
            complete: function () {
                if (mstrMobileApp && mstrMobileApp.sendCallback) {
                    mstrMobileApp.sendCallback('complete', argv.target, JSON.stringify(argv.memo));
                }        
                me.removeCallback(method, idx);
            },
            failure: function (res) {
                if (mstrMobileApp && mstrMobileApp.sendCallback) {
                    mstrMobileApp.sendCallback('failure', argv.target, JSON.stringify(argv.memo), JSON.stringify(res));
                }                            
            }
        }, callback);
	}
	
    mstrmojo._CanProxyCallback = mstrmojo.provide(
            
        'mstrmojo._CanProxyCallback', 
        
        {    
            _mixinName: "mstrmojo._CanProxyCallback",
            
            callbacks: null,
            
            isCallbackReceiver: false,
            
            newCallback: function newCallback(props) {
                
                
                return props;
                
                var cbs = this.callbacks,
                    cb = mstrmojo.hash.copy(props), 
                    idx = (props.index !== undefined) ? String(props.index) : 'index',
                    args = arguments.callee.caller.arguments,
                    argv,
                    i,
                    len,
                    method = props.method || 'anonymous';
                if (!cbs) {
                    cbs = this.callbacks = {};
                }
                
                if (!cbs[method]) {
                    cbs[method] = {};
                } 
                
                
                if (!this.isCallbackReceiver) {
                    for (i = 0, len = args.length; i < len; i++) {
                        argv = args[i];
                        if (argv && argv.target) {
                            cb = wrapCallback(cb, argv, method, idx, this);
                            break;
                        }
                    }
                }
                
                
                if (!props.method) {
                	cb.proxy = this.getCallbackMemo();
                }
                
                cbs[method][idx] = cb;
                return cb;                
            },
            
            anonymous: function (params, callback, config, argv) {
                if (!this.isCallbackReceiver) {
	            	callback = wrapCallback(callback, argv, 'anonymous', 'index', this);	            	
	            	mstrApp.serverRequest(params, callback, config);
            	}
            },
            
            getCallback: function getCallback(method, index) {
                var idx = index || 'index',
                    cbs = this.callbacks;
                return cbs && cbs[method] && cbs[method][idx];
            },
            
            removeCallback: function removeCallback(method, index) {
                var idx = index || 'index',
                    cbs = this.callbacks;
                if (cbs && cbs[method]) {
                    delete cbs[method][idx];
                    if (mstrmojo.hash.isEmpty(cbs[method])) {
                        delete cbs[method];
                    }
                }
            },

            getCallbackMemo: function getCallbackMemo(method, index) {
                return {
                    target: 'mstrmojo.all["' + this.id + '"].receiveCallback',
                    memo: {
                        method: method || 'anonymous',
                        index: index || 'index'
                    }
                };
            },
            
            receiveCallback: function receiveCallback(fn, memo, res) {
                var method = memo.method,
                    idx = memo.index,
                    cb = this.getCallback(method, idx);
                
                if (cb && fn && cb[fn]) {
                    cb[fn](res);
                }
            }
        }
    );
    
}());
(function() {
	mstrmojo.requiresCls("mstrmojo.hash","mstrmojo.string", "mstrmojo.StringBuffer");

	
	mstrmojo._XMLNode = mstrmojo.declare(null, null ,
		{
			nodeName: null,
			init: function init(props) {
		        
				mstrmojo.hash.copy(props, this);    
			},
			addChild: function addChild(nodeName)
			{
				var child = new mstrmojo._XMLNode({nodeName: nodeName});
				return this.appendNode(child);
			},

			appendNode: function appendNode(node)
			{
				if (node)
				{
					if (!this.children)
					{
						this.children = [];
					};
					this.children.push(node);
					node.parent = this; 
				};
				return node;
			},
			
			addAttribute: function addAttribute(name, value)
			{
				if (name != null)
				{
					if (!this.attributes)
					{
						this.attributes = {};
					};
					this.attributes[name] = value;
				};
				return this;
			},
			
			addText: function addText(text)
			{
				this._addToStringMember('text', text);
				return this;
			},

			addRawXML: function addRawXML(xml)
			{
				this._addToStringMember('rawXML', xml);
				return this;
			},
			getXMLString: function getXMLString() {
				var buf = new mstrmojo.StringBuffer();
				this.buildXMLString(buf);
				return buf.toString();
			},
			buildXMLString: function buildXMLString(buf)
			{
				buf = buf || new mstrmojo.StringBuffer();
				buf.append('<')
					.append(this.nodeName )
					.append(' ');
					this._buildAttributesXMLString(buf)
					.append('>')
						.append(((this.text != null) ? this._escapeString(this.text) : ''))
						.append(((this.rawXML != null) ? this.rawXML : ''));
						this._buildChildrenXMLString(buf)
					.append('</')
					.append(this.nodeName) 
					.append('>');
						
				return buf;
			},

			
			
			_buildAttributesXMLString: function buildAttributesXMLString(arr)
			{
				var attrs = this.attributes;
				if (attrs)
				{
					for (var id in attrs)
					{
						if (attrs[id] != null)
						{
							var v = String(attrs[id]);
							switch(id) {
							case 'et':
							case 'nt':
							case 'dmt':
							case 'ddt':
							case 'fnt':
							case 'tp':
							case 'stp':
								break;
							default:
								v = this._escapeString(v);
							}
							arr.append(id + '="' + v + '" ');
						};
					};
				};
				return arr;
			},
			
			_escapeString: function escapeString(v) {
				return mstrmojo.string.escape4HTMLText(v);
			},
			
			_buildChildrenXMLString: function buildChildrenXMLString(arr)
			{
				var c = this.children;
				var len = c && c.length;
				if (len)
				{
					for (var i = 0; i < len; i++)
					{
						if (c[i] && c[i].buildXMLString) {
							c[i].buildXMLString(arr);
						}
					};
				};
				return arr;
			},
			
			_addToStringMember: function addToStringMember(memberName, str)
			{
				var val = this[memberName];
				if (val == null)
				{
					this[memberName] = str;
				}
				else
				{
					this[memberName] = val + str;
				};
			}
	});
	mstrmojo.XMLBuilder = mstrmojo.declare(null, null, {
		
		root: null,
		
		curNode: null,
		
		addChild: function addChild(nodeName)
		{
			if (!this.root){
				this.currentNode = this.root = new mstrmojo._XMLNode({nodeName: nodeName});
				
			} else {
				this.currentNode = this.currentNode.addChild(nodeName);
				
			}
			return this;
		},
		
		appendNode: function appendNode(node)
		{
			if (!this.root){
				this.currentNode = this.root = node;
				
			} else {
				this.currentNode = this.currentNode.appendNode(node);
			}
			return this;
		},
		
		addAttribute: function addAttribute(name, value)
		{
			if (this.currentNode){
				this.currentNode.addAttribute(name, value);
			} else {
				alert('no root node');
			}
			return this;
		},
		
		addText: function addText(text)
		{
			if (this.currentNode){
				this.currentNode.addText(text);
			} else {
				alert('no root node');
			}
			return this;
		},
		
		addRawXML: function addRawXML(xml)
		{
			if (this.currentNode){
				this.currentNode.addRawXML(xml);
			} else {
				alert('no root node');
			}
			return this;
		},
		
		closeElement: function closeElement() {
			this.currentNode = this.currentNode.parent;
		},
		
		toString: function toString() {
			if (this.root) {
				return this.root.getXMLString();
			} else {
				return '';
			}
		}
			
	}
	);
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.EnumReadystate");

    var $READYSTATE = mstrmojo.EnumReadystate;

    
    var DELAY = 1200;

    
    var fnToggle = function (v, w) {
        if (w) {
            w.style.display = (v) ? 'block' : 'none';
        }
    };

    
    mstrmojo._HasWaitIcon =
        
        {
            
            waitHandle: null,

            
            postBuildRendering: function pstBldRndr() {
                
                if (!this._rsl) {
                    var id = this.id;
                    this._rsl = this.defn.attachEventListener('readyStateChange', id, function (evt) {
                        
                        if (!this.hasRendered) {
                            
                            return;
                        }

                        switch (evt.value) {
                        case $READYSTATE.WAITING:
                            
                            if (!this.waitIcon) {
                                
                                var icon = document.createElement('div');
                                icon.className = 'mojo-overlay-wait'; 

                                
                                icon.innerHTML = '<div class="overlay"></div><div class="icon"></div>';

                                
                                this.domNode.appendChild(icon);

                                
                                this.addSlots({
                                    waitIcon: icon
                                });
                            }

                            
                            var wi = this.waitIcon;

                            
                            if (DELAY) {
                                
                                this.waitHandle = window.setTimeout(function () {
                                    
                                    if (mstrmojo.all[id]) {
                                        mstrmojo.all[id].waitHandle = null;
                                    }

                                    
                                    fnToggle(true, wi);
                                }, DELAY);

                            } else {
                                
                                fnToggle(true, wi);

                            }
                            break;

                        case $READYSTATE.IDLE:
                            
                            if (this.waitHandle) {
                                
                                window.clearTimeout(this.waitHandle);
                                this.waitHandle = null;
                            }

                            
                            fnToggle(false, this.waitIcon);
                            break;
                        }
                    });
                }

                return this._super();
            }
        };
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.EnumReadystate");
    

    var $RS = mstrmojo.EnumReadystate;    
    
    
    function getViewKey(view) {
        return (view.getKey && view.getKey()) || view.k;
    }
    
    mstrmojo._IsDocController = {
        _mixinName: 'mstrmojo._IsDocController',
        
        _getXtabCallback: function (xtab) {
            var targetDefinitions = {},
                defn = targetDefinitions[getViewKey(xtab)] = xtab.defn,
                me = this,
                model = me.model;

            return model.newCallback({
                submission: function () {
                	
                	if ( defn.set ) {
                		defn.set('readyState', $RS.WAITING);
                	}
                },
                
                success: function (res) {
                	if(res.pukeys) {
                        targetDefinitions = model.getUnitDefinitions(res.pukeys);
                    }
                    model.partialUpdate(res.data, targetDefinitions);
                },
                
                failure: function (details) {
                    mstrmojo.alert(details.code + ': ' + details.message);
                },
                
                complete: function () {
                	
                	if ( defn.set ) {
                		defn.set('readyState', $RS.IDLE);
                	}
                    me.docRequestComplete();
                }
            });
        },
    
        _addNodeKeyToAction: function (view, action) {
            action.nodeKey = getViewKey(view);
            return action;
        },
        
        onGridSelector: function (view, action) {
        	var m = this.model,
        		ifws = m.getTargetInfoWin(action.tks);
        	if (ifws && ifws.length) {
        		for (var i = 0;i < ifws.length;i++) {
        			m.showInfoWin(ifws[i], action.anchor, 'h', true);
        		}
        	}
        	
            
            action.sid = view.sid;
            m.slice(action);
        },
        
         onVisSelector: function (view, action){
        	 if (action.anchor) {
        		var m = this.model,
      			ifws = m.getTargetInfoWin(action.tks);
	 	     	if (ifws && ifws.length) {
	 	     		m.showInfoWin(ifws[0], action.anchor, 'h', true);
	 	     	} 
        	 }
        	
	     	
        	if (view.xtabModel && view.xtabModel.docModel && view.xtabModel.docModel["slice"] ) {
				view.xtabModel.docModel.slice(action);
			}
        },
        
        
        
        isInRequest: function isInRequest() {
        	var inProcess = !!this._inProcess;
        	if (!inProcess) {
        		this._inProcess = true;
        	}
        	
        	return inProcess;
        },
        
        docRequestComplete: function docRequestComplete() {
        	this._inProcess = false;
        },

        
        nudgeWidget: mstrmojo.emptyFn,

        
        getGroupByElements: function getGroupByElements(w) {
            var gbelems = [],
                keys;
            
            while (w ) {
                var keys = w.node && w.node.data && w.node.data.pbes;
                if ( keys ) {
                    break;
                }
                w = w.parent;
            }
            
            if (keys) {
                var dataElems = this.model.data.elems;
                
                for (var i = 0, len = keys.length; i < len; i++) {
                    var idx = keys[i];
                    gbelems.push(isNaN(idx) ? idx : dataElems && dataElems[idx]);
                }
            }
            
            return gbelems;
        }
        
        
    };
    
}());

(function(){
    
    mstrmojo.requiresCls(
            "mstrmojo.func"
            );
    

    
    mstrmojo.ACL.UserDataService = mstrmojo.provide(
            "mstrmojo.ACL.UserDataService", 
            {
                topgroups: null,
                
                userCandidates: null, 
                
                
                getMembers: function(params, callbacks){
                    var taskParams =  {
                            taskId:'getUserEntityInfo',
                            blockBegin: params.blockBegin,
                            blockCount: params.blockCount,
                            userEntityID: params.data.did,
                            userEntityName: params.data.n || '',
                            incremental: true,
                            outputElements: params.outputElements || 3,
                            sessionState: mstrApp.sessionState
                    };
                    mstrmojo.xhr.request('POST', mstrConfig.taskURL, callbacks, taskParams);
                },
                
                
                getTopLevelGroups: function getTopLevelGroups(params, callbacks){
                    var me = this;
                    
                    if(this.topgroups){
                        callbacks.success({items: this.topgroups});
                        return;
                    } else {
                        callbacks.success = mstrmojo.func.composite([callbacks.success, function(res){
                            me.topgroups = res.items;
                        }]);
                    }
                    this.getUsers({topGroupsOnly:true}, callbacks);
                },
                
                
                searchUserCandidates: function searchUserCandidates(pattern, wildCard, blockCount, callbacks){
                    var params = {
                            blockBegin: 1, 
                            blockCount: blockCount,
                            searchPattern: pattern,
                            nameWildcards: wildCard ? 1 : 2
                    };
                    this.getUsers(params, callbacks);
                },
                
                
                getUserCandidates: function getUserCandidates(blockCount, callbacks){
                    if(this.userCandidates){
                        callbacks.success(this.userCandidates);
                        return;
                    } else {
                        var successWas = callbacks.success,
                            me = this;
                        callbacks.success = function(res){
                            me.userCandidates = {items: res.items, isComplete: (res.bc == -1 || (res.bb + res.bc > res.sz))};
                            successWas(me.userCandidates);
                        };
                    }
                    var params = {
                            blockBegin: 1,
                            blockCount: blockCount,
                            nameWildcards: 1
                    };
                    this.getUsers(params, callbacks);  
                },
                
                getUsers: function getUsers(params, callbacks){
                    var ps = {taskId:'getUserServices', 
                            sessionState:mstrApp.sessionState};
                    mstrmojo.hash.copy(params, ps);
                    mstrmojo.xhr.request('POST', mstrConfig.taskURL, callbacks, ps); 
                }
            
            }); 
                 
})();
(function() {
    mstrmojo.requiresCls("mstrmojo.registry");
    
    mstrmojo._PagingList = mstrmojo.provide(
            'mstrmojo._PagingList', {
                
                usePaging: false,
                
                page: 0,
                
                totalPages: 1,
                
                _set_page: function(n, p){
                    if (this.page !== p && this.usePaging) {
                        if (p >= 0 && p < this.totalPages){
                            this.page = p;
                        }
                        return true;
                    } 
                    return false;
                },
                
                _inScroll: false,
                
                _inPaging: false,
                
                onscroll: function() {
                    if (this.usePaging && !this._inPaging) {
                        
                        this._inScroll = true;
                        
                        this.set('page', this.listMapper.whichPage(this));
                        this._inScroll = false;
                    }
                    if (this._super){
                        this._super();
                    }
                }
                
            });
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    
    var CGS_HEIGHT = 1,
        CGS_WIDTH = 2;

    
    function canGrowOrShrink(children) {
        var defn = this.defn,
            verticalConfig = defn.vc,
            horizontalConfig = defn.hc;

        
        if (!children || children.length === 0 || (!verticalConfig && !horizontalConfig)) {
            
            return {};
        }

        return {
            v: !!verticalConfig,
            h: !!horizontalConfig
        };
    }

    
    function getInitialSize(mode) {
        return parseInt(this.getFormats()[(mode === CGS_HEIGHT) ? 'height' : 'width'], 10);
    }

    
    function getMaxSize(mode) {
        var maxProperty = this.getFormats()['max-' + ((mode === CGS_HEIGHT) ? 'height' : 'width')];
        return maxProperty && parseInt(maxProperty, 10);
    }

    
    function getDynamicChildDomNode(child, mode) {
        
        
        
        var defn = this.defn,
            childDomNode = child && (child.dimNode || child.domNode),
            dynamicChild = defn.ck && defn.ck[child && (child.k || child.content.k)];

        
        if (childDomNode && dynamicChild && (dynamicChild & mode)) {
            
            return childDomNode;
        }

        
        return null;
    }

    
    function getChildEndPoint(child, mode, domNode, size) {
        
        var start = parseInt(domNode.style[(mode === CGS_HEIGHT) ? 'top' : 'left'], 10);

        
        if (!!size) {
            
            return start + size;
        }

        
        var fx = (child.fmts && child.fmts.fx) || {},
            rotatedMode = (!$DOM.isIE7 && (fx.rt === 1 || fx.rt === 3)) ? ((mode === CGS_HEIGHT) ? CGS_WIDTH : CGS_HEIGHT) : mode,     
            rotatedUCProperty = (rotatedMode === CGS_HEIGHT) ? 'Height' : 'Width';                                                     

        
        
        
        
        size = domNode['offset' + rotatedUCProperty] + (fx.ds || 0);

        
        var endPoint = start + size;

        
        
        
        
        
        if ($DOM.isIE7 && rotatedUCProperty === 'Width' && child instanceof mstrmojo.XtabBase) {
            var childWidth = child.contentNode.offsetWidth;
            if (endPoint < childWidth) {
                endPoint += childWidth;
            }
        }

        return endPoint;
    }

    
    function updateCalculatedSize(endPoint, calculatedSize, maxSize) {
        
        if (endPoint > calculatedSize) {
            
            if (maxSize) {
                
                endPoint = Math.min(endPoint, maxSize);
            }

            
            return endPoint;
        }

        return calculatedSize;
    }

    
    function updateContainerSize(mode, calculatedSize, dontShrink) {
        var containerNode = this.getCanGrowShrinkNode(),
            propertyName = (mode === CGS_HEIGHT) ? 'Height' : 'Width',
            lcPropertyName = propertyName.toLowerCase(),
            currentValue = parseInt(containerNode.style[lcPropertyName], 10);

        
        if (calculatedSize && calculatedSize !== currentValue && !(calculatedSize < currentValue && !!dontShrink)) {
            
            currentValue = calculatedSize;

            
            containerNode.style[lcPropertyName] = currentValue + 'px';

            
            this.afterCanGrowShrink();
        }

        
        this['_fixed' + propertyName] = currentValue;
    }

    
    function calculateSize(ctrls, mode, dontShrink) {
        var maxSize = getMaxSize.call(this, mode),
            calculatedSize = getInitialSize.call(this, mode),
            len = ctrls.length,
            i;

        
        for (i = 0; i < len; i++) {
            var child = ctrls[i],
                childDomNode = getDynamicChildDomNode.call(this, child, mode);

            
            if (!childDomNode) {
                
                continue;
            }

            
            calculatedSize = updateCalculatedSize(getChildEndPoint.call(this, child, mode, childDomNode), calculatedSize, maxSize);

            
            if (calculatedSize === maxSize) {
                
                break;
            }
        }

        
        updateContainerSize.call(this, mode, calculatedSize, dontShrink);
    }

    
    function calculateFixedSize(child, mode, size, dontShrink) {
        
        var childDomNode = getDynamicChildDomNode.call(this, child, mode);
        if (!childDomNode) {
            
            return;
        }

        
        var endPoint = getChildEndPoint.call(this, child, mode, childDomNode, size);

        
        updateContainerSize.call(this, mode, updateCalculatedSize(endPoint, getInitialSize.call(this, mode), getMaxSize.call(this, mode)), dontShrink);
    }

    
    mstrmojo._CanGrowOrShrink = mstrmojo.provide(

        "mstrmojo._CanGrowOrShrink",

        
        {
            
            getCanGrowShrinkNode: function getCanGrowShrinkNode() {
                return this.domNode;
            },

            
            performCanGrowCanShrink: function performCanGrowCanShrink(ch, dontShrink) {
                var config = canGrowOrShrink.call(this, ch);

                
                if (config.v) {
                    
                    calculateSize.call(this, ch, CGS_HEIGHT, dontShrink);
                }

                
                if (config.h) {
                    
                    calculateSize.call(this, ch, CGS_WIDTH, dontShrink);
                }
            },

            
            fixedSizeCanGrowShrink: function fixedSizeCanGrowShrink(child, height, width, dontShrink) {
                
                var config = canGrowOrShrink.call(this, child && [ child ]);

                
                height = parseInt(height, 10);
                width = parseInt(width, 10);

                
                if (config.v && !isNaN(height)) {
                    
                    calculateFixedSize.call(this, child, CGS_HEIGHT, height, dontShrink);
                }

                
                if (config.h && !isNaN(width)) {
                    
                    calculateFixedSize.call(this, child, CGS_WIDTH, width, dontShrink);
                }
            },

            
            afterCanGrowShrink: mstrmojo.emptyFn
        }
    );

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom");

    
    var FLOATING_TB_CSS = "mstrmojo-floating-toolbar-lightbox";
    var FLOATING_BAR_CSS = "mstrmojo-floating-toolbar";
    var FLOATING_CELL_CSS = "mstrmojo-floating-toolbar-cell";

    var FIXED_TB_CSS = "mstrmojo-fixed-toolbar-lightbox";
    var FIXED_BAR_CSS = "mstrmojo-fixed-toolbar";
    var FIXED_CELL_CSS = "mstrmojo-fixed-toolbar-cell";    
    
    var CTN_CSS_SUFFIX = " hasToolBar";
    var BTN_CSS_PREFIX = "mstrmojo-Button mstrmojo-InteractiveButton mstrmojo-oivmSprite ";
    var BTN_CNT_CSS = "mstrmojo-Button-text";
        
    var SL = 27; 
    
    
    mstrmojo._HasToolbar =
    
    {
        
        _mixinName: 'mstrmojo._HasToolbar',
        

        
        postBuildRendering: function TB_postBuildRendering() {        
            this._super();
            
            var tb = this.getToolbarCfg();
            
            
            if(!tb || this.defn.ttl) {
                return;
            }
            
            
            var cn = this.containerNode;
            if(cn) {                
                
                var d = this._createToolbar(FLOATING_BAR_CSS, FLOATING_CELL_CSS);
                
                
                d.className = FLOATING_TB_CSS;
                
                cn.className += CTN_CSS_SUFFIX;
                
                
                cn.insertBefore(d, cn.firstChild);
                
                var dm = this.domNode,
                    ofst = mstrmojo.boxmodel.offset(dm, this.parent && this.parent.domNode); 

                
                
                
                if(ofst.top < SL) {
                    d.style.top = (SL - ofst.top) + 'px';
                }
            }
        },
        
                
        
        _createToolbar: function TB_addBtns(barCss, btnCss) {            
            var tb = this.getToolbarCfg(),
                me = this,            
                d = document,
                dv = d.createElement('div'),
                tbl = d.createElement('table'),
                tr = d.createElement('tr'),
                td = d.createElement('td');
            
            dv.appendChild(tbl);

            
            tbl.className = barCss;
            td.className = btnCss;
            tr.appendChild(td);
            tbl.appendChild(tr);
            
            
            
            
            
            
            
            
            
            
            
            for(var i in tb) {
                var div = d.createElement('div');
                div.className = BTN_CSS_PREFIX + tb[i].css[0];
                
                var cnt = d.createElement('div');
                cnt.className = BTN_CNT_CSS;
                cnt.nodeValue = "&nbsp;";
                
                
                cnt.setAttribute("ix", i);
                
                
                cnt.setAttribute("cix", 0);

                div.appendChild(cnt);                
                td.appendChild(div);

                div.onclick = function(e) {
                    me.onClick(e);
                };
            }
            
            return dv;

        },
        
        
        
        renderToolbar: function TB_rndToolbar(slot) {
            if(!this.getToolbarCfg()) {
                
                return;
            }
            
            var fc = slot.firstChild,
                tb = this._createToolbar(FIXED_BAR_CSS, FIXED_CELL_CSS);
            
            tb.className = FIXED_TB_CSS;
            
            if(fc) {
                slot.insertBefore(tb, fc);
            } else {
                slot.appendChild(tb);
            }
        },
    
        
        
        onClick: function TB_clk( e,  hWin) {
            
            var d = mstrmojo.dom,
                b = d.eventTarget(hWin, e),
                cix = b.getAttribute("cix"),
                ix = b.getAttribute("ix");            
            
            var tb = this.toolbarCfg[ix],
                tbFn = tb.callback;
            
            if(tbFn && this[tbFn] && this[tbFn]()) { 
                
                cix = ++cix % tb.css.length; 
                b.parentNode.className = BTN_CSS_PREFIX + tb.css[cix];
                b.setAttribute("cix", cix);
            }
        }

    };
})();
(function(){

	 mstrmojo.requiresCls("mstrmojo.dom");

	var $DOM = mstrmojo.dom;

	var TEXTMARGIN = 5; 
	
	var D_S_P = 1;
	
	var D_E_P = 2;
	
	var D_O_P = 4;

	var T_Z_A = 0;

	var needAdjust = true;

	var ZoomFactor = 0;


	
	var millisOnDay = 86400000;

	mstrmojo.VisChartUtils = mstrmojo.provide(
        "mstrmojo.VisChartUtils",
        
        {
        	getScreenZoomFactor: function getScrnZmFctr(){
        		if(ZoomFactor == 0){
        			if(mstrMobileApp){
        				var dpi = mstrMobileApp.getDeviceDPI();
        				console.log("dpi:"+dpi);
    	        		ZoomFactor = dpi/160;
        			}else{
        				ZoomFactor = 1;
        			}

        		}
        		return ZoomFactor;
        	},

        	changeElementSize: function chngfntsz(el,prop,zf){

        		if(prop == 'fontSize' || prop == 'height' || prop == 'line-height'){
        			var propValue = mstrmojo.css.getStyleValue(el,prop);
	        		var intSize = Math.round(zf*parseInt( propValue ));
	        		

	        		el.style[prop] = intSize + "px";
	        	
        		}else if(prop == 'font'){
        			var fontSize = mstrmojo.css.getStyleValue(el,'fontSize');
        			var intSize = Math.round(zf*parseInt( fontSize ));
        			var fontWeight = mstrmojo.css.getStyleValue(el,'fontWeight');
        			var fontFamily = mstrmojo.css.getStyleValue(el,'fontFamily');
        			el.style.font = fontWeight+ " "+ intSize+"px " + fontFamily;
        			
        		}
        	},

        	rgbaStr2rgba: function C_rgbaStr2rgba(color) {
                var rgba = null;
                color = color.replace(/ /g, ''); 
                var i = color.indexOf('rgba');
                if (i >= 0) {
                    color = color.substring(i + 5, color.length - 1);
                    rgba = color.split(',');
                }
                return rgba;
            },

            
            fillBackground: function fllBckgrnd(widget, width, height, context, opacity) {

                
                var cntx = context || widget.context,
                    wd = width || widget.canvas.width,
                    ht = height || widget.canvas.height,
                    themeColor = widget.themeColor || '#000000', 
                    gradient = null,
                    opc = opacity || 1;

				if(!cntx){
					
					cntx = widget.canvas.getContext('2d');
					if(!cntx){
						
						return;
					}
				}
                cntx.save();

                if (widget.noBackground) {
                	
                } else if(!widget.isAndroid && !widget.isTimeSeries) {

                	gradient = cntx.createLinearGradient(0, 0, 0, ht / 2);

                	
                	cntx.fillStyle = themeColor;
                	cntx.fillRect(0, 0, wd, ht);

                	

                	cntx.globalAlpha = 0.4;

                	gradient.addColorStop(0, '#fff');
                	gradient.addColorStop(0.1, '#fff');
                	gradient.addColorStop(1, themeColor);


                	cntx.fillStyle = gradient;
                	cntx.rect(0, 0, wd, ht / 2);
                	cntx.fill();


                	cntx.globalAlpha = 0.1;
                	cntx.fillStyle = '#fff';
                	cntx.fillRect(0, 0, wd, ht / 2);
                } else if(widget.isTimeSeries) {
                	var formatProp = widget.formatProp;

            		gradient = cntx.createLinearGradient(0, 0, 0, ht);
                	
                	cntx.globalAlpha = formatProp.backgroundAlpha;

                	var topGradient = this.rgb2rgbStr(formatProp.backgroundClr, 0.83) || '#2c2c2c';
     			    var bottomGradient = this.rgb2rgbStr(formatProp.backgroundClr) || '#000000';
					gradient.addColorStop(0, topGradient);
                	gradient.addColorStop(1, bottomGradient);
                	cntx.fillStyle = gradient;
                	cntx.rect(0, 0, wd, ht);
                	cntx.fill();

                }else {
                	cntx.globalAlpha = opc;
                	cntx.fillStyle = themeColor;
                	cntx.fillRect(0, 0, wd, ht);
                }

                cntx.restore();

            },

            rgb2rgbStr: function rgb2rgbStr(rgb, opc){
            	var result = '';

            	if(!rgb || rgb.length != 3){
            		return result;
            	}

            	if(opc || opc == 0){
            		result = 'rgba('+ rgb[0] + ','+rgb[1]+','+rgb[2]+','+opc+')';
            	}else{
            		result = 'rgb('+ rgb[0] + ','+rgb[1]+','+rgb[2]+')';
            	}

            	return result;
            },

            
            getRGBWithOpacity: function getRGBWithOpacity(rgb, opacity, rgb2){
            	if(isNaN(opacity)){
            		return;
            	}

            	if(!rgb2){
            		rgb2 = [255, 255, 255];
            	}

            	var resultRGB = [];

            	for(color in rgb){
            		resultRGB[color] = parseInt( rgb[color]*(1 - opacity) + rgb2[color]*opacity );
				}
            	return resultRGB;
            },

            fillMasterChartBackground: function fillMasterChartBackground(widget, topX, topY, width, height, bottomY, context){
				 
			     var cntx = context || widget.context,
			         wd = width || widget.canvas.width,
			         ht = height || widget.canvas.height,
			         themeColor = widget.themeColor,
			         gradient = null;

			     var formatProp = widget.formatProp;

			    cntx.save();
			    cntx.globalAlpha = formatProp.backgroundAlpha;
			    cntx.fillStyle = this.rgb2rgbStr(formatProp.backgroundClr) || '#000000';
				cntx.fillRect(0, 0, wd, topY);

			    gradient = cntx.createLinearGradient(0, 0, 0, ht/2);
				


				
			    var topGradient = this.rgb2rgbStr( this.getRGBWithOpacity(formatProp.backgroundClr, 0.45) ) || '#737373';
			    var bottomGradient = this.rgb2rgbStr( this.getRGBWithOpacity(formatProp.backgroundClr, 0.13) ) || '#222222';
				gradient.addColorStop(0, topGradient);
				gradient.addColorStop(1, bottomGradient);
				cntx.fillStyle = gradient;
				cntx.fillRect(topX, topY, wd, ht/2 );

				cntx.fillStyle = this.rgb2rgbStr(formatProp.backgroundClr) || '#000000';
				cntx.fillRect(topX, topY + ht/2, wd, ht/2 + bottomY);

				
				cntx.globalAlpha = 1;
				cntx.strokeStyle = this.rgb2rgbStr ( widget.formatProp.textClr, 0.50 );
				cntx.lineWidth = 1;
				
				var lineY = topY +0.5;
				this.drawLineSet(this, [{
	                x: topX,
	                y: lineY
	            }, {
	                x: topX + wd,
	                y: lineY
	            }], false, cntx);
				
				
				lineY = topY + ht - 0.5;
				this.drawLineSet(this, [{
	                x: topX,
	                y: lineY
	            }, {
	                x: topX + wd,
	                y: lineY
	            }], false, cntx);

				cntx.restore();
          },

			
			drawLineSetWithSplit: function(widget, lines, fill, context, split) {
				var n = lines.length, 
					np = Math.ceil(n / split), 
					start, end;
				for (var i = 0; i < np; i++) {
					start = i * split; 
					end = Math.min(start + split + 1, n); 
					this.drawLineSet(widget, lines.slice(start, end), fill, context);
				}
			},

            
			drawLineSet: function drwlnst(widget, lines, fill, context) {

                
				var cntx = null,
					l = lines.length,
					li = null;

                
                if (context) {
                    cntx = context;
                } else {
                    cntx = widget.context;
                }

            	
            	var lastPoint = null,
            		moveToPoint = false;

                
				cntx.beginPath();
				var i = 0;
				while(i < l) {
					if(lines[i]) {
						cntx.moveTo(lines[i].x, lines[i].y);
						lastPoint = lines[i];
						moveToPoint = true;
						i++;
						break;
					}

					i++;

				}
				
				
				var skip = false;
				for(;i<l;i++) {
					li = lines[i];
					if(li) { 
						if(!skip) {
							cntx.lineTo(li.x, li.y);
							moveToPoint = false;
						} else {
							cntx.moveTo(li.x, li.y);
							moveToPoint = true;
							lastPoint = li;
							skip = false;
						}
					} else {
						if(!skip){
							skip = true;
							if(moveToPoint){
									
									cntx.arc(lastPoint.x,lastPoint.y, 1, 0, Math.PI * 2, false);
							}
						}
					}
				}

                
				if (fill) {
					cntx.closePath();
					cntx.fill();
				} else {
					cntx.stroke();
				}
			},

			
			getMinYPosition: function getMinYPosition(lines, start, end){
				var i = start,min;
				while(i <= end){
					if(lines[i]){
						min = lines[i].y;
						break;
					}
					i++;
				}
				for(i = start; i <= end;i++){
					if(lines[i]){
						min = Math.min(min,lines[i].y);
					}
				}
				return min;
			},

			drawLineAreaWithSplit: function (widget, lines, start, end, bottomY, rgbClr, context, split) {
				var n = end - start + 1, 
					np = Math.ceil(n / split), 
					p1, p2;
				for (var i = 0; i < np; i++) {
					p1 = start + i * split; 
					p2 = Math.min(p1 + split, start + n - 1); 
					this.drawLineArea(widget, lines, p1, p2, bottomY, rgbClr, context);
				}
			},

			
			drawLineArea: function drwlnst(widget,lines, start, end, bottomY, rgbClr, context) {
				
				var cntx = null,
					l = lines.length,
					li = null,
					startBottomX = 0,
					endBottomX = 0;

		        
		        if (context) {
		            cntx = context;
		        } else {
		            cntx = widget.context;
		        }

		        
            	var lastPoint = null,
            		moveToPoint = false;

		        cntx.save();

		        cntx.lineWidth = 0;
		        
				cntx.beginPath();
				var i = start, startIndex;
				while(i <= end) {
					if(lines[i]) {
						startBottomX = lines[i].x;
						cntx.moveTo(startBottomX, bottomY);
						lastPoint = lines[i];
						moveToPoint = true;
						break;
					}
					i++;
				}
				startIndex = i;
				
				
				var skip = false;
				for( ;i<=end;i++) {
					li = lines[i];
					if(li) { 
						if(!skip) {
							cntx.lineTo(li.x, li.y);
							moveToPoint = false;
							endBottomX = li.x;
						} else {

							startBottomX = li.x;
							cntx.moveTo(startBottomX, bottomY);
							if(i+1<=end && lines[i+1]){
								cntx.lineTo(li.x, li.y);
							}
							lastPoint = li;
							skip = false;
							startIndex = i;
						}
					} else {
						if(!skip){
							skip = true;
							if(!moveToPoint){
								cntx.lineTo(endBottomX, bottomY);
								cntx.lineTo(startBottomX, bottomY);
								var MinY = this.getMinYPosition(lines, startIndex, i) || 0;

								var my_gradient  = cntx.createLinearGradient(0,MinY,0,bottomY);
							    my_gradient.addColorStop(1,this.rgb2rgbStr(rgbClr, 0));
							    my_gradient.addColorStop(0,this.rgb2rgbStr(rgbClr, 1));
							    cntx.fillStyle = my_gradient;
							    cntx.globalAlpha = 0.8;
								cntx.fill();
							}
						}
					}
				}

		         
		        if(!moveToPoint){
					cntx.lineTo(endBottomX, bottomY);
					cntx.lineTo(startBottomX, bottomY);
					var MinY = this.getMinYPosition(lines, startIndex, end) || 0;
					cntx.closePath();
					var my_gradient  = cntx.createLinearGradient(0,MinY,0,bottomY);
				    my_gradient.addColorStop(1,this.rgb2rgbStr(rgbClr, 0));
				    my_gradient.addColorStop(0,this.rgb2rgbStr(rgbClr, 1));
				    cntx.fillStyle = my_gradient;
				    cntx.globalAlpha = 0.8;
					cntx.fill();
		        }

				cntx.restore();
			},

			
			drawRectangle: function drwRect(widget, x, y, w, h, fill, context) {
				var cntx = null;

				
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				if(fill) {
					cntx.fillRect(x,y,w,h);
				} else {
					cntx.strokeRect(x,y,w,h);
				}
			},
			
			drawArc: function drwArc(widget, x, y, radius, startAngle, endAngle, anticlockwise, fill, context) {
				var cntx = null;

				
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				cntx.beginPath();

				cntx.arc(x,y,radius,startAngle,endAngle,anticlockwise);

				if(fill) {
					cntx.fill();
				} else {
					cntx.stroke();
				}

			},

			
			drawRoundRect: function drawRoundRect(ctx, x, y, w, h, r, fill) {
				
				r = Math.min(w/2, h/2, r);

				ctx.beginPath();
				ctx.moveTo(x + r, y);
				ctx.arcTo(x+w, y,   x+w, y+h, r);
				ctx.arcTo(x+w, y+h, x,   y+h, r);
				ctx.arcTo(x,   y+h, x,   y,   r);
				ctx.arcTo(x,   y,   x+w, y,   r);








				ctx.closePath();

				if (fill) {
					ctx.fill();
				}else{
					ctx.stroke();
				}
			},

			drawHalfRoundedRectangle: function drwHRRect(widget, x, y, w, h, r, fill, context) {
				var cntx = null;

				
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				cntx.beginPath();
				cntx.moveTo(x+w,y);
				cntx.lineTo(x+r,y);
				cntx.arcTo(x,y,x,y+r,r);
				cntx.lineTo(x,y+h-r);
				cntx.arcTo(x,y+h,x+r,y+h,r);
				cntx.lineTo(x+w,y+h);
				if(fill) {
					cntx.fill();
				} else {
					cntx.stroke();
				}
			},

			
			drawStartEndPoints: function dsep(widget, lines, context, dp) {
				var l = lines.length;

				var cntx = null,
				r = widget.startEndPointRadius;

				
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				cntx.save();

				var spc = '#f0f43e',
					epc = '#f0f43e',
					opc = '#663300';

				if(widget.startPointColor) {
					spc = widget.startPointColor;
				}

				if(widget.endPointColor) {
					epc = widget.endPointColor;
				} else {
					
					
					var	s = lines[0].y,
					h = lines[l -1].y;
					if( s > h) {
						epc = '#008000';
					} else if( s < h) {
						epc = '#8d1616';
					} else {
						epc = spc;
					}
				}

				if (widget.otherPointColor) {
					opc = widget.otherPointColor;
				}

				if(dp & D_S_P && lines[0]) {
					cntx.strokeStyle = spc;
					cntx.fillStyle = spc;
					
					this.drawArc(this, lines[0].x, lines[0].y, r, 0, Math.PI * 2, true, true, cntx);
				}

				if(dp & D_E_P && lines[l - 1]) {
					cntx.strokeStyle = epc;
					cntx.fillStyle = epc;
					this.drawArc(this, lines[l - 1].x, lines[l - 1].y, r, 0, Math.PI * 2, true, true, cntx);
				}

				if(dp & D_O_P) {
					cntx.strokeStyle = opc;
					cntx.fillStyle = opc;
					
					for (var i = 1; i < l -1; i ++) {
						if(lines[i]){
							this.drawArc(this, lines[i].x, lines[i].y, r, 0, Math.PI * 2, true, true, cntx);
						}
					}
				}

				cntx.restore();
			},

            
			getColor: function gtclr(w) {
				return (parseInt(w.themeColor.substr(1), 16) > 0x7fffff) ? '#000000' : '#ffffff';
			},

            
            drawHighlightLine: function drwHghlghtln(w, y) {
				var ctx = w.context,
                    margin = w.margin,
					x1 = margin.l,
					x2 = w.isTimeSeries ? w.chartWidth + margin.l : w.getWidth() - margin.r;

				ctx.save();
                
				ctx.globalAlpha = 1;
				ctx.strokeStyle = this.rgb2rgbStr(w.formatProp.textClr, 0.35)
				ctx.lineWidth = 1;
				ctx.lineCap = 'round';

                
				while (x1 < x2) {
					ctx.beginPath();
					ctx.moveTo(x1, y);
					x1 += 2;
					ctx.lineTo(x1, y);
					ctx.stroke();
					x1 += 3;
				}

				ctx.restore();
			},


            
			addLabel: function adDtLbl(w, text, x, y, width, rotate, prevLabel) {

				
                var lbl = document.createElement("div");
                lbl.className = 'mstrmojo-Chart-lbl';
                lbl.style.color = this.rgb2rgbStr(w.formatProp.textClr, 0.8);

                lbl.innerHTML = text;

                if (width) {
                    lbl.style.width = width + 'px';
                }
                var node = null;
                var aWidth = 0;
                if(w.isTimeSeries) {
                	if(prevLabel.w >= 0) {
                		node = w.xdiv;
                		aWidth = w.animationCanvas.width;
                	} else {
                		node = w.domNode.getElementsByClassName('mstrmojo-chart-ylbl-div')[0];
                		if(!node) {
                			node = document.createElement("div");
                			node.id = 'mstrmojo-chart-ylbl-div';
                			node.className = 'mstrmojo-chart-ylbl-div';
                	
                	
                			w.domNode.appendChild(node);
                		}
                		node.style.width = w.margin.l - 1 + 'px';
                	}
                } else {
                	node = w.domNode;
                	aWidth = w.getWidth();
                }

                
                
                node.appendChild(lbl);

                var lblTextWidth = lbl.offsetWidth || ( w.getTextWidth && w.getTextWidthByElem(text,lbl) );

                

                
                var ht = lbl.offsetHeight || 22*(ZoomFactor || 1); 
                var wd = width || lblTextWidth || 100;

                var X_PAD = w.xLabelPadding/2;
                var Y_PAD = w.yLabelPadding/2;

                
                 if(prevLabel.w >= 0 && w.isTimeSeries && w._scroller.origin){
                	 var distanceOffOrgin = x - w._scroller.origin.x;
                	 if(distanceOffOrgin <= 0 && (distanceOffOrgin + lblTextWidth/2 > -w.maxYLblWidth)){
                	 	w.needRedrawVerticalLine = true;
                	 	node.removeChild(lbl);
                		return null;
                	 }

                	 var distanceOffLegend = distanceOffOrgin - w.getChartWidthOnScreen();
                	 if( (distanceOffLegend - lblTextWidth/2) <=0  && distanceOffLegend >= 0){
                	 	w.needRedrawVerticalLine = true;
                	 	node.removeChild(lbl);
                		return null;
                	 }
                 }


                if(prevLabel.w >= 0) {
                	x = x - wd /2;
                }

                
                if(prevLabel.h >= 0 && ((y >= prevLabel.y - Y_PAD && y <= prevLabel.y + prevLabel.h) ||
                		(y + ht >= prevLabel.y - Y_PAD && y + ht <= prevLabel.y + prevLabel.h) ||
                		(y + ht >= w.canvas.height - w.margin.b) )) {
                	node.removeChild(lbl);
                	return null;
                }

                
                if(prevLabel.w >= 0 && (((x >= prevLabel.x && x < prevLabel.x + prevLabel.w + X_PAD)) || x < prevLabel.x || x < w.margin.l || x + wd > aWidth)) {
                	node.removeChild(lbl);
                	return null;
                }

                
                if(w.isTimeSeries && prevLabel.h >= 0) {
                	node.style.top = (w.margin.t - ht/2) + 'px';
                	
                	node.style.height = (w.canvas.height - w.margin.t - w.margin.b -1 + ht/2) + 'px'; 
                	this.translateCSS(x, (y - w.margin.t) + ht/2, rotate, lbl);
                } else {
                	this.translateCSS(x, y, rotate, lbl);
                	lbl.style.maxHeight = ht + 'px'; 
                }

                
                prevLabel.x = x;
                prevLabel.y = y;
                if(prevLabel.h >= 0) {
                	prevLabel.h = ht;
                }
                if(prevLabel.w >= 0){
                	prevLabel.w = wd;
                	lbl.style.textAlign = 'center';
                }

                return lbl;
			},

            
			addDataLabel: function adDtLbl(w, text, y, prevLabel) {
				var xText = (w.margin.l > w.margin.r) ? TEXTMARGIN : w.getWidth() - w.margin.r + TEXTMARGIN,
                    spaceAvailable = (w.margin.l > w.margin.r) ? w.margin.l : w.margin.r;
                
                return this.addLabel(w, text, xText, y - 10, spaceAvailable-TEXTMARGIN*2, false, prevLabel);
			},

			

			translateCSS: function trnlt(x, y, rotate, lbl) {
			    var value = 'translate(' + x + 'px,' + y + 'px)';
			    if (rotate) {
			        value += ' rotate(45deg)';
			    }

                lbl.style[$DOM.CSS3_TRANSFORM] = value;
			},

			getTouchXYOnWidget: function getTouchXYOnWidget(touchX, touchY, widget){
				var TouchScroller = mstrmojo.TouchScroller,
			 		scrollerOffsets = (TouchScroller && widget.parent && TouchScroller.getScrollPositionTotals(widget.parent)) || { x: 0, y:0}; 

				touchX = touchX - widget.offsetLeft + scrollerOffsets.x;
				touchY = touchY - widget.offsetTop + scrollerOffsets.y;
				return {touchX:touchX, touchY:touchY};
			},

			
		    getYValue: function gyval(widget, point) {
		        var height = widget.canvas.height,
		            margin = widget.margin,
		            mvalues = widget.model.mvalues;
		        return height - margin.b - 4 -((parseFloat(point) - mvalues[0]) * widget.RTY);
		    },

		  
		    getMasterYValue: function getMasterYValue(widget, point, mm ) {
		        var height = widget.masterCanvas.height,
		            mvalues = widget.model.mvalues;
		        return height - mm.b - 3 - ((parseFloat(point) - mvalues[0]) * widget.MRTY);
		    },

		    
		    getSeriesIndexAndYValue: function gsiyv(w, rowIdx, touchY) {
		    	var s = w.model.series,
		    	l = s.length,
		    	si = 0;
				y = this.getYValue(w, s[si].rv[rowIdx]) || 0;
		    	var cp = touchY - y < 0 ? - (touchY - y) : touchY - y,
		    			pp = cp;
		    	for(var i = 1; i < l; i++) {
		    		var cy = this.getYValue(w, s[i].rv[rowIdx]) || 0;
		    		cp = touchY - cy < 0 ? - (touchY - cy) : touchY - cy;
		    		if(cp < pp) {
		    			y = cy;
		    			pp = cp;
		    			si = i;
		    		}
		    	}

		    	return {y:y, si:si};
		    },

		    getLabelWidthForMargin: function tsip(w, text) {
		    	var lbl = document.createElement("div");
                lbl.className = 'mstrmojo-Chart-lbl';
                lbl.innerHTML = text;

                
                w.domNode.appendChild(lbl);
                var wd = lbl.offsetWidth || 60;
                w.domNode.removeChild(lbl);
                return wd + TEXTMARGIN * 2;
		    },

			animateLineSet: function anmtHLnSt(w, fromLines, toLines, cfg) {
                var lines = [],
                    x = w.animationContext,
                    l = toLines.length;

                x.clearRect(0, 0, w.getWidth(), w.canvas.height);

                if (!cfg.index) {
                    cfg.index = 0;
                } else if (cfg.index >= cfg.rate) { 
                    this.drawLineSet(w, toLines, false, x);
                    w.drawLabels();
                    if(w.isFillLinesArea) {
                    	
                    	this.fillLinesArea(w,toLines.slice(0));
                    }
                    if(w.isDrawStartEndPoints) {
                    	this.drawStartEndPoints(w, toLines, x, w.isDrawStartEndPoints);
                    }
                    return;
                }

                for (var i = 0; i < l; i++) {
                    var tli = toLines[i],
                        fli = fromLines[i];
                    lines[i] = {x:(cfg.index * (tli.x - fli.x) / cfg.rate) + fli.x, y:(cfg.index * (tli.y - fli.y) / cfg.rate) + fli.y};
                }

                this.drawLineSet(w, lines, false,  x);

                var me = this;
                cfg.index++;
                window.setTimeout(function() {
                    me.animateLineSet(w, fromLines, toLines,  cfg);
                }, 40);

			},

			
            fillLinesArea: function flA(w,area) {
				var hgt = w.canvas.height;

				area.push({x:w.getWidth() - w.margin.r, y:hgt - w.margin.b});
				area.push({x:w.margin.l, y:hgt - w.margin.b});

                var fillColor = new Array();
                if(w.fillinColor) {
                	mstrmojo.requiresCls("mstrmojo.color");
                	var g = mstrmojo.color.hex2rgb(w.fillinColor).join(',');
                	fillColor[0] = 'rgba(' +  g + ', 0.8)';
                	fillColor[1] = 'rgba(' +  g + ', 0.2)';
                } else {
                	fillColor = ['rgba(255,128,0,0.8)', 'rgba(255,128,0,0.2)'];
                }

                var ctx = w.animationContext;
                var g = ctx.createLinearGradient(0, 0, 0, hgt);

                g.addColorStop(0, fillColor[0]);
                g.addColorStop(0.75, fillColor[1]);

                ctx.fillStyle = g;
                this.drawLineSet(w, area, true, ctx);
            },

            convertRawValueToMilliseconds: function convertRawValueToMilliseconds(val) {
          		var daysSinceJan1st1899_12_30 = Number(val),
            		realVal = daysSinceJan1st1899_12_30 - ((new Date('1/1/1970').getTime() - new Date('12/30/1899').getTime())/millisOnDay) - T_Z_A,
            		dt = new Date(realVal * millisOnDay); 
        		return new Date(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate()).getTime(); 
        	},

        	
        	getAncestorBgColor: function getAncestorBgColor(widget) {
    			var bgColor = null,
    				me = widget,
    				model = me.model,
    				docModel = null;
    			if (me.hasOwnProperty("xtabModel") && me.xtabModel.hasOwnProperty("docModel")) {
    				docModel = me.xtabModel.docModel;
    			}
    			if (docModel && docModel.defn && docModel.defn.layouts && docModel.defn.layouts.length>0) {
    				var layouts = docModel.defn.layouts,
    					layout;
    				var i;
    				
    				for(i in layouts) {
    					if (layouts[i].loaded) {
    						layout = layouts[i];
    					}
    				}
    				if (layout && layout.hasOwnProperty("units")) {
    					var units = layout.units;
    					var parent = model.parent;
    					while (parent) {
    						var pk = parent.k || null;
    						if (units[pk] && units[pk].fmts && units[pk].fmts["background-color"]) {
    							bgColor = units[pk].fmts["background-color"];
    							break;
    						} else {
    							parent = parent.parent || null;
    						}
    					}
    					if (!bgColor) {
    						if (layout.fmts && layout.fmts["background-color"]) {
    							bgColor = layout.fmts["background-color"];
    						}
    					}
    				}

    			}

    			return bgColor;

        	},

        	getPointDistanceSquare: function getPointDistSquare(p1 ,p2){
            	return (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);
            },

            truncateTextToLine: function(elem, span, lineCount){
            	span.className = elem.className;
            	span.style.whiteSpace = "nowrap";

            	var str = span.innerHTML = elem.innerHTML;
            	var paddingWidth = parseInt(elem.offsetWidth) - parseInt(elem.style.width);
            	var maxWidth = lineCount * parseInt(elem.style.width) + paddingWidth ;

            	var res = str;
            	if(span.offsetWidth > maxWidth){
            		var low = 0,
                    high = str.length - 1;
	                while (low <= high) {
	                    var mid = Math.round((low + high) / 2);
	                    var s0 = str.substr(0, mid+1);
	                    var s1 = str.substr(0, mid+2);
	                    span.innerHTML = s0;
	                    var h0 = span.offsetWidth;
	                    span.innerHTML = s1;
	                    var h1 = span.offsetWidth;

	                    if (h0 <= maxWidth && h1 > maxWidth) {
	                        break;
	                    } else if (h0 > maxWidth) { 
	                        high = mid - 1;
	                    } else if (h1 <= maxWidth) {
	                        low = mid + 1;
	                    }
	                }

	                res = str.substr(0, mid+1);
	                if (res.length < str.length) { 
	                    if (res.charAt(res.length-1) === ' ') { 
	                        res = res.substr(0, res.length-1);
	                    }
	                    var pos = res.lastIndexOf(' ');
	                    var left = res.length - 1 - pos; 
	                    if (left >= 2 && left <= 8) { 
	                        res = res.substr(0, res.length-left-1) + '...';
	                    } else {
	                        res = res.substr(0, res.length-3) + '...'; 
	                    }
	                }
            	}

            	elem.innerHTML = res;
            },
            getLen:function(text, span, errorAdjust, paddingWidth)
            {
            	span.innerHTML = text;
        		var wiLen = span.offsetWidth + errorAdjust - paddingWidth;
        		return wiLen;
            },

            splitWordIfTooLong: function(wlst, span, availSp, paddingWidth, errorAdjust){
        	
        	var wordsArr = wlst.split(' ');
        	var res = [];
        	var sz = wordsArr.length;
        	var i = 0;
        	var j = 0;
        	for (i = 0; i < sz; i++)
        	{
        		var wd = wordsArr[i];
        		while(true){
        			
        			var wiLen = this.getLen(wd, span, errorAdjust, paddingWidth);
        			if(wiLen > availSp){
        				var clipL = (availSp/wiLen) * wd.length;
        				var intClip = Math.round(clipL);

        				while(intClip > 0){
        					var tpWd = wd.substr(0, intClip);
        					var len1 = this.getLen(tpWd, span, errorAdjust, paddingWidth);
        					if(len1<=availSp){
        						res.push( tpWd );
        						break;
        					}
        					else
        						intClip--;
        				}
        				
        				wd = wd.substr(intClip, wd.length - intClip);
        			}
        			else{
        				res.push(wd);
        				break;
        			}
        		}
        	}
        	return res.join(' ');
        },
            truncateTextToLineWithWordWrap: function(elem, span, lineCount){
            	span.className = elem.className;
            	span.style.whiteSpace = "nowrap";

            	var errorAdjust = 7;
            	
            	var availSp = -1;
            	if(elem.style && elem.style.width && elem.style.width.length > 0){
            		availSp= parseFloat(elem.style.width);
            	}
            	if(availSp < 0)
            		availSp = parseFloat(mstrmojo.css.getComputedStyle(elem).width);

            	var str = elem.innerHTML;
            	var paddingWidth = parseFloat(elem.offsetWidth) - availSp;
            	

            	str = this.splitWordIfTooLong( str, span, availSp, paddingWidth, errorAdjust );

            	var wordsArr = str.split(' ');
            	var lenArr = [];
            	var preLenArr = [];
            	var i = 0;
            	var totalLen = 0;
            	var sz = wordsArr.length;
            	span.innerHTML = '&nbsp;';
            	var blankSpaceLen = span.offsetWidth - paddingWidth;
            	preLenArr.push(0);
            	for (i = 0; i < sz; i++)
            	{
            		
            		
            		var wiLen = this.getLen(wordsArr[i], span, errorAdjust, paddingWidth);
            		if(wiLen > availSp){
            			var wd = wordsArr[i];
            			var clipL = (availSp/wiLen) * wd.length;
            			wordsArr[i] = wd.substr(0, parseInt(clipL));
            			wiLen = availSp; 
            		}
            		lenArr.push(wiLen);
            		totalLen += wiLen;
            		preLenArr.push(totalLen);
            		if( i !== sz - 1 )
            			totalLen += blankSpaceLen;
            	}
            	
            	var lnS = 0, lnE = 0;
            	var ln = lineCount;
            	for (; lnE < preLenArr.length; )
            	{
            		var len1 = preLenArr[lnE] - preLenArr[lnS];
            		if(lnS > 0 && lnE != lnS)
            			len1 -= blankSpaceLen;
            		var len2 = preLenArr[lnE+1]-preLenArr[lnS];
            		if(lnS > 0 && lnE + 1 != lnS )
            			len2 -= blankSpaceLen;
            		if( len1 <= availSp &&  ((lnE+1 == preLenArr.length) || (len2 > availSp)))
            		{
            			
            			ln --;
            			if( ln == 0 || lnE === sz )
            				break;
            			else
            			{
            				lnS = lnE;
            				lnE++;
            			}
            		}
            		else
            		{
            			lnE++;
            		}
            	}
            	if(lnE > sz)
            		lnE = sz;
            	var lastlineLen = preLenArr[lnE] - preLenArr[lnS];
        		if(lnS > 0 && lnE != lnS)
        			lastlineLen -= blankSpaceLen;

            	var res;
            	if(lnE >= sz && lastlineLen < availSp)
            		res = wordsArr.join(' ');
            	else{
            		res = wordsArr.slice(0, lnE).join(' ');
            		
            		
            		
            		

            		
                	
                	var elipLen = this.getLen('...', span, errorAdjust, paddingWidth);

                	if( lastlineLen + elipLen <= availSp)
                		res += '...';
                	else
                	{
                		if (res.charAt(res.length-1) === ' ') { 
	                        res = res.substr(0, res.length-1);
	                    }
	                    var pos = res.lastIndexOf(' ');
	                    var left = res.length - 1 - pos; 
	                    
	                    if( left === 3 )
	                    	res = res.substr(0, res.length-3) + ' ...'; 
	                    else
	                    	res = res.substr(0, res.length-3) + '...';
                	}
            	}
            	elem.innerHTML = res;
            },

            getLen2:function(text, fontStr, txtCvs)
            {
            	var canvas = txtCvs;
				var context = canvas.getContext('2d');
				context.font = fontStr;
				context.textAlign = 'center';
				context.fillStyle = 'blue';
				
				var metrics = context.measureText(text);
				var width = metrics.width;
				return width;
            },

            splitWordIfTooLong2: function(wlst, availSp, fontStyle, txtCvs){
            	
            	var wordsArr = wlst.split(' ');
            	var res = [];
            	var sz = wordsArr.length;
            	var i = 0;
            	var j = 0;
            	for (i = 0; i < sz; i++)
            	{
            		var wd = wordsArr[i];
            		while(true){
            			
            			var wiLen = this.getLen2(wd, fontStyle, txtCvs);
            			if(wiLen > availSp){
            				var clipL = (availSp/wiLen) * wd.length;
            				var intClip = Math.max(Math.round(clipL), 1);

            				while(intClip > 0){
            					var tpWd = wd.substr(0, intClip);
            					var len1 = this.getLen2(tpWd, fontStyle, txtCvs);
            					
            					if(len1<=availSp ||intClip == 1){
            						res.push( tpWd );
            						break;
            					}
            					else
            						intClip--;
            				}
            				
            				wd = wd.substr(intClip, wd.length - intClip);
            			}
            			else{
            				res.push(wd);
            				break;
            			}
            		}
            	}
            	return res.join(' ');
            },

            
            getComputedFontStyle: function getCFontStyle(computedStyle){
                var fontStyle = computedStyle.fontStyle + " "
                    + computedStyle.fontWeight + " "
                    + computedStyle.fontSize + "/"
                    + computedStyle.fontVariant
                    + " " + computedStyle.fontFamily;

                return fontStyle;
            },

            
            truncateTextToLineWithWordWrap2: function(elem, txtCvs, lineCount){
            	
            	var availSp = -1;
            	if(elem.style && elem.style.width && elem.style.width.length > 0){
            		var paddingWidth = 0;

					var compStyle = mstrmojo.css.getComputedStyle(elem);
					if( compStyle.paddingLeft ){
						paddingWidth += parseFloat(compStyle.paddingLeft);
					}
					if( compStyle.paddingRight ){
						paddingWidth += parseFloat(compStyle.paddingRight);
					}

					var elemWidth = elem.offsetWidth;
					availSp = elemWidth ? elemWidth - paddingWidth : parseInt(elem.style.width);
            	}
            	if(availSp < 0){

            		elem.innerHTML = "...";
            		return;
            	}

            	var str = elem.innerHTML;
            	var computedStyle = mstrmojo.css.getComputedStyle(elem);
            	var fontStyle = this.getComputedFontStyle(computedStyle);
            	str = this.splitWordIfTooLong2( str, availSp, fontStyle, txtCvs );


            	var wordsArr = str.split(' ');
            	var lenArr = [];
            	var preLenArr = [];
            	var i = 0;
            	var totalLen = 0;
            	var sz = wordsArr.length;
            	
            	var blankSpaceLen = this.getLen2(' ', fontStyle, txtCvs);
            	preLenArr.push(0);
            	for (i = 0; i < sz; i++)
            	{
            		
            		
            		var wiLen = this.getLen2(wordsArr[i], fontStyle, txtCvs);
            		if(wiLen > availSp){
            			var wd = wordsArr[i];
            			var clipL = (availSp/wiLen) * wd.length;
            			wordsArr[i] = wd.substr(0, parseInt(clipL));
            			wiLen = availSp; 
            		}
            		lenArr.push(wiLen);
            		totalLen += wiLen;
            		preLenArr.push(totalLen);
            		if( i !== sz - 1 )
            			totalLen += blankSpaceLen;
            	}
            	
            	var lnS = 0, lnE = 0;
            	var ln = lineCount;
            	for (; lnE < preLenArr.length; )
            	{
            		var len1 = preLenArr[lnE] - preLenArr[lnS];
            		if(lnS > 0 && lnE != lnS)
            			len1 -= blankSpaceLen;
            		var len2 = preLenArr[lnE+1]-preLenArr[lnS];
            		if(lnS > 0 && lnE + 1 != lnS )
            			len2 -= blankSpaceLen;
            		if( len1 <= availSp &&  ((lnE+1 == preLenArr.length) || (len2 > availSp)))
            		{
            			
            			ln --;
            			if( ln == 0 || lnE === sz )
            				break;
            			else
            			{
            				lnS = lnE;
            				lnE++;
            			}
            		}
            		else
            		{
            			lnE++;
            		}
            	}
            	if(lnE > sz)
            		lnE = sz;
            	var lastlineLen = preLenArr[lnE] - preLenArr[lnS];
        		if(lnS > 0 && lnE != lnS)
        			lastlineLen -= blankSpaceLen;

            	var res;
            	if(lnE >= sz && lastlineLen < availSp)
            		res = wordsArr.join(' ');
            	else{
            		res = wordsArr.slice(0, lnE).join(' ');
            		
            		
            		
            		

            		
                	
                	var elipLen = this.getLen2('...', fontStyle, txtCvs);

                	if( lastlineLen + elipLen <= availSp)
                		res += '...';
                	else
                	{
                		if (res.charAt(res.length-1) === ' ') { 
	                        res = res.substr(0, res.length-1);
	                    }
	                    var pos = res.lastIndexOf(' ');
	                    var left = res.length - 1 - pos; 
	                    
	                    if( left === 3 )
	                    	res = res.substr(0, res.length-3) + ' ...'; 
	                    else
	                    	res = res.substr(0, res.length-3) + '...';
                	}
            	}
            	elem.innerHTML = res;

                return res.indexOf('...') > -1;
            },



            truncateDivContent: function (str, span, comp) {
				span.innerHTML = str;
                if (span.offsetHeight > comp) { 
                    var low = 0,
                        high = str.length - 1;
                    while (low <= high) {
                        var mid = Math.round((low + high) / 2);
                        var s0 = str.substr(0, mid+1);
                        var s1 = str.substr(0, mid+2);
                        span.innerHTML = s0;
                        var h0 = span.offsetHeight;
                        span.innerHTML = s1;
                        var h1 = span.offsetHeight;

                        if (h0 <= comp && h1 > comp) {
                            break;
                        } else if (h0 > comp) { 
                            high = mid - 1;
                        } else if (h1 <= comp) {
                            low = mid + 1;
                        }
                    }

                    var res = str.substr(0, mid+1);
                    if (res.length < str.length) { 
                        if (res.charAt(res.length-1) === ' ') { 
                            res = res.substr(0, res.length-1);
                        }
                        var pos = res.lastIndexOf(' ');
                        var left = res.length - 1 - pos; 
                        if (left >= 2 && left <= 8) { 
                            res = res.substr(0, res.length-left-1) + '...';
                        } else {
                            res = res.substr(0, res.length-3) + '...'; 
                        }
                    }
                    return res;
                } else {
					return str;
				}
			}


        });

})();


(function () {

    mstrmojo.requiresCls("mstrmojo.dom");

    var $D = mstrmojo.dom,
        _switchDimensions = false;

    
    mstrmojo._FillsBrowser = mstrmojo.provide(

        "mstrmojo._FillsBrowser",

        
        {
            _mixinName: 'mstrmojo._FillsBrowser',

            getBrowserDimensions: function () {
                var winDim = $D.windowDim(),
                    browserOffset = ($D.isFF || $D.isWK) ? 0 : 2;    

                var w = winDim.w,
                    h = winDim.h;
                
                if (_switchDimensions) {
                    var t = h;
                    h = w;
                    w = t;
                }

                return {
                    w: Math.max(w, 0) + 'px',
                    h: Math.max(h - browserOffset, 0) + 'px'
                };
            },

            

            simulateOrientationChange: function simulateOrientationChange() {
                _switchDimensions = !_switchDimensions;
                this.monitorWindow();
            },

            
            preBuildRendering: function preBuildRendering() {
                var rtn = true;
                if (this._super) {
                    rtn = this._super();
                }

                var d = this.getBrowserDimensions();

                
                if (!('browserResized' in this) || this.browserResized(d) !== true) {
                    this.height = d.h;
                    this.width = d.w;
                }

                
                if (!this._listenerProc) {
                    
                    window._monitor = this;

                    
                    var id = this.id,
                        fn = this._listenerProc = function (e) {
                            var evt = e || window.event;
                            mstrmojo.all[id].monitorWindow(evt);
                        };

                    
                    $D.attachEvent(window, 'resize', fn);
                }
                return rtn;
            },

            
            destroy: function destroy(ignoreDom) {
                
                if (this._listenerProc) {
                    
                    $D.detachEvent(window, 'resize', this._listenerProc);
                }
                this._super(ignoreDom);
            },

            
            monitorWindow: function (evt) {
                
                var currentTarget = evt.currentTarget,                             
                    d = this.getBrowserDimensions(),
                    size = {
                        w: (currentTarget ? currentTarget.innerWidth + 'px': d.w),
                        h: (currentTarget ? currentTarget.innerHeight + 'px': d.h) 
                    };

                
                if (size.h === this.height && size.w === this.width) {
                    
                    return;
                }

                
                
                if (!('browserResized' in this) || this.browserResized(size) !== true) {
                    if (size.h !== this.height) {
                        this.set('height', size.h);
                    }

                    if (size.w !== this.width) {
                        this.set('width', size.w);
                    }
                }
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.dom");
    
    var $D = mstrmojo.dom,
        $MATH = Math;
    
    var    PLACEMENT_AUTO = 1,
        PLACEMENT_FIXED = 2,
        PLACEMENT_ABOVE = 3,
        PLACEMENT_BELOW = 4,
        PLACEMENT_LEFT = 5,
        PLACEMENT_RIGHT = 6;
        
        function anchorPopup() {
        
            var anchor = this.anchor;
            
            if(!anchor){
                return false;
            }
            
            
            var  baseTipCls = this.baseTipClass, 
                tipNode = this[this.tipNodeName];
            tipNode.className = baseTipCls + ' top';
            
            var boundary = this[this.boundaryNodeName],
                popupNode = this[this.popupNodeName],
                editorOffset = this.anchorOffset,
                defaultOrientation = this.anchorOrientation,
                hasScrollbars = this.hasScrollbars(),
                anchorPosition = mstrmojo.hash.copy(this.anchorPosition || $D.position(anchor, true)),
                boundaryPosition = $D.position(boundary, true),
                boundaryRight = boundaryPosition.w,
                boundaryBottom = boundaryPosition.h,
                popWidth = popupNode.offsetWidth,
                popHeight = popupNode.offsetHeight,
                halfPopWidth =  popWidth / 2,
                halfPopHeight = popHeight / 2,
                tipPosition = $D.position(tipNode),
                tipDimensionShort = $MATH.min(tipPosition.h, tipPosition.w),
                tipHalfLong = $MATH.max(tipPosition.h, tipPosition.w) / 2,
                plm = this.placement;
            
            
            if (hasScrollbars) {
                
                boundaryRight -= 15;
                boundaryBottom -= 15;
            }
            
            
            var popupInsideBoundary = $D.contains(boundary, popupNode), 
                offsetTop = popupInsideBoundary ? 0 : boundaryPosition.y, 
                popLeft = boundaryRight / 2 - halfPopWidth,      
                popTop = boundaryBottom / 2 - halfPopHeight + offsetTop,     
                tipLeft = -1000,                                 
                tipTop = -1000,                                  
                tipClass,
                tipBorderStyles = ['borderBottomColor', 'borderTopColor', 'borderRightColor', 'borderLeftColor'],
                tipStyleIdx = 0;
            
            
            
            if(popupInsideBoundary) {
                
                anchorPosition.x = anchorPosition.x - boundaryPosition.x;
                anchorPosition.y = anchorPosition.y - boundaryPosition.y;
            }

            var anchorBottom = anchorPosition.y + anchorPosition.h,
                anchorRight = anchorPosition.x + anchorPosition.w,
                fitsRight = ((anchorRight + popWidth) < boundaryRight),
                fitsAbove = anchorPosition.y > popHeight,
                fitsBottom = ((anchorBottom + popHeight) < boundaryBottom),
                fnBounds = function (minVal, maxVal, desiredVal) {                              
                    return $MATH.min($MATH.max(minVal, desiredVal), $MATH.max(maxVal, 0));
                },
                fnVertFit = function() {
                    
                    if ((anchorPosition.x < boundaryRight) && (fitsBottom || fitsAbove)) {
                        
                        var anchorMidWidth = anchorPosition.x + (anchorPosition.w / 2),
                            
                            posBottom = (plm == PLACEMENT_BELOW && fitsBottom) || !fitsAbove;
                        
                        
                        if (posBottom) {
                            
                            tipClass = 'top';
                            tipTop = anchorBottom; 
                            tipStyleIdx = 0;
                            
                            
                            popTop = anchorBottom + tipDimensionShort - editorOffset;
                            
                        } else {
                            
                            tipClass = 'bottom';
                            tipTop = anchorPosition.y - tipDimensionShort;
                            tipStyleIdx = 1;
                            
                            
                            popTop = tipTop - popHeight + editorOffset;
                        }
    
                        
                        popLeft = fnBounds(0, boundaryRight - popWidth, anchorMidWidth - halfPopWidth);
    
                        
                        tipLeft = fnBounds(anchorPosition.x, anchorRight, anchorMidWidth) - tipHalfLong;
    
                        
                        return true; 
                    }
                    
                    
                    return false;
                },
                fnHorizFit = function() {
                    
                    if ((anchorPosition.y < boundaryBottom) && (fitsRight || anchorPosition.x > popWidth)) {
                        
                        var anchorMidHeight = anchorPosition.y + (anchorPosition.h / 2),
                            posRight = !(plm == PLACEMENT_LEFT && anchorPosition.x > popWidth) && fitsRight;
                        
                        
                        if (posRight) {
                            
                            tipClass = 'left';
                            tipLeft = anchorRight; 
                            tipStyleIdx = 2;
                            
                            
                            popLeft = anchorRight + tipDimensionShort - editorOffset;
                            
                        } else {
                            
                            tipClass = 'right';
                            tipLeft = anchorPosition.x - tipDimensionShort;
                            tipStyleIdx = 3;
                            
                            
                            popLeft = tipLeft - popWidth + editorOffset;
                        }
                        
                        
                        
                        popTop = fnBounds(offsetTop, boundaryBottom - popHeight, anchorMidHeight - halfPopHeight);
                        
                        
                        tipTop = fnBounds(anchorPosition.y, anchorBottom, anchorMidHeight) - tipHalfLong;
                        
                        
                        return true;
                    }               
                    
                    
                    return false;
                },
                testFns = [ fnVertFit, fnHorizFit ],                
                i = 0;
                
            if (plm == PLACEMENT_FIXED) {
                popTop = this.popPosition.top;
                popLeft = this.popPosition.left;
                tipTop = -1000;
                tipLeft = -1000;
                tipClass = null;
            } else {    
                
                
                if (plm == PLACEMENT_LEFT || plm == PLACEMENT_RIGHT ||
                        (plm == PLACEMENT_AUTO && defaultOrientation === 'h')) {
                    
                    testFns.reverse();
                }

                
                for (; i < 2; i++) {
                    
                    if (testFns[i]()) {
                        
                        break;
                    }
                }
                
                popTop = $MATH.round(popTop);
                popLeft = $MATH.round(popLeft);
                tipTop = $MATH.round(tipTop);
                tipLeft = $MATH.round(tipLeft);
            }
    
            
            tipNode.className = baseTipCls + ' ' + (tipClass || 'hidden');
            
            var tipNodeStyle = tipNode.style,
                popupNodeStyle = popupNode.style;
            
            
            tipNodeStyle.top = tipTop + 'px';
            tipNodeStyle.left = tipLeft + 'px';
            
            if (this.tipNodeColor) {
                
                mstrmojo.array.forEach(tipBorderStyles, function(s) {
                    tipNodeStyle[s] = '';
                });
                tipNodeStyle[tipBorderStyles[tipStyleIdx]] = this.tipNodeColor;
            }
            
            
            popupNodeStyle.top = popTop + 'px';
            popupNodeStyle.left = popLeft + 'px';
            
            return true;
        }
    
        
    mstrmojo._IsAnchorable = {
        
        
        anchor : null,
        
        
        anchorPosition: null,
        
        
        boundaryNodeName : 'curtainNode',
        
        
        popupNodeName : 'editorNode',
        
        
        tipNodeName : 'tipNode',
        
        
        baseTipClass : 'mstrmojo-Editor-tip',
        
        
        anchorOffset : 25,
        
        
        anchorOrientation : 'v',
        
        placement: PLACEMENT_AUTO,
        
        popPosition: null,
        
        
        hasScrollbars : function hasScrollbars(){
            return (!mstrApp.isTouchApp || !mstrApp.isTouchApp());
        },
        
        
        prepareAnchor : mstrmojo.emptyFn,
        
        positionDialog : function positionDialog(){
            this.prepareAnchor();
            if (!anchorPopup.apply(this,[])) {
                
                if ( typeof this._super === "function" ) {
                    this._super();
                }
            }
        }
    };
    
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.dom");
    
    var _D = mstrmojo.dom,
        _DND,
        _doc = mstrmojo.global.document;
    
    function _onMouseDown(e){        
        _DND.startDragCheck(self, e);
    }
    
    var _av,
        _avin,
        _avCSS = 'mstrmojo-dnd-avatar',
        _avs;
    
    function _updateAvatar(pos, allowDrop, html){
        if (html != null) { 
            _avin.innerHTML = html;         
        }
        _avs.left = pos.x + 'px';
        _avs.top = pos.y + 'px';
    }
    function _showAvatar(html, pos){
        if (!_av) {
            _av = _doc.createElement("div");
            _avs = _av.style;
            _av.className = _avCSS;
            _av.innerHTML = '<div class="'+ _avCSS + '-inner"></div>';
            _avin = _av.firstChild;
            _doc.body.appendChild(_av);
        }
        _updateAvatar(pos, true, html);
        _avs.display = 'block';
    }
    function _hideAvatar(){
        if (_av) {
            _avs.display = 'none';
        }
    }
    
    
     function _onMoveDuringCheck(e) {
        var c = ++_DND.ctxt.moveCount;
        if (c >= _DND.minMoves) {
            
            _DND.stopDragCheck(self, e);
            _DND.startDrag(self, e);
        }
    }
    
    
    function _onUpDuringCheck(e) {
        _DND.stopDragCheck(self, e);
    }
    
    
    function _onMoveDuringDrag(e) {
        _DND.onDragMove(self, e);
    }

    
    function _onUpDuringDrag(e) {
        _DND.stopDrag(self, e);
    }

    
    function _capEvtInf(h) {
        if (!h) {
            return;
        }        
        if (!h.hWin) {
            h.hWin = window;
        }
        if (!h.e) {
            h.e = h.hWin.event;
        }

        h.node = _D.eventTarget(h.hWin, h.e);
        h.pos = _D.getMousePosition(h.e, h.hWin);
        
        return h;
    }
    
    
    function _findDraggable(nd){
        var w = _D.findWidget(nd);
        while (w) {
            if (w.draggable) {
                return w;
            }
            w = w.parent;
        }
        return null;
    }
    
    
    function _findDroppable(nd, c){
        var w = _D.findWidget(nd);
        while (w) {
            if (w.dropZone) {
                
                
                if (w.allowDrop && w.allowDrop(c)) {
                    return w;
                }
            }
            w = w.parent;
        }
        return null;
    }
    

        
    function _ondragenterDefault(c){
        if (this.set) {
            this.set("allowingDrop", true);
        }
    }

        
    function _ondragleaveDefault(c){
        if (this.set) {
            this.set("allowingDrop", false);
        }
    }

        
    var _ondropDefault = _ondragleaveDefault;

    
    mstrmojo.dnd = mstrmojo.provide(
        "mstrmojo.dnd",
        
        {
            
            minMoves: 3,

                        
            enable: function(){
                if(!mstrmojo.dndEnabled){
                    _D.attachEvent(_doc, "mousedown", _onMouseDown);
                    mstrmojo.dndEnabled = true;
                } 
            },
            
                        
            disable: function(){
                _D.detachEvent(_doc, "mousedown", _onMouseDown);
            },
        
            
            startDragCheck: function(hWin, e){
                delete this.ctxt;
                                
                var src = _capEvtInf({hWin: hWin, e: e});
                
                this.ctxt = {src: src, moveCount: 0};
                    
                
                if (this.minMoves) {
                    
                    _D.attachEvent(_doc, "mousemove", _onMoveDuringCheck);
                    _D.attachEvent(_doc, "mouseup", _onUpDuringCheck);
                } else {
                    
                    this.startDrag(hWin, e);
                }
            },

            
            stopDragCheck: function(hWin, e){
                _D.detachEvent(_doc, "mousemove", _onMoveDuringCheck);
                _D.detachEvent(_doc, "mouseup", _onUpDuringCheck);
            },

            
            startDrag: function(hWin, e){
                
                var c = this.ctxt;
                c.id = new Date();

                var src = c.src,
                    w = _findDraggable(src.node);
                if (!w) {
                    return;
                }
                
                
                src.widget = w;
                src.data = w.getDragData && w.getDragData(c);
                
                
                if (w.ondragstart) {
                    if (w.ondragstart(c) === false) {
                        
                        return;
                    }
                }
                
                
                
                _D.clearBrowserHighlights();
                _D.preventDefault(self, e);

                _D.attachEvent(_doc, "mousemove", _onMoveDuringDrag);
                _D.attachEvent(_doc, "mouseup", _onUpDuringDrag);
                
                if(w && !w.ownAvatar) {
                    _showAvatar(src.data && src.data.html, src.pos);
                }
            },

            
            stopDrag: function(hWin, e){                
                
                _D.detachEvent(_doc, "mousemove", _onMoveDuringDrag);
                _D.detachEvent(_doc, "mouseup", _onUpDuringDrag);

                
                var c = this.ctxt,
                    ct = _capEvtInf({hWin: hWin, e: e}),
                    w = _findDroppable(ct.node, c);
                ct.widget = w;
                c.tgt = ct;
                
                
                
                
                
                
                
                
                
                if (w) {
                    
                    if (w.ondrop) {
                        w.ondrop(c);
                    } else {
                        _ondropDefault.apply(w, [c]);
                    }
                }

                
                var s = c.src.widget;
                if (s && s.ondragend) {
                    s.ondragend(c);
                }

                
                
                if(s && !s.ownAvatar) {
                    _hideAvatar();
                }
            },
            
            
            onDragMove: function(hWin, e){
                if (_D.isSafari) {
                    _D.clearBrowserHighlights();
                }

                
                var c = this.ctxt,
                    ct = _capEvtInf({hWin: hWin, e: e}),
                    w = _findDroppable(ct.node, c);
                ct.widget = w;      
                                
                
                var tWas = c && c.tgt && c.tgt.widget;
                
                c.tgt = ct;
                
                if (tWas !== w) {
                    

                    
                    if (tWas) {
                        
                        if (tWas.ondragleave) {
                            tWas.ondragleave(c);
                        } else {
                            _ondragleaveDefault.apply(tWas, [c]);
                        }
                    }
                    
                    
                    if (w) {
                        
                        if (w.ondragenter) {
                            w.ondragenter(c);
                        } else {
                            _ondragenterDefault.apply(w, [c]);
                        }
                    }
                } else if (w) {
                    
                    
                    
                    if (w.ondragover) {
                        w.ondragover(c);
                    }
                } 

                
                var s = c.src.widget;
                if (s && s.ondragmove) {
                    s.ondragmove(c);
                }
                
                if(s && !s.ownAvatar) {
                    _updateAvatar(ct.pos, !!w);                
                }
            }
            
        });
        
    _DND = mstrmojo.dnd;

    
    _DND.enable();

})();
(function(){

	mstrmojo.requiresCls("mstrmojo.dom");
	
    var _D = mstrmojo.dom;

    
    function _findGtEq(h, min){
        var ret = [];
        if (h) {
            for (var k in h) {
                var i = Number(k);
                if (i >= min) {
                    ret.push(i);
                }
            }
        }
        ret.sort(mstrmojo.array.numSorter);
        return ret;
    }
    
    mstrmojo.ListSelector = mstrmojo.provide(
        "mstrmojo.ListSelector",
        {
            
            premousedown: function pmd(w, p, evt){
                
                var hWin = evt.hWin,
                    e = evt.e,
                    el = _D.eventTarget(hWin, e),
                    idx = w.listMapper.findIndex(w, p, el);
                if (idx > -1) {
                    
                    var m = w.multiSelect,
                        c = _D.ctrlKey(hWin, e),
                        s = _D.shiftKey(hWin, e);
                    if (c || s) {
                        _D.clearBrowserHighlights(hWin);
                    }

                    if (m && ( c || (w.selectionPolicy === "toggle") )) {
                        w.toggleSelect(idx);
                    } else if (m && s) {
                        w.rangeSelect(idx);
                    } else {
                        w.singleSelect(idx);
                    }
                }
            },

            
            premouseup: function pmu(w, p, evt){
                var hWin = evt.hWin,
                    e = evt.e,
                    c = _D.ctrlKey(hWin, e),
                    s = _D.shiftKey(hWin, e);
                if (c || s) {
                    _D.clearBrowserHighlights(hWin);
                }
            },
                        
            
            onadd: function oa(w, evt){
                var c = evt && evt.value && evt.value.length;
                if (c) {
                    var idx = evt.index,
                        sel = w.selectedIndices,
                        inc = _findGtEq(sel, idx);
                    for (var j=inc.length-1; j>-1; j--){
                        var at = inc[j];
                        sel[at + c] = true;
                        delete sel[at];
                    }
                    
                    if (w.selectedIndex >= idx){
                        w.selectedIndex += c;
                    }
                }
            },

            
            onremove: function oa(w, evt){
                var c = evt && evt.value && evt.value.length;
                if (c) {
                    var idx = evt.index,
                        idxLast = idx + c - 1,
                        h = w.selectedIndices,
                        si = w.selectedIndex,
                        dec = [],
                        rem = [],
                        b = false;
                    if (h) {
                        for (var k in h) {
                            var i = Number(k);
                            if (i > idxLast) {
                                dec.push(i);
                            } else if (i >= idx) {
                                rem.push(i);
                                b = true;
                            }
                        }
                    }
                    dec.sort(mstrmojo.array.numSorter);
                    for (var j=0, len=dec.length; j<len; j++){
                        var at = dec[j];
                        h[at - c] = true;
                        delete h[at];
                    }
                    if (si > idxLast) {
                        
                        w.selectedIndex -= c;
                    }
                    
                    if (b) {
                        
                        w.removeSelect(rem);
                    }                  
                }
            }
        });
        
})();
(function() {
    
    mstrmojo.requiresCls("mstrmojo.dom");
    
    var $D = mstrmojo.dom;
    
    
    mstrmojo._IsDocXtab = {
            
        _mixinName: 'mstrmojo._IsDocXtab',            
        
        
        isDocXtab: true,
        
        formatHandlers: {
            
            domNode: [ 'RW', 'T', 'font'],
            msgNode: [ 'height', 'background-color' ],
            viewport: [ 'D', 'background-color', 'B', 'fx' ]
        },
                
        preBuildRendering: function preBuildRendering() {
            
            
            var f = this.getFormats(),
                cs = '',
                setDim = function setDim(dim) {
                    if(f[dim]) {
                        
                        var d = this[dim] || f[dim];
                        
                        
                        this[dim] = d;
                        
                        
                        if (this.isFullScreenWidget) {
                            f[dim] = d;
                        }
                        
                        
                        this[dim + 'Limit'] = parseInt(d, 10);
                    }
                };

            
            setDim.call(this, 'height');
            setDim.call(this, 'width');
            
            
            
            var fn = function (d, offset) {
                
                var x = f[d];

                
                if (x && x.charAt(x.length - 1) !== '%') {
                    var v = parseInt(x, 10);
                    
                    
                    if (!isNaN(v)) {
                        
                        if (offset) {
                            v -= offset;
                        }
                        
                        
                        
                        cs += d + ':' + v + 'px;';
                    }
                }

                
                
                
                return null;
            };
            
            
            fn('height', 0);
            
            
            fn('width', 0);
            
            this.scrollboxNodeCssText = cs;
            
            return this._super();
        },        
               
        
        resize: function() {              
            
            this.clearCache();                
            
            var f = this.getFormats(),
                h = parseInt(f.height, 10),
                w = parseInt(f.width, 10);
            if (w > 0 && h > 0) {
                if (!this.visible && this.forcedHidden){
                    this.set('visible', true);
                    this.forcedHidden = false;
                }
                
                
                
                mstrmojo.array.forEach([this.scrollboxNode, this.viewport], function (node) {
                    var nodeStyle = node.style;
                    nodeStyle.height = h + 'px';
                    nodeStyle.width = w + 'px';
                });
                
                
                if (this.scrollboxNode) {
                    
                    this.scrollboxHeightFixed = h && (h !== "auto");

                    
                    if (this.scrollboxHeightFixed) {
                        this.scrollboxHeight = parseInt(h, 10); 
                        
                        this.scrollboxBottom = this.scrollboxTop + h;
                        
                        
                    }                            

                    
                    if (this.lockHeadersCase) {
                        this.resizeScrollBox($D.isIE);
                    }
                }                   

                
                var zs = this.zones;
                if(zs) {
                    if(zs._BL) {
                        zs._BL.onscroll();
                    }
                    if(zs._BR) {
                        zs._BR.onscroll();
                    }
                }
                
                if (!(this.gridData && this.gridData.eg)) {
                    
                    this.onGridWidthChanged();
                }
            } else {
                
                if (this.visible) {
                    this.set('visible', false);
                    this.forcedHidden = true;
                }
            }
        },        
                
        
        renderPortalState: function renderPortalState() {
            this.clearCache();
            this.unrender();
            this.render();
        },        
        
        
        unrender: function unrender() {
            
            this.clearCache();
            
            
            if (this._super) {
                this._super();
            }
        },        
        
        
        defaultAction: function defaultAction(td, tCell) {
            if (this._super(td, tCell)) {
                var sti = this.model.sti,
                    titleId = sti && sti.titleId,
                    deselectCurrentCell = sti && sti.deselectCurrent,
                    z;
                
                
                this._currentSelectedTD = deselectCurrentCell ? undefined : td;            
                
                
                if (titleId) {
                    
                    for (z in this.zones) {
                        var zn = this.zones[z],
                            dn = zn.domNode,
                            fc = dn && dn.firstChild;
                        
                        if (fc && (td.offsetParent === fc || td.offsetParent === dn)) {
                            zn.clearHilites(titleId);
                            if (!deselectCurrentCell) {
                                zn.setHilites(titleId, td);
                            }
                            zn.hiliteKey = titleId; 
                            
                            this.model.sti = null;
                            return true;
                        }
                    }
                }
                
                return true;
            }
            
            return false;
        }        
    };
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.string");
    
    var _S = mstrmojo.string,
        RENDERED = 1;
    
    mstrmojo.ListBuilder = mstrmojo.provide(
        "mstrmojo.ListBuilder",
        {
            
            newContext: function bc(w){
                var fn = w.itemMarkupFunction;
                if (!fn) {
                    
                    var s = w.itemMarkup || 
                            (w.itemField && '<div class="mstrmojo-text">{@' + w.itemField + '}</div>');
                    fn = s ?
                            function(item, index, widget){
                                return _S.apply(s, item);
                            } 
                            : null;
                }
                return {
                        itemStatus: [],
                        itemFunc: fn
                };
            },
                        
            
            build: function b(w, ctxt, item, idx){
                ctxt.itemStatus[idx] = RENDERED;
                return ctxt.itemFunc(item, idx, w);
            },
            
            onadd: function oa(w, ctxt, evt){
                if (ctxt) {
                    mstrmojo.array.insert(
                        ctxt.itemStatus, 
                        evt.index, 
                        new Array(evt.value.length));
                }
            },
            
            onremove: function orm(w, ctxt, evt){
                if (ctxt) {
                    ctxt.itemStatus.splice(evt.index, evt.value.length);
                }
            }
        });
})();
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.hash",
        "mstrmojo.registry",
        "mstrmojo.ListBuilder");
    
    var _H = mstrmojo.hash,
        _R = mstrmojo.registry,
        RENDERED = 1;
    
    mstrmojo.WidgetListBuilder = mstrmojo.provide(
        "mstrmojo.WidgetListBuilder",
        mstrmojo.mixin(
            {
                
                newContext: function bc(w){
                    var fn = w.itemFunction;
                    if (!fn) {
                        
                        var cfg = w.itemConfig;
                        fn = cfg ?
                                function(item, index, widget){
                                    var c = _H.clone(cfg);
                                    c.data = item;
                                    c.parent = widget;
                                    return _R.ref(c);
                                } 
                                : null;
                    }
                    return {
                            itemStatus: [],
                            itemWidgets: [],
                            itemFunc: fn
                    };
                },
                        
                
                build: function b(w, ctxt, item, idx){
                    var iw = ctxt.itemFunc(item, idx, w);
                    if (iw) {
                        ctxt.itemStatus[idx] = RENDERED;
                        ctxt.itemWidgets[idx] = iw;
                        
                        if (iw.set) {
                            var s = w.selectedIndices;
                            if (s && s[idx]) {
                                iw.set("selected", true);
                            }
                        }
                    }
                    return iw;
                },

                
                onadd: function oa(w, ctxt, evt){
                    if (ctxt) {
                        mstrmojo.array.insert(
                            ctxt.itemWidgets, 
                            evt.index, 
                            new Array(evt.value.length));
                    }
                    this._super(w, ctxt, evt);
                },
                
                
                onremove: function orm(w, ctxt, evt){
                    if (ctxt) {
                        var ids = ctxt.itemWidgets.splice(evt.index, evt.value.length);
                        for (var i=0, len=ids.length; i<len; i++){
                            var iw = ids[i];
                            if (iw && iw.destroy) {
                                delete iw.parent;
                                
                                iw.destroy();
                            }
                        }
                    }
                    this._super(w, ctxt, evt);
                },
                
                
                onchange: function ocg(w, p, ctxt, evt) {
                    if (evt) {
                        var iws = ctxt.itemWidgets,
                            iw;
                        for (var i=0, r = evt.removed, rlen = r&&r.length; i<rlen; i++) {
                            iw = iws[r[i]];
                            if (iw && iw.set) {
                                iw.set("selected", false);
                            }
                        }
                        for (var j=0, a = evt.added, alen = a&&a.length; j<alen; j++) {
                            iw = iws[a[j]];
                            if (iw && iw.set) {
                                iw.set("selected", true);
                            }
                        }
                    }
                }
            },
            mstrmojo.hash.copy(mstrmojo.ListBuilder)
        )
    );

})();
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.hash",
        "mstrmojo.dom",
        "mstrmojo.ListSelector");
        
    var _D = mstrmojo.dom,
        _IE = _D.isIE;
            
    mstrmojo.TreeNodeSelector = mstrmojo.provide(
        "mstrmojo.TreeNodeSelector",
        mstrmojo.mixin(
            {
                
                premousedown: function pmd(w, p, evt){
                    var t = w && w.tree || w,
                        e = evt && evt.e;
                    if (!e) {
                        return false;
                    }
                    
                    
                    var lmd = t.lastMouseDown;
                    if (lmd) {
                        
                        
                        
                        
                        if (
                            (lmd.e === e) ||
                            (_IE && ((new Date())-lmd.dt < 50) )
                            ) {
                            return false;
                        }
                    }
                        
                    
                    
                    

                    
                    this._super(w, p, evt);
                    
                    
                    if (t){
                        if (t.onnodemousedown) {
                            t.onnodemousedown(evt);
                        }
                        
                        t.lastMouseDown = {e: e, dt: new Date()};
                        
                        
                        
                    }
                }
                
            },
            mstrmojo.hash.copy(mstrmojo.ListSelector)
        )
    );
        
})();
(function(){
    
    mstrmojo.requiresCls(
            "mstrmojo.dom",
            "mstrmojo.ListSelector"
    );
    
    
    mstrmojo.TreeBrowserSelector = mstrmojo.provide(
            "mstrmojo.TreeBrowserSelector",
            mstrmojo.hash.copy(
                    {
                        premousedown: function pmd(w, p, evt){
                            var hWin = evt.hWin,
                                e = evt.e,
                                el = mstrmojo.dom.eventTarget(hWin, e),
                                idx = w.listMapper.findIndex(w, p, el);
                            if (idx > -1) {
                                w.toggleSelect(idx);
                            }
                        }
                    },
            mstrmojo.hash.copy(mstrmojo.ListSelector)
        )
    );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.dnd");

    var $D = mstrmojo.dom;

    
    function cursorHack(rtnValue) {
        if ($D.isWK) {
            document.onselectstart = function (e) {
                if (!rtnValue) {
                    e.preventDefault();
                }

                return rtnValue;
            };
        }
    }

    mstrmojo._IsMovable = mstrmojo.provide("mstrmojo._IsMovable", {
        
        draggable: true,

        
        ownAvatar: true,

        
        getMovingHandle: function getMovingHandle() {
            return this.domNode;
        },

        
        getMovingTarget: function getMovingTarget() {
            return this.domNode;
        },

        
        ondragstart: function ondragstart(c) {
            var handle = this.getMovingHandle(),
                targetStyle = this.getMovingTarget().style;

            
            var shouldBeginDrag = $D.contains(handle, c.src.node, true, document.body);
            if (shouldBeginDrag) {
                
                cursorHack(false);

                
                handle.style.cursor = 'move';

                
                this._leftPos = parseInt(targetStyle.left, 10);
                this._topPos = parseInt(targetStyle.top, 10);
                this._hWidth = handle.clientWidth;
                this._hHeight = handle.clientHeight;
            }

            return shouldBeginDrag;
        },

        
        ondragmove: function ondragmove(c) {
            var targetPosition = c.tgt.pos,
                srcPosition = c.src.pos,
                targetStyle = this.getMovingTarget().style;

            
            
            targetStyle.left = this.left = Math.max(this._leftPos + targetPosition.x - srcPosition.x, -this._hWidth + 40) + 'px';
            targetStyle.top = this.top = Math.max(this._topPos + targetPosition.y - srcPosition.y, -this._hHeight + 10) + 'px';
        },

        
        ondragend: function ondragend(c) {
            
            cursorHack(true);

            
            this.getMovingHandle().style.cursor = 'default';

            
            delete this._leftPos;
            delete this._topPos;
            delete this._hWidth;
            delete this._hHeight;
        }
    });
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.css",
                         "mstrmojo.hash",
                         "mstrmojo.string",
                         "mstrmojo.DICFactory");

    var TX_ELEM_TEXTFIELD = 3,


        FIELDGROUP = 2,
        DATA_DRIVEN_CONTROL = 2,
        $CSS = mstrmojo.css,
        MASK = '********',
        $H = mstrmojo.hash;

    var tf_formatHandlers = null;

    
    function setDirtyFlag(c, d) {
        if (c) {
            
            var dicWidget = this.dicWidget;
            if (dicWidget && dicWidget.setDirtyFlag) {
                
                dicWidget.setDirtyFlag(c, d);

            
            } else if (c.className !== 'flag-container') {
                var f = document.createElement('div');
                f.className = 'flag-container';
                f.style.right = '10px';
                f.innerHTML = '<div class="dirty-cell"/>';
                d.insertBefore(f, c);
            }
        }
    }

    
    mstrmojo._IsEditableTextfield = {
        _mixinName: "mstrmojo._IsEditableTextfield",

        preBuildRendering: function preBldRnd() {
            if (!this.edb) {
                var d = this.node.data,
                    defn = this.node.defn,
                    di = d.dic || defn.txi.dic,
                    rv = (this.rv === '') ? this.value : this.rv; 

                
                if (di.psw) {
                    this.v = MASK;
                    rv = this.rv = '';
                }

                if (di.ipt === DATA_DRIVEN_CONTROL) {
                    di.vls = this.vls || []; 
                    this.dk = di.k;
                }

                this.req = di.req;
                this.dt = di.dt;

                this.dicWidget = mstrmojo.DICFactory.createDIC({dic: di, owner: this, k: 0, dv: this.value, value: rv, openerType: FIELDGROUP, popupTitle: defn.n});

                if (this.shouldReplaceValueNode()) {
                    
                    if (!tf_formatHandlers) {
                        tf_formatHandlers = $H.clone(this.formatHandlers);
                    }

                    this.formatHandlers.domNode = ['T', 'z-index', 'D', 'B', 'F', 'P', 'text-align', 'background-color', 'fx', 'white-space', 'overflow'];
                    
                    delete this.formatHandlers.valueNode;
                }
            }

            this.set('cssClass', this.edb ? '' : 'editable-field');

            this._super();
        },

        shouldReplaceValueNode: function shouldReplaceValueNode() {
            return this.dicWidget.showByDefault || this.dicWidget.hasPreview;
        },

        postBuildRendering: function pstBldRnd() {
            this._super();

            if (this.edb) {
                return;
            }

            var w = this.dicWidget,
                text = this.valueNode.innerHTML;

            
            if (mstrmojo.string.isEmpty(text)) {
                this.valueNode.innerHTML = text + '1';
                this.valueNode.style.height = this.valueNode.clientHeight + 'px';
                this.valueNode.innerHTML = text;
            }

            if (w.showByDefault) {
                w.render();
            } else {
                if (w.hasPreview) {
                    
                    w.openerNode = this.domNode;
                    
                    w.renderPreview(this.value);
                } else {
                    w.openerNode = this.valueNode;
                }

                mstrmojo.dom.attachEvent(w.openerNode, mstrApp.isMobile ? mstrmojo.dom.TOUCHEND : 'click', function () {
                    w.showInPopup();
                });
            }

            
            if (this.shouldReplaceValueNode()) {
                $H.copy(tf_formatHandlers, this.formatHandlers);
            }

            this.registerTxWidget();

            
            this.addToTraversalList();

            if (this.mdf && this.sci) {
                var domNode = this.domNode;
                setDirtyFlag.call(this, domNode.firstChild, domNode);
            }
        },

        getKeyContext: function getKeyContext() {
            return {
                dt: this.dt || 0,
                k: this.dk || undefined
            };
        },

        getUpdates: function getUpdates() {
            var udv = this.getUpdatedValues()[0],
                k = udv.k ? ('rw_control_key="' + udv.k + '" element_id="' + this.vls[mstrmojo.array.find(this.vls, 'v', udv.v)].eid + '" ') : '';
            return '<rwf rw_tree_type="' + this.tt + '" rw_node_key="' + this.fgk + '" rw_field_key="' + this.k + '" key="' + this.key + '" columns="' + this.cls + '" types="' + TX_ELEM_TEXTFIELD + '" ' + k + 'value="' + mstrmojo.string.encodeXMLAttribute(String(udv.v)) + '" dt="' + udv.dt + '" />';
        },

        updateValue: function updateValue(idx, vo) {
            if (this._super) {
                this._super(idx, vo);
            }

            var t = this.valueNode,
                d = this.domNode,
                w = this.dicWidget,
                v = vo.v,
                dv = vo.dv;

            if (this.rv !== v) {
                if (this.req) {
                    $CSS.removeClass(d, 'required');
                }

                this.rv = v;
                this.v = dv;
                this.mdf = 1;

                if (!w.showByDefault) {
                    if (w.hasPreview) {
                        w.renderPreview();
                    } else {
                        t[t.innerText !== undefined ? 'innerText' : 'textContent'] = this.psw ? MASK : dv;
                    }
                }

                if (this.req) {
                    $CSS.removeClass(d, 'required');
                }

                if (this.sci) {
                    setDirtyFlag.call(this, d.firstChild, d);
                }
            }

            
            
            return false;
        },

        applyPasswordMask: function applyPasswordMask() {
            this.psw = true;
            this.v = MASK;
            this.rv = '';
        },

        
        getUpdateObject: function getUpdateObject() {
            var changedObj = {
                    fieldKey: this.k,
                    wid: this.wid, 
                    newValue: mstrmojo.string.encodeXMLAttribute(String(this.rv)),
                    dataType: this.dt
                },
                udv = this.getUpdatedValues()[0];

            if (udv.k !== undefined) {
                changedObj.controlKey = udv.k;
                changedObj.elementId = this.vls[mstrmojo.array.find(this.vls, 'v', udv.v)].eid;
            }

            return {
                nodeKey: this.fgk,
                cells: [changedObj],
                retrieveData: false, 
                
                autoRefresh: false
            };
        },

        update: function update(node) {
            if (this._super) {
                this._super(node);
            }
            var d = node.data,
                df = node.defn;

            if (d.vls) {
                this.vls = d.vls;
            } else {
                delete this.vls;
            }

            this.cell = node.data;
            
            this.value = d.v || '';
            
            this.rv = (d.rv === undefined) ? this.value : d.rv;
            this.tca = d.tca || 0;
            this.dt = d.dt;
            this.key = d.key || ''; 
            this.cls = d.cls || ''; 
            this.wid = d.wid;

            this.edb = d.edb;

            
            this.mdf = d.mdf;
            this.req = d.req;

            
            this.sci = df.txi.sci;
            this.tt = df.tt;
            this.fgk = df.fgk;
        },

        
        addToTraversalList: function addToTraversalList() {
            if (mstrmojo.DICConfig.isKeyNavigable(this.dicWidget.dic)) {
                var traversalList = this.parent.traversalList,
                    dom = this.domNode;

                if (!traversalList) {
                    traversalList = this.parent.traversalList = [];
                }

                traversalList.push({
                    x: dom.offsetLeft,
                    y: dom.offsetTop,
                    h: dom.offsetHeight,
                    refField: this
                });
            }
        },

        
        editNext: function editNext() {
            var traversalList = this.parent.traversalList,
                i,
                len,
                avgHeight,
                sumHeight = 0;

            if (!traversalList) {
                return false;
            }

            
            if (!traversalList.isSorted) {

                
                for (i = 0, len = traversalList.length; i < len; i++) {
                    sumHeight += traversalList[i].h;
                }
                avgHeight = sumHeight / len;

                
                traversalList.sort(function (a, b) {
                    
                    var r1 = Math.floor(a.y / avgHeight),
                        r2 = Math.floor(b.y / avgHeight);

                    if (r1 < r2) { 
                        return -1;
                    }

                    if (r1 > r2) {
                        return 1;
                    }

                    if (a.x < b.x) { 
                        return -1;
                    }

                    if (a.x > b.x) {
                        return 1;
                    }

                    return (a.y < b.y) ? -1 : 1; 
                });
                
                traversalList.isSorted = true;
            }

            
            for (i = 0, len = traversalList.length; i < len; i++) {
                if (traversalList[i].refField.k === this.k) {
                    break;
                }
            }

            if (i < len) {
                do {
                    i++;
                    if (i >= len) {
                        i %= len;
                    }
                    if (i === parseInt(this.k, 10)) {
                        return false;
                    }

                    
                    var dicWidget = traversalList[i].refField.dicWidget;
                    if (dicWidget) {
                        if (!dicWidget.showByDefault) {
                            dicWidget.showInPopup();
                        } else {
                            
                            dicWidget.focus();
                        }
                        return true;
                    }
                } while (true);
            }
            
        },

        
        checkRequiredObjects: function checkRequiredObjects() {
            
            if (this.req && !this.mdf && !this.edb) {
                $CSS.addClass(this.domNode, 'required');
                return false;
            }
            return true;
        }
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css,
        clsSelected = 'selected';

    function delegateSelect(mthName, el, item, idx, widget) {
        
        var hook = widget.listHooks[mthName];
        if (hook && hook.call(widget, el, item, idx)) {
            
            return;
        }

        
        $CSS[((mthName === 'select') ? 'add' : 'remove') + 'Class'](el, clsSelected);
    }

    function addToCollection(propertyName, delimiter, values) {
        
        var existing = this[propertyName],
            arr = (existing) ? existing.split(delimiter) : [];

        
        arr = arr.concat(values.split(delimiter));

        
        this[propertyName] = arr.join(delimiter);

        
        return arr.length - 1;

    }

    
    mstrmojo._IsList = mstrmojo.provide(

        "mstrmojo._IsList",

        
        {
            _mixinName: 'mstrmojo._IsList',

            
            listHooks: {},

            
            getItemMarkup: function (item, idx) {
                return '<{@tag} class="item {@cls}" idx="{@idx}" style="{@style}">{@n}</{@tag}>';
            },

            
            getItemProps: function getItemProps(item, idx) {
                var isSelected = !!this.selectedIndices[idx];
                return {
                    tag: 'div',                                                 
                    sel: isSelected,                                            
                    cls: (isSelected) ? clsSelected : '',                       
                    n: item.n || '',                                            
                    style: '',                                                  
                    idx: idx,
                    addCls: function (cls) {
                        addToCollection.call(this, 'cls', ' ', cls);
                    },
                    addStyle: function (s) {
                        addToCollection.call(this, 'style', ';', s);
                    }
                };
            },

            itemRenderer: {
                render: function (item, idx, widget) {
                    
                    item._renderIdx = idx;

                    
                    return mstrmojo.string.apply(widget.getItemMarkup(item, idx), widget.getItemProps(item, idx));
                },

                select: function (el, item, idx, widget) {
                    delegateSelect('select', el, item, idx, widget);
                },

                unselect: function (el, item, idx, widget) {
                    delegateSelect('unselect', el, item, idx, widget);
                }
            },

            onclick: function onclick(evt) {
                try {
                    
                    var target = evt.target || $DOM.eventTarget(evt.hWin, evt.e),
                        item = $DOM.findAncestorByAttr(target, 'idx', true, this.domNode),
                        idx = item && parseInt(item.value, 10);

                    if (idx !== null && !isNaN(idx)) {
                        
                        if (!this.multiSelect) {
                            
                            this.singleSelect(idx);

                        } else {
                            
                            var m = (this.selectedIndices[idx]) ? 'remove' : 'add';

                            
                            this[m + 'Select'](idx);

                        }
                    }
                } catch (ex) {
                    
                    
                    mstrApp.onerror(ex);
                }
            }
        }
    );

    
    mstrmojo._IsList.SELECTED_CLS = clsSelected;

}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.css");
    
    
    var commonProps = {
        T: [ 'top', 'left' ],
        D: [ 'height', 'width' ],
        B: [ 'border', 'border-color', 'border-style', 'border-width' ],
        F: [ 'font', 'color', 'text-decoration' ],
        P: [ 'padding' ]
    };
    
     
    commonProps.RW = ['z-index'].concat(commonProps.T.concat(commonProps.D));
    
    
    var $D = mstrmojo.dom;
    
    
    function pushFxProperty(fx, n, v) {
        
        var p = fx[n] || [];
        
        p.push(v);
        
        fx[n] = p;
    }
    
    
    mstrmojo._Formattable = 
        
        {
            _mixinName: 'mstrmojo._Formattable', 
            
            
            formatHandlers: null,
            
            
            getCacheKey: function getCacheKey(w) {
                return 'csscache' + (w.thresholdId || '');
            },

            update: function update(node) {
                
                this.invisible = !!(node && node.data && node.data.invisible);
                
                if (this._super) {
                    this._super(node);
                }
            },
            
                        
            preBuildRendering: function preBuildRendering() {
                if (this._super) {
                    this._super();
                }
                
                
                var defn = this.defn;
                if (!defn) {
                    defn = this.defn = {};
                }
                var cacheKey = this.getCacheKey(this),
                    cache = defn[cacheKey];
                if (!cache) {
                    
                    cache = defn[cacheKey] = {};
                    
                    
                    var fmts = this.getFormats();
                    if (fmts) {
                    
                        
                        var fhs = this.formatHandlers;
                        for (var slot in fhs) {
                            var handle = fhs[slot];
                            
                            
                            var src = handle.src? fmts[handle.src] : fmts;
                            if (!src) {
                                return;
                            }
                            
                            
                            var css = [];
                            var x = -1;
                            
                            
                            var slotCss = slot + 'CssText';
                            
                            
                            var props = handle.props || handle;
                            if (!props) {
                                continue;
                            }
                            
                            
                            for (var bp = props.length-1; bp >= 0; bp--) {
                                var p = props[bp];
                                
                                
                                var c = commonProps[p] || [ p ];
                                
                                
                                for (var z = c.length-1; z >= 0; z--) {
                                    
                                    p = c[z];
                                    
                                    
                                    if (p in src) {
                                        
                                        if (p === 'fx') {
                                            var f = src[p],
                                                fx = {};
                                            
                                            
                                            if ('gd' in f) {
                                                this.formatGradient(f.gd, fx);
                                            }
                                            
                                            
                                            
                                            if ('rt' in f) {
                                                if(f.rt == 1 || f.rt == 3) this.formatTextRotation(f.rt, fx);
                                            }
                                            
                                            
                                            if ('ds' in f) {
                                                this.formatDropShadow(f, fx);
                                            }
                                            
                                            
                                            for (var fp in fx) {
                                                
                                                css[++x] = fp + ':' + fx[fp].join(' ');
                                            }
                                        } else {
                                            css[++x] = p + ':' + src[p];
                                        }
                                    }
                                }
                            }
                            
                            if ( this.invisible) {
                            	css.push("visibility:hidden");
                            }
                            
                            
                            this[slotCss] = cache[slotCss] = css.join(';') + ';';
    
                        } 
                    } 
                } else {
                    
                    for (var n in cache) {
                        this[n] = cache[n];
                    }
                }            
                return true;
            },
            
            
            formatGradient: function formatGradient(gp, fx) {
                var gd = mstrmojo.css.buildGradient(gp.t, gp.sc, gp.ec);
                if (gd) {
                    pushFxProperty(fx, gd.n, gd.v);
                }
            },
            
            
            formatDropShadow: function formatDropShadow(f, fx) {
                if ($D.supports($D.cssFeatures.DROP_SHADOW)) {
                    var ds = f.ds;
                    
                    if ($D.isDXIE) {
                        pushFxProperty(fx, 'filter', "progid:DXImageTransform.Microsoft.DropShadow(Color='#66000000',Positive='true',OffX=" + ds + ",OffY=" + ds + ")");
                    } else {
                        var v = [ ds, ds ];
                        
                        
                        if (f.rt == 1 || f.rt == 3) {
                            
                            v[((f.rt === 1) ? 1 : 0)] = -ds;
                        }
                        
                        pushFxProperty(fx,  ($D.isWK ? '-webkit-' : '') + 'box-shadow', v.join('px ') + 'px 3px 0px #888');
                    }
                }
            }, 
            
            
            formatTextRotation: function formatTextRotation(tr, fx) {
                if ($D.supports($D.cssFeatures.TEXT_ROTATION)) {
                    if ($D.isDXIE) {
                        pushFxProperty(fx, 'filter', 'progid:DXImageTransform.Microsoft.BasicImage(rotation=' + tr + ')');
                    } else {
                        
                        
                        var degrees = (tr === 1) ? 90 : -90;
                        
                        
                        pushFxProperty(fx, $D.CSS3_PREFIX + 'transform-origin', 'top left');
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        pushFxProperty(fx, $D.CSS3_PREFIX + 'transform', 'rotate(' + degrees + 'deg)');
                    }
                }
            },
            
            
            getFormats: function getFormats() {
                if (!this.fmts) {
                       this.fmts = this.formatResolver.getFormat(this.defn, this.thresholdId);    
                }
                
                return this.fmts;
            },
            
            clearCache: function clearCache() {
                
                delete this.defn[this.getCacheKey(this)];
            },
            
            unrender: function unrender(ignoreDom) {
                
                
                if (this.thresholdId) {
                    
                    this.fmts = null;
                }
                
                this._super(ignoreDom);
            }
            
        };
    
    
    mstrmojo._Formattable.getBorderWidths = function(w) {
        var f = w.getFormats(),
            b = ('border' in f) ? f.border.match(/(\d*|\d*\.\d*)pt/)[0] : f['border-width'],    
            dpi = w.model.docModel ? w.model.docModel.dpi : w.model.dpi; 
        return mstrmojo.css.getBorderWidths(b, dpi);
        };
    
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.css");

    
    mstrmojo._HasDocLink = mstrmojo.provide(
        'mstrmojo._HasDocLink',

        
        {
            _mixinName: 'mstrmojo._HasDocLink',

            url: '',

            target: '',

            linkEnabled: true,

            ifw: '',

            
            update: function update(node) {
                var d = node.defn;

                
                this.url = node.data.url || d.url;

                
                if (d.target) {
                    
                    this.target = d.target;
                }

                if (d.ifw) {
                    this.ifw = d.ifw;
                }

                this._super(node);
            },

            

            postBuildRendering: function postBuildRendering() {
                
                if (this.url || this.ifw) {
                    
                    mstrmojo.css.addClass(this.domNode, 'hasLink');
                }

                
                var doc = this.controller.view,
                    layout = doc && doc.getCurrentLayout();
                if (layout && layout.addLinkInfo) {
                    layout.addLinkInfo(this.id, {
                        url: this.url,
                        target: this.target,
                        src: this
                    });
                }

                return this._super();
            },

            
            setLinkEnabled: function setLinkEnabled(value) {
                this.linkEnabled = value;
                var node = this.domNode;
                if (!node) {
                    return;
                }

                var childNodes = node.childNodes,
                    lastChild = childNodes[childNodes.length - 1],
                    maskId = this.id + '_mask',
                    mask = (lastChild.id === maskId) ? lastChild : null;

                if (value) {
                    if (mask) {
                        node.removeChild(mask);
                        delete this._mask;
                    }

                } else {
                    if (!mask) {
                        mask = document.createElement('div');
                        mask.className = 'mstrmojo-DocLinkMask';
                        mask.id = maskId;
                        mask.innerHTML = '&nbsp;';
                        node.appendChild(mask);
                    }
                }
            },

            onclick: function () {
                
                if (this.linkEnabled) {
                	var drillLinkItems = this.drillLinkItems,
                        defaultLink = drillLinkItems && drillLinkItems[0];
                        url = this.url || (defaultLink && defaultLink.url);

                    
                    if (this.ifw) {
                        this.model.showInfoWin(this.ifw, (this.getAnchor && this.getAnchor()) || this.domNode, 'v', true);

                    
                    } else if (url) {
                        this.model.executeLink(url, this.target, this);
                    }
                }
            }
        }
    );
}());
(function(){
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.css", "mstrmojo.array");
    
    var ROW_AXIS = 1, COL_AXIS = 2;
    
    
    function _isOfSameUnit(c1, c2){
        return _isOfSameTitle(c1, c2) && c1.o === c2.o;
    }
    
    
    function _isOfSameTitle(c1, c2){
        return c1 && c2 && c1.ui === c2.ui && c1.axis === c2.axis && c1.mix === c2.mix;
    }
    
    function _addToSelection(td, cell,  w){
        var ttlId = w.getCellTitleId(cell),
            idx = w.getCellUnitIndex(cell);
        w.selections[ttlId] = w.selections[ttlId] || {};
        w.selections[ttlId][idx] = w.selections[ttlId][idx] || [];
        w.selections[ttlId][idx].push(td);
        _hilite(td);
    }
    
    function _clearSelection( w){
        var sel = w.selections;
        for (var i in sel){
            for (var j in sel[i]){
                for (var k=0, len=sel[i][j].length;k<len;k++){
                    _unHilite(sel[i][j][k]);
                }
            }
        }
        w.selections = {};
    }
    
    function _hilite(td){
        mstrmojo.css.setOpacity(td, 50);
    }
    
    function _unHilite(td){
        mstrmojo.css.setOpacity(td, 100);
    }
    
    
    function _getFormCount(cell, w){
        
        if (cell.mix === undefined){
            var titles = w.gridData.gts[cell.axis === ROW_AXIS?'row':'col'],
                ttl = titles[cell.tui || cell.ui],
                count = 0;
            for (var i=0, len=titles.length;i<len;i++){
                
                if (titles[i].id === ttl.id){
                    count++;
                }
            }
            return count;
        }
        return 0;
    }
    
    mstrmojo._XtabSelections = 
        {
            
            lastSelectedTD: null,
            
            
            singleSelect: function singleSelect(td, toggle){
                var data = this.getCellForNode(td),
                    row = td.parentNode;
                
                
                if (toggle){
                    var ttlId =  this.getCellTitleId(data), 
                        idx = this.getCellUnitIndex(data);
                        selectedTitle = this.selections[ttlId];
                        selectedUnit = selectedTitle && selectedTitle[idx];
                    if (selectedUnit){
                        
                        for (var i = 0, len = selectedUnit.length; i < len; i++){
                            _unHilite(selectedUnit[i]);
                        }
                        delete selectedTitle[idx];
                        return;
                    }
                }
                
                
                var totalForms = _getFormCount(data, this);

                if (data.axis === ROW_AXIS) {
                    
                    for (var i = 0, formFound = 0, len = row.cells.length; i < len && formFound < totalForms; i++){
                        var tc = row.cells[i], tcData = this.getCellForNode(tc);
                        if (_isOfSameUnit(tcData, data)){
                            _addToSelection(tc, tcData, this);
                            formFound++;
                        }
                    }
                } else if (data.axis === COL_AXIS) {
                    var table = mstrmojo.dom.findAncestorByName(td, 'table', false),
                    rows = table.rows;
                    
                    for (var i = 0, formFound = 0, len = rows.length; i < len && formFound < totalForms; i++){
                        var cells = rows[i].cells;
                        
                        for (var j = 0, len2 = cells.length; j < len2; j++){
                            var tc = cells[j], tcData = this.getCellForNode(tc);
                            if (_isOfSameUnit(tcData, data)){
                                _addToSelection(tc, tcData, this);
                                formFound++;
                                break;
                            }
                        }
                    }
                } else { 
                    _addToSelection(td, data, this);
                }
                
            },
            
             
                        
            rangeSelect: function rangeSelect(fromTD, toTD){
                var fromCell = this.getCellForNode(fromTD), 
                    toCell = this.getCellForNode(toTD);
                
                if (_isOfSameTitle(fromCell, toCell)){
                    
                    if (fromCell.o > toCell.o || fromCell._ei > toCell._ei){
                        var tmp = fromTD;
                        fromTD = toTD; fromCell = this.getCellForNode(fromTD);
                        toTD = tmp; toCell = this.getCellForNode(toTD);
                    }
                    
                    var totalForms = _getFormCount(fromCell, this),
                        axis = fromCell.axis,
                        table = mstrmojo.dom.findAncestorByName(fromTD, 'table', false),
                        rows = table.rows,
                        fromRow = fromTD.parentNode,
                        fromRowIdx = fromRow.rowIndex,
                        fromRowCells = fromRow.cells,
                        toRowIdx = toTD.parentNode.rowIndex;
                    
                    if (axis === ROW_AXIS) {
                        for (var i = fromRowIdx; i <= toRowIdx; i++){
                            var cells = rows[i].cells, found1 = false;
                            
                            
                            for (var j = 0, len = cells.length, formFound = 0; j < len && formFound < totalForms; j++){ 
                                var tc = cells[j], tcData = this.getCellForNode(tc);
                                if (_isOfSameTitle(tcData, fromCell)){
                                    _addToSelection(tc, tcData, this);
                                    formFound++;
                                }
                            }
                        }
                    }else if (axis === COL_AXIS){
                        for (var i = 0, len = rows.length, formsFound = 0; i < len && formsFound < totalForms; i++){
                            var cells = rows[i].cells, shouldSelect = false;
                            for (var j = 0, len2 = cells.length; j < len2; j++){ 
                                var tc = cells[j], tcData = this.getCellForNode(tc);
                                if (_isOfSameUnit(tcData, fromCell)){ 
                                    
                                    shouldSelect = true;
                                }
                                if (shouldSelect){
                                    _addToSelection(tc, tcData, this);
                                }
                                if (_isOfSameUnit(tcData, toCell)){ 
                                    
                                    break;
                                }
                            }
                            if (shouldSelect){
                                formsFound++;
                            }
                        }
                    }else{ 
                        if (fromRowIdx == toRowIdx){
                            
                            for (var i = fromTD.cellIndex, len = toTD.cellIndex; i <= len; i++){
                                var tc = fromRowCells[i], tcData = this.getCellForNode(tc);
                                _addToSelection(tc, tcData, this);
                            }
                        }else{
                            
                            for (var i = fromRowIdx, len = toRowIdx; i <= len; i++){
                                var cells = rows[i].cells;
                                for (var j = 0, len2 = cells.length; j < len2; j++){
                                    var tc = cells[j], tcData = this.getCellForNode(tc);
                                    if (_isOfSameTitle(tcData, fromCell)){
                                        _addToSelection(tc, tcData, this);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            },
            
            
            doSelection: function( e,  hWin,  td) {
                var d = mstrmojo.dom,
                    ctrl = d.ctrlKey(hWin, e),
                    shift = d.shiftKey(hWin, e);
                    
                if (!ctrl){
                    _clearSelection(this);
                }
                
                var data = this.getCellForNode(td);
                var isHeaderValue = data && (data.mix === undefined && data.o !== undefined),
                    isMetricValue = data && (data.mix !== undefined && (data._lp || data._tp));
                
                if (isHeaderValue || isMetricValue) { 
                    if (shift) {
                        this.rangeSelect(this.lastSelectedTD, td);
                    } else {
                        this.singleSelect(td, ctrl);
                        this.lastSelectedTD = td; 
                    }
                }
            }
        };
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.css");

    
    mstrmojo.android.selectors._SupportsHoriz = mstrmojo.provide(

        "mstrmojo.android.selectors._SupportsHoriz",

        
        {
            _mixinName: 'mstrmojo.android.selectors._SupportsHoriz',

            scrollerConfig: {
                bounces: false,
                showScrollbars: false
            },

            minItemHeight: 25,

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx),
                    h = this.height,
                    itemCnt = this.items.length,
                    lineHeight;

                
                props.tag = 'label';
                props.n = props.n || "&nbsp";

                
                if (this.isHoriz) {
                    
                    if (h) {
                        
                        lineHeight = h;
                    }

                    
                    if (this.itemWidthMode === 0) {
                        
                        props.style += 'width:' + Math.floor(100 / itemCnt) + '%;';
                    }

                } else {
                    
                    if (h) {
                        
                        lineHeight = Math.round(parseInt(h, 10) / itemCnt);

                        
                        lineHeight = Math.max(lineHeight, this.minItemHeight);

                        
                        lineHeight += 'px';
                    }

                }

                
                if (lineHeight) {
                    
                    props.style += 'line-height:' + lineHeight + ';';
                }

                return props;
            },

            init: function init(props) {
                this._super(props);

                
                if (this.isHoriz) {
                    
                    this.cssDisplay = 'table';

                    
                    var cls = [ 'horiz' ];

                    
                    if (this.itemWidthMode === 0) {
                        
                        cls.push('fixedWidth');
                    }

                    
                    mstrmojo.css.addWidgetCssClass(this, cls);
                }

            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    scrollEl = this.itemsContainerNode,
                    dimension = 'Height',
                    axis = 'y',
                    scroll = 'v',
                    offset = {};

                
                if (this.isHoriz) {
                    
                    dimension = 'Width';
                    axis = 'x';
                    scroll = 'h';
                }

                
                cfg.scrollEl = scrollEl;

                
                var size = this[dimension.toLowerCase()];
                if (size) {
                    
                    size = parseInt(size, 10);

                    
                    var offsetEnd = Math.max(scrollEl['offset' + dimension] - size, 0),
                        enableDimensionScroll = cfg[scroll + 'Scroll'] = (offsetEnd !== 0);

                    
                    if (enableDimensionScroll) {
                        
                        offset[axis] = {
                            start: 0,
                            end: offsetEnd
                        };
                    }
                }

                
                cfg.offset = offset;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                return cfg;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.css",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom,
        $POS = $DOM.position,
        $MTH = Math;

    
    function getCloneInfo(key, srcNode, isMultiLine) {
        var ellCollection = this._ellTestNodes || {},               
            info = ellCollection[key],                              
            compStyle = mstrmojo.css.getComputedStyle(srcNode),     
            dimensions = [ 'width', 'height' ];                     

        
        if (isMultiLine) {
            
            dimensions.reverse();
        }

        
        var testDimension = dimensions[0],
            oppositeDimension = dimensions[1];

        
        if (!info || !$DOM.contains(this.domNode, info.n, true, document.body)) {
            
            var node = srcNode.cloneNode(true);

            
            node.removeAttribute('id');
            node.removeAttribute('onclick');

            
            var nodeStyle = node.style;
            nodeStyle.position = 'absolute';                        
            nodeStyle.top = '-10000px';                             
            nodeStyle.maxHeight = nodeStyle.maxWidth = 'none';      
            nodeStyle[testDimension] = 'auto';                      

            
            srcNode.parentNode.appendChild(node);

            
            var max = parseInt(compStyle['max-' + testDimension], 10);

            
            if (isNaN(max)) {
                
                max = parseInt(compStyle[testDimension], 10);
            }

            
            info = ellCollection[key] = {
                n: node,                                            
                m: max,                                             
                d: testDimension.substr(0, 1)                       
            };

            
            this._ellTestNodes = ellCollection;

        } else {
            
            info.n.innerHTML = srcNode.innerHTML;

        }

        
        info.n.style[oppositeDimension] = compStyle[oppositeDimension];

        
        return info;
    }

    
    function addEllipsis(textArray, length) {
        var ellipsisText = this.ellipsisText;
        switch (this.ellipsisPosition) {
        case 'middle':
            
            var mid = $MTH.floor(length / 2);
            return textArray.slice(0, mid).join('') + ellipsisText + textArray.slice(-mid).join('');

        case 'end':
            
            return textArray.slice(0, length).join('') + ellipsisText;

        default:
            return textArray.join('');
        }
    }

    var COMPARE_THRESHOLD = 4;

    
    mstrmojo._SupportsEllipsisText = mstrmojo.provide(

        "mstrmojo._SupportsEllipsisText",

        
        {
            _mixinName: 'mstrmojo._SupportsEllipsisText',

            
            ellipsisText: '&hellip;',

            
            ellipsisPosition: 'end',

            
            ellipsize: function ellipsize(key, element, isMultiLine) {
                
                var text = element.innerHTML;
                if (!text) {
                    
                    return false;
                }

                
                var info = getCloneInfo.call(this, key, element, isMultiLine),
                    fnTestFit = function () {
                        var cloneDimension = $POS(info.n)[info.d];
                        return (cloneDimension <= info.m);
                    };

                
                if (fnTestFit()) {
                    
                    return false;
                }

                
                var node = info.n,
                    textArray = text.split(''),
                    low = 0,
                    high = textArray.length,
                    ellipsizedText,
                    x;

                
                while (low < high) {
                    
                    var mid = $MTH.floor((low + high) / 2);

                    
                    text = node.innerHTML = addEllipsis.call(this, textArray, mid);

                    
                    if (fnTestFit()) {
                        
                        low = mid + 1;
                    } else {
                        
                        high = mid - 1;
                    }

                    
                    if (high - low < COMPARE_THRESHOLD) {
                        
                        
                        for (x = low - 1; x < high + 1; x++) {
                            
                            text = node.innerHTML = addEllipsis.call(this, textArray, x);

                            
                            if (!fnTestFit()) {
                                
                                break;
                            }

                            
                            ellipsizedText = text;
                        }
                    }

                    
                    if (ellipsizedText) {
                        
                        element.innerHTML = ellipsizedText;
                        break;
                    }
                }

                return true;
            },

            
            unrender: function unrender(ignoreDom) {
                
                delete this._ellTestNodes;

                this._super(ignoreDom);
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.array",
        "mstrmojo.dom",
        "mstrmojo.css");
        
    var RENDERED = 1,
        CSS = 'mstrmojo-itemwrap',
        INNER = '&nbsp;',
        _A = mstrmojo.array;

    
    function _nd2iw(w, p, node){
        p = this.wrapperParentNode(p);
        if (p && node && p !== node) {
            var dn = w.domNode,
                pn = node.parentNode;
            while (pn) {
                if (pn === p) {
                    
                    return node;
                } else if (pn === dn) {
                    
                    break;
                }
                node = pn;
                pn = node.parentNode;
            }
        }
        return null;
    }

    
    function _iw2idx(w, p, node) {
        var len =  w.items && w.items.length,
            wns = this.wrapperNodes(p),
            idx = _A.findBin(wns, node, 'offsetTop', len);
        for (var i = idx; i < len; i ++) {
            if(wns[i].offsetHeight) {  
                return i;
            }
        }
        return -1;
    }
    
    function _pageSize (w) {
        
        if (!w.pageSize || w.pageSize <= 0) {
            
            var c = w.scrollboxNode;
            w.pageSize = c && c.clientHeight || 0;
        } 
        return w.pageSize;
    }
    
     function _initPages (w, me){
         if (w.usePaging) {
             
             w.totalPages = 1;
             var c = w.itemsContainerNode, 
                 ph = _pageSize(w);
             if (w.usePaging && c && ph) {
                 
                 
                 w.totalPages = Math.ceil((c.clientHeight - parseInt(c.style && c.style.paddingBottom || 0, 10)) / ph);
             } 
             
            
            
            
            if (c) {
    
    
    
    
                w.itemsContainerNode.style.paddingBottom = ph + 'px';
            }
         }
    }
    mstrmojo.ListMapper = mstrmojo.provide(
        "mstrmojo.ListMapper",
        
        {
            
            markupPrefix: '',
            
            markupSuffix: '',
            
            
            itemWrapperPrefix: function(w){
                return '<div class="' + this.getWrapperCss(w) + '">';
            }, 
            
            itemWrapperSuffix:  '</div>',
                
            itemWrapperPrefill: '&nbsp',
            
            wrapperNodes: function wrapperNodes(p){
                return p.childNodes;
            },
            
            wrapperParentNode: function wrapperParentNode(p){
                return p;
            },
        
            createWrapperNode: function createWrapperNode(p){
                var d = p.ownerDocument,
                    n = d.createElement('div');
                return n;
            },
            
            
            findScrollRange: function y2idx(p, count, top, h, left, w, offX, offY) {
                if (!count) {
                    return {start: 0, end: 0};
                }
                var ch = this.wrapperNodes(p),
                    idx = parseInt(count/2, 10),
                    loops = parseInt(Math.log(count)/Math.log(2),10),
                    start = 0,
                    end = count-1,
                    bot = top + h,
                    yFirst = ch[0].offsetTop,
                    y;
                for (var i=1; i<=loops; i++){
                    y = ch[idx].offsetTop - yFirst + offY;
                    if (y < top) {
                        start = idx;
                    } else if (y > bot){
                        end = idx;
                    }
                    
                    var inc = Math.round(count/Math.pow(2,i+1));
                    idx += (y > top) ? -inc: inc;
                    idx = Math.min(
                            Math.max(0, idx),
                            count-1);
                }
                return {start: start, end: end};        
            },

                        
            findWrapper: function fdwp(p, idx) {
                var ch = this.wrapperNodes(p);
                return ch && ch[idx];
            },
            
            
            findIndex: function nd2idx(w, p, node) {
                var iw = this._nd2iw(w, p, node);
                return iw ? this._iw2idx(w, p, iw) : -1;
            },
            
            
            itemOffsetTop: function iofft(w, p, idx, node){
                if (!node) {
                    var ch = this.wrapperNodes(p);
                    node = ch && ch[idx];
                    if (!node) {
                        return 0;
                    }
                }
                var f = p.firstChild;
                if (!f || (f === node)) {
                    return 0;
                } else {
                    return node.offsetTop - f.offsetTop;
                }
            },

            
            whereDrop: function whdp(w, p, node, pos, off){
                
                var iw = this._nd2iw(w, p, node),
                    idx, idxActual, t;
                if (iw) {
                    
                    idxActual = this._iw2idx(w, p, iw);
                    idx = idxActual;
                    
                    
                    
                    
                    t = this.itemOffsetTop(w, p, null, iw); 
                    
                    var h = iw.offsetHeight;
                    if (pos.y > off.top + t + h/2) {
                        
                        idx++;
                        t += h;
                    }               
                } else {
                    
                    
                    
                    

                        return w.dropCuePos;



                }
                return {left: 0, top: t, idx: idx, idxActual: idxActual};
            },
            getWrapperCss: function(w) {
                return CSS;
            },
            postBuildRendering: function(p, items, builder, w, ctxt) {
                _initPages(w, this);
            },
            
            buildItemWrappers: function biws(items, builder, w, ctxt, first, last) {
                var PRE = this.itemWrapperPrefix(w),
                    POST = this.itemWrapperSuffix,
                    S = PRE + this.itemWrapperPrefill + POST,  
                    out = [this.markupPrefix],
                    k = 1,
                    sel = w.selectedIndices || {},
                    fill = function fll(a,b){
                        for (var i=a; i<b; i++) {
                            out[k++] = PRE;
                            var s = builder.build(w, ctxt, items[i], i);
                            
                            
                            if (sel[i]) {
                                s = s.replace(/class\=\"([^\"]*)\"/, 'class="$1 selected"');
                            }
                            out[k++] = s;
                            out[k++] = POST;
                        }
                    };
        
                
                var len = (items && items.length) || 0;
                first = first && builder ? Math.min(first, len) : 0;
                if (first) {
                    fill(0, first);
                }
        
                
                last = last && builder ? Math.min(last, len-first) : 0;
                var stop = len-last;
                for (var j=first; j<stop; j++) {
                    out[k++] = S;
                }
                
                
                if (last) {
                    fill(stop, len);
                }
        
                out.push(this.markupSuffix);
                
                return out;
            },
            
            
            fillItemWrappers: function fi(p, items, builder, w, ctxt, start, end, max){
                var len = (items && items.length) || 0,
                    ns = this.wrapperNodes(p),
                    st = ctxt.itemStatus,
                    C = mstrmojo.css,
                    sel = w.selectedIndices || {};
            
                for (var i=start, stop=Math.min(end+1, len), k=0; i<stop; i++) {
                    if (st[i] !== RENDERED) {
                        ns[i].innerHTML = builder.build(w, ctxt, items[i], i);
                        
                        if (sel[i]) {
                            var el = ns[i].firstChild;
                            if (el) {
                                C.addClass(el, ['selected']);
                            }
                        }
                        k++;
                        if (k === max) {
                            break;
                        }
                    }
                }
                return k;
            },

            
            onadd: function oa(w, p, ctxt, evt){
                if (p && evt) {
                    
                    var c = evt.value.length,
                        ns = this.wrapperNodes(p),
                        bef = ns[evt.index],
                        css = this.getWrapperCss(w);

                    for (var i=0; i<c; i++){
                        var el = this.createWrapperNode(p);
                        el.className = css;
                        el.innerHTML = INNER;
                        if (bef) {
                            this.wrapperParentNode(p).insertBefore(el, bef);
                        } else {
                            this.wrapperParentNode(p).appendChild(el);
                        }
                    }
                    
                    
                    _initPages(w, this);
                }
            },
            
            onremove: function orm(w, p, ctxt, evt){
                if (p && evt) {
                    
                    var ns = this.wrapperNodes(p);
                    if (ns) {
                        var c = evt.value.length;
                        for (var i=evt.index+c-1, end=evt.index; i>=end; i--){
                            this.wrapperParentNode(p).removeChild(ns[i]);
                        }
                    }
                    
                    _initPages(w, this);
                }
            },
            
            onchange: function ocg(w, p, ctxt, evt){
                if (p && evt){
                    var ns = this.wrapperNodes(p);
                    if (ns) {
                        var C = mstrmojo.css,
                            st = ctxt.itemStatus,
                            idx;
                        for (var i=0, r = evt.removed, rlen = r&&r.length; i<rlen; i++) {
                            idx = r[i];
                            if (st[idx]) {
                                C.removeClass(ns[idx].firstChild, ["selected"]);
                            }
                        }
                        for (var j=0, a = evt.added, alen = a&&a.length; j<alen; j++) {
                            idx = a[j];
                            if (st[idx]) {
                                C.addClass(ns[idx].firstChild, ["selected"]);
                            }
                        }
                    }
                }
            },
            
            _nd2iw : _nd2iw,
            
            _iw2idx: _iw2idx,
            
            
            
            toPage: function(w, pg) {
                var scl = w.scrollboxNode;
                if (w.usePaging && scl) {
                    scl.scrollTop = pg * _pageSize(w);
                } else {
                    mstrmojo.alert("paging is not setup, can not perform paging.");
                }
            },
            
            whichPage: function(w){
                var scl = w.scrollboxNode,
                    ph = _pageSize(w);
                return Math.round((scl && ph && scl.scrollTop/ph) || 0); 
            },
            
            toItem: function (w, idx){
                var c = w && w.itemsContainerNode,
                    s = w.scrollboxNode,
                    off = this.itemOffsetTop(w, c, idx),
                    ih = this.wrapperNodes(c)[idx].clientHeight,
                    sh = s.clientHeight,
                    st = s.scrollTop,
                    to = st;
                
                if (off < st) { 
                    
                    to = off;
                } else if (st + sh - ih < off) { 
                    
                    to = Math.min(off, off - sh + ih); 
                }
                s.scrollTop = to;
            }

        });
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.css");

    var touchClass = 'tx-touch',
        HOLD_TIME = 100,
        previewMarkup = '<div class="mstrmojo-dicPreview dicx{@t} {@x}" ' +
                          'ontouchstart="mstrmojo.all[\'{@id}\'].previewTouchStart()";>' +
                             '<div>' +
                                 '<div>{@v}</div>' +
                             '</div>' +
                         '</div>';

    mstrmojo.android._HasPreviewButton = mstrmojo.provide(

        "mstrmojo.android._HasPreviewButton",

        {
            _mixinName: "mstrmojo.android._HasPreviewButton",

            renderPreview: function renderPreview() {
                
                var openerNode = this.openerNode,
                    group = this.group || this,
                    showFullPreview = (group.openerType === 2) || !!this.dic.dm || this.dicChanged;   

                this.renderPreviewButton(openerNode, showFullPreview ? this.dv : openerNode.innerHTML);
            },

            
            renderPreviewButton: function renderPreviewButton(target, value) {
                var dic = this.dic,
                    dicType = dic.t,
                    group = this.group || this,
                    showPreview = false,                    
                    showArrow = true,                       
                    $TYPES = mstrmojo.DICConfig.TYPES,
                    cls = [];


                
                switch (dicType) {
                case $TYPES.SLIDER:
                case $TYPES.TEXTAREA:
                    
                    showArrow = !dic.dm;
                    break;

                case $TYPES.SWITCH:
                case $TYPES.TOGGLE:
                case $TYPES.RATING:
                case $TYPES.STEPPER:
                case $TYPES.LIKERTSCALE:
                    
                    showArrow = false;
                    break;
                }

                
                if (group.openerType === 2) {
                    
                    showPreview = showArrow;
                }

                
                if (showArrow) {
                    
                    var targetStyle = target.style;
                    targetStyle.border = '';
                    targetStyle.padding = '';

                    
                    cls.push('arw');

                    
                    if (showPreview) {
                        
                        cls.push('prv');
                    }
                }

                var id = this.id;
                
                target.innerHTML = mstrmojo.string.apply(previewMarkup, {
                    t: dicType,
                    v: value || '&nbsp;',                   
                    id: id,
                    x: cls.join(' ')
                });

                
                this._previewNode = target.firstChild;
                
                
                if(this.inlineExtraCssText) {
                    this._previewNode.style.cssText += ' ' + this.inlineExtraCssText;
                }
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                var previewNode = this._previewNode,
                    childNode = previewNode && previewNode.firstChild;

                
                mstrmojo.css.addClass(childNode || d, 'tx-active');
            },

            previewTouchStart: function previewTouchStart() {
                var me = this;
                mstrmojo.css.addClass(me._previewNode, touchClass);
                if (this._holderTimer) {
                    clearTimeout(this._holderTimer);
                }
                this._holdTimer = setTimeout(function() {
                    delete me._holdTimer;
                    mstrmojo.css.removeClass(me._previewNode, touchClass);
                }, HOLD_TIME);
            }
        }
    );

}());
(function(){
    
    mstrmojo.requiresCls(
    "mstrmojo.ListMapper");
    
    var RENDERED = 1,
        CSS = 'mstrmojo-itemwrap';
    
    mstrmojo.ListMapperHoriz = mstrmojo.provide(
        "mstrmojo.ListMapperHoriz",
        
        mstrmojo.hash.copy(
        
        {
            markupPrefix: '<table class="mstrmojo-itemwrap-table" cellspacing="0" cellpadding="0"><tbody><tr>',
            
            markupSuffix: '</tr></tbody></table>',
            
            itemWrapperPrefix: function(w){
                return '<td class="' + this.getWrapperCss(w) + '">';
            }, 
            
            getWrapperCss: function(w) {
                return "mstrmojo-itemwrap-td";
            },
            
            itemWrapperPrefill: '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;',
            
            itemWrapperSuffix:  '</td>',
            
            wrapperNodes: function wrapperNodes(p){
                return this.wrapperParentNode(p).cells;
            },
            
            wrapperParentNode: function wrapperParentNode(p){
                return p.firstChild.rows[0];
            },
        
            createWrapperNode: function createWrapperNode(p){
                var d = p.ownerDocument,
                    n = d.createElement('td');
                return n;
            },
            
            
            findScrollRange: function y2idx(p, count, top, h, left, w, offX, offY) {
                var ch = this.wrapperNodes(p),
                    idx = parseInt(count/2, 10),
                    loops = parseInt(Math.log(count)/Math.log(2),10),
                    start = 0,
                    end = count-1,
                    r = left + w,
                    xFirst = ch[0].offsetLeft,
                    x;
                for (var i=1; i<=loops; i++){
                    x = ch[idx].offsetLeft - xFirst + offX;
                    if (x <= left) {
                        start = idx;
                    } else if (x >= r){
                        end = idx;
                    }
                    
                    var inc = Math.round(count/Math.pow(2,i+1));
                    idx += (x > left) ? -inc: inc;
                    idx = Math.min(
                            Math.max(0, idx),
                            count-1);
                }
                return {start: start, end: end};        
            },

            
            findIndex: function nd2idx(w, p, node) {
                if (p && node) {
                    var dn = w.domNode,
                        tr = this.wrapperParentNode(p),
                        pn = node.parentNode;
                    while (pn) {
                        if (pn === tr) {
                            
                            return mstrmojo.array.findBin(this.wrapperNodes(p), node, 'offsetLeft', w.items && w.items.length);
                        } else if (pn === dn) {
                            
                            break;
                        }
                        node = pn;
                        pn = node.parentNode;
                    }
                }
                return -1;
            }
        },mstrmojo.hash.copy(mstrmojo.ListMapper)));

})();
(function () {

    mstrmojo.requiresCls("mstrmojo._IsList",
                         "mstrmojo.dom");

    
    var isList = mstrmojo.android._IsList = mstrmojo.provide(
        "mstrmojo.android._IsList",

        mstrmojo.hash.copy(mstrmojo._IsList, {
            _mixinName: 'mstrmojo.android._IsList',

            
            getItemIdxTouch: function getItemIdxTouch(touch) {
                
                var item = mstrmojo.dom.findAncestorByAttr(touch.target, 'idx', true, this.domNode),
                    idx = item && parseInt(item.value, 10);

                return (idx !== null && !isNaN(idx)) ? idx : -1;
            },

            
            resetListState: function resetListState() {
                
                this.clearSelect(true);

                
                var scrollerConfig = this.scrollerConfig;
                if (scrollerConfig) {
                    
                    delete this.scrollerConfig.origin;
                }
            },

            
            restoreListState: function restoreListState(idx, origin) {
                
                var indices = {};
                indices[idx] = true;

                this.selectedIndices = indices;
                this.selectedIndex = idx;

                
                var scrollerConfig = this.scrollerConfig;
                if (scrollerConfig) {
                    
                    scrollerConfig.origin = origin;
                }
            },

            
            touchSelectEnd: function touchSelectEnd(touch) {
                
                this.touchTap(touch);
            }
        })
    );

    
    var fnClick = isList.onclick;
    isList.onclick = mstrmojo.emptyFn;

    
    isList.touchTap = function (touch) {
        
        this._listTarget = touch.target;

        
        fnClick.call(this, touch);
    };

}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.locales", "mstrmojo.expr", "mstrmojo.date","mstrmojo.num", "mstrmojo.string");
    
    mstrmojo.validation = {
            STATUSCODE: {
                    UNKNOWN: -1,
                    VALID : 0,
                    INVALID: 1,
                    INVALID_EMPTY: 2,
                    INVALID_CHAR: 3,
                    INVALID_OUTOFRANGE:4,
                    INVALID_REGEX:5,
                    INVALID_VALIDATOR:6,
                    INVALID_BAD_NUMERICFORMAT:7,
                    INVALID_BAD_DATESTRING:8            
            },        
            TRIGGER:{
                    NONE: 0,
                    ONBLUR: 1,
                    ONKEYUP: 2,
                    VALUESET: 4,
                    ALL: 7        
            },            
            REGEXP:{
                    US_ZIP: /^\d{5}([- ]?\d{4})?$/, 
                    EMAIL_ADDRESS: /^([a-zA-Z0-9\_\.\-])+@(([a-zA-Z0-9\-])+[\.])+([a-zA-Z0-9]{2,4})+$/,
                    SOCIAL_SECURITY_NUMBER: /^((?!000)(?!666)\d{3})(\s|\-)?((?!00)\d{2})\2((?!0000)\d{4})$/,
                    PHONE_NUMBER: /^(?!-)[ \d\-\(\)\.\+]+$/,
                    FILE_NAME:new RegExp("^[^:*?\"<>|/\\\\()]+$"),
                    FOLDER_PATH_WIN:new RegExp("^([a-zA-Z]:|\\\\\\\\[^:*?\"<>|/\\\\]+|[^:*?\"<>|/\\\\]*)(\\\\[^:*?\"<>|/\\\\]+)*(\\\\){0,1}$"),        
                    FOLDER_PATH_UNIX:new RegExp("^(/){0,1}([^:*?\"<>|/\\\\]+/)*([^:*?\"<>|/\\\\]+){0,1}$"),
                    PRINTER_PATH_SINGLE: new RegExp("^[^$%:*?\"<>|/\\\\]*$"),
                    PRINTER_PATH_MULTIPLE:new RegExp("^((/|\\\\\\\\)[^$%:*?\"<>|/\\\\]+)((/|\\\\)[^$%:*?\"<>|/\\\\]+)*(/|\\\\){0,1}$")
            },
            VALIDATOR:{
                    DEMO:function customValidator(v){
                           var parsed = parseInt(v,10),
                               SC = mstrmojo.validation.STATUSCODE;
                           if(parsed === 0 || parsed === 1 || parsed > 10) {
                               return {code:SC.VALID};
                           }
                           
                           return {code:SC.INVALID, msg:'This field must be either 0, 1 or greater than 10'};
                    },
                    VALIDATE_PHONENO: function validatePhoneNo(v){
                        var dt = this.dtp, 
                            phoneNo = String(v).replace(/[^\d]/g, '');
                        
                        
                        if (phoneNo.length < 10){
                            return {code:_SC.INVALID, msg: mstrmojo.desc(9203)}; 
                        }
                        
                        if (!_V.REGEXP.PHONE_NUMBER.test(v)){
                            return {code:_SC.INVALID, msg: mstrmojo.desc(9204)}; 
                        }
                        return {code:_SC.VALID};
                    },
                    VALIDATE_ZIPCODE: function validateZipCode(v){
                        var msg = '', dt = this.dtp;
                        if (!_V.REGEXP.US_ZIP.test(v)){
                            if (_V.isNumeric(dt) || _V.isInt(dt))
                                msg = mstrmojo.desc(9208); 
                            else if (_V.isString(dt)){
                                msg = mstrmojo.desc(9206); 
                            }
                            return {code:_SC.INVALID, msg: msg};
                        }
                        return {code:_SC.VALID};
                    },
                    VALIDATE_EMAIL: function validateEmail(v){
                        var atSignIdx = v.indexOf('@');
                        
                        if (atSignIdx === -1){
                            return {code: _SC.INVALID, msg: mstrmojo.desc(9197)}; 
                        }
                        
                        if (v.substring(atSignIdx).indexOf('.') === -1){
                            return {code: _SC.INVALID, msg: mstrmojo.desc(9198)}; 
                        }
                        
                        return _V.REGEXP.EMAIL_ADDRESS.test(v) ? {code:_SC.VALID} : {code:_SC.INVALID, msg:mstrmojo.desc(9207)}; 
                    },
                    VALIDATE_SSN: function validateSSN(v){
                        var dt = this.dtp, ssnNo;
                        if (_V.isNumeric(dt) || _V.isInt(dt)){
                            ssnNo = String(v).replace(/[^\d]/g, '');
                            if (ssnNo.length != 9){
                                return {code:_SC.INVALID, msg: mstrmojo.desc(9209)}; 
                            }
                        }
                        if (!_V.REGEXP.SOCIAL_SECURITY_NUMBER.test(v)){
                            return {code:_SC.INVALID, msg: mstrmojo.desc(9210)}; 
                        }
                        return {code:_SC.VALID};
                    }
            },
            isInt: function(dtp){
                return DTP2TYPE[dtp] == 1;
            },
            isNumeric: function(dtp){
                return DTP2TYPE[dtp] == 2 || DTP2TYPE[dtp] == 5;
            },
            isString: function(dtp){
                return DTP2TYPE[dtp] == 3;
            }            
    };

    
    var _G = window.mstrConfig,
    listSep = _G.listSep,
    _E = mstrmojo.expr,
    DTP = _E.DTP,
    _V = mstrmojo.validation,
    _TR = _V.TRIGGER,
    _SC = _V.STATUSCODE,    
    _C = mstrmojo.css,
    _N = mstrmojo.num,
    _S = mstrmojo.string, 
    _DP = mstrmojo.date,
    DTP2TYPE = {
        '-1':-1,
        1:1,
        2:1,
        3:2,
        4:2,
        5:2,
        6:2,
        7:2,
        8:3,
        9:3,
        10:3,
        11:4,
        12:4,
        13:4,
        14:6,
        15:6,
        16:6,
        21:2,
        22:2,
        23:3,
        24:4,
        25:3,
        30:5
    };
   
    
    
    function _containsInvalidChar(me, v){
        var dtp = me.dtp,
            c = me.constraints,
            allows = c.allowedFormatChars ? c.allowedFormatChars : '',
            isInt = (DTP2TYPE[dtp] == 1),                        
            isNumeric = (DTP2TYPE[dtp] == 2),                        
            isDT = (DTP2TYPE[dtp] == 6),
            thousand = mstrmojo.locales.number.THOUSANDSEPARATOR,
            decimal = mstrmojo.locales.number.DECIMALSEPARATOR,
            regExp;
                          
        if(isInt){
            if(!me._intRegExp){
                allows += '0-9-' + (me.isList ? listSep : '') + thousand;
                me._intRegExp = new RegExp('[^' + allows + ']');
            }
            regExp = me._intRegExp;
        }
        
        if(isNumeric){
            if(!me._numericRegExp){
                allows += '0-9-' + (me.isList ? listSep : '') + decimal + thousand;
                me._numericRegExp = new RegExp('[^' + allows + ']');
            }
            regExp = me._numericRegExp;                      
        }
            
        if(isDT){
            
        }
        
        return !!regExp && regExp.test(v);
    }
    
    
    function _valueOutOfRange(me, v){
        var dtp = me.dtp,
        c = me.constraints,
        isInt = (DTP2TYPE[dtp] == 1),                        
        isNumeric = (DTP2TYPE[dtp] == 2),                        
        isDT = (DTP2TYPE[dtp] == 6),
        min = c.min,
        max = c.max,
        parsed;
        
        
        if(min == undefined && max == undefined) {
            return false;
        }
        
        
        if(isInt || isNumeric){
            return _N.inNumericRange(v, min, max) !== 0;
        }
        
        
        if(isDT){
            return _DP.inDateTimeRange(v, min, max) !== 0;
        }
            
        return false;                        
    }
    
    
    function _badNumericFormat(me, v){                 
        return !_N.isNumeric(v) ;
    }

    
    function _badDTString(me, v){
        var isD = (me.dtp === DTP.DATE),
            isT = (me.dtp === DTP.TIME);
        return (isD ? !_DP.isDate(v) : (isT ? !_DP.isTime(v) :!_DP.isDateAndOrTime(v)));
    }
    
    
    mstrmojo._CanValidate = mstrmojo.provide(
            "mstrmojo._CanValidate",
            {
                
                constraints:null,
                
                
                required:false,
                
                
                dtp: DTP.INTEGER,
                
                
                isList: false,
                
                
                autoFormat: false,
                
                
                
                
                
                
                
                validationStatus:null,
                
                init: function init(props){
                    this._super(props);
                    if(!this.constraints) {
                        this.constraints = {};
                    }
                    var c = this.constraints;                    
                    if(!('trigger' in c)) {
                        c.trigger = _TR.NONE;    
                    }
                },
                
             
                
                
                _set_value: function(n,v){
                    var vWas = this.value,
                        bChanged = (vWas !== v);
                    if(bChanged){
                        this.value = v;
                        var t = this.constraints.trigger,
                            cv = (t & _TR.VALUESET) > 0;
                        if(cv) {
                            this.validate(v);
                        }
                    }
                    return bChanged;
                },

                
                
                
                   
                               
                
                
                validate: function validate(){
                    
                    var v = (this.value !== null && this.value !== undefined)? this.value : '',
                        vl = this.isList ? v.split(listSep) : [v],
                        r, isInvalid, method;
                    
                    for(var i=0, len = vl.length;i<len;i++){
                        r = this.doValidation(vl[i]);
                        isInvalid = (r.code > _SC.VALID);
                        if(isInvalid) {
                            if(len>1){
                                r.msg = mstrmojo.locales.validation.invalidValueInListError.replace("#", vl[i] ? vl[i] : ' ');
                            }
                            break;
                        }
                    }
                    
                    method = isInvalid ? 'onInvalid' : 'onValid';
                    
                    if(!isInvalid && this.autoFormat) {
                        this.format();
                    }
                    
                    
                    this.set('validationStatus',r);
                    
                    
                    if (this[method]) {
                        this[method](r);
                    }
                },
                
                
                format: function format(){
                    var dtp = this.dtp,
                        isDT = (DTP2TYPE[dtp] == 6);
                    if(!isDT) return;
                    
                    var listSep = mstrConfig.listSep,
                        v = this.value || '',
                        vl = this.isList ? v.split(listSep) : [v],                                   
                        isD = dtp === 14,
                        va=[], 
                        dt,
                        _DT = mstrmojo.locales.datetime;
                        
                    for(var i =0,len=vl.length;i<len;i++){
                        v = vl[i];
                        dt = _DP.parseDateAndOrTime(v);
                        if(dt){
                            if(isD && dt.date){
                                va.push(_DP.formatDateInfo(dt.date, _DT.DATEOUTPUTFORMAT));
                            } else {
                                va.push((dt.date ? _DP.formatDateInfo(dt.date, _DT.DATEOUTPUTFORMAT):'') + ' ' +
                                        (dt.time ? _DP.formatTimeInfo(dt.time, _DT.TIMEOUTPUTFORMAT) : ''));
                            }
                        }
                    }
                    this.set('value', va.join(listSep));
                },
                
                
                isValid: function isValid(){
                    var s = this.validationStatus;
                    if(!s) this.validate();
                    return this.validationStatus.code === _SC.VALID;
                },
                
                
                clearValidation: function clearValidation(){
                    this.set('validationStatus', {code:_SC.VALID});
                    if(this.onClearValidation) {
                        this.onClearValidation();  
                    }                    
                },
                
                
                doValidation: function doValidation(v){
                    var c = this.constraints,
                        regExp = c.regExp,
                        validator = c.validator, 
                        r = {id: this.id,code:_SC.VALID,msg:''},
                        dtp = this.dtp,
                        isInt = (DTP2TYPE[dtp] == 1),
                        isNumeric = (DTP2TYPE[dtp] == 2 || DTP2TYPE[dtp] == 5),
                        isString = (DTP2TYPE[dtp] == 3),
                        isDT = (DTP2TYPE[dtp] == 6),
                        isEmpty = _S.isEmpty(v),
                        vLen = String(v).length;
                        err = '',
                        _VAL = mstrmojo.locales.validation;
                    
                    
                    if(this.required && isEmpty) {
                        r.code = _SC.INVALID_EMPTY;
                        r.msg = _VAL.requiredFieldError;
                        return r;
                    }
                    
                    v = _S.trim(v);
                    
                    
                    if(!isEmpty && _containsInvalidChar(this,v)){
                        if(isInt) {
                            err = _VAL.integerDataType;
                        }
                        if(isNumeric) {
                            err = _VAL.numericDataType;
                        }
                        if(isDT) {
                            err = _VAL.dateDataType;
                        }
                        r.code = _SC.INVALID_CHAR;
                        r.msg = _VAL.invalidCharError.replace('#',err);
                        return r;
                    }
                    
                    
                    if(!isEmpty && isDT && _badDTString(this,v)){
                        r.code = _SC.INVALID_BAD_DATESTRING;
                        r.msg = _VAL.invalidDateStringError;
                        return r;
                    }
                    
                    
                    if(!isEmpty && (isNumeric || isInt) && _badNumericFormat(this,v)){
                        r.code = _SC.INVALID_BAD_NUMERICFORMAT;
                        r.msg = _VAL.invalidNumericFormatError; 
                        return r;
                    }
                    
                    
                    if(!isEmpty && (isInt || isNumeric || isDT) && _valueOutOfRange(this,v)){
                        r.code = _SC.INVALID_OUTOFRANGE;
                        if(c.min != null && c.max != null){
                            err = _VAL.outofRangeError.replace('#', '').replace('##', c.min).replace('###', c.max);
                        } else if(c.min != null){
                            err = _VAL.noLessMinError.replace('##', c.min).replace('#', '');  
                        } else if(c.max != null){
                            err = _VAL.noGreaterMaxError.replace('###', c.max).replace('#', ''); 
                        }
                        r.msg = err;
                        return r;
                    }
                    
                    
                    if (isString && c.minLen != null && c.maxLen != null){
                        if (vLen < c.minLen || vLen > c.maxLen){
                            r.code = _SC.INVALID;
                            r.msg = mstrmojo.desc(9211).replace(/#/, c.minLen).replace(/##/, c.maxLen);
                            return r;
                        }
                    }
                    
                    
                    if(regExp && !regExp.test(v)){
                        r.code = _SC.INVALID_REGEX;
                        r.msg = mstrmojo.desc(9205); 
                        return r;
                    }
                    
                    
                    var _t = validator && validator.apply(this,[v]);
                    
                    if(_t){
                        r.code = _t.code;
                        r.msg = _t.msg;
                        return r;
                    }
                    
                    
                    
                    return r;
                    
                }
                

            });
    
})();
(function() {
    mstrmojo.requiresCls("mstrmojo.hash",
            "mstrmojo.date",
            "mstrmojo.string");

    var $H = mstrmojo.hash,
        $S = mstrmojo.string,
        CLEARING_DIV_MKP = '<div class="clearingDiv"></div>',
        START_DIV = '<div {@attr}>',
        END_DIV = '</div>';
    
    
    function createAttrString(attr) {
        var str = [],
            len = -1;
        
        $H.forEach(attr, function (v, k) {
            str[++len] = k + '="' + v + '"';
        });
        
        return str.join(' ');
    }
    
    
    mstrmojo.android.ui.CalendarMarkupBuilder = {
        
        getHeaderHTML: mstrmojo.emptyFn,
        
        
        getContentHTML: mstrmojo.emptyFn,

        
        getSingleMonthHelper: function getSingleMonthHelper(month, year, config) {
            var html = [],
                len = -1,
                $MKP = config.mkp || (START_DIV + '{@d}' + END_DIV),
                startDate = new Date(year, month),
                curMonth = -1,
                includeAdjacentMonths = config.incl,
                showAddlWeek = config.showAddlWeek,
                week = 0;

            
            startDate.setDate(1 - startDate.getDay());
            
            
            curMonth = startDate.getMonth() - month;

            while (!((curMonth === 1 || curMonth === -11) && startDate.getDay() === 0) || (showAddlWeek && week < 6)) {
                
                var date = startDate.getDate(),
                    curItemProps = (includeAdjacentMonths || curMonth === 0) ? {
                        d: date,
                        attr: createAttrString({
                            d: date
                        })
                    } : {};
                    
                
                
                if (curItemProps.attr && config.cls) {
                    curItemProps.attr["class"] = config.cls;
                }

                
                html[++len] = $S.apply($MKP, curItemProps);
                
                
                startDate.setDate(date + 1);
                
                
                curMonth = startDate.getMonth() - month;
                
                
                if (startDate.getDay() === 0) {
                    week++;
                }
            }

            html[++len] = CLEARING_DIV_MKP;
            
            return html.join('');
        }
    };
}());
(function(){
	mstrmojo.requiresCls("mstrmojo.num","mstrmojo.VisChartUtils");

	
	var percent = 0;
	
	var $NUM = mstrmojo.num;
	
	var NumUnits = [{n:1, s:""}, {n:1000, s:"K"}, {n:1000000, s:"M"}, {n:1000000000, s:"B"}, {n:1000000000000, s:"T"}, {n:1000000000000000, s:"Q"}];
	var DEFAULT_LEN_LIMIT = 3;
	var MAX_LEN_LIMIT = 5;
	
	function normalizeValue(val, interval, isFloor) {

		var ceilOrFloor = function(val, isFloor) {
			return isFloor ? Math.floor(val) : Math.ceil(val); 
		};
		
		var lab = ceilOrFloor(val/interval, isFloor) * interval;

		if(lab.toString().indexOf(".") >= 0 && interval < 1 && lab > 1) {
			lab = parseFloat(lab.toFixed(2));
		}

		if(lab > 0 && lab < 1 && interval > 1 / 1000) {
			lab = parseInt(ceilOrFloor(lab * 100, isFloor)) / 100;
		}
		return lab;
	}
	
	function updateSeriesRawValues(s, ds) {
		if(!ds) {
			ds = ','; 
		}
		var sl = s.length;
		for(var i = 0; i < sl; i++) {
			var rvs = s[i].rv,
				l = rvs.length;
			for(var j = 0; j < l; j++) {
				if(Number(rvs[j])) {
					break; 
				}
				rvs[j] = rvs[j].replace(ds,'.');
			}
		}
	}
	
	mstrmojo.VisChartData = mstrmojo.provide(
			"mstrmojo.VisChartData",
			
			{
				
				process: function prcss(w) {
	
					if((!w.baseModel && w.model) || w.model.vp) {
						this.setDerivedModel(w);
						
						var bm = w.baseModel,
							ch = bm.colHeaders,
							chl = ch.length,
							ds = ch[chl -1].items[0].ds;
						if(ds && ds !== '.') {
							updateSeriesRawValues(bm.series, ds);
						} else if(!ds) {
							updateSeriesRawValues(bm.series);
						}
					}
	
					
					
					var	model = w.model;
					var	values = model.series,
					l = values.length;
					
					if (l <= 0) {
						return;
					}
	
					
					var nlc = !w.isLinearChart && w.isDrawAxis && w.drawYAxisLabels,
						ms = "";
	
					percent = 0;
					
					
					var v = new Array(); 
					if (values && values[0] && values[0].rv.length) {
						for(var j = 0; j < l; j++) {
							var s = values[j].rv,
								sl = s.length,
								k = v.length;	
							for(var i = 0; i < sl; i++ ) {
								var val = s[i];
								
								if(!val || val.length == 0) {
									continue;
								}
								
								if(percent === 0) {
									
									percent = values[j].v[i].indexOf('%')  >= 0 ? 100 : 1;
								}
								
								v[k] = parseFloat(val);
								if(nlc && v[k].toString().length > ms.length) {
									ms = v[k].toString();
								}
								k++;
							}
						}
						v = v.sort(function sortArray(a,b){return a - b;});
					}
					model.mvalues = v;
					if(nlc) {
						
						model.mls = ms;
						model.ylbls = v;
					}
				},
	
				setDerivedModel: function sdm(w) {
					var m = w.model,
						s = m.series,
						sl = s.length,
						ri = m.ri,
						rows = m.rowHeaders,
						cols = m.colHeaders; 
					
					var rl = typeof(m.vp) !== 'undefined' && m.vp.rl && m.vp.rl.length > 0 ? m.vp.rl : null;
					
					w.baseModel = m;
					
					
					
					var rne = s[0].rv.length,
						rns = 0;
					if(rl && w.isTimeSeries) {
						var rs = parseInt(rl[0].rs),
						 	sr = rl[0].sr;
						for(var i = 0; i < rows.length; i++) {
							
							if(rows[i].id == sr) {
								rns = rne - (rows[i].l * rs) >= 0 ? rne - (rows[i].l * rs) : 0;
								break;
							}
						}
					}
					w.model = { categories:m.categories, mtrcs:m.mtrcs, series:s, colHeaders:cols, rowHeaders:rows, rne:rne, rns:rns, ri:ri};
					
				},
				
				processLinearData: function pld(w) {
					this.process(w);
					var model = w.model;
					var vals = model.mvalues,
					_max = w.getMaxValue(),
					_min = w.getMinValue();
					
					var _lbs = this.generateAxisLabels(w, _max, _min);
					model.mvalues = _lbs;
					
	
					var da = w.isDrawAxis && w.drawYAxisLabels;
					
					var useAbbr = w.isTimeSeries ? w.formatProp.condenseLabels : true;
					
					if(da) {
						var res = this.condenseLabels(_lbs, DEFAULT_LEN_LIMIT);
						if(useAbbr){
							var duplicatedCondensed = this.checkDuplicatedCondensed(res.condensedLabels);
							if(duplicatedCondensed){
								for (i=DEFAULT_LEN_LIMIT+1; i<MAX_LEN_LIMIT; ++i) {
									res = this.condenseLabels(_lbs, i);
									duplicatedCondensed = this.checkDuplicatedCondensed(res.condensedLabels);
									if (!duplicatedCondensed) {
										break;
									}
								}
								
								
								if (duplicatedCondensed) {
									useAbbr = false;
								}
							}
							model.mls = res.maxLabel;
							model.ylbls = res.condensedLabels;
						}
						
						if(!useAbbr){						
							var formatedStr = [];
							var ms = "";
							
							var items = model.colHeaders[model.colHeaders.length - 1].items;
							var formatMask = items && items[0] && items[0].f || "";
							
							for(var i = 0; i < _lbs.length; i++){
								formatedStr[i] = $NUM.formatByMask(formatMask, _lbs[i]);
								
								if(formatedStr[i].toString().length > ms.length) {
									ms = formatedStr[i].toString();
								}
							}
							
							model.mls = ms;
							model.ylbls = formatedStr;
						}
											
						
					}
	
				},
				
				checkDuplicatedCondensed: function checkDuplicatedCondensed(lbls){
					var duplicatedCondensed = false;
					for (var i=1; i<lbls.length; i++) {
						if (lbls[i] == lbls[i-1]) {
							duplicatedCondensed = true;
							break;
						}
					}
					
					return duplicatedCondensed;
				},
				
				condenseLabels: function condenseLabels(lbls, lenLimit){
					var ll = lbls.length;
					var ms = "";
					var _lbstr = new Array();					
					
					for(var i = 0; i < ll; i++) {
						
						
						_lbstr[i] = this.formatNumber(lbls[i], lenLimit);
						
						if(_lbstr[i].toString().length > ms.length) {
							ms = _lbstr[i].toString();
						}
					}
					
					return {condensedLabels:_lbstr, maxLabel:ms};
				},
				
				generateAxisLabels: function generateAxisLabels(w, _max, _min, intAsStep){
					var _lbs = new Array();
					
					if(_max == _min){
						if( _min < 0){
							_lbs.push(_min);
						}
						_lbs.push(0);
						if(_min > 0){
							_lbs.push(_min);
						}
						
						return _lbs;
					}
					
					var interval = this.calInterval(_max, _min, intAsStep);
									
					
					if(w.isTimeSeries && w.formatProp.useCustomAxisScale){
						var labelMax = _max;					
						var labelMin = _min;
					}else{
						var labelMax = normalizeValue(_max, interval, false);					
						var labelMin = normalizeValue(_min, interval, true);
						
					}
					
					
					if((_min - labelMin) > 0.9*interval){
						labelMin =  normalizeValue(_min, interval, false);
					}
					
					if((labelMax - _max) > 0.9*interval){
						labelMax =  normalizeValue(_max, interval, true);
					}
					_lbs = new Array();
					
					
	
	
	
	
	
					
					if( interval < ((labelMax - labelMin) / 30)){
						
						_lbs.push(labelMin);
						_lbs.push(labelMax);
					}else{
						var currentValue = labelMin;
						
						while(currentValue <= labelMax){
							_lbs.push(currentValue);
							if(currentValue == labelMin){
								currentValue  = Math.ceil((labelMin + interval/100)/interval)*interval;
							}else{
								currentValue = Math.ceil((currentValue + interval) * 1000) / 1000; 
							}
						}
						if(_lbs[_lbs.length - 1] < labelMax){
							_lbs.push(labelMax);
						}
					}
					
					return _lbs;
				},
				
				formatNumber: function formatNumber(number, lenLimit){
					var os = "",
						on = 1,
						posNum = number  * percent;
					if(posNum < 0){
						posNum = -number * percent;
						on = -1;
						os = "-";
					}
					
					if(posNum <= 1+1e-6){
						
						on *= posNum;
						if (posNum.toString().length <= lenLimit) {
							os += posNum;
						}
						else {
							var precision = 2;
							os += posNum.toFixed(precision);
							
							
							for (var i=os.length-1; i>=0; --i) {
								if (os.charAt(i) == '.') {
									break;
								}
								else if (os.charAt(i) != '0') {
									++i
									break;
								}
							}
							if (i < os.length) {
								os = os.substr(0, i);
							}
						}
					}else{
						
						var power = Math.log(posNum)/Math.LN10 + 1e-6;
						var n = parseInt(power / 3);					
						
						if (n >= NumUnits.length) {
							n = NumUnits.length - 1;
						}
						var fNum = posNum / NumUnits[n].n;
						var sNum = fNum.toString();
						
						if (sNum.length > lenLimit) {
							var separatorIdx = sNum.indexOf('.');
							var fracLen = separatorIdx < 0 ? 0 : sNum.length - separatorIdx + 1,
								intLen = separatorIdx < 0 ? sNum.length : separatorIdx;
							var nPrecision = lenLimit - intLen - 1;
							

							
							
							sNum = fNum.toFixed(nPrecision < 0 ? 0 : nPrecision);
							
						}
						on *= parseFloat(sNum) * NumUnits[n].n;
						os += sNum + NumUnits[n].s;
					}
					
					return os;				
				},
	
				calInterval: function cInt(_max, _min, intAsStep) {
					var interval,	
						diff = (_max - _min);
					if(diff == 0) {
						if(_max == 0) {
							_max = 1;
							_min = -1;
						} else {
							_max = _max * 2;
							_min = _min / 2;
						}
						diff = _max - _min;
					}
					
					interval = 1;
					if(diff < 1){
						while(diff < 1){
							diff *= 10;
							interval /= 10;
						}
					} else if(diff >= 10){
						while(diff >= 10){
							diff /= 10;
							interval *= 10;
						}
					}
	
					if(diff < 1.8){
						interval *= 0.2;
					} else if(diff < 3.1){
						interval *= 0.4;
					} else if(diff < 4.6){
						interval *= 0.5;
					} else if(diff >= 8.1){
						interval *= 2;
					}
	
					if(intAsStep){
						interval = Math.round(interval);
						if(interval < 1){
							interval = 1;
						}
					}else if((interval > 0 && interval < 1) && (parseInt(interval.toFixed(2) * 100) / 100) > 0) {
						interval = parseInt(interval.toFixed(2) * 100) / 100;
					}
					
					return interval;
				}
			});

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.num",
                         "mstrmojo.array",
                         "mstrmojo.DICFactory");

    var INPUT_VALUES_MANUAL = 1,
        POPUP_INLINE = 0,
        POPUP_ABOVE = 1,
        POPUP_BELOW = 2,
        decimal = '.',
        $D = mstrmojo.dom,
        $C = mstrmojo.css,
        $H = mstrmojo.hash,
        TAB_KEY = mstrmojo.Enum_Keys.TAB,

        isNumType = function (dt) {
            return (dt >= 1 && dt <= 7) || dt == 21 || dt == 22 || dt == 30;
        },

        
        convertEmtoPx = function (dom, v) {
            if ($D.isIE && !/px$/.test(v)) {
                var img = document.createElement('img'), pl;
                img.style.zIndex = -1;
                img.style.left = v;

                dom.appendChild(img);

                
                pl = img.style.pixelLeft;
                dom.removeChild(img);

                return pl + 'px';
            }
            return v;
        },

        _getScaleStyle = function (dom, n) {
            return parseInt(convertEmtoPx(dom, $C.getStyleValue(dom, n)), 10) || 0;
        },

        getPadding = function (dom) {
            return {
                lp: _getScaleStyle(dom, 'paddingLeft'),
                rp: _getScaleStyle(dom, 'paddingRight'),
                tp: _getScaleStyle(dom, 'paddingTop'),
                bp: _getScaleStyle(dom, 'paddingBottom')
            };
        },

        
        getFontStyle = function (dom) {
            var s = dom.currentStyle;
            if (!s) {
                s =  document.defaultView.getComputedStyle(dom, null);
            }
            return {
                fontFamily: s.fontFamily,
                fontSize: convertEmtoPx(dom, s.fontSize),
                fontStyle: s.fontStyle,
                fontVariant: s.fontVariant,
                fontWeight: s.fontWeight,
                textAlign: s.textAlign
            };
        },
        
        lockInfoWindow = function (widget, isLock) {
            var infowindow = mstrmojo.findAncestor(widget, 'scriptClass', 'mstrmojo.DocInfoWindow');
            if (!!infowindow) {
                infowindow.autoCloseLocked = isLock;
            }
        };

    mstrmojo._IsInputControl = {

        _mixinName: '_IsInputControl',

        
        dic: null,

        
        owner: null,

        
        openerNode: null,

        
        popupStyle: POPUP_INLINE,

        
        items: null,

        
        applyOnEnter: true,

        
        lv: null,

        init: function (props) {
            if (this._super) {
                this._super(props);
            }

            var dic = this.dic, dt = dic.dt, _DTP = mstrmojo.expr.DTP, dtObj, arr = [];

            
            
            if (mstrApp.useBinaryFormat) {
                if (dt == _DTP.DATE || dt == _DTP.TIME || dt == _DTP.TIMESTAMP) {
                    dtObj = mstrmojo.date.parseDateAndOrTime(this.value);

                    if (dtObj) {
                        if (dt != _DTP.TIME) {
                            arr.push(mstrmojo.date.formatDateInfo(dtObj.date, mstrmojo.locales.datetime.DATEOUTPUTFORMAT));
                        }

                        if (dt != _DTP.DATE) {
                            arr.push(mstrmojo.date.formatTimeInfo(dtObj.time, mstrmojo.locales.datetime.TIMEOUTPUTFORMAT));
                        }
                        this.value = arr.join(' ');
                    }
                }
            }

            
            this.lv = this.value;

            
            if (dic.wm && dic.w === undefined) {
                dic.wm = 0;
            }
        },

        
        showByDefault: false,

        
        hasPreview: false,

        
        
        getItems: function () {
            var dic = this.dic, m = [], i, v, nm = 0,
                dv = String(dic.itv),
                dx = dv && dv.indexOf(decimal), 
                isNumeric = isNumType(dic.dt);

            if (dx >= 0) {
                nm = dv.substring(dx + 1).length;
            }

            if (parseInt(dic.ipt, 10) === 0) { 
                for (i = 0, v = dic.min; v < dic.max + 0.00001; i++, v += dic.itv) {
                    m[i] = {'n': mstrmojo.num.toLocaleString(nm > 0 ? v.toFixed(nm) : v), 'v': v};
                }
            } else {
                m = dic.vls;
                mstrmojo.array.forEach(m, function (mi) {
                    if (mi.n === undefined) {
                        mi.n = isNumeric ? mstrmojo.num.toLocaleString(mi.v) : mi.v;
                    }
                });
            }

            return m;
        },

        font: null,

        
        onfontChange: function () {
            if (this.getInputNode) {
                var node = this.getInputNode(),
                    f = this.font;

                $H.forEach(f, function (o, i) {
                    node.style[i] = o;
                });
            }
        },

        
        getOpenerNodeStyle: function () {
            var s = this.group && this.group.ons,
                p = this.openerNode;

            if (!s) {
                s = getPadding(p);

                
                s.hp = s.lp + s.rp;
                s.vp = s.tp + s.bp;

                
                s.iw = Math.max(0, p.clientWidth - s.hp);
                s.ih = Math.max(0, p.clientHeight - s.vp);

                
                if (this.group) {
                    this.group.ons = s;
                }
            }
            return s;
        },

        
        onvalueChange: function () {
            if (this._super) {
                this._super();
            }

            
            this.dicChanged = true;

            if (this.showByDefault) {
                this.applyChanges();
            } else {
                if (this.popupStyle !== POPUP_INLINE && this.popup && this.popup.enableApply) {
                    this.popup.enableApply();
                }
            }
        },

        preBuildRendering: function () {
            if (this._super) {
                this._super();
            }

            this.openerNode = this.openerNode || this.owner.domNode;

            if (this.showByDefault) {
                this.openerStyle = this.getOpenerNodeStyle();
                if (this.inlineExtraCssText) {
                    this.cssText += ' ' + this.inlineExtraCssText;
                }
            }

            if (!this.placeholder) {
                this.placeholder = document.body.appendChild(document.createElement("div"));
            }
        },

        postBuildRendering: function () {
            var target = this.openerNode;

            if (this._super) {
                this._super();
            }

            
            if (!mstrmojo.isDescendant(this.owner, this)) {
                if (this.showByDefault) {
                    
                    target.replaceChild(this.domNode, target.lastChild);
                } else {
                    
                    this.set('font', getFontStyle(target));
                }
            }

            if (mstrmojo.DICConfig.isKeyNavigable(this.dic)) {
                this.registerKeyEvents(this.domNode);
            }
        },

        
        applyChanges: function () {
            var lv = this.lv, v = this.getCurValue ? this.getCurValue() : this.value, d = this.openerNode,
                dv = this.getDisplayValue ? this.getDisplayValue() : v,
                dt = this.dic.dt,
                _DTP = mstrmojo.expr.DTP,
                LD = mstrmojo.locales.datetime;

            if (String(v) !== String(lv)) {
                
                if (mstrApp.useBinaryFormat) {
                    if (dt == _DTP.TIME || dt == _DTP.TIMESTAMP) {
                        v = v.replace(new RegExp(LD.AM_NAME), 'AM').replace(new RegExp(LD.PM_NAME), 'PM');
                    }
                }

                this.lv = v;
                this.dv = dv;

                if (this.owner && this.owner.dataChanged) {
                    this.owner.dataChanged(this.k, lv, {dv: dv, v: v}, d);
                }
            }
            return true;
        },

        
        cancelChanges: function cancelChanges() {
            this.value = this.lv;
        },

        
        showInPopup: function () {

            this.popup = mstrmojo.DICFactory.createDICPopup(this.owner, this);

            if (this.focus) {
                this.focus();
            }
            
            this.setInfoWindowLock(true);
        },

        
        lockPopup: function () {
            this.setInfoWindowLock(false);
        },
        
        
        renderPreview: null,

        
        onTabDown: function (evt) {
            mstrmojo.dom.preventDefault(window, evt);

            
            if (this.applyChanges() !== false) {

                
                if (this.popup) {
                    this.popup.close();
                }

                
                this.owner.editNext(this.k);
                
                
                this.cleanup();
            }
        },

        
        cleanup: mstrmojo.emptyFn,
        
        
        registerKeyEvents: function (dom) {
            var me = this;

            $D.attachEvent(dom, 'keydown', function (evt) {
                var e = evt || window.event;
                if (e.keyCode === TAB_KEY) { 
                    me.onTabDown(evt);
                }
            });

            
            
            if ($D.isIE) {
                $D.attachEvent(dom, 'keyup', function (evt) {
                    var e = evt || window.event;
                    if (e.keyCode === TAB_KEY) {
                        me.focus();
                    }
                });
            }
        },
        
        
        setInfoWindowLock: function(isLock) {
        	lockInfoWindow(this.owner, isLock);
        }
    };
}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.hash",
        "mstrmojo.WidgetListBuilder");
    
    
    mstrmojo.WidgetTreeBuilder = mstrmojo.provide(
        "mstrmojo.WidgetTreeBuilder",
        mstrmojo.mixin(
            {
                
                newContext: function bc(w){
                    var c = this._super(w);
                    
                    if (!w.itemFunction && c.itemFunc) {
                        
                        var ifn = c.itemFunc;
                        c.itemFunc = function(item, index, widget){
                            var iw = ifn(item, index, widget);
                            if (iw) {
                                iw.tree = widget.tree || widget;
                            }
                            return iw;
                        };
                    }
                    return c;
                }
            },
            mstrmojo.hash.copy(mstrmojo.WidgetListBuilder)
        )
    );

})();
(function() {
    mstrmojo.requiresCls("mstrmojo.hash",
            "mstrmojo.locales",
            "mstrmojo.array",
            "mstrmojo.date",
            "mstrmojo.string",
            "mstrmojo.android.ui.CalendarMarkupBuilder");

    var $A = mstrmojo.array,
        $H = mstrmojo.hash,
        $DL = mstrmojo.locales.datetime,
        $DN = $DL.dayNames_FULL,
        $S = mstrmojo.string,
        CLEARING_DIV_MKP = '<div class="clearingDiv"></div>',
        START_DIV = '<div {@attr}>',
        END_DIV = '</div>',
        CSS_PREFIX = 'mstrmojo-CalendarMV-';
    
    function createAttrString(attr) {
        var str = [],
            len = -1;
        
        $H.forEach(attr, function (v, k) {
            str[++len] = k + '="' + v + '"';
        });
        
        return str.join(' ');
    }
    
    
    mstrmojo.android.medium.ui.CalendarMarkupBuilder = $H.copy({
        getHeaderHTML: function getHeaderHTML(month, year) {
            var html = [],
                len = -1,
                startDate = new Date(year, month - 1);
            
            html[++len] = $S.apply(START_DIV, {
                attr: createAttrString({
                    "class": CSS_PREFIX + 'MonthLabel'
                })
            });
            
            html[++len] = mstrmojo.locales.datetime.MONTHNAME_SHORT[startDate.getMonth()] + ' ' +  startDate.getFullYear() + END_DIV;

            $A.forEach($DN, function(v, i) {
                html[++len] = $S.apply(START_DIV, {}) + v.substring(0, 3) + END_DIV;
            });

            html[++len] = CLEARING_DIV_MKP;
            
            return html.join('');
        },

        
        getContentHTML: function getContentHTML(start, end, config) {
            var html = [],
                len = -1,
                startDate = new Date(start.y, start.m),
                endDate = (new Date(end.y, end.m));
            
            
            config.showAddlWeek = true;
            
            while (startDate <= endDate) {
                html[++len] =  $S.apply(START_DIV, {
                    attr: createAttrString({
                        m: startDate.getMonth() + 1,
                        y: startDate.getFullYear(),
                        "class": CSS_PREFIX + 'Container'
                    })
                });
                
                html[++len] = $S.apply(START_DIV, {
                    attr: createAttrString({
                        "class": CSS_PREFIX + 'DatesList'
                    })
                });
                
                html[++len] = this.getSingleMonthHelper(startDate.getMonth(), startDate.getFullYear(), config);
                html[++len] = END_DIV;
                html[++len] = CLEARING_DIV_MKP;
                html[++len] = END_DIV;
                
                
                startDate.setMonth(startDate.getMonth() + 1);
            }
            
            html[++len] = CLEARING_DIV_MKP;
            
            return html.join('');
        }
        
    }, $H.copy(mstrmojo.android.ui.CalendarMarkupBuilder));
}());

(function() {
    mstrmojo.requiresCls("mstrmojo._Fetchable",
                         "mstrmojo.hash");

    var $H = mstrmojo.hash;
    
    function getDS() {
        var factory = mstrApp.modelFactory;
        if (factory) {
            return factory.newDataService('Element');
        } else {
            return mstrApp.viewFactory.newElementDataService();
        }
    }

    function getElementArity(elementID) {
        var count1, count2, startPos;

        count1 = -1;
        startPos = 0;
        while (startPos >= 0) {
            count1++;
            startPos = elementID.indexOf(":", startPos);
            if (startPos >= 0) 	startPos++;
        }

        count2 = -1;
        startPos = 0;
        while (startPos >= 0) {
            count2++;
            startPos = elementID.indexOf("*:", startPos);
            if (startPos >= 0) startPos++;
        }

        if (count1 < count2 + 1) {
            alert ("Unexpected format for element ID " + elementID);
        }

        return count1 - count2;
    }

	mstrmojo.requiresCls("mstrmojo.XMLBuilder", "mstrmojo.Obj");
	mstrmojo.mstr.WebElements = mstrmojo.declare(
			
			mstrmojo.Obj,
			
			[mstrmojo._Fetchable],
			
			{
			    scriptClass: 'mstrmojo.mstr.WebElements',
				
				source: null,
				
				items: null,
				duplicate: function() {
					return new mstrmojo.mstr.WebElements({
							source: $H.copy(this.source),
							browseConfig: $H.copy(this.browseConfig)
					});
				},
				
				
				browseConfig: null,				
				init: function(props) {
					var cf = props && props.browseConfig
					if (cf) {
						this.blockBegin = cf.blockBegin || 1;
						this.blockCount = cf.blockCount || 15;
					}
					if (this._super) {
						this._super(props);
					}
				},
				getBrowseConfig: function(bb){
					var config = this.browseConfig;
					return {
		                'attributeID': this.source && this.source.did || 0,
		                'blockBegin': bb || 1,
		                'blockCount': this.blockCount || -1,
		                'filterXML': config.filter && config.filter.getXML() || '',
		                'shortFilterXML' : config.shortFilterXML || '',
		                'searchPattern': config.searchPattern || '',
		                'matchCase' : !!config.matchCase,
		                'dataSourcesXML': config.dataSources || '',
		                'targetAttributeID':config.searchTarget && config.searchTarget.did || '',
		                'searchForms':config.searchForms || ''




					}
				},
				_retrieveItems: function(bb, callbacks){
				    var me = this;
					getDS().getElements(
							this.getBrowseConfig(bb)
							, 
							{
		                        success: function (res) {
		                            if (callbacks && callbacks.success) {
		                            	callbacks.success({
		                            		items: me.convertElems(res.items),
		                            		totalSize: res.totalSize
		                            	});
		                            }
		                        },
		                        failure: function (details) {
		                        	if (callbacks && callbacks.failure) {
		                        		callbacks.failure(details);
		                        	}
		                        }
		                    });

				},				
			    
				convertElems: function convertElems(items){
			        var ris = [],
			            items = items || [];
			        for (var i = 0; i < items.length; i ++) {
			            var item = items[i];
			            ris[i] = {
			                    vi: i,
			                    v: item.dssid,
			                    n: item.n,
			                    t: item.emt
			            }
			        }
			        return ris;
			    },

				
				
				
				buildShortXML: function buildShortAnswerXML(builder) {
					builder.addChild("mi");
			        builder.addChild("es");
			        if (this.source != null) {
			            this.source.buildShortObjectElt(builder);
			        }
			        
			        
			        var es = [].concat(this.items);
			        es.sort(function(e1, e2) {
			        	var n1 = e1.n,
			        	    n2 = e2.n,
			        	    res;
			        	if ( n1 === n2 ) {
			        		res = 0;
			        	} else if ( n1 < n2 ) {
			        		res = -1;
			        	} else {
			        		res = 1;
			        	}
			        	return res;
			        });
			        for (var i = 0; i < es.length; i++) {
			            var elt = es[i];
			            builder.addChild("e");
			            builder.addAttribute("ei", elt.v);
			            builder.addAttribute("emt", elt.t);
			            builder.addAttribute("art", getElementArity(elt.v));
			            builder.addAttribute("disp_n", elt.n);
			            builder.closeElement(); 
			        }
			        builder.closeElement(); 
			        builder.closeElement(); 
				}
				
			}
	);
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.hash");

    var $H = mstrmojo.hash,
        PENDING = 'pending',
        FAILED = 'failed';

    
    function getOfflineTransactions(callback) {
        if (mstrApp.isHosted()) {

            callback.success({});
        } else {
            mstrApp.serverRequest({
                taskId: 'getOfflineTransaction'
            }, callback, {
                noTaskURL: true,
                skipLogin : true
            });
        }

    }

    function noPendingQueue(list) {
        var noPending = true;
        $H.forEach(list, function (o) {
            if (o.pending && o.pending.length > 0) {
                noPending = false;
            }
        });

        return noPending;
    }

    
    function setBoardModel() {
        var me = this;

        
        getOfflineTransactions({
            success: function (res) {
                var updated = false, po, docs, list;

                
                me.emptyTransactionQueue = $H.isEmpty(res);

                
                $H.forEach(me.prjModel, function (v, k) {
                    if (!res[k]) {
                        po = me.prjModel[k];
                        if (po && po.list) {
                            delete me.prjModel[k];
                            updated = true;
                        }
                    }
                });

                
                $H.forEach(res, function (v, k) {
                    var p = mstrApp.getConfiguration().getProjectByRealPid(k);
                    
                    if (!p) {
                        
                        return;
                    }

                    po = me.prjModel[k];
                    if (!po) {
                        po = me.prjModel[k] = {pid: p.pid, realPid: k, pn: p.pn, list: v};
                        updated = true;
                    } else {
                        
                        if (!$H.equals(po.list, v)) {
                            po.list = v;
                            updated = true;
                        }
                    }
                });

                if (updated) {
                    list = {};
                    $H.forEach(me.prjModel, function (v) {
                        if (v) {
                            
                            docs = $H.clone(v.list);
                            
                            $H.copy(docs, list);
                            
                            $H.forEach(docs, function (o) {
                                o.p = v;
                            });
                        }
                    });
                    
                    me.ntfBoardModel.docsTx = list;

                    me.ntfBoardModel.raiseEvent({
                        name: 'recordChanged',
                        data: me.ntfBoardModel.docsTx
                    });
                }
            }
        });
    }

    var $MODEL = mstrmojo.OfflineTransactionModel = mstrmojo.declare(
        mstrmojo.Obj,
        null,
        {
            scriptClass: 'mstrmojo.OfflineTransactionModel',

            
            lastSubmission: false,

            
            emptyTransactionQueue: true,


            
            ntfBoardModel: null,

            
            prjModel: null,

            
            init: function init(props) {
                this._super(props);

                
                this.prjModel = {};

                
                this.ntfBoardModel = new mstrmojo.Obj({
                    
                    docsTx: {},

                    getOfflineRecords: function getOfflineRecords(did) {
                        return did ? this.docsTx[did] : this.docsTx;
                    }

                    
                });

                setBoardModel.call(this);
            },

            
            getBoardModel: function getBoardModel() {
                return this.ntfBoardModel;
            },

            
            hasOfflineTransactions: function hasOfflineTransactions() {
                return !this.emptyTransactionQueue;
            },

            editTransactionRecord: function editOfflineTransactionRecord(documentId, isPending, timeStamp, callback) {
                var bm = this.ntfBoardModel,
                    p = bm.docsTx[documentId].p,
                    dim = mstrApp.getContentDimensions();

                
                mstrApp.serverRequest({
                    taskId: 'editOfflineTransaction',
                    projectId: p.realPid,
                    documentId: documentId,
                    isPending: isPending,
                    timeStamp: timeStamp,
                    availableWidth: dim.w,
                    availableHeight: dim.h
                }, callback, {
                    projectId: p.pid,
                    skipLogin : true
                });
            },

            deleteTransactionRecord: function deleteTransactionRecord(documentId, isPending, timeStamp, callback) {
                var bm = this.ntfBoardModel,
                    rec = bm.docsTx[documentId],
                    p = rec.p,
                    d = rec[isPending ? PENDING : FAILED],
                    idx,
                    prjList,
                    me = this;

                mstrApp.serverRequest({
                    taskId: 'deleteOfflineTransaction',
                    projectId: p.realPid,
                    documentId: documentId,
                    isPending: isPending,
                    timeStamp: timeStamp
                }, {
                        
                    success: function () {
                        
                        idx = mstrmojo.array.find(d, 'timestamp', timeStamp);
                        if (idx !== -1) {
                            d.splice(idx, 1);
                        }
                        
                        
                        if (rec.pending.length === 0 && rec.failed.length === 0) {
                            delete bm.docsTx[documentId];
                            
                            if ($H.isEmpty(bm.docsTx)) {
                                me.emptyTransactionQueue = true;
                            }
                            
                            
                            prjList = me.prjModel[p.realPid];
                            if(prjList) {
                                
                                delete prjList.list[documentId];
                                
                                if($H.isEmpty(prjList.list)) {
                                    delete me.prjModel[p.realPid];
                                }
                            }                            
                            
                            
                            bm.raiseEvent({
                                name: 'recordChanged',
                                data: bm.docsTx
                            });
                        }

                        if (callback.success) {
                            callback.success(d);
                        }
                    }
                }, {
                    noTaskURL: true,
                    skipLogin : true
                });
            },

            
            submitOfflineTransaction: function submitOfflineTransaction() {
                
                if (!this.lastSubmission || !this.emptyTransactionQueue) {
                    $H.forEach(this.prjModel, function (v, k) {
                        
                        
                        if (v && v.list && !$H.isEmpty(v.list) && !noPendingQueue(v.list)) {
                            mstrApp.submitTransactionQueue(k, 'submitOfflineTransaction');
                        }
                    });
                }
            },

            onSubmitDone: function onSubmitDone(status) {
                this.lastSubmission = status;
                this.refresh();
            },

            refresh: function refresh() {
                setBoardModel.call(this);
            }
        }
    );

    $MODEL.PENDING = PENDING;
    $MODEL.FAILED = FAILED;
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.hash",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    var $M = Math,
        $HS = mstrmojo.publisher.hasSubs,
        $HASH = mstrmojo.hash,
        $forEachHash = $HASH.forEach,
        $D = mstrmojo.dom;

    var VELOCITY_THRESHOLD = 0.15;      

    var INC_EDGE_START = 1,
        INC_EDGE_END = 2;

    
    var indicators = {
        y: {
            edge: [ 'top', 'bottom' ],   
            size: 0                      
        },

        x: {
            edge: [ 'left', 'right' ],   
            size: 0                      
        },

        
        clsName: 'mstrmojo-touch-scroll-indicator',

        
        init: function init() {
            
            var vertical = this.y,
                horizontal = this.x;

            
            if (!vertical.i) {
                
                var vIndicator = vertical.i = document.createElement('div');
                vIndicator.className = this.clsName;

                
                var hIndicator = horizontal.i = vIndicator.cloneNode();

                
                document.body.appendChild(vIndicator);
                document.body.appendChild(hIndicator);
            }
        },

        
        setGradient: function setGradient(indicator, scrollerAtMax, delta, containerMaxSize) {
            
            var indicatorEl = indicator.i,
                edge = indicator.edge[(scrollerAtMax) ? 1 : 0];

            
            var gradientSize = $M.min($M.round($M.min($M.abs(delta) / 200, 1) * 100), containerMaxSize / 2),
                start = 'left top',
                end = 'left bottom';

            
            if (scrollerAtMax) {
                
                end = start;

                
                if (edge === 'bottom') {
                    
                    start = 'left bottom';

                } else {
                    
                    start = 'right top';

                }

            
            } else if (edge === 'left') {
                
                end = 'right top';
            }

            
            if (gradientSize !== indicator.size) {
                
                indicatorEl.style.background = '-webkit-gradient(linear, ' + start + ', ' + end + ', from(rgba(39, 104, 162, .4)), to(rgba(39, 104, 162, 0)), color-stop(' + (gradientSize / 100) + ', rgba(39, 104, 162, 0)))';

                
                indicator.size = gradientSize;
            }
        },

        
        scrollAxis: function scroll(axis, touchPosition, constrainedPosition, widgetPosition, outOfBounds) {
            
            var delta = touchPosition - constrainedPosition,            
                isOutOfBounds = outOfBounds[axis] = (delta !== 0);      

            
            if (!isOutOfBounds) {
                
                this.hide(axis);
                return;
            }

            var indicator = this[axis],
                indicatorEl = indicator.i,
                indicatorStyle = indicatorEl.style,
                isVertical = (axis === 'y'),
                scrollerAtMax = (delta > 0),
                clsName = this.clsName + ' ' + indicator.edge[(scrollerAtMax) ? 1 : 0];

            
            if (!indicator.size || indicatorEl.className !== clsName) {

                
                indicatorEl.className = clsName;

                
                var px = 'px',
                    borderWidth = 3,
                    top = widgetPosition.y,
                    left = widgetPosition.x,
                    height = 100,
                    width = widgetPosition.w;

                
                if (isVertical) {
                    
                    if (scrollerAtMax) {
                        
                        top += widgetPosition.h - height - borderWidth;
                    }

                } else {
                    
                    width = height;
                    height = widgetPosition.h;

                    
                    if (scrollerAtMax) {
                        
                        left += widgetPosition.w - width - borderWidth;
                    }
                }

                
                indicatorStyle.top = top + px;
                indicatorStyle.left = left + px;
                indicatorStyle.width = width + px;
                indicatorStyle.height = height + px;

                
                indicatorStyle.display = 'block';
            }

            
            this.setGradient(indicator, scrollerAtMax, delta, (isVertical) ? widgetPosition.h : widgetPosition.w);
        },

        scroll: function scroll(scroller, position, constrainedX, constrainedY, scrollEl) {
            
            var x = position.x,
                y = position.y;

            
            if (x !== constrainedX || y !== constrainedY) {
                
                this.init();

                
                var widgetPosition = this._widgetPosition;
                if (!widgetPosition) {
                    var el = scroller.indicatorEl || scrollEl;
                    
                    widgetPosition = mstrmojo.dom.position(el.parentNode);
                }

                
                var outOfBounds = scroller._outOfBounds || {};

                
                this.scrollAxis('y', y, constrainedY, widgetPosition, outOfBounds);
                this.scrollAxis('x', x, constrainedX, widgetPosition, outOfBounds);

                
                this._widgetPosition = widgetPosition;

                
                scroller._outOfBounds = outOfBounds;

            } else {
                
                this.hideAll();

                
                delete scroller._outOfBounds;

            }
        },


        
        hide: function hide(axis) {
            
            var a = this[axis];
            if (a.size !== undefined) {
                
                a.i.style.display = 'none';
                a.i.className = this.clsName;

                
                a.size = 0;
            }
        },

        
        hideAll: function hideAll() {
            
            this.hide('y');
            this.hide('x');

            
            delete this._widgetPosition;
        }
    };

    
    function constrainPoint(value, offset) {
        return (offset) ? $M.max($M.min($M.round(value), offset.end), offset.start) : value;
    }

    function raiseScrollerEvent(scroller, evtName, evtObj) {
        
        evtObj.name = evtName;
        evtObj.id = scroller.identifier;

        
        scroller.raiseEvent(evtObj);
    }


    
    function stopDecelOnScrollDone() {
        
        
        
        var evtName = 'scrollDone',
            origin = this.origin;
        if ($HS(this.id, evtName) && origin) {
            raiseScrollerEvent(this, evtName, {
                x: origin.x,
                y: origin.y
            });
        }

        this.stopDeceleration();
    }

    
    function applyPosition(scroller, position, duration) {
        var scrollEl = scroller.scrollEl;
        
        
        if (!scrollEl) {
        	stopDecelOnScrollDone.call(scroller);
            return;
        }
        
        var positions = {
                x: position.x || 0,
                y: position.y || 0
            };

        
        $forEachHash(scroller._scrollBarEls, function (bar, axis) {
            var isX = (axis === 'x'),
                position = positions[axis],
                length = bar.length,
                ratio = bar.ratio,
                viewportSize = bar.viewportSize,
                minScale = 6 / length,
                minPosition = bar['base' + ((isX) ? 'Left' : 'Top')],
                maxPosition = minPosition + viewportSize - length,
                newPosition = $M.round(minPosition + (ratio * position));

            
            if (newPosition < minPosition) {
                newPosition = minPosition - position;
                length += position;
            } else if (newPosition > maxPosition) {
                var delta = (position - scroller.offset[axis].end) * ratio;
                newPosition = $M.min(maxPosition + delta, viewportSize + minPosition - 6) - 1;
                length -= delta;
            }

            
            var v = 0,
                translate = [v, v, v],
                scale = [1, 1, 1],
                idx = (isX) ? 0 : 1;

            translate[idx] = (newPosition - minPosition);
            scale[idx] = $M.min($M.max(length / bar.length, minScale), 1);

            $D.translate(bar, translate[0], translate[1], translate[2], ' scale3d(' + scale.join(',') + ')');
        });

        if (duration) {
            duration += 'ms';
        }

        
        if (scroller._isHosted) {
            
            var parentNode = scrollEl.parentNode;
            parentNode.scrollTop = positions.y;
            parentNode.scrollLeft = positions.x;
        } else {
            
            scrollEl.style[$D.CSS3_TRANSITION_DURATION] = duration || '0';    
            $D.translate(scrollEl, -positions.x, -positions.y, 0, scroller.transform, scroller.useTranslate3d);
        }

        
        if ($HS(scroller.id, 'scrollMoved')) {
            
            raiseScrollerEvent(scroller, 'scrollMoved', {
                x: position.x,
                y: position.y
            });
        }
    }

    
    function fnGetTime(finalVelocity, initialVelocity, friction) {
        return $M.ceil(1 + $M.log(finalVelocity / $M.abs(initialVelocity)) / $M.log(1 - friction));
    }

    
    function fnGetPosition(position, directionMultiplier, initialVelocity, timeInterval, friction) {
        return position + (directionMultiplier * (initialVelocity * (1 - $M.pow(1 - friction, timeInterval)) / friction));
    }

    
    function calculateAxisPosition(scroller, position, axis, direction, velocity, delta, totalTime) {
        var offset = scroller.offset[axis];     

        
        if (!offset) {
            
            return position;
        }

        var outOfBounds = scroller._outOfBounds,
            isAxisOutOfBounds = outOfBounds && outOfBounds[axis],   
            incFetch = offset.incFetch,                             
            friction = scroller.friction,
            start = offset.start,
            end = offset.end,
            limit = (direction) ? end : start;                      

        
        velocity = $M.abs(velocity);

        
        if (isAxisOutOfBounds) {
            
            direction = (position < start);
            limit = (direction) ? start : end;
        }

        var directionMultiplier = (direction) ? 1 : -1;

        
        if (isAxisOutOfBounds && (direction || !incFetch)) {
            
            
            
            var finalVelocity = VELOCITY_THRESHOLD * 3,
                a = 1 / (1 - friction),
                initialVelocity = finalVelocity / $M.pow((1 - friction), ($M.log(1 - $M.abs(position - limit) * (1 - a) / finalVelocity) / $M.log(a)) - 1);

            
            var calculatedPosition = $M.round(fnGetPosition(position, directionMultiplier, initialVelocity, delta, friction));

            
            if (direction ? (calculatedPosition >= limit) : (calculatedPosition <= limit)) {
                
                stopDecelOnScrollDone.call(scroller);

                
                return limit;
            }

            
            return calculatedPosition;

        }

        
        var pageSize = offset.pageSize,
            supportedEdges = offset.supportedEdges;


        
        var newPosition = fnGetPosition(position, directionMultiplier, velocity, delta, friction),
            bStart = (newPosition <= start),
            bEnd = (newPosition >= end);

        
        if (bStart || bEnd) {

            
            if (incFetch && ((bStart && ((supportedEdges & INC_EDGE_START) > 0)) ||
                    (bEnd && ((supportedEdges & INC_EDGE_END) > 0)))) {

                
                if (newPosition - end >= pageSize) {
                    
                    newPosition = end + pageSize;

                    
                    limit = newPosition;
                }

                if (!scroller.STATUS_INC_FETCH) {
                    
                    scroller.STATUS_INC_FETCH = true;

                    
                    raiseScrollerEvent(scroller, 'incFetch', {
                        edge: bEnd ? INC_EDGE_END : INC_EDGE_START
                    });
                }

            } else {

                
                if (scroller.bounces) {

                    
                    var bounceFriction = friction * 2,
                        bVelocity = scroller.bounceVelocity,
                        bTime = scroller.bounceTime,
                        bDistance = scroller.bounceDistance;

                    
                    if (!scroller.hasBounced) {
                        
                        bVelocity[axis] = $M.abs(VELOCITY_THRESHOLD / $M.pow(1 - friction, totalTime - delta - 1));

                        
                        bTime[axis] = fnGetTime(VELOCITY_THRESHOLD, bVelocity[axis], bounceFriction);

                        
                        bDistance[axis] = $M.abs(fnGetPosition(newPosition, directionMultiplier, bVelocity[axis], bTime[axis], bounceFriction) - newPosition);

                        
                        scroller.raiseEvent({
                            name: 'bounceOut',
                            id: scroller.identifier,
                            axis: axis,
                            direction: direction,
                            value: $M.round(newPosition)
                        });

                        
                        scroller.hasBounced = true;
                    }

                    var bounceLimit = Math.floor(bDistance[axis] / 2);

                    
                    var bouncePosition = fnGetPosition(limit, directionMultiplier, bVelocity[axis], delta, bounceFriction),
                        travelDistance = $M.abs(bouncePosition - limit);

                    
                    if ($M.abs(travelDistance) < bounceLimit) {
                        
                        return bouncePosition;
                    }

                    
                    if ($M.abs(travelDistance) >= bDistance[axis]) {
                        
                        stopDecelOnScrollDone.call(scroller);
                        return limit;
                    }

                    
                    var limitDistance = bounceLimit - (travelDistance - bounceLimit);
                    return $M.round(limit - ((direction) ? -limitDistance : limitDistance));  
                }

                
                newPosition = limit;
            }
        }

        
        return $M.round(newPosition);
    }

    
    function detachHostedScrollListener(el) {
        var scrollListener = this._scrollListener;
        if (scrollListener) {
            if (!el || el !== scrollListener.el) {
                $D.detachEvent(scrollListener.el, 'scroll', scrollListener.fn);
                delete this._scrollListener;

                return true;
            }

            return false;
        }

        return true;
    }

    
    var $TOUCHSCROLLER = mstrmojo.TouchScroller = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        
        {
            scriptClass: "mstrmojo.TouchScroller",

            
            scrollEl: null,

            
            identifier: '',

            
            hScroll: false,

            
            vScroll: false,

            
            offset: null,

            
            origin: null,

            
            transform: '',

            
            friction: 0.0015,

            
            frameRate: 60,

            
            bounces: true,

            
            hasBounced: false,

            
            bounceDistance: {},

            
            bounceTime: {},

            
            bounceVelocity: {},

            
            showScrollbars: false,

            
            showIndicators: true,

            
            useTranslate3d: true,

            
            STATUS_INC_FETCH: false,

            
            init: function init(props) {
                this._super(props);

                
                indicators.init();
            },

            
            initScroller: function initScroller(props) {
                
                $HASH.copy(props, this);

                
                var scrollEl = this.scrollEl;
                if (scrollEl) {
                    
                    var isHosted = this._isHosted = false; 
                    if (isHosted) {
                        var parentNode = scrollEl.parentNode;

                        
                        if (detachHostedScrollListener.call(this, parentNode)) {
                            
                            parentNode.style.overflow = 'auto';

                            
                            var id = this.id,
                                listener = this._scrollListener = {
                                    el: parentNode,
                                    fn: function (evt) {
                                        var origin = mstrmojo.all[id].origin,
                                            target = evt.target;

                                        origin.x = target.scrollLeft;
                                        origin.y = target.scrollTop;
                                    }
                                };

                            
                            $D.attachEvent(parentNode, 'scroll', listener.fn);
                        }

                        
                        this.showScrollbars = false;
                    }
                }
            },

            
            canScroll: function canScroll() {
                return this.vScroll || this.hScroll;
            },

            
            updateScrollBars: function updateScrollBars(viewportCoords, scrollBarContainerElement) {
                var scrollEl = this.scrollEl;

                
                if (!this.showScrollbars || !scrollEl) {
                    
                    return;
                }

                var bars = this._scrollBarEls;

                
                if (!bars) {
                    var me = this;
                    bars = this._scrollBarEls = {
                        x: 'hScroll',
                        y: 'vScroll'
                    };

                    
                    $forEachHash(bars, function (scroll, axis) {
                        
                        if (me[scroll]) {
                            
                            var bar = document.createElement('div');
                            bar.className = 'mstrmojo-touch-scrollBar ' + axis + 'Axis';

                            
                            (scrollBarContainerElement || scrollEl.parentNode).appendChild(bar);
                            bars[axis] = bar;
                        } else {
                            
                            delete bars[axis];
                        }
                    });
                }

                
                if (!viewportCoords) {
                    
                    var parentNode = this.scrollEl.parentNode;
                    viewportCoords = {
                        top: 0,
                        right: parentNode.clientWidth,
                        bottom: parentNode.clientHeight,
                        left: 0
                    };
                }

                
                var offset = 9,
                    scrollBarCoords = {
                        x: {
                            left: viewportCoords.left,
                            top: viewportCoords.bottom - offset,
                            x: viewportCoords.right - viewportCoords.left,
                            d: 'Width'
                        },
                        y: {
                            left: viewportCoords.right - offset,
                            top: viewportCoords.top,
                            x: viewportCoords.bottom - viewportCoords.top,
                            d: 'Height'
                        }
                    };

                
                $forEachHash(bars, function (bar, axis) {
                    var barStyle = bar.style,
                        coords = scrollBarCoords[axis],
                        dimension = coords.d,
                        parentNode = bar.parentNode,
                        x = coords.x;

                    
                    var left = coords.left,
                        top = coords.top,
                        ratio = x / scrollEl['offset' + dimension],
                        length = Math.min(Math.round(x * ratio), x);

                    
                    bar.baseLeft = left;
                    bar.baseTop = top;
                    bar.ratio = ratio;
                    bar.viewportSize = x;
                    bar.length = length;

                    
                    barStyle.left = left + 'px';
                    barStyle.top = top + 'px';
                    barStyle[dimension.toLowerCase()] = length + 'px';
                });
            },

            
            toggleScrollBars: function toggleScrollBars(visible) {
                
                $forEachHash(this._scrollBarEls, function (bar) {
                    
                    bar.style.opacity = (visible) ? 1 : 0;
                });
            },

            
            scrollTo: function (x, y, duration) {
                
                if (!this.canScroll() && !(x === 0 && y === 0)) {
                    
                    
                    applyPosition(this, {
                        x: 0,
                        y: 0
                    });

                    
                    return;
                }

                
                var offset = this.offset,
                    origin = this.origin,
                    position = {
                        x: (this.hScroll) ? constrainPoint(x, offset.x) : 0,
                        y: (this.vScroll) ? constrainPoint(y, offset.y) : 0
                    };

                
                applyPosition(this, position, duration);

                
                origin.x = position.x;
                origin.y = position.y;
            },

            
            scrollToEnd: function (x, y, duration) {
                var origin = this.origin,
                    offset = this.offset,
                    result = {
                        x: 0,
                        y: 0
                    };

                
                if (origin && offset) {
                    
                    mstrmojo.array.forEach([ x, y ], function (scroll, idx) {
                        
                        var axis = (idx) ? 'y' : 'x',
                            axisOffset = offset[axis];

                        
                        result[axis] = (scroll) ? (axisOffset && axisOffset.end) || 0 : origin[axis];
                    });
                }

                
                this.scrollTo(result.x, result.y, duration);
            },

            
            scroll: function scroll(touch) {
                
                if (this._isHosted) {
                    
                    return;
                }

                var offset = this.offset,
                    scrollEl = this.scrollEl,
                    touchDelta = touch.delta,
                    touchDeltaX = touchDelta.x,
                    touchDeltaY = touchDelta.y;

                
                if (!scrollEl) {
                    
                    return;
                }

                
                if (!offset && this.showIndicators) {
                    
                    indicators.scroll(this, {
                        x: (this.noHScroll) ? 0 : -touchDeltaX,
                        y: (this.noVScroll) ? 0 : -touchDeltaY
                    }, 0, 0, scrollEl);

                    return;
                }

                
                var origin = this.origin,
                    position = {
                        x: (this.hScroll) ? $M.round(origin.x - touchDeltaX) : 0,
                        y: (this.vScroll) ? $M.round(origin.y - touchDeltaY) : 0
                    },
                    constrainedX = constrainPoint(position.x, offset.x),
                    constrainedY = constrainPoint(position.y, offset.y);

                
                if (!offset.scrollPast) {
                    
                    if (this.showIndicators) {
                        
                        indicators.scroll(this, position, constrainedX, constrainedY, scrollEl);
                    }

                    
                    position.x = constrainedX;
                    position.y = constrainedY;

                } else {
                    
                    var isXAxisOutOfBounds = (constrainedX !== position.x),
                        isYAxisOutOfBounds = (constrainedY !== position.y),
                        isOutOfBounds = (isXAxisOutOfBounds || isYAxisOutOfBounds),
                        outOfBounds = this._outOfBounds,
                        evtName = '';

                    
                    if (outOfBounds) {
                        
                        if (isXAxisOutOfBounds !== (outOfBounds.x === true) || isYAxisOutOfBounds !== (outOfBounds.y === true)) {
                            
                            evtName = 'scrollIn';
                        }

                    
                    } else if (isOutOfBounds) {
                        
                        evtName = 'scrollOut';
                    }

                    
                    if (evtName) {
                        
                        if ($HS(this.id, evtName)) {
                            
                            var direction = touch.direction;
                            raiseScrollerEvent(this, evtName, {
                                x: {
                                    position: position.x,
                                    direction: direction.x
                                },
                                y: {
                                    position: position.y,
                                    direction: direction.y
                                }
                            });
                        }

                        
                        if (isOutOfBounds) {
                            
                            this._outOfBounds = {
                                x: isXAxisOutOfBounds,
                                y: isYAxisOutOfBounds
                            };
                        } else {
                            
                            delete this._outOfBounds;
                        }
                    }
                }

                
                applyPosition(this, position);
            },

            
            scrollEnd: function scrollEnd(touch) {
                
                indicators.hideAll();

                
                if (!this.canScroll() || this._isHosted) {
                    
                    return;
                }

                var id = this.id,
                    friction = this.friction,
                    a = 1 / (1 - friction),
                    initialPosition = this.origin,
                    initialVelocity = touch.velocity,
                    direction = touch.direction,
                    startTime = new Date(),
                    outOfBounds = this._outOfBounds,
                    offset = this.offset,
                    canScrollAxis = {
                        x: this.hScroll,
                        y: this.vScroll
                    },
                    velocity = {},
                    position = {},
                    directionMultiplier = {},
                    totalTime = {},
                    totalDistance = {},
                    finalVelocity = {},
                    start = {},
                    end = {},
                    limit = {},
                    initializeVars = function (axis) {
                        
                        finalVelocity[axis] = VELOCITY_THRESHOLD;

                        
                        var axisOffset = offset[axis],
                            axisIsOutOfBounds = (outOfBounds && outOfBounds[axis]),
                            indicatorVisible = (axisIsOutOfBounds && (!axisOffset || !offset.scrollPast));

                        
                        position[axis] = (canScrollAxis[axis] && !indicatorVisible) ? initialPosition[axis] - touch.delta[axis] : initialPosition[axis];

                        if (axisOffset) {
                            
                            start[axis] = axisOffset.start;
                            end[axis] = axisOffset.end;

                            
                            if (axisIsOutOfBounds) {
                                if (!indicatorVisible) {
                                    
                                    direction[axis] = (position[axis] < start[axis]);
                                    limit[axis] = (direction[axis]) ? start[axis] : end[axis];

                                    
                                    if (direction[axis] || !axisOffset.incFetch) {
                                        
                                        
                                        
                                        finalVelocity[axis] = VELOCITY_THRESHOLD * 3;
                                        initialVelocity[axis] = finalVelocity[axis] / $M.pow((1 - friction), ($M.log(1 - $M.abs(position[axis] - limit[axis]) * (1 - a) / finalVelocity[axis]) / $M.log(a)) - 1);
                                    }
                                } else {
                                    
                                    position[axis] = constrainPoint(initialPosition[axis] - touch.delta[axis], axisOffset);
                                }
                            }
                        }

                        
                        velocity[axis] = (canScrollAxis[axis] && !indicatorVisible) ? $M.abs(initialVelocity[axis]) : 0;

                        directionMultiplier[axis] = (direction[axis] || false) ? 1 : -1;

                        
                        totalTime[axis] = fnGetTime(finalVelocity[axis], velocity[axis], friction);
                        totalDistance[axis] = fnGetPosition(position[axis], directionMultiplier[axis], velocity[axis], totalTime[axis], friction);
                    };

                
                initializeVars('x');
                initializeVars('y');

                
                initialPosition.x = position.x;
                initialPosition.y = position.y;

                
                var decelerateX = (velocity.x > 0),
                    decelerateY = (velocity.y > 0);

                
                if (!offset.scrollPast && !decelerateX && !decelerateY) {
                    
                    stopDecelOnScrollDone.call(this);

                    
                    var axis,
                        offsetObj,
                        bStart,
                        bEnd,
                        supportedEdges;

                    for (axis in offset) {
                        offsetObj = offset[axis];

                        supportedEdges = offsetObj.supportedEdges;

                        bStart = ((offsetObj.start === position[axis]) && ((supportedEdges & INC_EDGE_START) > 0));
                        bEnd = ((offsetObj.end === position[axis]) && ((supportedEdges & INC_EDGE_END) > 0));

                        
                        if (offsetObj.incFetch && (bStart || bEnd)) {
                            
                            this.STATUS_INC_FETCH = true;

                            
                            raiseScrollerEvent(this, 'incFetch', {
                                edge: (bEnd) ? INC_EDGE_END : INC_EDGE_START
                            });
                        }
                    }


                    
                    return;
                }

                
                this.hasBounced = false;
                this.bounceDistance = {};
                this.bounceTime = {};
                this.bounceVelocity = {};

                
                this.decelerating = true;

                var expectedInterval = Math.round(1000 / this.frameRate),           
                    prevTime = startTime,                                           
                    actualInterval,                                                 
                    axisIterator = {
                        x: decelerateX,
                        y: decelerateY
                    };

                
                this.decelerationTimer = window.setTimeout(function () {
                    var scroller = mstrmojo.all[id],
                        origin = scroller.origin,
                        curTime = new Date(),
                        delta = (curTime - startTime),
                        axis;

                    
                    if (scroller._halt) {
                        stopDecelOnScrollDone.call(scroller);
                        return;
                    }

                    
                    actualInterval = curTime - prevTime;
                    prevTime = curTime;

                    if (actualInterval > (expectedInterval + 5)) {
                        expectedInterval = expectedInterval + $M.round((actualInterval - expectedInterval) / 2);
                    }

                    
                    for (axis in axisIterator) {
                        
                        if (axisIterator[axis]) {
                            
                            var newPosition = calculateAxisPosition(scroller, position[axis], axis, direction[axis], velocity[axis], delta, totalTime[axis]);

                            
                            if (!isNaN(newPosition)) {
                                
                                origin[axis] = newPosition;
                            }
                        }
                    }

                    
                    applyPosition(scroller, origin);

                    
                    var stopDecel = (delta > totalTime.x && delta > totalTime.y);
                    if (!stopDecel && !scroller.bounces) {

                        
                        stopDecel = true;

                        
                        mstrmojo.hash.forEach(offset, function (axis, key) {
                            
                            var v = origin[key];

                            
                            if (v !== axis.end && v !== axis.start) {
                                
                                stopDecel = false;

                                
                                return false;
                            }
                        });
                    }

                    
                    if (stopDecel) {
                        stopDecelOnScrollDone.call(scroller);

                    } else if (scroller.decelerating) {
                        
                        scroller.decelerationTimer = window.setTimeout(arguments.callee, expectedInterval);
                    }

                }, expectedInterval);

            },

            
            stopDeceleration: function stopDeceleration() {
                
                var isDecelerating = !!this.decelerating;
                if (isDecelerating) {
                    
                    if (this.decelerationTimer) {
                        
                        window.clearTimeout(this.decelerationTimer);
                        delete this.decelerationTimer;
                    }

                    
                    delete this.decelerating;

                    
                    this.toggleScrollBars(false);
                }

                
                delete this._outOfBounds;
                delete this.hasBounced;
                delete this.bounceDistance;
                delete this.bounceTime;
                delete this.bounceVelocity;
                delete this._halt;

                return isDecelerating;
            },

            haltScroller: function haltScroller() {
                this._halt = !!this.decelerating;
            },

            unrender: function unrender() {
                
                delete this.scrollEl;
            },

            
            destroy: function destroy() {
                
                this.stopDeceleration();

                detachHostedScrollListener.call(this);

                this._super();
            }


        }
    );

    
    mstrmojo.TouchScroller.getScrollPositionTotals = function getScrollPositionTotals(widget) {
        var parent = widget.parent,
            scroller = widget._scroller,
            origin = mstrmojo.hash.copy((scroller && scroller.origin) || {      
                x: 0,
                y: 0
            });

        
        if (parent) {
            
            var parentOrigin = mstrmojo.TouchScroller.getScrollPositionTotals(parent);
            origin.x += parentOrigin.x;
            origin.y += parentOrigin.y;
        }

        return origin;
    };

    
    mstrmojo.TouchScroller.ScrollIndicators = indicators;

    
    $TOUCHSCROLLER.EnumIncFetchEdges = {
        start: INC_EDGE_START,
        end: INC_EDGE_END
    };
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Obj");

    mstrmojo.maps.AndroidMapModel = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,
        
        
        {            
            scriptClass: "mstrmojo.maps.AndroidMapModel",

            getVisProps: function() {
                return this.data.vp;
            },
            
            
            
            setPrompts: function setPrompts(prompts) {},

            getDataService: function getDataService() {},
                        
            execute: function execute(params, callback) {},
            
            answerPrompts: function answerPrompts(callback) {},
            
            getPageByTree: function getPageByTree(callback) {},                        
            
            sort: function sort (params, callback) {},
            
            pivot: function pivot (params, callback) {},
            
            drillGrid: function drillGrid (params, callback) {},
            
            drill2Grid: function drill2Grid (params, callback) {},            

            linkToObject: function linkToObject (params, callback) {},
            
            pageBy: function pageBy(pageByKeys, callback) {},
                        
            saveRWProps: function saveRWProps(nodeKey, props, type, loadData, callback) {}
         
        }
        
 
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.func",
                         "mstrmojo.Obj");

    var $HASH = mstrmojo.hash;
    
    
    var cnt = 0;

    
    var requestQueue = [];

    
    var graphRequests = {};

    
    var holdForGraphs = false;

    
    function handleSubmission(request) {
        var callback = request.callback;

        
        if (callback.submission) {
            
            callback.submission( this.userInteractionRequired( request ) );
        }

        
        this.submitRequest(request);
    }

    
    function submitNextInQueue() {
        
    	
    	
        if (requestQueue.length && !holdForGraphs) {
            
            handleSubmission.call(this, requestQueue.shift());
        }
    }

    
    mstrmojo.ServerProxy = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        
        {
            scriptClass: 'mstrmojo.ServerProxy',

            
            transport: null,

            cnt: 0,

            
            request: function request(callback, params, override, config) {
                
                if (override) {
                    this.cancelRequests();
                }

                var proxyId = this.id,
                    transport = this.transport,
                    requestId = mstrmojo.now() + params.taskId + cnt++,
                    callbackCancel = callback.canceled || mstrmojo.emptyFn;

                
                callback.canceled = function (id) {
                    
                    callbackCancel();

                    
                    callback.complete(true);

                    
                    return transport.cancelRequest(id);
                };

                
                callback = mstrmojo.func.wrapMethods(callback, {
                    complete: function (id) {
                        
                        mstrmojo.all[proxyId].deleteRequest(id);
                    }
                });

                
                
                
                var existingRequests = !$HASH.isEmpty(this._requests),
                    newRequest = this.createRequest(requestId, callback, params, config),
                    
                    holdRequests = (holdForGraphs || existingRequests) && ! config.doNotHold;

                
                if (holdRequests) {
                    
                    requestQueue.push(newRequest);
                } else {
                    
                    handleSubmission.call(this, newRequest);
                }
            },

            
            createRequest: function createRequest(requestId, callback, params, config) {
                var reqsCollection = this._requests;

                
                if (!reqsCollection) {
                    
                    reqsCollection = this._requests = {};
                }

                
                var request = reqsCollection[requestId] = {
                    id: requestId,
                    callback: callback,
                    params: params,
                    config: config
                };

                
                return request;
            },

            
            submitRequest: function submitRequest(request) {
                this.transport.serverRequest(this.id, request.id, request);
            },

            
            cancelRequests: function cancelRequests() {
                var didCancel = false;

                
                $HASH.forEach(this._requests, function (request) {
                    
                    if (typeof request.gotResponse === "undefined") {
                        
                        didCancel |= request.callback.canceled(request.id);
                    }
                });

                
                this._requests = {};

                
                requestQueue = [];

                
                return didCancel;
            },

            
            response: function response(requestId, status, res) {

                
                $MAPF(false, "AndroidServerTransport", 'transportRequest');

                
                var request = this.getRequest(requestId);
                if (request) {
                    
                
                request.gotResponse = true;

                    
                var callback = request.callback,
                    methodName = (status && !res.mstrerr) ? 'success' : 'failure';  

                try {
                    
                    if (callback[methodName]) {
                        
                        callback[methodName](res, request);
                    }
                } finally {
                    
                    callback.complete(requestId);
                }
                }

                
                submitNextInQueue.call(this);
            },

            
            deleteRequest: function deleteRequest(requestId) {
                var requestCollection = this._requests;
                delete requestCollection[requestId];
            },

            
            getRequest: function getRequest(requestId) {
                var requestCollection = this._requests;
                return requestCollection && requestCollection[requestId];
            },
      
                  
            userInteractionRequired: function userInteractionRequired(request) {
                return false;
            },

            
            addLoadingGraph: function addLoadingGraph(key) {
                
                graphRequests[key] = true;

                
                holdForGraphs = true;
            },

            
            removeLoadingGraph: function removeLoadingGraph(key) {
                
                delete graphRequests[key];

                
                if ($HASH.isEmpty(graphRequests)) {
                    
                    holdForGraphs = false;

                    
                    submitNextInQueue.call(this);
                }
            }
        }
    );
}());
(function() {
	
    mstrmojo.requiresDescs(8409);
    
    mstrmojo.prompt.WebPrompt = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,

        
        {
            scriptClass: 'mstrmojo.prompt.WebPrompt',
            
            
            promptType: 0,
            
            
            prs: null,
            
            
            pt: 0,
            
            
            pin: 0,
            
            
            loc: null,
            
            
            title: '',
            
            
            mn: '',
            
            
            req: false,
            
            
            min: null,
            
            
            max: null,
            
            
            dataSourcesXML: '',
            
            getStyle: mstrmojo.emptyFn,
            
            
            getDisplayValue: mstrmojo.emptyFn,
            
            
            validate: function validate(v){
            	if (this.isAnswerEmpty(v) && this.req) {
            		 throw new Error(mstrmojo.desc(8409, 'This prompt (#) requires an answer.').replace('#', this.title)); 
            	}
            },
            
            
            prepareAnswer: function prepareAnswer(callbacks){
                var fn = callbacks && callbacks.success;
                if (fn) {
                    fn();
                }
            },
            
            
            getAnswerXML: function getAnswerXML() {
                var buf = new mstrmojo.XMLBuilder();
                this.buildShortPa(buf);
                return buf.toString();
            },
            
            
            buildShortAnswerXML: function buildShortAnswerXML(builder) {
                
                return builder;
            },
            
            
            buildShortPa: function buildShortPa(builder) {
                builder.addChild("pa");
                builder.addAttribute("pt", this.pt);
                
                var loc = this.loc;
                if (loc) {
                    builder.addAttribute("pin", loc.pin);
                    builder.addAttribute("did", loc.did);
                    builder.addAttribute("tp", loc.t);
                }
                
                
                this.buildShortAnswerXML(builder);
                builder.closeElement();
            },
            
            
            populateAnswer: function populateAnswer(ans){
                
            },
            
            
            setAnswerValue: mstrmojo.emptyFn,
            
            
            isAnswerEmpty: function isAnswerEmpty(v){
                
                return false;
            },
            
            
            populate: function populate(props) {
                this.promptType = props.ptp;
                this.pt = props.dptp;
                this.mn = props.mn;
                this.pin = props.pin;
                this.title = props.ttl;
                this.loc = props.loc;
                this.min = props.min || '';
                this.max = props.max || '';
                this.req = props.reqd;
                this.dataSourcesXML = props.dsrcs;
                
                
                var prs = this.prs = {};
                mstrmojo.array.forEach(props.prs, function (p) {
                    prs[p.n] = p.v;
                });
                this.hasAnswer = props.hasAns;
            },
            
            buildAnswerObject: function buildAnswerObject() {
                return {
                    
                    
                };
            },
            
            supported: function supported() {
            	return true;
            }
        }
    );
    
    mstrmojo.prompt.WebPrompt.TYPES = {
        CONSTANT_PROMPT: 1,
        CONSTANT_GEO_PROMPT: 1.5,
        ELEMENTS_PROMPT: 2            
    };
    
    mstrmojo.prompt.WebPrompt.STYLES = {
        TEXT: 1,
        LIST: 2,
        STEPPER: 3,
        SWITCH: 4,
        SLIDER: 5,
        CALENDAR: 6,
        TIME: 7,
        GEO: 8,
        BARCODE: 9
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.StringBuffer",
                         "mstrmojo.hash",
                         "mstrmojo.dom",
                         "mstrmojo._IsGraphDataService",
                         "mstrmojo.func");

    mstrmojo.requiresDescs(8445);

    var $H = mstrmojo.hash;
    var $DOM = mstrmojo.dom;
    var $PST = [mstrmojo.desc(8445, 'Loading')];
    var updateNum = 0;

    function submitRequest(params, callback, config) {
        var updateId = updateNum++,
        	updates = this.getTxUpdates(updateId);
        
        config = config || {};
        config.src = arguments.callee.caller.name;

        if (!mstrmojo.string.isEmpty(updates)) {
            params.updateChanges = updates;
        }

        
        mstrApp.serverRequest(params, this.wrapCallback(callback, updateId), config);
    }

    function addContentSize(request) {

    	
    	var availableDim = window.mstrMobileApp ? this.model.controller.getContentDimensions() : mstrApp.getContentDimensions();

        if (availableDim) {
            
            request.styleName = 'RWDocumentMobileStyle';
            request.availableWidth = availableDim.w;
            request.availableHeight = availableDim.h;
        }
    }

    
    mstrmojo.DocDataService = mstrmojo.declare(
        mstrmojo.Obj,

        [mstrmojo._IsGraphDataService],

        
        {
            scriptClass: "mstrmojo.DocDataService",

            wrapCallback: function wrapCallback(callback, updateId) {
                var me = this;
                return mstrmojo.func.wrapMethods({
                    success: function (res) {
                        if (res) {
                            me.rwb = res.bs || me.rwb;
                            me.msgId = res.mid || me.msgId;
                        }
                        me.clearTxUpdates(updateId);
                    }, failure: function (res) {
                    	me.resetTxUpdates(updateId);
                    }
                }, callback);
            },

            refresh: function refresh(params, callback) {

            	var isRefresh = !!params.useRefreshProgress,
            		pst = isRefresh ? [mstrmojo.desc(10078, 'Refreshing data. Please wait.')] : $PST;

            	delete params.useRefreshProgress;

            	submitRequest.call(this, $H.copy(params, {
                    taskId: 'docRefresh',
                    rwb: this.rwb,
                    rePrompt: false,
                    fresh: false,
                    regenerate: false
                }), callback,  {
                    showProgress:true,
                    hideProgress:true,
                    progressStateText: pst,
                    useRefreshProgress: isRefresh
                });
            },

            getTxUpdates: function getTxUpdates(t) {
                var m = this.model;
                return m && m.getTransactionUpdates && m.getTransactionUpdates(t);
            },

            clearTxUpdates: function clearTxUpdates(t) {
                var m = this.model;
                if (m && m.clearTransactionUpdates) {
                    m.clearTransactionUpdates(t);
                }
            },

            resetTxUpdates: function resetTxUpdates(t) {
                var m = this.model;
                if (m && m.resetTransactionUpdates) {
                    m.resetTransactionUpdates(t);
                }
            },

            loadDocLayout: function loadDocLayout(params, callback) {
                
                var taskParams = $H.copy(params, {
                    taskId: 'loadDocLayout',
                    rwb: this.rwb
                });

                
                addContentSize.call(this, taskParams);

                
                submitRequest.call(this, taskParams, callback, {
                        showProgress:true,
                        hideProgress:true,
                        progressStateText: $PST
                    }
                );

            },

            setCurrentDocLayout: function setCurrentDocLayout(layoutKey, callback) {
                callback = callback || null;

                submitRequest.call(this, {
                    taskId: 'setDocLayout',
                    rwb: this.rwb,
                    layoutKey: layoutKey
                }, callback, {
                    silent: (callback === null)
                });

                if(typeof mstrMobileApp !== 'undefined') {
                	mstrMobileApp.clearWebViewCache(false);
                }
            },

            fetchDocPage: function fetchDocPage(position, callback) {
                submitRequest.call(this, {
                    taskId: 'fetchDocPage',
                    rwb: this.rwb,
                    pos: position
                }, callback);
            },

            
            setCurrentPanel: function setCurrentPanel(panelKey, panelStackKey, selectorKeyContext, callback) {
                submitRequest.call(this, {
                    taskId: 'setCurrentPanel',
                    rwb: this.rwb,
                    key: panelKey,
                    panelStackKey: panelStackKey,
                    selectorKeyContext: selectorKeyContext
                }, callback, {
                    silent: true   
                });
            },

            
            requestNewPanel: function requestNewPanel(panelKey, panelStackKey, selectorKeyContext, dirtyKeys, useLoader, callback) {
                submitRequest.call(this, {
                    taskId: 'requestNewPanel',
                    rwb: this.rwb,
                    key: panelKey,
                    panelStackKey: panelStackKey,
                    selectorKeyContext: selectorKeyContext,
                    dirtyKeys: dirtyKeys
                }, callback, {
                    showProgress: useLoader,
                    hideProgress: useLoader,
                    progressStateText: $PST
                });
            },

            
            applyGraphSelectorAction: function applyGraphSelectorAction(selectorKeyContext, targetList, sliceID, x, y, callback, zoomFactor) {
                submitRequest.call(this, {
                    taskId: 'applyGraphSelectorAction',
                    rwb: this.rwb,
                    selectorKeyContext: selectorKeyContext,
                    ctrlKeys: targetList,
                    sliceID: sliceID,
                    x: x,
                    y: y,
                    zoomFactor : zoomFactor
                }, callback);
            },

            
            setDocSelectorElements: function setDocSelectorElements(selectorKeyContext, elemList, controlKey, includeClause, callback, zoomFactor, useAndroidTask, sdpKeys, tks, disablePU) {
                var params = {
                    taskId: 'setDocSelectorElements',
                    rwb: this.rwb,
                    selectorKeyContext: selectorKeyContext,
                    elemList: elemList,
                    ctlKey: controlKey,
                    zoomFactor : zoomFactor
                };

                if ($DOM.isAndroid || useAndroidTask) {
                    params.taskId = 'androidSetDocSelectorElements';
                }

                if (includeClause !== null && includeClause !== undefined) {
                    params.include = includeClause;
                }

                if(sdpKeys)
        		{
        		   params.sdpKeys = sdpKeys;
        		}
                if ( tks ) {
                    params.tks = tks;
                }
                
                if (disablePU) {
                	params.usePartialUpdate = '0';
                }

                submitRequest.call(this, params, callback, {
                    showProgress: true,
                    hideProgress: true,
                    progressStateText: $PST,
                    delay: true
                });
            },

            
            setDocVisSelectorElements: function setDocVisSelectorElements(selectorKeyContext, elemList, controlKey, includeClause, callback, zoomFactor, useAndroidTask, sdpKeys, tks) {
                var params = {
                    taskId: 'setDocVisSelectorElements',
                    rwb: this.rwb,
                    selectorKeyContext: selectorKeyContext,
                    elemList: elemList,
                    ctlKey: controlKey,
                    zoomFactor : zoomFactor
                };

                if ($DOM.isAndroid || useAndroidTask) {
                    params.taskId = 'androidSetDocSelectorElements';
                }

                if (includeClause !== null && includeClause !== undefined) {
                    params.include = includeClause;
                }

                if(sdpKeys)
                {
                   params.sdpKeys = sdpKeys;
                }

                if ( tks ) {
                    params.tks = tks;
                }

                submitRequest.call(this, params, callback, {
                    showProgress: true,
                    hideProgress: true,
                    progressStateText: $PST,
                    delay: true
                });
            },


            
            setMultiDocSelectorElements: function setMultiDocSelectorElements(selectorObjects, multiSelect, callback, zoomFactor) {
                var params = {
                    taskId: 'setMultiDocSelectorElements',
                    rwb: this.rwb,
                    multiSelect: multiSelect,
                    selectorObjects: selectorObjects,
                    zoomFactor : zoomFactor
                };

                submitRequest.call(this, params, callback, {
                    showWait: true,
                    hideWait: true,
                    delay: true
                });
            },

            
            setDocSelectorExpression: function setDocSelectorExpression(unitKeyContext, controlKey, objectId, objectType, expressionFunction, expressionFunctionType, includeClause, expressionConstants, dataType, callback, zoomFactor, unset) {
                var params = {
                    taskId: 'setDocSelectorExpression' + (unset ? 'Unset' : ''),
                    rwb: this.rwb,
                    unitKeyContext: unitKeyContext,
                    ctlKey: controlKey,
                    objectId: objectId,
                    objType: objectType,
                    expFunction: expressionFunction,
                    expFunctionType: expressionFunctionType,
                    zoomFactor : zoomFactor
                };

                if (includeClause !== null && includeClause !== undefined) {
                    params.include = includeClause;
                }

                if (expressionConstants !== null && expressionConstants !== undefined) {
                    params.expConstants = expressionConstants;
                }

                if (dataType !== null && dataType !== undefined) {
                    params.dataType = dataType;
                }

                submitRequest.call(this, params, callback);
            },

            
            setDocSelectorInclude: function setDocSelectorInclude(controlKey, includeClause, callback, objectID, objectType, zoomFactor) {
                var params = {
                    taskId: 'setDocSelectorInclude',
                    rwb: this.rwb,
                    include: includeClause,
                    ctlKey: controlKey,
                    zoomFactor : zoomFactor
                };

                if (objectID) {
                    params.objectID = objectID;
                }

                if (objectType) {
                    params.objType = objectType;
                }

                submitRequest.call(this, params, callback);
            },

            
            setDocUnsetSelector: function setDocUnsetSelector(unitKeyContext, ctlKey, callback, zoomFactor) {
                submitRequest.call(this, {
                    taskId: 'unsetSelector',
                    rwb: this.rwb,
                    unitKeyContext: unitKeyContext,
                    ctlKey: ctlKey,
                    zoomFactor: zoomFactor
                }, callback);
            },

            
            getRWGraphImage: function getRWGraphImage(params, callback) {
                var app = mstrApp,
                    id = this.id,
                    p = {
                        taskId: 'getRWGraphImage',
                        taskEnv: 'xhr',
                        imgType: 4,
                        messageID: this.msgId,
                        nodeKey: params.k,
                        sliceID: parseInt(params.sid, 10),
                        width: parseInt(params.w, 10),
                        height: parseInt(params.h, 10)
                    };

                
                
                
                if (app.onMobileDevice() && app.useBinaryFormat) {
                    
                    window.setTimeout(function () {
                        submitRequest.call(mstrmojo.all[id], p, callback);
                    }, 0);

                } else {
                    if (params.encodeImage) {
                        
                        p.taskContentEncoding = 'base64';

                        
                        delete p.taskEnv;

                        
                        submitRequest.call(this, p, {
                            success: function (res) {
                                callback.success('data:image/png;base64,' + res);
                            },
                            failure: function (err) {
                                (callback.failure || app.onerror)(err);
                            }
                        });

                    } else {
                        var cfg = app.getConfiguration(),
                            projectId = app.getCurrentProjectId(),
                            values = new mstrmojo.StringBuffer();

                        
                        p.__ts__ = new Date().getTime();
                        p.sessionState = app.getSessionState(projectId);

                        
                        $H.forEach(p, function (v, n) {
                            
                            values.append(n + '=' + encodeURIComponent(v));
                        });

                        
                        callback.success(cfg.getTaskUrlByProject(projectId) + '?' + values.toString('&'));
                    }
                }
            },

            getImage: function getImage(url) {
                var app = mstrApp,
                    config = app.getConfiguration();

                if (config && url && url.indexOf('://') === -1) {
                    
                    url = config.getHostUrlByProject(app.getCurrentProjectId()) + url;
                }

                return (mstrApp.useBinaryFormat) ? String(mstrMobileApp.getImage(url)) : url;
            },

            getDocImage: function getDocImage(url) {
                return this.getImage(url);
            },

            setQuickSwitchViewMode: function setQuickSwitchViewMode(gridKeyContext, displayMode) {
                submitRequest.call(this, {
                    taskId: 'setDisplayMode',
                    gridKeyContext: gridKeyContext,
                    messageID: this.msgId,
                    displayMode: displayMode
                }, null, {
                    silent: true
                });
            },

            setRWUnitProperties: function setRWUnitProperties(key, props, formatType, returnData, callback) {
                submitRequest.call(this, {
                    taskId: 'setRWUnitProperties',
                    rwb: this.rwb,
                    nodeKey: key,
                    props: props,
                    formatType: formatType,
                    returnData: returnData
                }, callback, {
                    silent: true
                });
            },

            setDocZoom: function setDocZoom(params, callback) {
                submitRequest.call(this, {
                    taskId: 'setDocZoom',
                    rwb: this.rwb,
                    zoomType: params.zoomType,
                    zoomFactor: params.zoomFactor
                }, callback);
            },

            sort: function sort(params, callback) {
                submitRequest.call(this, $H.copy(params, {
                    taskId: 'DocSort',
                    rwb: this.rwb
                }), callback);
            },

            pivot: function pivot(params, callback) {
                var request = $H.copy(params, {
                    messageID: this.msgId,
                    rwb: this.rwb
                });

                request.key = params.nodeKey;
                delete request.nodeKey;
                request.taskId = params.formID ? 'docPivotForm' : 'docPivot';

                submitRequest.call(this, request, callback);
            },

            drillGrid: function drillGrid(params, callback) {
                submitRequest.call(this, {
                    taskId: 'DocDrill',
                    messageID: this.msgId,
                    nodeKey: params.nodeKey,
                    drillPathIndex: params.drillPathIndex, 
                    drillPathKey: params.drillPathKey,
                    elementList: params.drillElements
                }, callback, {
                    showProgress: true,
                    hideProgress: true,
                    progressStateText: $PST,
                    delay: true
                });
            },

            changeDocGroupBy: function changeDocGroupBy(params, callback, config) {
                var request = {
                    taskId: 'changeDocGroupBy',
                    rwb: this.rwb,
                    messageID: this.msgId,
                    treesToRender: 3
                };

                if ( params.flags) {
                	request.flags = params.flags;
                }
                if (params.groupbyKey) {
                    request.groupByKey = params.groupbyKey;
                    request.elementID = params.elementId;
                } else {
                    request.gbUnits = params.gbUnits;
                }

                
                addContentSize.call(this, request);

                submitRequest.call(this, request, callback, config);
            },

            downloadGridData: function downloadGridData(params, callback) {
                submitRequest.call(this, {
                    taskId: 'DocXtabIncrementalFetch',
                    rwb: this.rwb,
                    nodeKey: params.nodeKey,
                    rowPosition: params.rowPosition,
                    maxRows: params.maxRows,
                    colPosition: params.colPosition,
                    sliceId: params.sliceId,
                    maxColumns: params.maxColumns
                }, callback);
            },

            txMarkRows: function txMarkRows(params, callback) {
                submitRequest.call(this, {
                    taskId: 'markRow',
                    rwb: this.rwb,
                    nodeKey: params.nodeKey,
                    sliceId: params.sliceId,
                    rowOrdinal: params.rowOrdinal,
                    actionType: params.actionType
                }, callback);
            },

            txChangeData: function txChangeData(params, callback) {
                submitRequest.call(this, {
                    taskId: 'changeData',
                    rwb: this.rwb,
                    nodeKey: params.nodeKey,
                    sliceId: params.sliceId,
                    cells: params.cells,
                    autoRefresh: params.autoRefresh
                }, callback);
            },

            sendTransactionActions: function sntTxActs(params, callback) {
                var request = {
                    taskId: 'DocTransaction',
                    rwb: this.rwb,
                    keyContext: params.keyContext,
                    actions: params.actions,
                    messageID: this.msgId
                    };

                
                if(params.txrcd) {
                    request.isPending = params.txrcd.pending;
                    request.timestamp = params.txrcd.timestamp;
                }

                submitRequest.call(this, request, callback, {silent: !!callback}); 
            },

            RWEventsTask: function RWEventsTask(params, callback){
                submitRequest.call(this, {
                    taskId: 'RWEventsTask',
                    rwb: this.rwb,
                    messageID: params.messageID,
                    styleName: params.styleName,
                    events: params.events
                }, callback);
            },

            getPageByTree: function getPageByTree(callback) {
                mstrApp.serverRequest({
                    taskId: 'getPageByTree',
                    msgID: this.msgId
                }, callback);
            },

            resetSelections: function resetSelections(unitKeyContext, disablePU, callback) {
            	submitRequest.call(this, {
            		taskId: 'resetSelections',
            		rwb: this.rwb,
            		unitKeyContext: unitKeyContext || '',
            		usePartDisplay: disablePU ? '0' : '1'
            	}, callback);
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.hash");

    mstrmojo.touchManager = new mstrmojo.Obj({
        notify: function (srcId, touch) {
            return this.raiseEvent({
                name: 'touchesBegin',
                srcId: srcId,
                touch: touch
            });
        }
    });

    var $D = mstrmojo.dom,
        $DAE = $D.attachEvent,
        $DDE = $D.detachEvent,
        $MATH = Math,
        $C = window.mstrConfig,
        debug = false,                                                  
        activeWinListener = null,                                       
        defaultTouchConfiguration = $C && $C.allowDefaultTouches;

    
    var SWIPE_THRESHOLD = 10,
        TAP_TIMEOUT = 250,
        SELECT_DURATION = 400,
        MIN_DELTA_BETWEEN_MOVE_EVENTS = 100;

    
    var EVT_BEGIN = 'Begin',
        EVT_END = 'End',
        EVT_MOVE = 'Move',
        EVT_CANCEL = 'Cancel';

    
    var ACTION_SELECT = 1,
        ACTION_SWIPE = 2,
        ACTION_MULTI = 3,
        ACTION_TAP = 4;

    var actionMethodMap = {};
    actionMethodMap[ACTION_SELECT] = 'Select';
    actionMethodMap[ACTION_SWIPE] = 'Swipe';
    actionMethodMap[ACTION_MULTI] = 'Multi';
    actionMethodMap[ACTION_TAP] = 'Tap';

    
    
    $DAE(document.body, $D.TOUCHMOVE, function (evt) {
        
        if (!$C || !$C.allowDefaultTouches) {
            if (evt.preventDefault) {
                evt.preventDefault();
                return false;
            }
        }

        return true;
    });

    
    function getEvtIdentifier(evt) {
        var id = evt.identifier;
        return (id === undefined) ? 1 : id;
    }

    function debugLog(cmd, msg, widget, evt) {
        
        if (debug) {
            
            var touchId = (evt) ? getEvtIdentifier(evt) + ' ' : '';
            window.console.log(cmd + ':' + ((widget) ? ' ' + widget.scriptClass + ' ' + widget.id : '') + ' ' + touchId + (msg || ''));
        }
    }

    
    function isActive(widget) {
        return (activeWinListener === widget);
    }

    
    function detachWinEvts(widget) {
        
        if (!isActive(widget)) {
            
            return;
        }

        debugLog('detachWinEvts', '', widget);

        
        $DDE(window, $D.TOUCHMOVE, widget._tmCallback, true);
        $DDE(window, $D.TOUCHEND, widget._teCallback, true);
        $DDE(window, $D.TOUCHCANCEL, widget._teCallback, true);

        
        activeWinListener = null;
    }

    
    function attachWinEvts(widget) {
        
        if (isActive(widget)) {
            
            return;
        }

        
        var activeWidget = activeWinListener;
        if (activeWidget) {
            debugLog('forced deactivation', '', activeWidget);

            
            detachWinEvts(activeWidget);
        }

        debugLog('attachWinEvts', '', widget);

        
        $DAE(window, $D.TOUCHMOVE, widget._tmCallback, true);
        $DAE(window, $D.TOUCHEND, widget._teCallback, true);
        $DAE(window, $D.TOUCHCANCEL, widget._teCallback, true);

        
        activeWinListener = widget;
    }

    function getWidgetHandlerMethodName(evtName, action) {
        return 'touch' + ((action && actionMethodMap[action]) || '') + (evtName || '');
    }

    
    function getWidgetHandler(widget, evtName, action) {
        
        var methodName = getWidgetHandlerMethodName(evtName, action);

        
        return (widget[methodName] !== undefined) ? methodName : '';
    }

    
    function fireWidgetHandler(widget, evtName, touch, action, gesture) {
        
        gesture = gesture || widget.gestures[touch.id];

        var target = (gesture && gesture.bubbleTarget) || widget,
            methodName = getWidgetHandler(target, evtName, action);

        if (methodName) {
            debugLog('fire', methodName, target);

            
            touch.methodName = methodName;

            
            return target[methodName](touch);
        }
        debugLog('no handler', getWidgetHandlerMethodName(evtName, action), target);

        return true;
    }

    
    function createTouchObject(e, startTouch, changedTouch, lastTouch) {
        var pageX = changedTouch.pageX,
            pageY = changedTouch.pageY,
            timeStamp = e.timeStamp,
            id = getEvtIdentifier(changedTouch),
            delta = {
                x: $MATH.round(pageX - startTouch.pageX),
                y: $MATH.round(pageY - startTouch.pageY)
            };

        var evt = {
            id: id,
            evt: e,
            pageX: pageX,
            pageY: pageY,
            clientX: changedTouch.clientX,
            clientY: changedTouch.clientY,
            target: changedTouch.target,
            delta: delta,
            date: timeStamp,
            stop: function () {
                debugLog('event stopped', id);

                
                e.stopPropagation();
                e.cancelBubble = true;
            }
        };

        if (lastTouch) {
            
            var timeDelta = timeStamp - lastTouch.date,
                lastDelta = lastTouch.delta,
                accelDelta = {
                    x: $MATH.abs(delta.x - lastDelta.x),
                    y: $MATH.abs(delta.y - lastDelta.y)
                };

            
            evt.velocity = {
                x: accelDelta.x / timeDelta,
                y: accelDelta.y / timeDelta
            };

            
            evt.isVertical = (accelDelta.y > accelDelta.x);

            
            evt.accelDelta = accelDelta;

            
            var direction = evt.direction = {};

            
            if (pageX !== lastTouch.pageX) {
                direction.x = (pageX < lastTouch.pageX);
            } else if (pageX !== startTouch.pageX) {
                direction.x = (pageX < startTouch.pageX);
            }

            if (pageY !== lastTouch.pageY) {
                direction.y = (pageY < lastTouch.pageY);
            } else if (pageX !== startTouch.pageX) {
                direction.y = (pageY < startTouch.pageY);
            }
        }

        return evt;
    }

    
    function createGestureObject(touch, previousOneTouch, previousTwoTouch, evt) {
        return {
            s: touch,
            p1: previousOneTouch,
            p2: previousTwoTouch,
            evt: evt,
            target: evt.target
        };
    }

    
    function deleteBubbleTargetGesture(target, touchId) {
        if (target) {
            target.gestures[touchId] = null;
        }
    }

    
    function cancelTouch(widget, touchObject) {
        detachWinEvts(widget);

        fireWidgetHandler(widget, EVT_END, touchObject);
    }

    
    function cancelSelect(widget) {
        if (widget._selectHandle) {
            
            window.clearTimeout(widget._selectHandle);

            delete widget._selectHandle;

            debugLog('cancelSelect', '', widget);
        }
    }

    
    function touchesBegin(widget, e) {
        
        var which = e.which;
        if (which && which === 3) {
            debugLog('ignore', 'right mouse click', widget);

            
            return;
        }

        
        var gestures = widget.gestures,
            touches = e.touches || [ e ],
            changedTouch = (e.changedTouches && e.changedTouches[0]) || e,
            isWidgetActive = isActive(widget),
            touchObject = createTouchObject(e, changedTouch, changedTouch),          
            gesture = createGestureObject(touchObject, touchObject, touchObject, e);

        debugLog('touchBegin', '', widget, changedTouch);

        
        if (touches.length > 1) {
            
            if (!isWidgetActive) {
                
                touchObject.stop();

                debugLog('ignore', 'cross widget multitouch', widget, changedTouch);
                
                var activeWidget = activeWinListener;
                if (activeWidget && activeWidget.onCrossWidgetMultitouch !== undefined) {
                    debugLog('call onCrossWidgetMultitouch for', '', activeWidget);
                    activeWidget.onCrossWidgetMultitouch();
                }
                return false;

            }
        } else {
            
            if (isWidgetActive) {
                debugLog('forced deactivation', '', widget, changedTouch);

                
                detachWinEvts(widget);

                
                isWidgetActive = false;
            }
        }

        
        if (widget.singleNode && changedTouch.target !== widget._tn) {
            debugLog('ignore', 'target is not touch node', widget, changedTouch);

            return;
        }

        
        if (mstrmojo.touchManager.notify(widget.id, touchObject).ignore) {
            
            touchObject.stop();
            return;
        }

        
        if (!isWidgetActive) {
            
            var tagName = touchObject.target.tagName;
            tagName = tagName && tagName.toLowerCase();

            
            if (tagName === 'select' || tagName === 'input') {
                debugLog('ignore', 'target is input or select', widget, changedTouch);

                
                if (widget.monitorInputs) {
                    
                    fireWidgetHandler(widget, null, touchObject, ACTION_TAP);
                }

                
                return;
            }
        }

        
        gestures[touchObject.id] = gesture;

        
        if (isWidgetActive) {

            
            if (!widget.multiTouch) {
                
                cancelSelect(widget);

                
                var prevTouch = touches[touches.length - 2],
                    prevGesture = gestures[getEvtIdentifier(prevTouch)];

                fireWidgetHandler(widget, EVT_CANCEL, prevTouch, prevGesture.action, prevGesture);
            } else {
                
                gesture.action = ACTION_MULTI;

                
                if (widget._singleTouch) {
                    
                    cancelSelect(widget);

                    
                    widget._singleTouch.action = ACTION_MULTI;

                    
                    delete widget._singleTouch.bubbleTarget

                    
                    delete widget._singleTouch;

                    
                    fireWidgetHandler(widget, EVT_BEGIN, touchObject, ACTION_MULTI);
                }
            }

            
            touchObject.stop();

            
            return;
        }

        
        if (!$D.contains(widget._tn, e.target, true, widget.domNode)) {
            
            delete gestures[touchObject.id];

            
            return;
        }

        
        widget._singleTouch = gesture;

        
        if (fireWidgetHandler(widget, EVT_BEGIN, touchObject) === false) {
            
            return;
        }

        
        touchObject.stop();

        
        if (getWidgetHandler(widget, EVT_BEGIN, ACTION_SELECT)) {
            
            widget._selectHandle = window.setTimeout(function () {
                
                gesture.action = ACTION_SELECT;

                
                if (fireWidgetHandler(widget, EVT_BEGIN, touchObject, ACTION_SELECT) === false) {
                    
                    cancelTouch(widget, touchObject);
                }

                
                delete widget._selectHandle;
            }, SELECT_DURATION);
        }

        
        attachWinEvts(widget);
    }

    
    function touchesMoved(widget, e) {
        var changedTouch = (e.changedTouches && e.changedTouches[0]) || e,
            gesture = widget.gestures[getEvtIdentifier(changedTouch)];

        
        if (!gesture) {
            
            return;
        }

        var touchObject = createTouchObject(e, gesture.s, changedTouch, gesture.p2),
            action = gesture.action;

        
        gesture.p2 = gesture.p1;
        gesture.p1 = touchObject;

        
        if (!action && ($MATH.abs(touchObject.delta.x) > SWIPE_THRESHOLD || $MATH.abs(touchObject.delta.y) > SWIPE_THRESHOLD)) {
            
            action = gesture.action = ACTION_SWIPE;

            
            cancelSelect(widget);

            
            if (!getWidgetHandler(widget, EVT_BEGIN, action) && !getWidgetHandler(widget, EVT_MOVE, action)) {
                
                touchObject.methodName = getWidgetHandlerMethodName(EVT_BEGIN, action);

                
                return widget.bubbleTouchEvent(touchObject);
            }

            
            if (fireWidgetHandler(widget, EVT_BEGIN, touchObject, action) === false) {
                
                cancelTouch(widget, touchObject);
                return;
            }
        }

        
        if (action) {
            var lastMove = gesture.lastMove || gesture.s.date,
                delta = touchObject.date - lastMove;

            
            
            
            if (!mstrApp.isTouchApp() || delta >= MIN_DELTA_BETWEEN_MOVE_EVENTS) {
                gesture.lastMove = touchObject.date;
                fireWidgetHandler(widget, EVT_MOVE, touchObject, action);
            }
        }
    }

    
    function touchesEnd(widget, e) {
        var changedTouch = (e.changedTouches && e.changedTouches[0]) || e,
            touchCount = (e.touches && e.touches.length) || 0,          
            gestures = widget.gestures,
            touchId = getEvtIdentifier(changedTouch),
            gesture = gestures[touchId];

        
        if (!gesture) {
            debugLog('No gesture', touchId, widget, changedTouch);

            
            return;
        }

        var action = gesture.action,
            touchObject = createTouchObject(e, gesture.s, changedTouch, gesture.p2);

        
        if (!action) {
            
            cancelSelect(widget);

            
            if (!gesture.wasMulti) {
                action = ACTION_TAP;
            }
        }

        
        if (touchCount === 0) {
            
            detachWinEvts(widget);

            
            widget.gestures = [];

            debugLog('gestures', 'clear all', widget, changedTouch);
        } else {
            
            gestures[touchId] = null;

            debugLog('gestures', 'clear single', widget, changedTouch);
        }

        
        deleteBubbleTargetGesture(gesture.bubbleTarget, touchId);

        
        switch (action) {
        case ACTION_SWIPE:
        case ACTION_SELECT:
            
            touchObject.stop();
            fireWidgetHandler(widget, EVT_END, touchObject, action, gesture);
            break;

        case ACTION_MULTI:
            
            if (touchCount < 2) {
                
                fireWidgetHandler(widget, EVT_END, touchObject, action, gesture);

                
                if (touchCount === 1) {
                    
                    var remainingTouch = e.touches[0],
                        rebasedTouch = createTouchObject(e, remainingTouch, remainingTouch),
                        newGesture = createGestureObject(rebasedTouch, rebasedTouch, rebasedTouch, e);

                    
                    newGesture.wasMulti = true;

                    
                    gestures[getEvtIdentifier(remainingTouch)] = newGesture;

                    
                    widget._singleTouch = newGesture;
                }
            }

            
            if (touchCount > 0) {
                
                return;
            }
            break;

        case ACTION_TAP:
            
            if (!getWidgetHandler(widget, null, action)) {
                
                break;
            }
            
            
            

            
            var tapHandler = widget._tapHandler;
            if (tapHandler) {
                
                window.clearTimeout(tapHandler.h);
            }

            
            if (touchObject.date - gesture.s.date < SELECT_DURATION) {
                
                if (fireWidgetHandler(widget, 'Before', touchObject, action, gesture) === false) {
                    
                    break;
                }

                if (!widget.multiTap) {
                    
                    touchObject.count = 1;

                    
                    fireWidgetHandler(widget, null, touchObject, action, gesture);

                } else {
                    
                    if (tapHandler) {
                        
                        tapHandler.count++;
                    } else {
                        
                        tapHandler = widget._tapHandler = {
                            count: 1
                        };
                    }

                    
                    
                    tapHandler.h = window.setTimeout(function () {
                        
                        touchObject.count = tapHandler.count;

                        
                        fireWidgetHandler(widget, null, touchObject, action, gesture);

                        
                        delete widget._tapHandler;
                    }, TAP_TIMEOUT);
                }

            } else {
                
                delete widget._tapHandler;
            }
            break;
        }


        
        fireWidgetHandler(widget, EVT_END, touchObject, undefined, gesture);
    }

    
    function attachTouchEvents(widget) {

        
        var touchNode = widget._tn;
        if (!touchNode) {
            
            return;
        }

        
        if (!widget._tmCallback) {
            
            widget._tsCallback = function (e) {
                touchesBegin(widget, e);
            };
            widget._tmCallback = function (e) {
                touchesMoved(widget, e);
            };
            widget._teCallback = function (e) {
                touchesEnd(widget, e);
            };
        }

        
        $DAE(touchNode, $D.TOUCHSTART, widget._tsCallback);
    }

    
    mstrmojo._TouchGestures = mstrmojo.provide(
        "mstrmojo._TouchGestures",
        
        {
            _mixinName: 'mstrmojo._TouchGestures',

            
            singleNode: false,

            
            multiTouch: false,

            
            touchNode: null,

            
            multiTap: false,

            
            monitorInputs: false,

            
            postBuildRendering: function postBuildRendering() {
                if (this._super) {
                    this._super();
                }

                
                this._tn = this.touchNode || this.domNode;

                
                this.gestures = [];

                
                attachTouchEvents(this);
            },

            
            bubbleTouchEvent: function bubbleTouchEvent(touch) {
                var evtName = touch.methodName,
                    touchId = touch.id,
                    gesture = this.gestures[touchId],
                    p = this.parent;

                
                while (p) {
                    
                    var targetMethod = p[evtName],
                        touchBegin = p.touchBegin;

                    
                    if (targetMethod && (!touchBegin || fireWidgetHandler(p, EVT_BEGIN, touch) !== false)) {
                        
                        touch.methodName = evtName;

                        
                        deleteBubbleTargetGesture(gesture.bubbleTarget, touchId);

                        
                        gesture.bubbleTarget = p;

                        
                        p.gestures[touchId] = gesture;

                        
                        debugLog('bubble', ((this.k) ? ' ' + this.k : '') + '] bubbled ' + evtName + ' to [' + p.scriptClass + ((p.k) ? ' ' + p.k : '') + ']', this, touch);

                        
                        return targetMethod.call(p, touch);
                    }

                    
                    p = p.parent;
                }

                return false;
            },

            
            unrender: function unrender(ignoreDom) {
                
                if (isActive(this)) {
                    
                    detachWinEvts(this);
                }

                
                var touchNode = this._tn;
                if (touchNode) {
                    
                    $D.detachEvent(touchNode, $D.TOUCHSTART, this._tsCallback);
                }

                this._super(ignoreDom);
            },

            
            restoreDefaultTouches: function restoreDefaultTouches(resetFlag) {
                if ($C) {
                    
                    $C.allowDefaultTouches = resetFlag && defaultTouchConfiguration;
                }
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.array",
                         "mstrmojo.color",
                         "mstrmojo.hash",
                         "mstrmojo.num",
                         "mstrmojo.storage.DOMLocalStorage",
                         "mstrmojo.StringBuffer",
                         "mstrmojo.android.EnumMenuOptions");

    mstrmojo.requiresDescs(1089, 1143, 7830, 7831, 7832, 7859, 7860, 7861, 7862, 8621);

    var $A = mstrmojo.array,
        $AFE = $A.forEach,
        $HASH = mstrmojo.hash,
        $MENUS = mstrmojo.android.EnumMenuOptions,
        _cacheKey = "CacheEnabled",

        _verifyJsonKey = "VerifyJson",
        _diagnosticModeKey = "DiagnosticMode",

        EnumHSButtonType = {
            FOLDER: 1,
            RESULTSET: 2,
            REPORTS: 3,
            SETTINGS: 4,
            SHAREDLIBRARY: 5,
            SUBSCRIPTIONS: 8,
            HELP: 6
        };

    function isObject(o) {
        return (typeof o === 'object');
    }

    function getColor(clr) {
        
        if (isObject(clr)) {
            
            if (clr.tp) {
                return 'transparent';
            }

            
            clr = clr.clr;
        }

        
        return mstrmojo.color.decodeColor(clr);
    }

    function findServer(project) {
        var servers = this.getWebServersList(),
            res = null;
        $AFE(servers, function (server) {
            $AFE(server.pl, function (proj) {
                if (proj === project) {
                    res = server;
                    return false;
                }
            });
            return !res;
        });
        return res;
    }

    function iterateProjects(searchConfig, serversNode, projectCache) {
        var serverCache = projectCache ? projectCache.servers : [],
            projectFound = false;

        
        $AFE(serversNode, function (server) {

            
            $AFE(server.pl, function (project) {
                var id = project.pid;

                
                if (id !== undefined) {
                    
                    
                    if (projectCache) {
                        projectCache[id] = project;
                        serverCache[id] = server;
                    }

                    
                    if (project[searchConfig.n] === searchConfig.v) {
                        
                        projectFound = true;

                        
                        return false;
                    }
                }
            });

            
            if (projectFound) {
                
                return false;
            }
        });

        return projectFound;
    }

    
    function reconcileHSType(hsType) {

        var projectID = getHSProjectID.call(this, hsType),
            hscNode = this._cfg.hsc,
            projectExists;

        
        if (!projectID) {
            return;
        }

        projectExists = iterateProjects({
            n: 'pid',
            v: projectID
        }, this.getWebServersList());

        if (!projectExists) {

            
            hscNode.tp = 1;

            switch (hsType) {
            case 3:     
                delete hscNode.rs;
                break;
            case 4:     
                delete hscNode.fd;
                break;
            }
        }
    }

    
    function getHSProjectID(hsType) {

        var projectID,
            hscNode = this._cfg.hsc;

        switch (hsType) {
        case 3:     
            projectID = hscNode.rs.oi.pid;
            break;
        case 4:     
            projectID = hscNode.fd.oi.pid;
            break;
        }

        return projectID;
    }

    function buildCustomHomeScreen(hsc, asFolder) {
        var ths = this,
            cst = hsc.cst,
            btns = [],
            hscType = ths.getHomeScreenType(),
            devType = ths.getDeviceType();

        if (hscType === 1 &&  devType !== 4 ) {
            var addSubsButton = true;

	        
	        
	        

	        
	        $AFE(cst.btns, function (btn) {
	            

	            
	            
	            if ((btn.act === EnumHSButtonType.SUBSCRIPTIONS) || (btn.act === EnumHSButtonType.REPORTS)) {
	                
	                addSubsButton = false;
	                return false;
	            }
	        });

	        
	        
	        if (addSubsButton && (hscType === 1 || (devType === 4 && hscType === 2 && cst.fmt.vw.rpt))) {
	            btns.push({
	                act: EnumHSButtonType.SUBSCRIPTIONS,
	                txt: mstrmojo.desc(1089, 'Subscriptions'),
	                dsc: ""
	            });
	        }
        }

        
        $AFE(cst.btns, function (btn) {
            

            
            
            
            var xlt = ths.xlat[$A.find(ths.xlat, 'act', btn.act)],
	            
	            
	            
                txt = xlt ? (btn.cap === xlt.dcp ? xlt.cap : btn.cap) : btn.cap,
                dsc = xlt ? xlt.dsc : btn.dsc,
                b = {};

            if ( asFolder ) {
            	b.n = txt;
            	b.desc = dsc;
            } else {
            	b.txt = txt;
            	b.dsc = dsc;
            }
            
            var icon = btn.icn;
            if (isObject(icon)) {
                
                b.icn = icon.img;
            }

            
            var action = btn.act;

            
            if (isObject(action)) {
                
                
                
                var objInfo = (action.fd && action.fd.oi) || (action.rs && action.rs.oi) || action.rs;

                
                b.did = objInfo.did;
                
                b.t = objInfo.t;
                b.st = objInfo.st;
                b.pid = objInfo.pid;

                
                b.ab = objInfo.ab;
                
                b.csp = !!(action.fd && action.fd.csp);

            } else {

                
                b.act = action;

                
                if (b.act === EnumHSButtonType.SETTINGS && !ths.getGeneralSettings().uas) {
                    
                    b = null;
                }
            }

            
            if (b) {
                btns.push(b);
            }
        });

        var config = {
                btns: btns,
                fmt: {},
                ttl: ""
            },

            
            
            
            fmt = cst.btns ? cst.fmt : cst;

        
        if (fmt) {
            var bgFmt = fmt.bkg,
                btnFmt = fmt.btn;

            config.fmt = {
                bg: {
                    tp: bgFmt.tp,                                                
                    v: (bgFmt.tp === 1) ? getColor(bgFmt.fll.clr) : bgFmt.img    
                },
                btn: {
                    bc: getColor(btnFmt.brd),   
                    bg: getColor(btnFmt.fll),   
                    c: getColor(btnFmt.fnt),    
                    sty: btnFmt.stl             
                }
            };

            config.ttl = fmt.ttl.cap;
        }

        if (devType === 4) {        
            config.hlp = fmt.vw.hlp;            
        }

        return config;
    }

    function _loadConfiguration() {

        
        var cfg = mstrMobileApp.getConfiguration();



        
        
        return eval('(' + cfg + ')');
        
    }

    

    function _initializePrjCache(cfg) {
        
        cfg._hostUrls = {};
        cfg._projects = {
            servers: {}
        };
    }

    
    function _clearCachedValues() {
        
        delete this._hsType;
        delete this._hsCfg;
        delete this._wsl;
        delete this._gnl;
    }

    
    mstrmojo.MobileConfiguration = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        
        {
            scriptClass : 'mstrmojo.MobileConfiguration',

            
            _cfg: null,

            
            xlat: null,

            init: function init(props) {

                var xl = this.xlat = [],
                    md = mstrmojo.desc;
                xl.push({   
                    act: 5,
                    cap: md(7832),
                    dsc: md(7859),
                    dcp: "Shared Library"
                });
                xl.push({   
                    act: 4,
                    cap: md(7831),
                    dsc: md(7861),
                    dcp: "Settings"
                });
                xl.push({  
                    act: 6,
                    cap: md(1143),
                    dsc: md(7862),
                    dcp: "Help"
                });
                xl.push({  
                    act: 3,
                    cap: md(7830),
                    dsc: md(7860),
                    dcp: "Reports"
                });
                xl.push({  
                    act: EnumHSButtonType.SUBSCRIPTIONS,
                    cap: md(1089),
                    dsc: md(7860),
                    dcp: "Subscriptions"
                });


                this._super(props);

                this._cfg = this._cfg || _loadConfiguration();

                
                _initializePrjCache(this);

                this.cacheEnabled = $LS.getItem(_cacheKey) || false;

                
                this.binaryMode = mstrMobileApp.useBinaryFormat();

                this.verifyJson = $LS.getItem(_verifyJsonKey) === true;

                this.diagnosticMode = mstrMobileApp.getDiagnosticMode();
            },

            
            getConfiguration: function () {

                return this._cfg;
            },

            
            saveConfiguration: function (silently) {

                
                _clearCachedValues.call(this);

                
                _initializePrjCache(this);

                mstrMobileApp.saveConfiguration(JSON.stringify(this._cfg), !!silently);
            },

            reloadDefaultConfiguration: function () {

                
                mstrMobileApp.reloadDefaultConfiguration();

                this._cfg = _loadConfiguration();

                
                _clearCachedValues.call(this);

                
                _initializePrjCache(this);
            },

            setWebServerList: function (wsl) {
                this._wsl = this._cfg.cty.wsl = wsl;

                
                _initializePrjCache(this);

                return this;
            },

            

            getWebServersList: function () {
                if (!this._wsl) {
                    this._wsl = this._cfg.cty.wsl || [];
                }
                return this._wsl;
            },

            

            getGeneralSettings: function () {
                if (!this._gnl) {
                    this._gnl = this._cfg.gnl;
                }
                return this._gnl;
            },

            getDefaultServerCreds: function () {
                var cty = this._cfg.cty;
                cty.wsdc = cty.wsdc || {
                    am: 1,
                    lo: '',
                    ps: ''
                };
                return cty.wsdc;
            },

			getBackgroundSyncSettings: function () {
				var gnl = this.getGeneralSettings();
				gnl.bss = gnl.bss || {
					ebs: false,
					ui: 4,
					tod: 0,
					wo: false,
					co: false
				};
				gnl.bss.wo = gnl.bss.wo || false; 
				gnl.bss.co = gnl.bss.co || false; 
				return gnl.bss;
			},

            setDefaultServerCreds: function (sd) {
                var cty = this._cfg.cty;

                $HASH.copy(sd, cty.wsdc);
                return this;
            },

            getCacheEnabled: function () {
                
                return false;

            },

            setCacheEnabled: function (c) {
                this.cacheEnabled = c;
                $LS.setItem(_cacheKey, c, -1);
            },

            getBinaryMode: function () {
                return this.binaryMode;
            },

            setBinaryMode: function (v) {
                if (this.binaryMode !== v) {
                    this.binaryMode = v;
                    mstrApp.serverProxy.closeAllSessions();
                    mstrApp.useBinaryFormat = v;
                    
                    mstrMobileApp.setBinaryFormat(v);
                }
            },

            
            getDeviceType: function () {
                return this._cfg.dt;
            },

            isSubscriptionEnabled: function () {
            	return this.getHomeScreenType() != 2 ? true : !!this._cfg.hsc.cst.fmt.vw.rpt;
            },

            getVerifyJson: function () {
                return this.verifyJson;
            },

            getDiagnosticMode: function () {
                return this.diagnosticMode;
            },

            setDiagnosticMode: function (v) {
                if (this.diagnosticMode !== v) {
                    this.diagnosticMode = v;

                    $LS.setItem(_diagnosticModeKey, v, -1);

                    mstrApp.diagnosticMode = v;

                    
                    mstrMobileApp.setDiagnosticMode(v);
                }
            },

            getSettingsAllowed: function getSettingsAllowed() {
                return this.getGeneralSettings().uas;
            },

            
            isMenuAllowed: function isMenuAllowed(menuItem, menuMask) {
                
                if ((menuMask & menuItem) > 0) {
                    
                    var generalSettings = this.getGeneralSettings(),
                    	vw = this._cfg.hsc.cst ?  this._cfg.hsc.cst.fmt.vw : {stg: true, hlp: true};

                    
                    switch (menuItem) {
                    case $MENUS.SETTINGS:
                        
                    	return !!generalSettings.uas && !!vw.stg;
                    case $MENUS.HELP:
                    	return !!vw.hlp;
                    case $MENUS.SHARE:
                    	var project = this.getProject(mstrApp.getCurrentProjectId());
                        return (!!generalSettings.es && project && !!project.es);

                    case $MENUS.LEARN:
                        
                        return !!generalSettings.slml;

                    default:
                        return true;
                    }
                }

                return false;
            },

            

            reconcileHomescreen: function reconcileHomescreen() {
                var ths = this,
                    hsType = ths.getHomeScreenType(),
                    hs = this._cfg.hsc;

                switch (hsType) {
                case 1:     
                	break;
                case 2:     
                    var btns = [];

                    

                    $AFE(hs.cst.btns, function (btn) {
                        var action = btn.act;

                        
                        if (isObject(action)) {
                            
                            var objInfo = (action.fd && action.fd.oi) || (action.rs && action.rs.oi) || action.rs;

                            
                            if (ths.getProject(objInfo.pid) !== undefined) {
                                
                                btns.push(btn);
                            }
                        } else {
                            
                            btns.push(btn);
                        }
                    });

                    
                    if (!btns.length) {
                        btns.push({
                            'act': 5,
                            'cap': mstrmojo.desc(7832),
                            'icn': 1
                        });
                    }
                    hs.cst.btns = btns;
                    break;

                case 3:     
                case 4:     
                	reconcileHSType.call(this, hsType);
                    break;
                }
            },

            
            getHomeScreenType: function () {
                if (!this._hsType) {
                    var hscNode = this._cfg.hsc;
                    if (hscNode) {
                        
                        
                        this._hsType = (typeof hscNode === 'number') ? hscNode : hscNode.tp;
                    }
                }

                return this._hsType;
            },

            getHomeScreen: function (asFolder) {
                
                if (!this._hsCfg) {
                    var type = this.getHomeScreenType(),
                        hsc = this._cfg.hsc,
                        cfg;

                    
                    switch (type) {
                    case 1: 
                    case 2: 
                        cfg = buildCustomHomeScreen.call(this, hsc, asFolder);
                        break;

                    case 3: 
                        cfg = hsc.rs;
                        
                        
                        if (cfg.oi) {
                            cfg = cfg.oi;
                        }
                        break;

                    case 4: 
                        cfg = hsc.fd;
                        
                        cfg.hlp = true;
                        break;
                    }

                    this._hsCfg = cfg;
                }

                return this._hsCfg;

            },

            getProjectByRealPid: function getProjectByRealPid(realPid) {
                var proj;
                $AFE(this.getWebServersList(), function (server) {
                    $AFE(server.pl, function (project) {
                        if (realPid === project.realPid) {
                            proj = project;
                            return false;
                        }
                    });

                    if (proj) {
                        return false;
                    }
                });
                return proj;
            },

            

            getProjectByServerAndProjectName: function getProjectByServerAndProjectName(serverName, port, projName) {
                var proj;
                $AFE(this.getWebServersList(), function (server) {
                    $AFE(server.pl, function (project) {
                        if ((serverName === project.sn) && (projName === project.pn)) {
                            if ((port === undefined) || (!!port && parseInt(port, 10) === project.sp)) {
                                proj = project;
                                return false;
                            }
                        }
                    });

                    
                    if (proj) {
                        return false;
                    }
                });
                return proj;
            },

            getHostUrlByRealPid: function getHostUrlByRealPid(realPid) {
                var proj = this.getProjectByRealPid(realPid);
                return this.getHostUrlByProject((proj && proj.pid) || realPid);
            },

            
            getWebServerUrlByProject: function getWebServerUrlByProject(projectId) {
                var servUrl = this.getHostUrlByProject(projectId);
                return servUrl.replace(/(servlet\/|asp\/)$/, '');
            },

            
            getCurrentProjectWebServerUrl: function getCurrentProjectWebServerUrl() {
                return this.getWebServerUrlByProject(mstrApp.getCurrentProjectId());
            },

            
            getHostUrlByProject: function getHostUrlByProject(projectId) {
                var urls = this._hostUrls;

                
                if (!urls[projectId]) {
                    
                    var server = this.getServerByProjectId(projectId);

                    if (server === undefined) {
                        throw new Error("Could not find server for project, pid=" + projectId);
                    }

                    var hostUrl = new mstrmojo.StringBuffer();

                    
                    hostUrl.append('http');

                    
                    if (server.rt) {
                        
                        hostUrl.append('s');
                    }

                    
                    hostUrl.append('://' + server.nm);

                    
                    var port = server.po;
                    if (port) {
                        hostUrl.append(':' + port);
                    }

                    
                    hostUrl.append('/' + server.pt + '/');

                    
                    hostUrl.append(((server.ty === 0) ? 'servlet' : 'asp') + '/');

                    
                    urls[projectId] = hostUrl.toString();
                }

                
                return urls[projectId];
            },

            
            getTaskUrlByProject: function getTaskUrlByProject(projectId) {
                
                var server = this.getServerByProjectId(projectId);
                if (server === undefined) {
                    throw new Error("Could not find server for project, pid=" + projectId);
                }
                return this.getHostUrlByProject(projectId) + mstrConfig.taskURL + ((server.ty === 1) ? '.aspx' : '');
            },

            
            getProject: function getProject(projectId) {
                
                var projects = this._projects;

                
                if (!projects[projectId]) {
                    
                    iterateProjects({
                        n: 'pid',
                        v: projectId
                    }, this.getWebServersList(), projects);
                }

                
                return projects[projectId];
            },

            
            getProjectHash: function getProjectHash() {
                var _result = {},
                    serverList = this.getWebServersList();
                if (serverList.length < 1) {
                	return _result;
                }

                var projects = this._projects,
                    dummyProjectID = mstrmojo.num.generateUniqueID(64);

                
                
                iterateProjects({
                    n: 'pid',
                    v: dummyProjectID
                }, serverList, projects);

                
                _result = $HASH.clone(projects);

                
                delete _result.servers;

                
                return _result;
            },

            
            getProjectList: function getProjectList() {
                var projectList = [];

                
                $HASH.forEach(this.getProjectHash(), function (project) {
                    
                    projectList.push({
                        did: project.pid,
                        n: project.pn,
                        desc: project.sn,
                        st: 'Project',
                        t: 8,
                        rtf: project.rtf    
                    });
                });

                return projectList;
            },

            
            clearLoginInfoForProject: function clearLoginInfoForProject(pid) {
                var cfg = this.getConfiguration(),
                    server = this.getServerByProjectId(pid),
                    project = this.getProject(pid),
                    creds = project.udc ? server.pdc : project.pc;

                creds.lo = creds.ps = "";
            },

            
            getLoginInfo: function (projectId) {
                var cfg = this.getConfiguration(),

                    server = this.getServerByProjectId(projectId),
                    serverCreds = server.wsc,
                    wsuid = serverCreds.lo || "",
                    wspwd = serverCreds.ps || "",
                    wsam = serverCreds.am,

                    project = this.getProject(projectId),
                    projectCreds = project.pc,
                    uid = projectCreds.lo || "",
                    pwd = projectCreds.ps || "",
                    am = projectCreds.am;

                
                if (server.udc) {
                    var wsdc = cfg.cty.wsdc;
                    wsam = wsdc.am;
                    wsuid = wsdc.lo || "";
                    wspwd = wsdc.ps || "";
                }

                
                if (project.udc) {
                    var pdc = server.pdc;
                    uid = pdc.lo;
                    pwd = pdc.ps;
                    am = pdc.am;
                }

                return {
                    wsuid: wsuid,
                    wspwd: wspwd,
                    wsam: wsam,

                    uid: uid,
                    pwd: pwd,
                    am: am
                };
            },

            
            updateLoginInfo: function updateLoginInfo(projectId, loginInfo) {
                var server = this.getServerByProjectId(projectId),
                    project = this.getProject(projectId),
                    creds = project.udc ? server.pdc : project.pc,
                    serverCreds = server.udc ? this.getDefaultServerCreds() : server.wsc;

                
                if (loginInfo.updateCfgAfterLogin & 0x01) {
                    serverCreds.lo = loginInfo.wsuid;
                    serverCreds.ps = loginInfo.wspwd;
                }

                
                if (loginInfo.updateCfgAfterLogin & 0x02) {
                    creds.lo = loginInfo.uid;
                    creds.ps = loginInfo.pwd;
                }

                this.saveConfiguration(false);
            },

            
            getProjectCount: function () {
                var wsl = this.getWebServersList(),
                    count = 0,
                    i = 0;

                for (i = 0; i < wsl.length; i++) {
                    if (wsl[i].pl) {
                        count += wsl[i].pl.length;
                    }
                }

                return count;
            },

            
            getServerByProjectId: function (projectId) {
                var projects = this._projects,
                    servers = projects.servers;

                
                if (!servers[projectId]) {
                    
                    iterateProjects({
                        n: 'pid',
                        v: projectId
                    }, this.getWebServersList(), projects);
                }

                
                return servers[projectId];
            },

            
            setPid: function setPid(project) {
                var oldPid = project.pid,
                    oldRealPid = project.realPid,
                    projCache = this._projects,
                    serverCache = projCache.servers,
                    pid = mstrmojo.num.generateUniqueID(32),
                    server = findServer.call(this, project);
                if (oldPid) {
                    delete projCache[oldPid];
                    delete serverCache[oldPid];
                }
                if (oldRealPid) {
                    delete projCache[oldRealPid];
                    delete serverCache[oldRealPid];
                }
                project.pid = pid;
                delete project.realPid;

                projCache[pid] = project;
                serverCache[pid] = server;
            },

            setRealPid: function setRealPid(project, value) {
                
                

                
                if (typeof project === 'string') {

                    
                    project = this.getProject(project);

                    
                    if (!project) {

                        
                        
                        return;
                    }
                }

                var oldRealPid = project.realPid,
                    projCache = this._projects,
                    serverCache = projCache.servers,
                    server = findServer.call(this, project);

                
                
                if (oldRealPid && oldRealPid !== project.pid) {
                    delete projCache[oldRealPid];
                    delete serverCache[oldRealPid];
                }
                project.realPid = value;

                projCache[value] = project;
                serverCache[value] = server;
                this.saveConfiguration(true);
            }
        }
    );

}());
(function(){

    mstrmojo.requiresCls("mstrmojo.func");
    
    
    mstrmojo.ResSetLink = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,
        
        
        {            
            scriptClass: "mstrmojo.ResSetLink",
            
            SAME_PROMPT: 1,
            DO_NOT_ANSWER: 2,
            CLOSE: 3,
            DYNAMIC: 4,
            STATIC: 5,
            CURRENT_UNIT: 6,
            ALL_VALID_UNITS: 7,
            USE_DEFAULT_ANSWER: 8,
            
            toXml: function toXml() {
                
                
                var me = this,
                    fnXMLAttribute = function(name, value) { 
                        return ' ' + name + '="' + value + '"';
                    },
                    fnXMLAttributeElement = function(name, value) {
                        return fnXMLAttribute(name, mstrmojo.string.encodeXMLAttribute(value));
                    },
                    xml = new mstrmojo.StringBuffer();

                                 
                
                var prms = this.prms,
                    prmCnt = prms && prms.length;
                
                
                
                if (prmCnt || me.aopam != me.DO_NOT_ANSWER) {
                    
                    xml.append('<hl' + fnXMLAttribute('mid', me.mid) + fnXMLAttribute('srct', me.srct) + fnXMLAttribute('aopam', me.aopam) + '>');
                    
                    if (prmCnt) {
                        
                        xml.append('<prms>');
                        
                        for (var i = 0; i < prmCnt; i++) {
                            var prm = prms[i];
                              
                            
                            
                            
                            xml.append('<prm' + fnXMLAttribute('id', prm.id) + fnXMLAttribute('am', prm.am) + fnXMLAttribute('pt', prm.pt));
                              
                            
                            if (prm.orid) {
                                xml.append(fnXMLAttribute('orid', prm.orid) + fnXMLAttribute('ortp', prm.ortp));
                            }
                            xml.append('>');  
                  
                            
                            switch (prm.am) {
                                case me.DO_NOT_ANSWER:
                                case me.CLOSE:
                                case me.USE_DEFAULT_ANSWER:
                                case me.SAME_PROMPT:
                                    break;
                                      
                                case me.STATIC:
                                    xml.append('<pa ia="1"><es>');
                                    var es = prm.pa.es,
                                        esLen = es && es.length || 0;
    
                                    for (var z = esLen - 1; z >= 0; --z) {
                                        var e = es[z];
                                        xml.append('<e' + fnXMLAttributeElement('ei', e.ei) + fnXMLAttribute('disp_n', e.disp_n) + fnXMLAttribute('emt', e.emt)  + '/>');
                                    }
                                      
                                    xml.append('</es></pa>');
                                    break;
                                      
                                case me.DYNAMIC:
                                case me.ALL_VALID_UNITS:
                                case me.CURRENT_UNIT:
                                    var pa = prm.pa;
                                    if (pa) {
                                        xml.append('<pa ia="1">');
                                        var a = pa.a;
                                        
                                        if (a) {
                                            xml.append('<a' + fnXMLAttribute('id', a.id) + fnXMLAttributeElement('n', a.n) + '>');
                                        }
                                        if ( prm.pt === 1) {
                                            
                                        	xml.append(mstrmojo.string.encodeXMLAttribute(pa.v));
                                        } else {             
	                                        xml.append('<es' + fnXMLAttribute('dispForms', a && a.dispForms >=0 ? a.dispForms : '') + '>'); 
	                                        var es = pa.es
	                                            esLen = es && es.length || 0;
	                                        for (var z = esLen - 1; z >= 0; --z) {
	                                            var e = es[z];
	                                            xml.append('<e' + fnXMLAttributeElement('ei', e.ei) + fnXMLAttribute('disp_n', e.disp_n) + fnXMLAttribute('emt', e.emt)  + '/>');
	                                        }
	                                        xml.append('</es>');
                                          
                                        if (a) {
                                            xml.append('</a>');
                                        }
                                        }
                                        xml.append('</pa>');
                                    }
                                    break;
                                    
                            }
                            xml.append('</prm>');
                        }
                        xml.append('</prms>');
                    }
                    xml.append('</hl>');
                }
                  
                return xml.toString();
            }


        }
    );
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.ListMapper");
    
    var RENDERED = 1;
    
    mstrmojo._hasWidgetListMapper = {

            
            buildItemWrappers: function biws(items, builder, w, ctxt, first, last) {
                
                ctxt.first = first;
                ctxt.last = last;
                return this._super(items, builder, w, ctxt, 0, 0);
            },
            
            
            postBuildRendering:function pbr(p, items, builder, w, ctxt) {
                var f = ctxt.first;
                if (f) {
                    this.fillItemWrappers(p, items, builder, w, ctxt, 0, f);
                }
                if (ctxt.last) {
                    var len = items && items.length || 0,
                        start = Math.max(Math.max(0, len-ctxt.last), f);
                    this.fillItemWrappers(p, items, builder, w, ctxt, start, len);
                }
                if (this._super) {
                    this._super(p, items, builder, w, ctxt);
                }
            },
            
            
            fillItemWrappers: function fi(p, items, builder, w, ctxt, start, end, max){
                var len = (items && items.length) || 0,
                    ns = this.wrapperNodes(p),
                    st = ctxt.itemStatus;
            
                for (var i=start, stop=Math.min(end+1, len), k=0; i<stop; i++) {
                    if (st[i] !== RENDERED) {
                        var iw = builder.build(w, ctxt, items[i], i);
                        if (iw) {
                            iw.placeholder = ns[i].firstChild;
                            iw.render();
                        }
                        k++;
                        if (k === max) {
                            break;
                        }
                    }
                }
                return k;
            },
            
            
            onchange: null
        };
    
    
    mstrmojo.WidgetListMapper = mstrmojo.provide(
        "mstrmojo.WidgetListMapper",
        mstrmojo.mixin(
            
            mstrmojo._hasWidgetListMapper,
            mstrmojo.hash.copy(mstrmojo.ListMapper)
        )
    );
    
    
    mstrmojo.WidgetListMapper.RENDERED = RENDERED;
    
    mstrmojo.requiresCls("mstrmojo.ListMapperHoriz");

    mstrmojo.WidgetListMapperHoriz = mstrmojo.provide(
        "mstrmojo.WidgetListMapperHoriz",
        mstrmojo.mixin(mstrmojo._hasWidgetListMapper,
            mstrmojo.hash.copy(mstrmojo.ListMapperHoriz)
        )
    );
            
})();
(function(){

    mstrmojo.requiresCls(
    "mstrmojo.ListMapper");
    
    mstrmojo.ListMapperTable = mstrmojo.provide(
        "mstrmojo.ListMapperTable",
        mstrmojo.hash.copy(
        
        {
            markupPrefix: '<table class="mstrmojo-itemwrap-table" cellspacing="0" cellpadding="0">',
            
            markupSuffix: '</table>',
            
            itemWrapperPrefix: function(w){
                return '<tbody class="' + this.getWrapperCss(w) + '">';
            }, 
            
            itemWrapperPrefill: '<tr><td>&nbsp;</td></tr>',
            
            itemWrapperSuffix:  '</tbody>',
            
            wrapperNodes: function wrapperNodes(p){
                return this.wrapperParentNode(p).tBodies;
            },
            
            wrapperParentNode: function wrapperParentNode(p){
                return p.getElementsByTagName('table')[0];
            },

            createWrapperNode: function createWrapperNode(p){
                var d = p.ownerDocument,
                n = d.createElement('tbody');
                return n;
            },
            
            
            findIndex: function nd2idx(w, p, node) {
                if (p && node) {
                    var dn = w.domNode,
                        tb = this.wrapperParentNode(p), 
                        pn = node.parentNode;
                    while (pn) {
                        if (pn === tb) {
                            
                            return mstrmojo.array.findBin(this.wrapperNodes(p), node, 'offsetTop', w.items && w.items.length);
                        } else if (pn === dn) {
                            
                            break;
                        }
                        node = pn;
                        pn = node.parentNode;
                    }
                }
                return -1;
            }
        }, mstrmojo.hash.copy(mstrmojo.ListMapper)));

        
    mstrmojo.requiresCls(
    "mstrmojo.WidgetListMapper");
    
    mstrmojo.WidgetListMapperTable = mstrmojo.provide(
            "mstrmojo.WidgetListMapperTable",
            mstrmojo.mixin(
                
                mstrmojo._hasWidgetListMapper,
                mstrmojo.hash.copy(mstrmojo.ListMapperTable)
            )
    );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.func",
        "mstrmojo.Model",
        "mstrmojo._CanProxyCallback",
        "mstrmojo.EnumRWUnitType",
        "mstrmojo.DocDataService",
        "mstrmojo.StringBuffer",
        "mstrmojo.EnumReadystate");

    var $RWTYPES = mstrmojo.EnumRWUnitType,
        $RS = mstrmojo.EnumReadystate,
        $HFE = mstrmojo.hash.forEach,
        $WRAP = mstrmojo.func.wrapMethods,
        $A = mstrmojo.array;

    
    var observables = {
        isObservable: function (defn) {
            
            var t = defn && defn.t;

            
            if (!t || !(t in this) || defn.scriptClass) {
                
                return false;
            }

            
            return (t !== $RWTYPES.SUBSECTION || !defn.dt);
        },

        makeObservable: function (defn) {
            
            defn.audibles = this[defn.t] || {};

            
            if ('readyState' in defn.audibles) {
                
                defn.readyState = $RS.IDLE;
            }

            
            return new mstrmojo.Model(defn);
        }
    };

    observables[$RWTYPES.PANELSTACK] = {
        '*': false,
        selKey: true,    
        readyState: true
    };

    observables[$RWTYPES.GRID] = {
        '*': false,
        readyState: true,
        ds: true    
    };

    observables[$RWTYPES.GRAPH] = {
        '*': false,
        readyState: true,
        ds: true    
    };

    observables[$RWTYPES.GRIDGRAPH] = {
        '*': false,
        qsm: true,
        ds: true    
    };

    observables[$RWTYPES.SUBSECTION] = {
        '*': false,
        resize: true,
        adjustSize: true
    };

    observables[$RWTYPES.VISUALIZATION] = {
        '*': false,
        ds: true    
    };

    observables[$RWTYPES.SELECTOR] = {
        '*': false,
            cek: true,    
            ds: true
    };

    observables[$RWTYPES.MOJOVISUALIZATION] = {
        '*': false,
        ds: true    
    };


    
    function getLayout(node, lytKey) {

        
        
        var lyt = node.layoutMap && node.layoutMap[lytKey];
        if (lyt) {
            return lyt;
        }

        var lyts = node.layouts,
            cnt = (lyts && lyts.length) || 0,
            i = 0;

        for (i = 0; i < cnt; i++) {
            if (lyts[i].k == lytKey) {
                return lyts[i];
            }
        }

        return null;
    }

    
    function lookupDefn(defn, lytKey, key) {
        var lyt = getLayout(defn, lytKey);

        if (key == lytKey) {
            
            lyt._lkz = lytKey;

            return lyt;

        } else if (lyt) {
            
            var unit = lyt.units[key];
            
            if (unit) {
                
                if (unit.t == $RWTYPES.GRIDGRAPH) {
                    
                    
                    if (!lyt.units[key + '_0']) {

                        
                        lyt.units[key + '_0'] = {
                            ck: unit.ck,  
                            fmts: unit.fmts.gd,    
                            txi: unit.txi, 
                            t: $RWTYPES.GRID
                        };

                        
                        lyt.units[key + '_1'] = {
                            ck: unit.ck,  
                            fmts: unit.fmts.gp,    
                            t: $RWTYPES.GRAPH
                        };
                    }
                }

                
                if (observables.isObservable(unit)) {
                    
                    unit = lyt.units[key] = observables.makeObservable(unit);
                }

                
                unit._lkz = lytKey;
            }

        }

        return lyt && lyt.units[key];
    }
    
    function filterSectionsByTypes(node, isPartial, types, include) {
        var children = this.getChildren(node, isPartial, 0);
        
        return (mstrApp.isMobile ? (mstrmojo.array.filter(children, function (sec) {
                                            var idx = types && types.indexOf(sec.defn.t),
                                            	dk = sec.defn.dk;
                                            return include? (idx > -1 && dk === -1) : (idx < 0 || dk !== -1);
                                        })) : (include ? [] : children));
    }

    
    var fnBuildId = function(data, lk) {
        var id = new mstrmojo.StringBuffer();

        
        if (lk) {
            
            id.append('*l' + lk);
        }

        
        id.append('*k' + data.k);

        
        if ('wid' in data) {
            
            id.append('*x' + data.wid);
        }

        
        id.append('*t' + this.buildTime);

        return id.toString();
    };

    
    function getTxUpdates(t) {
        var i, w,
        d = this.delta,
        pu = this.pendingUpdate,
        updates = [];

        
        if(!pu) {
            pu = this.pendingUpdate = {};
        }

        if(!mstrmojo.hash.isEmpty(d)) {
            updates.push('<updates>');
            for(i in d) {
                if(d.hasOwnProperty(i)) {
                    w = d[i];
                    updates.push(w.getUpdates());
                }
            }
            
            pu[t] = d;
            
            this.delta = {};

            updates.push('</updates>');
        }
        return updates.join('');
    }

    
    function fnGetTargetDefn(keys, delim) {
        var defs;
        if ( keys ) {
	        keys = keys.split(delim || '\u001E');
	        for (var i = 0, cnt = keys.length; i < cnt; i++) {
	            defs = defs || {};
	            defs[keys[i]] = lookupDefn.call(this, this.defn, this.currlaykey, keys[i]);
	        }
        }
        return defs;
    }

    function unloadAffectedLayouts(me, data) {
        var ulkeys = data.ulkeys,
        
            view = me.controller.view;
        if (view && view.unloadLayouts && ulkeys && ulkeys.length) {
            view.unloadLayouts(ulkeys);
        }
    }

    
    function isInfoWindowPS(key, layoutKey) {
        var defn = this.getLayoutUnitDefn(key, layoutKey);
        return (defn && defn.t === $RWTYPES.PANELSTACK && defn.ifw);
    }

    function isCurrentSlice(node, sid){
        return !sid || (node.wid == sid);
    }

    
    function hasAllSelectedInGB() {
        var lyts = this.data && this.data.layouts,
            lyt = lyts[$A.find(lyts, 'k', this.getCurrentLayoutKey())],
            gbs = lyt && lyt.gbys && lyt.gbys.groupbys,
            isAllSelected = false;

        $A.forEach(gbs, function (gb) {
            if (gb.unit && gb.unit.elms && gb.unit.elms[gb.unit.idx].v === 'u;' ) {
                isAllSelected = true;
                return false;
            }
        });

        return isAllSelected;
    }
    
    mstrmojo.DocModel = mstrmojo.declare(
        
        mstrmojo.Model,

        
        [mstrmojo._CanProxyCallback],

        
        {
            scriptClass: 'mstrmojo.DocModel',

            audibles: {
                '*': false,
                data: true
            },

            
            features: null,

            
            dataCache: null,

            
            controller: null,

            
            sdp : null,

            
            init: function init(props) {
                this._super(props);

                if (!this.features) {
                    this.features = new mstrmojo.Model();
                    this.disposables.push(this.features);
                }
                this.ondefnChange();

                
                this.buildTime = mstrmojo.now();
            },

            
            makeObservable: function makeObservable(defn) {
                return observables.makeObservable(defn);
            },

            
            getTargetDefn: function(keys) {
                return fnGetTargetDefn.call(this,keys);
            },

            getTargetInfoWin: function(keys) {
            	var ret = [],
            		tgtDefs = fnGetTargetDefn.call(this, keys);
            	if (tgtDefs) {
            		var tgt;
            		for (tgt in tgtDefs) {
            			if (tgtDefs[tgt] && tgtDefs[tgt].ifw) {
            				ret.push(tgt);
            			}
            		}
            	}

            	return ret;
            },

            
            getUnitDefinitions: function(keys, delim) {
                return fnGetTargetDefn.call(this,keys, delim);
            },

            
            hasFeatures: function rsFts( featList){
                var fs = this.features;
                if (!fs) {
                    return false;
                }

                var arr = featList.split(',');
                for (var i=0, len=arr.length; i<len; i++){
                    var s = arr[i],
                        neg = s.match(/^\!/);
                    if (neg) {
                        s = s.replace("!", "");
                    }
                    if (neg ? this.features[s] : !this.features[s]) {
                        return false;
                    }
                }
                return true;
            },

            
            ondefnChange: function ondefnChg(){
                var defn = this.defn,
                    lyts = defn && defn.layouts,
                    lytMap = {};
                if (defn) {
                defn.layoutMap = lytMap;

                for (var i = 0, cnt = lyts && lyts.length || 0; i < cnt; i++) {
                    var lyt = lyts[i];
                    lytMap[lyt.k] = lyt;
                }
                }
            },

            
            formatResolver: {

                
                getFormat: function getFormats(defn, thresholdId) {
                    
                    var fmts = ((defn && defn.fmts) || null);

                    
                    if (thresholdId) {
                        
                        var ts = defn.thresholds,
                            tFmts = ts && ts[thresholdId];

                        
                        if (tFmts) {
                            
                            var fx = {},
                                p;

                            
                            for (p in fmts) {
                                fx[p] = tFmts[p] || fmts[p];
                            }

                            
                            for (p in tFmts) {
                                var formatValue = tFmts[p];
                                fx[p] = (typeof(formatValue) === "string") ? (formatValue + " !important") : formatValue;
                            }

                            
                            fmts = fx;
                        }
                    }

                    
                    return fmts;
                }
            },

            
            getSelectedXtabStyles: function getSelectedGridStyles(k)  {
                var sk = k || this.currlaykey;
                var ss = {};

                var lyts = this.data && this.data.layouts;
                for (var i in lyts) {
                    if (lyts[i].k === sk) {
                        ss = lyts[i].xtabStyles;
                        break;
                    }
                }

                return ss;
            },

            
            getChildren: function getCh(node, isPartial, start, count, includeTotal) {
                
                var layoutKey = this.currlaykey;

                
                if (node) {
                    
                    var defn = node.defn;
                    layoutKey = (defn && defn._lkz) || node.k;
                }

                
                
                var dc = this.getLayoutDataCache(layoutKey),
                    useCache = (!isPartial && !mstrmojo.hash.isEmpty(dc)),
                    lookin;

                
                if (!node) {
                    
                    lookin = this.data;
                } else {
                    
                    var src = node.data || node;

                    
                    if (useCache) {
                        
                        lookin = dc[fnBuildId.call(this, src, layoutKey)];

                        
                        lookin = (lookin && lookin.data) || lookin || src;
                    } else {
                        
                        lookin = src;
                    }
                }

                
                var arr = lookin ? (lookin.sections || lookin.subsections || lookin.objects || lookin.panels || lookin.layouts || lookin.children) : [],
                    ch = [];

                var len = (arr && arr.length) || 0;
                if (len) {
                    var defn = this.defn,
                        traversingLayouts = !node,
                        ck = node ? layoutKey : null,                                           
                        type = (node && ((node.defn) ? node.defn.t : lookupDefn.call(this, defn, ck, node.k).t));        

                    
                    var isGridGraph = (type === $RWTYPES.GRIDGRAPH),
                        isDetails = (type === $RWTYPES.DETAILS);

                    for (var i = start || 0, stop = (isNaN(count)) ? len : i + count; i < stop; i++) {
                        var item = arr[i];
                        if (isGridGraph) {
                            
                            item.k = node.k;
                            item.wid = node.data.wid;
                        }
                        var key = item.k,
                            id = fnBuildId.call(this, item, ck),
                            df;

                        
                        
                        
                        if (!traversingLayouts && !isPartial && isInfoWindowPS.call(this, key, ck)) {
                            var unitDef = this.getLayoutUnitDefn(key),
                                unit = {
                                        data:item,
                                        defn: unitDef,
                                        id: id,
                                        k: key,
                                        p: lookin
                                    };
                            dc[id] = unit;
                            
                            
                            if(!this.infoWinByKey || !this.infoWinByKey[key]) { 
                                var infoWindows = this.infoWindows = this.infoWindows || {};
                                var infoWinByKey = this.infoWinByKey = this.infoWinByKey || {};
                                infoWindows[unitDef.n] = infoWinByKey[key] = unit;
                            }
                            continue;
                        }

                        
                        if (isGridGraph) {

                            
                            id += '_' + i;

                            
                            df = lookupDefn.call(this, defn, ck, item.k + '_' + i);

                        } else {
                            df = lookupDefn.call(this, defn, ck || item.k, item.k);    
                        }


                        
                        if (isDetails) {
                            
                            
                            df.dt = true;
                        }

                        
                        ch.push({
                            k: item.k,
                            id: id,
                            defn: df,
                            data: useCache ? (dc[id] && dc[id].data) || item : item
                        });
                    }
                }
                   
                return includeTotal ? { nodes: ch, total: len } : ch;
            },

            
            getInfoWindow: function getInfoWindow(name) {
                var infoWindows = this.infoWindows;
                return infoWindows && infoWindows[name];
            },

            
            getFixedHeaders: function(node, isPartial) {
                return filterSectionsByTypes.call(this, node, isPartial, [$RWTYPES.PAGEHEADER], true);
            },
            
            getFixedFooters: function(node, isPartial) {
                return filterSectionsByTypes.call(this, node, isPartial, [$RWTYPES.PAGEFOOTER], true);
            },
            getNonFixedSections: function(node, isPartial) {
                return filterSectionsByTypes.call(this, node, isPartial, [$RWTYPES.PAGEHEADER, $RWTYPES.PAGEFOOTER], false);
            },
            
            getLayoutUnitDefn: function getLayoutUnitDefn(key, layoutKey) {
                return lookupDefn.call(this, this.defn, layoutKey || this.currlaykey, key);
            },

            getUnitInstance: function getUnitInstance(key, widgetID) {
                return mstrmojo.all[fnBuildId.call(this, {
                    k: key,
                    wid: widgetID
                }, this.currlaykey)];
            },

            getFirstUnitInstanceByName: function getFirstUnitInstanceByName(name) {
                var lyt = getLayout(this.defn, this.currlaykey);
                if (lyt) {
                    
                    var units = lyt.units;
                    for (u in units) {
                        var unit = units[u];
                        if ( unit.n === name ) {
                           return this.getUnitInstance(u,1);
                        }
                    }
                }
                return null;
            },

            
            getSelectedKey: function getSelK( node) {
                return (!node && this.currlaykey) || null;
            },

            getCurrentLayoutKey: function getCurrentLayoutKey() {
                return this.currlaykey;
            },

            getCurrentLayoutDef: function getCurrentLayoutDef() {
                var layouts = this.defn && this.defn.layouts;
                return layouts && layouts[$A.find(layouts, 'k', this.currlaykey)];
            },

            
            replaceLayout: function replaceLayout(key, node) {
                var dc = this.dataCache;

                
                if (dc && dc[key]) {
                    
                    dc[key] = {};
                }

                
                var lyts = (this.data && this.data.layouts) || (this.defn && this.defn.layouts);
                for (var i = (lyts && lyts.length - 1) || 0; i >= 0; i--) {
                    if (lyts[i].k === key) {
                        break;
                    }
                }

                
                this.bs = node.bs;

                
                this.zf = node.zf;

                
                if (node.data) {
                    this.data.layouts[i] = node.data.layouts[i];
                    
                    this.data.elems = node.data.elems;
                }

                
                if (node.defn) {
                    this.defn.layouts[i] = node.defn.layouts[i];

                    
                    this.ondefnChange();
                }

            },

            
            loadLayout: function loadLayout(layoutJSON, unloadCache, restoreIW) {
                this.replaceLayout(layoutJSON.currlaykey, layoutJSON);

                this.raiseEvent({
                    name: 'rebuildLayout',
                    unloadCache: !!unloadCache, 
                    restoreIW: !!restoreIW 
                });
            },

            
            getTransactionUpdates: function getTransactionUpdates(t) {
                return this.txDiscardTargets ? '' : getTxUpdates.call(this, t);
            },

            
            clearTransactionUpdates: function clearTransactionUpdates(t) {
                this.clearTxDeltaUpdate(t);
            },

            
            resetTransactionUpdates: function resetTransactionUpdates(t) {
            	var pu = this.pendingUpdate,
            		d = this.delta;

            	
            	if(pu && pu[t]) {
            		
            		$HFE(pu[t], function(v, i) {
            			if(d && !d[i]) {
            				d[i] = v;
            			}
            		});
            		
            		delete pu[t];
            	}
            },

            getDataService: function getDataService() {
                var dataService = this.dataService,
                    me = this;
                if (!dataService) {
                    var params = {
                        rwb: this.bs,
                        msgId: this.mid,
                        model: this
                    };

                    if (mstrApp.modelFactory) {
                        dataService = mstrApp.modelFactory.newDataService('Document', params);
                    } else {
                        dataService = mstrApp.viewFactory.newDocDataService(params);
                    }

                    this.dataService = dataService;
                    this.disposables.push(dataService);
                }
                return dataService;
            },

            partialUpdate: function partialUpdate(data, targetDefinitions) {
                
                var updatedDataCache = this.updateDataCache(data, targetDefinitions);

                
                this.raiseEvent({
                    name: 'partialUpdate',
                    tree: data,                 
                    ids: updatedDataCache
               });

                return updatedDataCache;
            },

            
            transactionUpdate: function(res, evt){
                
                if (!res.data){
                    return;
                }

                var me = this,
                    tgtDefs;

                
                if (evt && evt.tks) {
                    tgtDefs = fnGetTargetDefn.call(this, evt.tks);
                }
                
                if(res.pukeys) {
                    tgtDefs = fnGetTargetDefn.call(this, res.pukeys);

                    
                    var tgt;
                    for (tgt in tgtDefs) {
                        if (tgtDefs[tgt] && tgtDefs[tgt].cek) {
                            tgtDefs[tgt].cek = null;
                        }
                    }
                }

                
                if(res.txrcd) {
                    this.txrcd = res.txrcd;
                } else {
                    
                    delete this.txrcd;
                }

                
                
                
                var ids = this.updateDataCache(res.data, tgtDefs, evt && evt.sid),
                    ue = {
                            name: 'partialUpdate',
                            tree: res.data,   
                            ids: ids
                        };

                
                if(!mstrmojo.hash.isEmpty(ids.ifws)){
                    if (evt && evt.type === $RWTYPES.GRID) {
                        ue.anchor = evt.anchor;
                    } else {
                        
                        ids.ifws = {};
                    }
                }

                
                this.raiseEvent(ue);

                return ids;
            },

            deltaUpdate: function dltUdt(w) {
                var d = this.delta;
                if(!d) {
                    d = this.delta = {};
                }
                d[w.id] = w;
            },

            
            clearTxDeltaUpdate: function clrDltUdt(t) {
                var widgetsToClearTx = this.txDiscardTargets,
                    clearAll = !widgetsToClearTx, 
                    pu = this.pendingUpdate,
                    me = this,
                    id;

                
                if(!clearAll) {
                    
                    $HFE(widgetsToClearTx, function(v, id) {
                        if(me.delta && me.delta[id]) {
                            me.delta[id].clear();
                            delete me.delta[id];
                        }
                    });
                }

                
                if(pu && pu[t]) {
                    
                    $HFE(pu[t], function(w) {
                        w.clear();
                    });
                	delete this.pendingUpdate[t];
                }

            },

            
            sendTransactionActions: function sendTransactionActions(ck, at, callbacks) {

                var me = this, params;
                if(!callbacks) {
                    callbacks = {
                        success: function(res){
                            
                            me.transactionUpdate(res);
                        }
                    };
                }

                me.getDataService().sendTransactionActions({
                    keyContext: ck,
                    actions: at,
                    txrcd: this.txrcd
                }, callbacks);
            },

            
	     addSDP: function addSDP(sdpKey, primaryWidgetInfo) {
		    if (!sdpKey || !primaryWidgetInfo) {
			return;
		    }
		    if(!this.sdp){
			this.sdp = {};
		    }
		    this.sdp[sdpKey] = {k: primaryWidgetInfo.k,visName:primaryWidgetInfo.visName};

	     },

	    
            removeSDP: function removeSDP(sdpKey) {
		    if (!sdpKey || !this.sdp[sdpKey]) {
			return;
		    }

		    
		    delete this.sdp[sdpKey];

            },

            
            slice: function slice(evt) {
                try {
                    
                    
                    if (!evt || (!mstrmojo.dom.isAndroid && !evt.tks && !evt.multiSelect && (evt.type === 3 || (evt.type === $RWTYPES.GRAPH && evt.tty != 1)))) {
                        return;
                    }

                    var dataCacheUpdate = null,
                        me = this,
                        dataService = this.getDataService(),

                        
                        tgtDefs = evt.tks ? fnGetTargetDefn.call(this, evt.tks) : null,

                        
                        orignalTargetDefs = tgtDefs,

                        
                        fnSetReadyState = function (v) {
                            
                            $HFE(orignalTargetDefs, function (targetDef, key) {
                                
                                if (targetDef && targetDef.set) {
                                    
                                    targetDef.set('readyState', v);
                                }
                            });
                        },

                        
                        fnGetWidget = function (k, wid) {
                            return mstrmojo.all[fnBuildId.call(me, {
                                k: k,
                                wid: wid
                            }, me.currlaykey)];
                        },

                        
                        callback = this.newCallback({
                            method: 'slice',

                            submission: function () {
                                
                                fnSetReadyState($RS.WAITING);
                            },

                            success: function (res) {

                                if (evt.disablePU) {
                                    me.loadLayout(res, evt.isUConDS, evt.restoreIW); 
                                    
                                    return;
                                }
                                
                                if (res.pukeys) {
                                    tgtDefs = fnGetTargetDefn.call(me, res.pukeys);
                                }
                                unloadAffectedLayouts(me, res);

                                
                                
                                dataCacheUpdate = me.updateDataCache(res.data, tgtDefs,evt && evt.sid);
                                if (typeof(res) == 'object') {
                                    
                                    mstrmojo.hash.copyProps(['bs', 'exopt', 'dty'], res, me);
                                }

                                var ue = {
                                        name: 'partialUpdate',
                                        tree: res.data,   
                                        ids: dataCacheUpdate
                                 };

                                 
                                if(!mstrmojo.hash.isEmpty(ue.ids.ifws)){
                                    if (evt && !evt.suppressIW && (evt.type === $RWTYPES.GRID || evt.type === $RWTYPES.GRAPH)) { 
                                        ue.anchor = evt.anchor;
                                    } else {
                                        
                                        
                                        ue.ids.ifws = {};
                                    }
                                }

                                
                                me.raiseEvent(ue);
                            },

                            complete: function () {
                                
                                fnSetReadyState($RS.IDLE);
                            }
                        });

                    
                    if (evt.type == 3) {
                        
                        var panelStackKey = evt.tks,
                            panelKey = evt.eid;

                        
                        if (!panelStackKey) {
                            
                            return;
                        }


                        
                        var pnlDef = lookupDefn(this.defn, this.currlaykey, panelKey);
                        if (!pnlDef) {
                            
                            return;
                        }

                        
                        var dirtyKeys = panelKey,

                            panelStackDefn = tgtDefs[panelStackKey],

                            
                            fnActivatePanel = function () {
                                panelStackDefn.set('selKey', panelKey);
                            },

                            
                            fnPanelState;

                        
                        panelStackDefn.newSelKey = panelKey;

                        
                        if (pnlDef.l) {

                            
                            var dk = pnlDef.dirtyKeys;

                            
                            
                            if (!!dk) {

                                
                                dirtyKeys = mstrmojo.hash.keyarray(dk).join(',');

                                
                                orignalTargetDefs = tgtDefs = fnGetTargetDefn.call(this, dirtyKeys, ',');

                                
                                fnPanelState = function () {
                                    
                                    fnActivatePanel();

                                    
                                    $HFE(dataCacheUpdate.upd, function (v, updatedId) {
                                        
                                        var updatedWidget = mstrmojo.all[updatedId];

                                        
                                        if (updatedWidget && updatedWidget.setDirty) {
                                            updatedWidget.setDirty(false);
                                        }
                                    });
                                };

                            } else {
                                
                                dataService.setCurrentPanel(panelKey, evt.tks, evt.ck, this.newCallback({
                                    method: 'slice',
                                    success: fnActivatePanel
                                }));
                                return;
                            }

                        } else {
                            
                            fnPanelState = function () {
                                    
                                fnActivatePanel();

                                    
                                    pnlDef.l = true;
                            };
                                }

                        
                        var fnSuccess = callback.success;
                        callback.success = function (res) {

                                
                            var lyt = getLayout(res.defn, me.currlaykey),
                                oldLyt = getLayout(me.defn, me.currlaykey),
                                fnAppendNewProps = function (oldObj, newObj) {
                                        for (var u in newObj) {
                                            
                                            
                                            if (oldObj[u] === undefined) {
                                                oldObj[u] = newObj[u];
                                            }
                                        }
                                    },
                                    newUnits = lyt && lyt.units,
                                    oldUnits = oldLyt && oldLyt.units,
                                    newCGBMap = lyt && lyt.cgbMap,
                                    oldCGBMap = oldLyt && oldLyt.cgbMap;

                                
                                if (newUnits) {
                                fnAppendNewProps(oldUnits, newUnits);
                                }

                                
                                if (newCGBMap) {
                                    fnAppendNewProps(oldCGBMap, newCGBMap);

                                    
                                    me.raiseEvent({
                                        name: 'CGBMapChange',
                                        cgbMap: oldCGBMap
                                    });
                                }

                            
                            fnSuccess(res);

                            
                            fnPanelState();

                            
                            var panelStack = fnGetWidget(evt.tks, 0);
                            if (panelStack) {
                                panelStack.clearDirtyChild(panelKey);
                            }
                        };

                        
                        dataService.requestNewPanel(panelKey, evt.tks, evt.ck, dirtyKeys, !evt.hasLoader, callback);

                    } else {

                        
                        callback = $WRAP(callback, {
                            success: function (res) {

                                
                                $HFE(orignalTargetDefs, function (def, targetKey) {
                                    
                                    var targetWidget = fnGetWidget(targetKey, 1);

                                    
                                    if (!targetWidget) {

                                          
					  

					  
					  

					  if (!!me.sdp && !!me.sdp[targetKey]) {
						var sdpData = me.getLayoutDataCache(me.getCurrentLayoutKey());
						var sdpId = fnBuildId.call(me, {k: targetKey, wid: 1}, me.currlaykey);
						me.raiseEvent({name: 'secondaryDataSliced',key:targetKey,data:sdpData[sdpId].data});
					  }

                                        
                                        return;
                                    }

                                    
                                    if (dataCacheUpdate && !(targetKey in dataCacheUpdate.def)) {

                                        
                                        if(targetWidget.setDirty) {
                                    	    targetWidget.setDirty(true);
                                        }

                                    
                                    } else if (def.t == $RWTYPES.PANELSTACK) {

                                        
                                        targetWidget.setDirtyChildren();
                                    }
                                });
                            }
                        });

                        var args, methodName;

                        
                        if (evt.type == $RWTYPES.GRAPH) {
                            
                            methodName = 'applyGraphSelectorAction';
                            args = [ evt.ck, evt.cks, evt.sid, evt.x, evt.y, callback, me.zf];
                        } else {

                            
                            
                        if(evt.isMultipleEvents){
                            methodName = 'RWEventsTask';
                            params = {
                                    messageID: this.mid,
                                    styleName: 'RWDocumentMojoStyle',
                                    events: evt.events
                            };
                            args = [params, callback];
                        } else if ('eid' in evt) { 
                                methodName = evt.isDocVis ? 'setDocVisSelectorElements' : 'setDocSelectorElements';
                                args = [ evt.ck, evt.eid, evt.ctlKey, evt.include, callback , me.zf];
                                
                                var hasAllInGB = hasAllSelectedInGB.call(this);
                                if (evt.isUConDS || hasAllInGB) {
                                	evt.disablePU = true;
                                    args = args.concat([null, 0, null, true]);
                                }
                                
                                if (hasAllInGB) {
                                    evt.restoreIW = true;
                                }

                				 
                				 

                				 if (me.sdp) {
                					var sdpreqKeys = {};
                					$HFE(me.sdp, function(obj, key){
                						if (me.sdp[key]) {
                							sdpreqKeys[key] = obj.visName;
                						}

                					});

                					args[7] = JSON.stringify(sdpreqKeys);

                				 }
                                 args[8] = evt.tks;
                            } else if (evt.multiSelect) {
                                if (evt.selectorObjects.length > 0) {
                                    methodName = 'setMultiDocSelectorElements';
                                    args = [evt.selectorObjects, evt.multiSelect, callback, me.zf];
                                }
                            } else {
                                
                                
                                if ('srct' in evt && evt.srct == 4) {
                                    if (evt.onlyInclude){
                                        methodName = 'setDocSelectorInclude';
                                        args = [ evt.ckey, evt.include, callback, evt.srcid, evt.srct, me.zf];

                                    } else {
                                        methodName = 'setDocSelectorExpression';
                                        args = [ evt.ck, evt.ckey, evt.srcid, evt.srct, evt.f, evt.ft, evt.include, evt.cs, 5, callback, me.zf];

                                        if (!evt.cs) {
                                            args[7] = null;
                                            args[8] = null;

                                            if (evt.changeQual) {
                                                
                                                dataService.setRWUnitProperties(evt.ckey, evt.ckey + '\u001F' + 'FormattingSelector' + '\u001F' + 'MetricConditionType' + '\u001F' +evt.qt, 1, false, null);

                                                args.push(evt.unset);
                                            }
                                        }

                                    }
                                } else if (evt.unset) {
                                    methodName = 'setDocUnsetSelector';
                                    args = [ evt.ck, evt.ckey, callback, me.zf];

                                } else {
                                    methodName = 'setDocSelectorInclude';
                                    args = [ evt.ckey, evt.include, callback, null, null, me.zf ];

                                }
                            }
                        }

                        if (methodName) {
                            dataService[methodName].apply(dataService, args);
                        }
                    }

                } catch (ex) {
                    mstrmojo.err(ex);
                }
            },

            
            getLayoutDataCache: function getLayoutDataCache(key) {
                
                if (!key) {
                    return null;
                }

                var dc = this.dataCache;
                
                if (!dc) {
                    
                    dc = this.dataCache = {};
                }

                
                if (!dc[key]) {
                    
                    dc[key] = {};
                }

                return dc[key];
            },

            
            updateDataCache: function updDC(tree, tks, sid) {

                var me = this,
                    dc = this.getLayoutDataCache(this.getCurrentLayoutKey()),
                    _result = {
                        ifws: {},    
                        upd: {},    
                        tgts: {},   
                        def: {},    
                        secs: {}    
                    };

                
                function findTgtDescendants(node, wasInst, activeKey) {

                    var isInst = false,   
                        chnodes = me.getChildren(node, true), 
                        w;              

                    
                    if (!chnodes.length) {
                        
                        return;
                    }

                    
                    if (wasInst) {
                        
                        w = mstrmojo.all[node.id];

                        
                        
                        isInst = !node.id || !!w;
                    }

                    var nodeDefn = node.defn,
                        nodeData = node.data,
                        selectedPanelKey;

                    
                    if (nodeDefn && nodeDefn.t === $RWTYPES.PANELSTACK && nodeDefn.od) {
                        
                        selectedPanelKey = nodeData.selKey;
                    }

                    
                    for (var cnt in chnodes) {
                        var ch = chnodes[cnt],
                            childKey = ch.k,
                            id = ch.id,
                            localActiveKey = null;

                        
                        if (mstrmojo.all[id]) {
                            isInst = true;
                        }

                        
                        if (childKey in tks) {

                            if (isInfoWindowPS.call(me, childKey) && isCurrentSlice(ch.data, sid)) {
                                
                                dc[id] = ch;

                                
                                if (!activeKey) {
                                    
                                    _result.ifws[childKey] = me.infoWinByKey[childKey].id; 
                                }
                            }

                            
                            localActiveKey = childKey;

                            
                            if (isInst) {
                                
                                
                                if (selectedPanelKey && selectedPanelKey !== childKey) {
                                    
                                    continue;
                                }

                                
                                if (!activeKey) {
                                _result.tgts[id] = true;
                                }

                                var secDef = w && w.defn,
                                    ty = secDef && secDef.t,
                                    ck = secDef && secDef.ck;

                                
                                if (ty === $RWTYPES.SUBSECTION && (ck && (childKey in ck))) {
                                    
                                    _result.secs[w.id] = true;
                                }
                            }
                        }

                        
                        if ((activeKey || localActiveKey) && (!selectedPanelKey || selectedPanelKey === childKey)) {
                            
                            dc[id] = ch;

                            
                            _result.def[childKey] = true;

                            
                            if (isInst) {
                                
                                _result.upd[id] = true;
                            }
                        }

                        
                        findTgtDescendants(ch, isInst, activeKey || localActiveKey);
                    }
                }

                
                if (tree && tree.layouts && tks) {
                    
                    findTgtDescendants(mstrmojo.array.filter(tree.layouts, function (l) {
                            return (l.loaded);
                        }, {
                            max: 1
                        })[0], true);
                }

                return _result;
            },
            
            getCGBMap: function getCGBMap(){
                var lyt = getLayout(this.defn, this.currlaykey);

                return lyt && lyt.cgbMap;
            },

            executeLink: function executeLink(url, target, src) {
                
                
                
                if (url.indexOf('prevMsgID') > 0) {
                    var replacement = 'prevMsgID=' + this.mid;
                    url = url.replace(/prevMsgID=0($|&)/g, function (match, cap) {
                        if (cap == '&') {
                            return replacement += '&';
                        } else {
                            return replacement;
                        }
                    });
                    
                    if (mstrmojo.dom.isIE) {
                        url += '&cb' + mstrmojo.now() + '=1';
                    }
                }

                url = mstrmojo.addCSRFTokenToURL(url);

                this.controller.onLink(
                        this,
                        {
                            url: url,
                            target: target,
                            src: src || null
                        }
                 );
            },

            showInfoWin: function showInfoWin(key, anchor, orientation, invalidate, anchorPosition) {
                var ifwunit = this.infoWinByKey && this.infoWinByKey[key];
                if (ifwunit === undefined) { 
                    return;
                }
                this.raiseEvent({
                    name: 'showInfoWin',
                    psId: ifwunit.id,
                    psKey: ifwunit.k,
                    anchor: anchor,
                    anchorOrientation: orientation,
                    anchorPosition: anchorPosition,
                    invalidate: invalidate
                });
            },

            
            downloadGridData: function downloadGridData(params) {
                var me = this,
                    widgetID = params.xtabId,
                    memo = params.memo,
                    w = mstrmojo.all[widgetID],
                    dataService = this.getDataService();

                var callback = this.newCallback({
                        success: function (res) {
                            
                            function findWidgetData( node,  wID) {
                                
                                var chnodes = me.getChildren(node, true);

                                
                                for (var cnt in chnodes) {
                                    var ch = chnodes[cnt];
                                    if(wID == ch.id) {
                                        return ch;
                                    }

                                    
                                    var w = findWidgetData(ch, wID);
                                    
                                    if(w) {
                                        return w;
                                    }
                                }
                                return null;
                            }

                            
                            var tree = res.data,
                                newGridData = null,
                                nodeDef, 
                                lyt = tree && getLayout(tree, me.currlaykey);

                            
                            if (lyt) {
                                newGridData = findWidgetData(lyt, widgetID);
                            }

                            if (newGridData && w) {
                                w.dataDownloaded(newGridData, memo);
                            }

                            if(lyt && lyt.xtabStyles) {
                                me.raiseEvent({
                                    name: 'updateStyles',
                                key: lyt.k,
                                    updatedStyles: lyt.xtabStyles
                                });
                            }

                            
                            nodeDef = lookupDefn.call(me, me.defn, me.currlaykey, params.nodeKey);
                            if(nodeDef && nodeDef.t === $RWTYPES.GRIDGRAPH && memo.recalculating) {
                                var gg = w.parent,
                                    gp = gg && gg.getGraphWidget();
                                if(gg && gp && gg.updateGraph) {
                                    gg.updateGraph(findWidgetData(lyt, gp.id));
                                }
                            }

                        },

                        failure: function() {
                            if(w.dataDownloadErr) {
                                w.dataDownloadErr();
                            }
                        }
                });

                dataService.downloadGridData(params, callback);
            },

            
            saveRWProps: function saveRWProps(nodeKey, props, type, loadData, callback) {
                var data = [],
                    d = '\u001F';

                
                $HFE(props, function (o, key) {
                    
                    $HFE(o, function (v, p) {
                        
                        data.push(key + d + p + d + v);
                    });
                });

                
                if (!data.length) {
                    
                    return;
                }

                
                    if (loadData) {
                    
                    var g = lookupDefn.call(this, this.defn, this.currlaykey, nodeKey),
                        fnReadyState = function (rs) {
                            g.set('readyState', rs);
                        };

                    
                    callback = $WRAP(callback, {
                        submission: function () {
                            
                            fnReadyState($RS.WAITING);
                        },

                        complete: function () {
                            
                            fnReadyState($RS.IDLE);
                        }
                    });
                }

                
                this.getDataService().setRWUnitProperties(nodeKey, data.join('\u001E'), type || 1, loadData, callback);
            },

            loadPartialData: function loadPartialData(data, nodeKey){
                
                var tgtDef =  {};
                tgtDef[nodeKey] = lookupDefn.call(this, this.defn, this.currlaykey, nodeKey);


                
                
                var ids = this.updateDataCache(data, tgtDef),
                    dc = this.getLayoutDataCache(this.getCurrentLayoutKey()),
                    me =  this;

                
                mstrmojo.array.forEach(data.layouts, function (l) {
                    if(l && l.xtabStyles) {
                        me.raiseEvent({
                            name: 'updateStyles',
                            key: l.k,
                            updatedStyles: l.xtabStyles
                        });
                    }
                });

                
                $HFE(ids, function (col, meth) {
                    if (meth === 'upd') {
                        $HFE(col, function (v, id) {
                            
                            var w = mstrmojo.all[id];
                            
                            if (w && w.update) {
                                w.update(dc[id]);
                            }
                        });
                    }
                });
            },

            
            addAutoWidthID: function addAutoWidthID (id) {
                var aws = this.aws || {},
                    units = aws[this.currlaykey] || [];

                
                units.push(id);

                
                aws[this.currlaykey] = units;

                
                this.aws = aws;
            },

            
            getAutoWidthIDs: function getAutoWidthIDs() {
                var aws = this.aws,
                    l = this.currlaykey;

                
                var ids = aws && aws[l];
                if (ids) {
                    
                    delete aws[l];
                }

                return ids;
            }
        }
    );
})();

(function(){

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.array",
                         "mstrmojo.StringBuffer",
                         "mstrmojo.ResSetLink");
    
    var ROW_AXIS = 1,
        COL_AXIS = 2;
    
    var ATTRIBUTE_SORT = 2,
        COLUMN_SORT = 4;
    
    var DRILLING_ACTION = 1,
        HYPERLINK_ACTION = 4;
    
    
    
    function getTitlesAxis(gts, ax) {
        return gts[((ax === ROW_AXIS) ? 'row' : 'col')];
    }
    
    function getCellLinksContainer(cell, title) {
        var linkMap = title.lm;
        
        
        return linkMap && linkMap[cell.mix || 0];
    }
    
    function getCellDrillsContainer(cell, title) {
        var drillList = title.dp;
        
        return drillList && drillList[cell.mix || 0];
    }
    
    
    function buildLink(linksContainer, linkInfo, cell) {
        var link = new mstrmojo.ResSetLink({
            mid: this.getMessageId(),
            srct: 2,
            aopam: linkInfo.daMode
        });          
        
        var answers = linkInfo.ans,
            answerCnt = answers && answers.length;
          
        if (answerCnt) {
            
            
            var prms = link.prms = [],
                i = 0;

            for (i = 0; i < answerCnt; i++) {
                var answer = answers[i];
                  
                
                var pid = answer.pid,
                    am = parseInt(answer.m, 10),
                    prm = {
                        id: pid,
                        am: am,
                        
                    	pt: answer.pt
                    };
                prms.push(prm); 
                if (answer.po) {
                    prm.orid = answer.po.did;
                    prm.ortp = answer.po.t;
                }
                  
      
                
                switch (am) {
                    case link.DO_NOT_ANSWER:
                    case link.CLOSE:
                    case link.USE_DEFAULT_ANSWER:
                    case link.SAME_PROMPT:
                        break;
                          
                    case link.STATIC:
                        var statElems = answer.es,
                        staticLen = (statElems && statElems.length) || 0,
                        z;

                        prm.pa = {
                            es:[]        
                        };
                    for (z = staticLen - 1; z >= 0; --z) {
                            var statElem = statElems[z];
                            prm.pa.es.push({
                                ei: statElem.id,
                                disp_n: statElem.n,
                                emt: 1
                            });
                        }
                          
                        break;
                          
                    case link.DYNAMIC:
                    case link.ALL_VALID_UNITS:
                    case link.CURRENT_UNIT:
                        var dynUnits = answer.dunits;       
                        if (dynUnits && dynUnits.length && cell) {
                            var pa = prm.pa = {};

                            
                            var pCell = cell,
                                
                                isMetricValue = (cell.mix !== undefined) && (cell._lp || cell._tp);
                                  
                                
                                if (isMetricValue) {
                                    
                                    
                                    pCell = cell._lp || cell._tp;
                                }
                                  
                        var axis = parseInt(pCell.axis, 10);
                                while (pCell) {
                                    
                                	  var pTitle = this.getPTitle(pCell, axis); 

                                    
                                    if (pTitle && mstrmojo.array.find(dynUnits, 'id', pTitle.id) >= 0) {
                                    if (am !== link.DYNAMIC) {
                                        pa.a = {
                                            id: pTitle.id,
                                            n: pTitle.n,
                                            dispForms: pTitle.dfi
                                        };
                                    }
                                    if ( answer.pt === 1 ) {
                                        
                                    	pa.v = pCell.v;
                                    	break;
                                    } else {
                                        
                                        var eid = pCell._e.id,
                                            dsn = pCell._e.n; 
                                        
                                        pa.es = [];
                                        pa.es.push({
                                            ei: eid,
                                            emt: 1,
                                            disp_n: dsn 
                                        });
                                    }
                                    
                                    if (am === link.CURRENT_UNIT) {
                                            break;
                                        }
                                    }

                                    
                                   pCell = this.getPCellParentNode(pCell, axis);
                                    
                                    
                                    if (isMetricValue && !pCell && axis === ROW_AXIS) {
                                        
                                        axis = COL_AXIS;
                                          
                                        
                                        pCell = cell._tp;
                                    }
                                }
                        }
                        break;
                }
            }
        }
        return link;
    }
        
    
    function getDrillElements(cells) {
        var titleInfo = this.getCellTitleInfo(cells[0]),
            elements = [],
            fnAddCell= function (cell) {
                if (cell) {
                    if ( mstrApp.useBinaryFormat ) {
                    	if ( cell._e ) {
	                        elements.push(cell.axis + 'A' + (cell.ui + 1) + 'A' + cell._e.id);
                    	}
                        fnAddCell(cell._p);
                    } else {
                        elements.push(cell.axis + 'A' + (cell.ui + 1) + 'A' + cell.o);
                    }
                }
            },
            i,
            len;
        
        if (!titleInfo.isSrcTitle) {            
            for (i = 0, len = cells.length; i < len; i++) {
                var c = cells[i];            
                
                if (c.mix !== undefined && (c._lp || c._tp)) {
                    fnAddCell(c._lp);
                    fnAddCell(c._tp);
                } else {
                    fnAddCell(c);
                }
            }
        }

        return (mstrApp.useBinaryFormat) ? elements : elements.join(',');
    }
    
    
    mstrmojo.XtabModel = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,
        
        
        {            
            scriptClass: "mstrmojo.XtabModel",
            
            getMessageId: function getMessageId() {
                return this.data.mid;
            },
            
            
            getCellTitleInfo: function getCellTitleInfo(cell, dataBlock) {
                var gts = dataBlock ? dataBlock.gts : this.data.gts;
                
                
                
                
                
                var title = null;
                
                
                if (cell.mix === undefined) {
                    title = getTitlesAxis(gts, cell.axis)[cell.tui || cell.ui];
                    
                } else {
                    
                    
                    var findMetricTitle = function(titles) {
                        var len = (titles && titles.length) || 0,
                            i;

                        for (i = len - 1; i >= 0; --i) {
                            if (parseInt(titles[i].otp, 10) === -1) {
                                
                                return titles[i];
                            }
                        }
                        
                        
                        return null;
                    };
                    
                    
                    title = findMetricTitle(gts.col) || findMetricTitle(gts.row); 
                }
                
                return {
                    isSrcTitle: (cell.o === undefined), 
                    title: title
                };            
            },
            
            
            getCellLinksInfo: function getCellLinksInfo(cell, title) {
                if (!title) {
                    var titleInfo = this.getCellTitleInfo(cell);
                    title = titleInfo && titleInfo.title;
                }
                
                return getCellLinksContainer(cell, title);
            },

            
            getCellDrillsInfo: function getCellDrillsInfo(cell, title) {
                if (!title) {
                    var titleInfo = this.getCellTitleInfo(cell);
                    title = titleInfo && titleInfo.title;
                }
                return getCellDrillsContainer(cell, title);
            },
            
            getLinkDrillAction: function getLinkDrillAction(cells) {
                return this.getActionObject(cells);
            },

            getAction: function getAction(cells) {
                return this.getActionObject(cells);
            },

            getActionObject: function getActionObject(cells) {
                var actionType = cells[0] && cells[0].at,
                    _rtn = null;

                
                if (actionType) {
                    
                    if (actionType & HYPERLINK_ACTION) {
                        _rtn = {
                            h: 'onLink',
                            a: this.getLinkAction(cells[0])
                        };
                        
                    
                    } else if (actionType & DRILLING_ACTION) {
                        _rtn = {
                            h: 'onDrill',
                            a: this.getDrillAction(cells)
                        };
                    }
                }
                
                return _rtn;
            },
            
            
            getSortAction: function getSortAction(cell, isAsc) {
                var titleInfo = this.getCellTitleInfo(cell),
                    title = titleInfo.title,
                    subTotalsPos = this.data.gts[((cell.axis === ROW_AXIS) ? 'row' : 'col') + 'SubPos'],
                    elems = [],
                    unitAxis = title.axis,
                    sortType,
                    unitID,
                    unitType,
                    formId;
                
                
                isAsc = (isAsc === null || isAsc === undefined) ? !(cell && cell.so) : isAsc;
                
                
                if (titleInfo.isSrcTitle) {
                    sortType = ATTRIBUTE_SORT;
                    unitID = title.id;
                    unitType = title.otp;
                    formId = title.fid;
                    
                } else {
                    
                    sortType = COLUMN_SORT;
                    unitType = 4;
                    unitAxis = ROW_AXIS;
                    subTotalsPos = this.data.gts.rowSubPos;
                    
                    
                    
                    do {
                        
                        var e = cell._e;
                        if (e) {
                        
                        if (e.oid) {
                            unitID = e.oid;
                            
                        } else {
                            
                            elems.push(e.id);
                            
                        }                
                        }
                        
                        
                        cell = cell._p;
                        
                    } while (cell);
                }
                
                
                var action = {
                    sortType: sortType,
                    axis: unitAxis, 
                    isAsc: isAsc, 
                    unitID: unitID, 
                    unitType: unitType, 
                    elementList: elems.join('\u001E'), 
                    subTotalsPos: subTotalsPos
                };
                
                
                if (unitID) {
                    
                    action.unitID = unitID;
                }

                
                if (formId) {
                    
                    action.formId = formId;
                }
                
                
                var sortKey;
                if (sortType === COLUMN_SORT) {
                    sortKey = [ '', '', action.elementList || '', action.axis ];
                } else {
                    sortKey = [ action.formId, '21' ];
                }
                sortKey = [ action.unitType, action.unitID ].concat(sortKey);
                action.sortKey = sortKey.join('!');
                
                
                return action;

            },
            
            
            getPivotAction: function getPivotAction(cell, btn) {
                var isForm = false,                                
                    isMetric = cell.hasOwnProperty('mix'),         
                    ax = (isMetric) ? null : cell.axis,            
                    pos = ((isMetric) ? cell.mix : cell.ui) + 1,   
                    isMT = (cell.otp === -1);                      
                
                
                if (!isNaN(btn)) {
                    ax = btn;           
                    pos = 1;            
                    
                    
                    if (isMetric) {
                        isMetric = false;   
                        isMT = true;        
                    }
                    
                } else {
                    
                    var dec = (btn === 'u' || btn === 'l');
    
                    
                    if (!isMetric) {
                        
                        var axis = getTitlesAxis(this.data.gts, ax),        
                            cnt = 0,                                        
                            info = {},                                      
                            bCur = false;                                   
                        
                        
                        mstrmojo.array.forEach(axis, function (u) {
                            
                            if (info[u.id]) {
                                
                                info[u.id].frm++;
                                
                            } else {
                                
                                cnt++;
                                
                                
                                info[u.id] = {
                                    pos: cnt,
                                    frm: 1
                                };
                                
                                
                                if (u.id === cell.id) {
                                    
                                    bCur = true;
                                } else if (bCur) {
                                    
                                    return false;
                                }
                            }
                            
                        });
                        
                        
                        pos = info[cell.id].pos;
    
                        
                        var fix = cell.fix;
                        if (fix) {
                            
                            
                            if (!dec || fix > 1) {
                                
                                if (dec || fix !== info[cell.id].frm) {
                                    
                                    pos = fix;
                                    
                                    
                                    isForm = true;
                                }
                            }
                        }
                    }
                    
                    
                    pos = pos + ((dec) ? -1 : 1);
                }
                
                
                var action = {
                    pos: pos        
                };
                
                
                if (isForm) {
                    
                    action.formID = cell.fid;
    
                } else if (!isMetric) {
                    
                    action.axis = ax;
                }
                
                
                if (!isMT) {
                    
                    var mSrc = (isMetric) ? cell._e : cell;
                    
                    
                    if (!isForm) {
                        action.objectType = mSrc.otp;
                    }
                    
                    
                    action.objectId = (isMetric) ? mSrc.oid : cell.id;
                }
                
                return action;
            },
            
            
            isPvtButtonVisible: function isPvtButonVisible(c, btn) {
                var ax = c.axis,                                         
                    axis = getTitlesAxis(this.data.gts, ax),             
                    isMetric = c.hasOwnProperty('mix');
                
                
                if (!isNaN(btn)) {
                    
                    if (parseInt(btn, 10) === ax) {
                        return false;
                    }
                    
                    
                    if (isMetric) {
                        
                        return !!axis[c.ui]._hid;
                    }
                    
                    
                    return true;
                }
    
                var es = axis[c.ui].es,                           
                    pos = c.ui,                                   
                    len = (isMetric) ? es.length : axis.length;   
                    
                
                if (len === 1) {
                    
                    return false;
                }
                        
                
                if (ax === ((isMetric) ? COL_AXIS : ROW_AXIS)) {
                    
                    if (btn === 'u' || btn === 'd') {
                        return false;
                    }
                } else {
                    
                    if (btn === 'l' || btn === 'r') {
                        return false;
                    }
                }
                
                
                if ((isMetric) ? c._e === es[0] : pos === 0) {
                    
                    if (btn === 'l' || btn === 'u') {
                        return false;
                    }
                }
                    
                
                if (isMetric ? c._e === es[len - 1] : pos === len - 1) {
                    
                    if (btn === 'r' || btn === 'd') {
                        return false;
                    }
                }
                
                
                return true;
            },
            
            
            getDrillAction: function getDrillAction(cells) {
                var titleInfo = this.getCellTitleInfo(cells[0]),
                    title = titleInfo.title,
                    drillPath = title.dp[cells[0].mix || 0];
                
                return {
                    srcMsgId: this.data.mid,
                    isWithin: drillPath.within,
                    drillPathKey: drillPath.k,
                    drillPathIndex: drillPath.dpi,
                    drillElements: getDrillElements.call(this, cells)
                };
            },
            
            getPTitle: function getPTitle(pCell, axis){
            	var gts = this.data.gts;
           		return getTitlesAxis(gts, axis)[pCell.tui];
            },
            
            getPCellParentNode: function getPCellParentNode(pCell, axis){
            	 
            	return pCell._p;
            },
                        
            
            getLinkAction: function getLinkAction(cell, idx) {
                var titleInfo = this.getCellTitleInfo(cell),
                    title = titleInfo.title;                
                return this.getLinkActionImpl(cell, title, idx);
            },
            
            getLinkActionImpl: function getLinkActionImpl(cell, title, idx) {
                var linksContainer = getCellLinksContainer(cell, title),    
                    linkArray = linksContainer && linksContainer.links,
                    linkTarget = (linksContainer.onw) ? '_blank' : '';
                
                
                if (idx === null || idx === undefined) {
                    
                    idx = (linksContainer && linksContainer.di) || 0;    
                }
                
                
                var linkInfo = linkArray && linkArray[idx];           
                if (!linkInfo) {
                    
                    return null;
                }
                
                
                var action = {
                    linkInfo: linkInfo,
                    linkTarget: linkTarget
                };
                
                
                var url = linkInfo.url;
                if (url) {
                    
                    var currentElement = '&CurrentElement';
                    if (cell && title && url.indexOf(currentElement) > -1) {
                        url = url.replace(currentElement, cell._e.id);
                    }

                    
                    action.url = url;

                } else {
                    
                    var target = linkInfo.target,
                        evt,
                        idField;
                    
                    
                    switch (parseInt(target && target.t, 10)) {
                        case 55:                
                            
                            if (parseInt(target.st, 10) === 14081) { 
                                
                                evt = 2048001;   
                                idField = 'objectID';

                            } else {
                                
                                evt = 32001;   
                                idField = 'documentID';
                            }
                            break;
                            
                        case 3:                 
                            
                            evt = 4001;         
                            idField = 'reportID';
                            
                            
                        action.reportViewMode = ((parseInt(target.st, 10) === 0x301) ? 2 : 1);
                            break;
                            
                        default: 
                            
                            return null;
                    }
                    
                    
                    action.evt = evt;
                    action[idField] = target.did;
                    action.srcMsgId = this.getMessageId();
                    
                    
                    var link = buildLink.call(this, linksContainer, linkInfo, cell);
                    if (link) {
                        action.link = link;
                    }
                    
                    
                    
                    
                    
                    return action;
                }
            },
            
            
            getDownloadAction: function getDownloadAction(rowPosition, maxRows,  colPosition, maxCols, widgetID, memo) {
                return {
                    xtabId: widgetID,
                    rowPosition: rowPosition,
                    maxRows: maxRows,
                    colPosition: colPosition,
                    maxColumns: maxCols,
                    memo: memo
                };
            }
        }
    );
}());

(function () {
    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.num",
                         "mstrmojo._TouchGestures");

    var $D = mstrmojo.dom,
        $CSS = mstrmojo.css,
        $MIN = Math.min,
        $MAX = Math.max,
        $RND = Math.round,
        $NUM = mstrmojo.num,
        $CD = $NUM.countOfDecimals;

    

    
    function initCal() {
        var cs = document.defaultView.getComputedStyle,
            ns = [this.leftNode, this.rightNode],
            ps = [ 'border-left-width', 'padding-left', 'margin-left', 'border-right-width', 'padding-right', 'margin-right' ],
            ds = [0, 0],
            i,
            j;

        
        for (i = 0; i < ns.length; i++) {
            var styl = cs(ns[i]);
            for (j = 0; j < ps.length; j++) {
                ds[i] += parseInt(styl.getPropertyValue(ps[j]), 10) || 0;
            }
        }

        this._lnExt = ds[0];
        this._rnExt = ds[1];

        
        if (!this._thumbLen) {
            this._thumbLen = parseInt(this.thumbNode.offsetWidth, 10);
        }

        
        
        this._length = this.domNode.clientWidth;
        this._effLen = $RND(this._length - this._thumbLen);
        this._unitLen = this._effLen / (this.max - this.min);
        
    }

    
    function position(v) {
        
        var min = this.min,
            unitLength = this._unitLen,
            thumbLength = this._thumbLen / 2,
            lLen = $RND((v - min) * unitLength);

        
        this.leftNode.style.width = (lLen + thumbLength - this._lnExt) + 'px';

        
        this.rightNode.style.width = (this._effLen - lLen + thumbLength - this._rnExt) + 'px';

        
        
        
        $D.translate(this.thumbNode, $MAX($MIN(lLen, (this.max - min) * unitLength), 0), 0);
    }

    
    function calValueWDelta(v, delta) {
        var interval = this.interval;
        return $MIN($MAX(this.min, parseFloat(v, 10) + $RND(delta / this._unitLen / interval) * interval), this.max).toFixed(this._intervalDecimals); 
    }

    
    function calValueWX(x) {
        return calValueWDelta.call(this, this.min, x - $D.position(this.domNode, true).x - this._thumbLen / 2);
    }

    function getTouchRedirectFn(methodName) {
        return function (touch) {
            return this['touchSelect' + methodName](touch);
        };
    }
    
    mstrmojo.ui.MobileSlider = mstrmojo.declare(
        mstrmojo.Widget,

        [ mstrmojo._TouchGestures ],

        
        {
            markupString: '<div class="mstrmojo-MobileSlider" style="visibility:hidden;">' +
                              '<div class="v"></div>' +        
                              '<div class="bk"></div>' +        
                              '<div class="th"><div></div></div>' +        
                              '<div class="min">{@minText}' + '</div>' +     
                              '<div class="max">{@maxText}</div>' + 
                          '</div>',

            markupSlots: {
                leftNode: function () { return this.domNode.childNodes[0]; },
                rightNode: function () { return this.domNode.childNodes[1]; },
                thumbNode: function () { return this.domNode.childNodes[2]; },
                minNode: function () { return this.domNode.childNodes[3]; },
                maxNode: function () { return this.domNode.childNodes[4]; }
            },

            markupMethods: {
                onvalueChange: function () {
                    if (this.hasRendered) {
                        
                        position.apply(this, [this.value]);
                    }

                    if (this.slidingValue !== this.value) {
                        this.set('slidingValue', this.value);
                    }
                },
                onslidingValueChange: function () {
                    if (this.hasRendered) {
                        position.apply(this, [this.slidingValue]);
                    }
                }

            },
            
            value: 0,

            
            slidingValue: 0,

            
            max: 10,

            
            min: 0,

            
            interval: 1,

            
            _intervalDecimals: 0,

            
            init: function init(props) {
                this._super(props);
                this._intervalDecimals = $CD(this.interval, '.'); 
            },

            onintervalChange: function onintervalChange(n, v) {
                this._intervalDecimals = $CD(v, '.'); 
            },

            preBuildRendering: function preBuildRendering() {
                
                this.minText = $NUM.toLocaleString(this.min);
                this.maxText = $NUM.toLocaleString(this.max);

                this._super();
            },

            
            postBuildRendering: function postBuildRendering() {
                this._super();

                
                initCal.call(this);

                
                position.call(this, this.value);

                
                this.domNode.style.visibility = 'visible';
            },

            resize: function resize() {
                
                initCal.call(this);

                
                position.call(this, this.value);
            },
            

            
            touchBegin: function touchBegin(touch) {
                touch.stop();
            },

            
            touchSelectBegin: function touchSelectBegin(touch) {
                
                var target = touch.target;
                if (!target || target !== this.thumbNode) {
                    
                    return this.bubbleTouchEvent(touch);
                }

                
                $CSS.addClass(this.domNode, 'active');

                
                this.slidingValue = this.value;
            },

            
            touchSelectMove: function touchSelectMove(touch) {
                this.set('slidingValue', calValueWDelta.apply(this, [ this.value, touch.delta.x || 0 ]));
            },

            
            touchSelectEnd: function touchSelectEnd(touch) {
                
                $CSS.removeClass(this.domNode, 'active');

                this.set('slidingValue', calValueWDelta.apply(this, [this.value, touch.delta.x || 0 ]));
                this.set('value', this.slidingValue);
            },

            touchSwipeBegin: getTouchRedirectFn('Begin'),

            touchSwipeMove: getTouchRedirectFn('Move'),

            touchSwipeEnd: getTouchRedirectFn('End'),

            
            
            onclick: function onclick(evt, hWin) {
                this.touchTap({
                    clientX: $D.getMousePosition(evt.e, hWin).x
                });
            },

            
            
            touchTap: function touchTap(touch) {
                this.set('value', calValueWX.call(this, touch.clientX));
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Widget",
        "mstrmojo._Formattable");
    
    
    mstrmojo.DocRectangle = mstrmojo.declare(
        mstrmojo.Widget,
        
        [mstrmojo._Formattable],

        
        {
            scriptClass: "mstrmojo.DocRectangle",

            markupString: '<div id="{@id}" class="mstrmojo-DocRectangle" title="{@tooltip}" style="{@domNodeCssText}"></div>', 

            markupMethods: {
                onheightChange: function(){
                    if (this.height) {
                        this.domNode.style.height = this.height + 'px';
                    }
                },
                onwidthChange: function(){
                    if (this.width) {
                        this.domNode.style.width = this.width + 'px';
                    }
                },
				onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },
            
            formatHandlers: {
                domNode: ['RW', 'B', 'background-color', 'fx']
            },
            
            
            preBuildRendering: function preBuildRendering() {
            	var rtn = this._super(),
            		defn = this.defn;
            	
            	
            	if (defn.r) {
            		
               		this.domNodeCssText += mstrmojo.css.buildRoundCorners(defn.r, defn.topc);
            	}
            	
            	return rtn;
            },
            
            
            postBuildRendering: function() {
                var rtn = this._super();
                   
                
                var fmts = this.fmts;
                if (fmts) {
                    var b = fmts.border || fmts['border-width'],
                        bw = b && (parseInt(b, 10) / 72 * this.model.dpi ); 
                        
                    if (bw) {
                        if (fmts.height == '100%') {
                            this.set('height', this.domNode.clientHeight - 2 * bw);
                        }
                        if (fmts.width == '100%') {
                            this.set('width', this.domNode.clientWidth - 2 * bw);
                        }
                    }
                }
                return rtn;
            },
            
            update: function update(node) {
                
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
                
				this.set('visible', !node.data.hidden);
				
                if (this._super) {
                    this._super(node);
                }
            }
        }
    );
    
})();
(function(){

    var AUTO_TR = '<tr>';
    var TBL_MKP_START = ['<table cellspacing="0" cellpadding="0" style="table-layout:', null,
                                                   ';width:', null,
                                                   ';mstr-tablestyle-slot" ', null,
                                                   '>', null,
                                                   '<tbody>'];
    var NBSP = "&nbsp;";
    var STITCH_TOP_CSS = "fsbp_1 ";
    var STITCH_MIDDLE_CSS = "fsbp_2 ";
    var STITCH_BOTTOM_CSS = "fsbp_3 ";
    var STACK_TOP = 1,
        STACK_MIDDLE = 2,
        STACK_BOTTOM = 3,
        NO_STACK = 4,
        FULL_STACK = 5,
        STACK_CSS = {
        1: ' stack-top',
        2: ' stack-middle',
        3: ' stack-bottom',
        4: ' no-stack',
        5: ' stack-full'
    };

    var $CSS = mstrmojo.css;

    var BASEFORM_PICTURE = 4;

    
    function stitchBottomCells(cells, tbody) {
        for(var i=0, iLen = cells.length; i < iLen; i++) {
            var c = cells[i];
            var d = tbody.rows[c.rows].cells[c.cells];
            if(d) {
                mstrmojo.css.addClass(d, STITCH_TOP_CSS);
            }
        }

    }

    mstrmojo.requiresCls(
            "mstrmojo.Widget");

    mstrmojo.GridBase = mstrmojo.declare(
        
        mstrmojo.Widget,

        
        null,

        
        {
            scriptClass: "mstrmojo.GridBase",

            
            markupString: '<span id="{@id}" class="mstrmojo-Grid {@cssClass}" style="{@cssText}"></span>',

            markupSlots: {
                gridContainerNode: function(){ return this.domNode; }
            },

            
            autoFitWindow:false,

            
            tableLayout:null,

            
            numAutoHeightRows:0,

            
            cp:null,

            
            rc:0,

            
            cc:0,

            
            cws:null,

            
            rh:null,

            
            totalColWidth: 0,

            
            start:0,

            
            end:0,

            forceFixedSizes:true,

            
            hiliteCellsMap: null,

            
            eiMap: null,

            
            init: function init_Grid( props) {
                
                this._super(props);
            },

            
            numColumnCanMerge: 0,

            
            preBuildRendering: function preBuildRendering(res) {
                var cp = this.cp;
                if(!cp) {
                    return;
                }
                cp.initContent();
                this.rc = cp.rc || 0;           
                this.cws = cp.colWidths || [];  
                this.cc = this.cws.length;              

                this.tdWidths = cp.tdWidths || [];	
                this.tdCnt = this.tdWidths ? this.tdWidths.length : 0;	

                this.start = 0;
                this.end = this.rc - 1;

                
                this.numAutoHeightRows = cp.getNumAutoHeightRows && cp.getNumAutoHeightRows() || 0;

                this.hiliteCellsMap= {};
                this.eiMap= {};
                this.posMap = [];
                this.thPosMap = [];

                
                this.totalColWidth = 0;

                
                
            },

            
            buildRendering: function buildRendering(res) {
                
                var ret = this._super(res);

                this.renderGrid();

                return ret;
            },

            
            renderGrid: function renderGrid(append) {
                
                var containerNode = this.getGridContainer();

                
                this.preBuildGridTable();

                
                this.buildGridTable(containerNode, append);

             
                this.postBuildGridTable();
            },

            
            getGridContainer: function getGridContainer() {
                return this.gridContainerNode;
            },


            
            buildGridTable: function buildGridTable( gridContainer, append) {
                
                var tms = this.getTableStartMarkup();

                
                var tme = this.getTableEndMarkup();

                
                if(append) {
                    this.mergeHdrsAcrossBlks = true;
                }

                
                var tInnerHTML = this.buildTableRowsMarkup(this.start, this.end, tms, tme).join('');

                if(append) {
                    
                    var creationContainer = document.createElement('div');
                    creationContainer.innerHTML = tInnerHTML;

                    var cn = gridContainer.firstChild,
                        tBodies = cn && cn.tBodies,
                        ntBody = creationContainer.firstChild.tBodies[0],
                        mh = this.matchedHdrsAcrossBlks;

                    cn.appendChild(ntBody);

                    if(mh && mh.length > 0) {
                        stitchBottomCells(mh, tBodies[tBodies.length - 2]);
                    }
                } else {
                    
                gridContainer.innerHTML = tInnerHTML;
                }
            },

            getTableStartMarkup : function _bldTableSMkp() {
                
                var gw = this._getGridWidths(),
                       mkp = TBL_MKP_START;

                mkp[1] = gw.tableLayout;

                mkp[3] = gw.totalColWidths;

                
                
                mkp[5] = this.tableCssClass ? "class=" + this.tableCssClass : '';

                mkp[7] = '<colgroup>' + gw.colgroup + '</colgroup>';

                if(this.tbodyStyle) {
                    mkp[8] = '<tbody style="' + this.tbodyStyle + '">';
                }
                return mkp.join('');
            },

            getTableEndMarkup : function _bldTableEMkp() {
                return '</tbody></table>';
            },

            
            _getGridWidths : function _initGridWidths() {
                var gw = {};

                
                var totalColWidths = '',
                    colgroup = [],
                    tl='fixed',
                    cws = this.cws,
                    cols = cws.length;

                if (cols) {
                    totalColWidths = 0;
                    colgroup = [];
                    
                    
                    for (var i=0; i<cols; i++) {
                        if(cws[i].w !== "") {
                            totalColWidths += parseInt(cws[i].w, 10);
                        }
                    }

                    for (i=0; i<cols; i++) {
                        var width = cws[i];
                        if(width.w !== "") {
                            
                            var w = parseInt(width.w, 10);

                            
                            if (mstrmojo.dom.isIE7) {
                                if(w === 0) {
                                    colgroup.push('<col style="width:0%;display:none"></col>');
                                } else {
                                    colgroup.push('<col style="width:' + (w / totalColWidths * 100) + '%"></col>');
                                }
                            } else if (mstrmojo.dom.isWK && w === 0) {
                                
                                
                                colgroup.push('<col style="width:-1px"></col>');
                            } else {
                                colgroup.push('<col style="width:' + width.w +'"></col>');
                            }
                        } else {
                            colgroup.push('<col />');
                            
                            tl = 'auto';
                        }
                    }

                    
                    this.totalColWidth = totalColWidths;
                }

                
                
                gw.colgroup = colgroup.join('');

                
                tl = this.tableLayout || tl;

                if(this.autoFitWindow) {
                    
                    tl = this.tableLayout || tl || 'fixed';
                    totalColWidths = '100%';
                } else if(tl == 'fixed') {
                    totalColWidths += 'px';
                } else {
                    totalColWidths = 'auto';
                }

                
                gw.totalColWidths = totalColWidths;
                gw.tableLayout = tl;

                return gw;
            },


            
            
            _CELL_MARKUP: ['<td rowSpan="', null, '" colSpan="', null, '" class="', null, '" ei="',null, '" style="', null, '" r="', null, '">', null, '</td>'],

            
            buildTableRowsMarkup: function _buildRowsMarkup( start,  end,  markupPrefix,  markupSuffix) {
                
                
                
                
                
                var markup = [],
                    i = 0;
                markup[i++] = markupPrefix || '<table><tbody>';

                
                var cp = this.cp,
                    
                    rh = cp.getRowHeight(),
                    
                    TD = this._CELL_MARKUP,
                    
                    TR = rh ? '<tr style="height:' + (rh ? rh + 'px' : '') + '">' : AUTO_TR;

                
                var firstRow = true,
                    lastMatched = true,
                    nlr = [], rhi; 

                this.matchedHdrsAcrossBlks = [];

                for (var r = start; r<=end; r++) {
                    
                    rhi = i++;
                    
                    markup[rhi] = r < this.numAutoHeightRows ? AUTO_TR : TR;
                    var cells = cp.getRowCells(r);

                    
                    var maxRowspan = end + 1 - r;

                    var umCellsLen = 0;
                    
                    if(!this.mergeHdrsAcrossBlks) {
                    
                    if(firstRow && start > 0 && cells.length < cp.colWidths.length) {
                        
                        var umCells = cp.getUnmergedCells(start);
                        if (umCells) {
                            umCellsLen = umCells.length;
                        }
                        for(var j in umCells) {
                            var p = umCells[j];
                            
                            if(p.rs > maxRowspan) { 
                                TD[1] = maxRowspan;
                                
                                TD[5] = STITCH_MIDDLE_CSS + p.css;
                            } else { 
                                TD[1] = p.rs || 1; 
                                
                                TD[5] = STITCH_BOTTOM_CSS + p.css;
                            }
                            if(p.cet) {
                                TD[5] += " mstrmojo-selected-cell";
                                this.addHilitePosition(p.cet, r, j);
                            }
                            if(p._ei) {
                                this.addExtraInfoMap(p._ei, r, j);
                                TD[5] += " pt";
                            }
                                TD[9] = "";
                                TD[13] = NBSP;
                            TD[3] = p.cs;
                            TD[7] = p._ei !== undefined ? p._ei : "";;

                            markup[i++] = TD.join('') ;
                        }
                        firstRow = false;
                    }
                    }

                    for (var c=0, len=cells.length; c<len; c++) {
                        var cell = cells[c], rt;
                        if(cell.rs && cell.rs > maxRowspan) {
                            TD[1] = maxRowspan;
                            TD[5] = STITCH_TOP_CSS + cell.css;
                            if(cell._ei) {
                                this.addExtraInfoMap(cell._ei, r, c);
                            }

                        } else {
                            TD[1] = cell.rs || 1;
                            TD[5] = cell.css;
                        }

                        if (cell.rowType !== STACK_TOP){
                            TD[5] += " xtab-td ";
                        }

                        if(cell.cet) {
                            TD[5] += "sc_" + this.parent.k;
                            this.addHilitePosition(cell.cet, r, c);
                        }

                        rt = cell.rowType;
                        if(rt) {
                            
                            TD[5] += STACK_CSS[rt] || '';
                            
                            var srh = cp.getRowHeight(rt);
                            if(srh) {
                                markup[rhi] = '<tr style="height:' + (srh ? srh + 'px' : '') + '">';
                            }
                        }

                        TD[3] = cell.cs || 1;
                        
                        TD[7] = cell._ei !== undefined ? cell._ei : "";

                        if (cell.fs || cell._e){
                            this.addTitleHeaderPositionMap(r, c + umCellsLen, cell);
                        }

                        if (cell._ei != null){
                            this.addPositionMap(cell._ei, r, c + umCellsLen);
                        }

                        TD[11] = r;
                        if(cell.ts === BASEFORM_PICTURE) {

                            
                            
                            
                            
                            

                            

                            var imgUrl = cell.v;
                            
                            if(this.imgCacheMap) {
                                var m = this.imgCacheMap,
                                    v = imgUrl && imgUrl.replace(/\\/g, '/');

                                if(m.cachedImg[v]) {
                                    cell.v = imgUrl = m.baseURL + m.cachedImg[v];
                                } else {
                                    if(v && !m.unCachedImg[v]) {
                                        
                                        m.unCachedImg[v] = v;
                                    }
                                }
                            } else {
                                var ds = this.parent && this.parent.controller && this.parent.controller.model && this.parent.controller.model.dataService;
                                if ( ds && ds.getImage ) {
                                    imgUrl = ds.getImage(imgUrl);
                                }
                            }

                            
                            if(cell.rowType) {
                            	
                            	
                            	
                            	
                            	
                                var height = (cp.getRowHeight(cell.rowType) || cp.rh || rh),
                                	fsHeight = height,
                                	cws = this.tdWidths,
                                	colIdx = cell.colIdx,
                                	colWidth = 0;
                                if (colIdx!=='undefined' && colIdx>-1 && cws && cws.length>colIdx) {
                                	var cw = cws[colIdx] && cws[colIdx].w;
                                	if (cw !== 'undefined') {
                                		colWidth = parseInt(cw, 10);
                                	}
                                }
                                var maxWidth = colWidth>30 ? (colWidth-30) : 0;
                                    
                                
                                
                                
                                TD[13] = '<div><div style="top:' + (-parseInt(fsHeight/2, 10)) + 'px;height:' + height + 'px;line-height:' + height + 'px !important;">&nbsp;<img style="max-height:' + height + 'px; max-width: ' + maxWidth + 'px;" src="' + imgUrl + '"></img></div></div>';
                            
                            } else if (this.parent.gridData.lhv) {
                                
                                TD[9] = "background-image:url('" + imgUrl + "');background-repeat:no-repeat;background-position:center " + (cell.rs > 1 ? 'top' : 'center') + ";";
                                TD[13] = NBSP;
                            } else {
                                
                                TD[9] = '';
                                TD[13] = '<img src="' + imgUrl + '"></img>';
                                
                                
                                if (cell.css && cell.css.indexOf('hl') > -1){
                                    TD[13] = '<span>' + TD[13] + '</span>';
                                }
                            }

                        } else {
                            TD[9] = "";
                            
                            TD[13] = cell.v || cell.n || NBSP;
                            
                            
                            if (cell.css && cell.css.indexOf('hl') > -1){
                                TD[13] = '<span>' + TD[13] + '</span>';
                            }
                        }

                        
                        
                        
                        if(c < this.numColumnCanMerge) {
                            
                            
                            
                            if(r === start && this.mergeHdrsAcrossBlks) {
                                var lr = this.rowHdsAcrossBlks;
                                
                                
                                
                                if(lastMatched && cell.v && lr && lr[c]) {
                                    if(cell.v === lr[c].v) { 
                                        TD[1] = cell.rs || 1;
                                        TD[5] = STITCH_BOTTOM_CSS + cell.css;
                                        TD[13] = "";
                                        
                                        
                                        this.matchedHdrsAcrossBlks.push(lr[c]);
                                    } else {
                                        lastMatched = false;
                                    }
                                }
                            }

                            if(TD[1] >= maxRowspan && cell.v) { 
                                nlr.push({rows: r-start, cells: c, v:cell.v});
                            }
                        }
                        markup[i++] = TD.join('');
                    }
                    
                    markup[i++] = '</tr>';
                }

                
                markup[i++] =  markupSuffix || '</tbody></table>';

                
                this.rowHdsAcrossBlks = nlr;
                return markup;
            },

            addHilitePosition: function(key, row, cell) {
                var hm = this.hiliteCellsMap[key];
                if(!hm) {
                    this.hiliteCellsMap[key] = {pos: [], nodes: []};
                }
                this.hiliteCellsMap[key].pos.push({row: row, cell: cell, page: 0});
            },

            addExtraInfoMap: function(ei, r, c) {
                if(!this.eiMap[ei]) {
                    this.eiMap[ei] = [];
                }
                this.eiMap[ei].push({row:r, cell:c, page: 0});
            },

            addPositionMap: function(ei, r, c){
                
                if(!this.posMap[ei]) {
                    this.posMap[ei] = {row:r, cell:c, page:0};
                }
            },

            addTitleHeaderPositionMap: function(r, c, o){
                this.thPosMap.push({row:r, cell:c, page:0, obj:o});
            },

            
            clearHilites: function(key) {
                
                var hc = this.hiliteCellsMap[key],
                    ns = hc && hc.nodes,
                    parent = this.parent;

                if(ns) {
                    if (ns.length == 0 && hc.pos) {
                        ns = this.getNodesByPositions(hc.pos);
                    }
                    for(var i = 0, iLen = ns.length; i < iLen; i++) {
                        var nd = ns[i],
                            cn = nd.className,
                            cell = parent.getCellForNode(nd);
                        
                        if ( cell ) {
                            delete cell.cet;
                        }
                        $CSS.removeClass(nd, "sc_" + parent.k);
                    }
                    this.hiliteCellsMap[key].nodes = [];
                }
            },

            
            setHilites: function(key, node) {
                $CSS.addClass(node, "sc_" + this.parent.k);

                if(!this.hiliteCellsMap[key]) {
                    this.hiliteCellsMap[key] = {pos:[], nodes:[]};
                }
                this.hiliteCellsMap[key].nodes.push(node);
                
                var cell = this.parent.getCellForNode(node);
                if ( cell ) {
                    cell.cet = key;
                }

            },

            
            getNodesByPositions: function(pos) {
                var tbl = this.tableNode,
                    arr = [];

                for(var i in pos) {
                    var v = pos[i];
                    arr.push(tbl.tBodies[0].rows[v.row].cells[v.cell]);
                }
                return arr;
            },

            preBuildGridTable : function preBuildGridTable() {
                
            },

            
            postBuildGridTable : function postBuildGridTable() {
                this.addSlots({tableNode: this.gridContainerNode && this.gridContainerNode.firstChild});
                
            }
        }   
    );

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.dom",
                         "mstrmojo._IsAnchorable");

    var POS_LEFT = 1,
        POS_RIGHT = 2,
        POS_TOP = 3,
        POS_BOTTOM = 4;
    var AREA_TYPE_TITLE = 'title',
        AREA_TYPE_CONTENT = 'content';

    
    mstrmojo.VisTextTooltip = mstrmojo.declare(
        mstrmojo.Widget,

        [mstrmojo._IsAnchorable],

        {
            scriptClass: 'mstrmojo.VisTextTooltip',

            left: 0,

            top: 0,

            zIndex: 10,

            boundaryNodeName : "boundary",

            popupNodeName : 'infoNode',

            baseTipClass: 'mstrmojo-vis-tip',

            anchorOffset : 1,

            anchorOrientation : 'h',

            anchor: null,

            boundary: null,

            tipNodeColor: '#ffffff',

            utils: mstrmojo.VisChartUtils,

            touchAreaType: AREA_TYPE_CONTENT,

            markupString: '<div id="{@id}" class="{@cssClass}" style="top:{@top}px;left:{@left}px;z-index:{@zIndex};position:absolute;{@cssText};">' +
                    '<div class="timeseries-slider-tooltip" style="display: block"></div>' +
                    '<div class="mstrmojo-vis-tip" style="display: block"></div>' +
                '</div>',

            markupSlots: {
                infoNode: function () { return this.domNode.firstChild; },
                tipNode: function () { return this.domNode.childNodes[1]; }
            },

            toggle: function toggle(show) {
                if (show) {
                    this.domNode.style.display = 'block';
                } else {
                    this.domNode.style.display = 'none';
                }
            },

            updateContent: function (anchor, touchAreaType, text) {
                this.fillContent(anchor, touchAreaType, text);
                this.positionDialog();
            },

            
            fillContent: function fC(anchor, touchAreaType, text) {
                this.anchor = anchor;
                this.touchAreaType = touchAreaType;
                this.domNode.firstChild.innerHTML = text || this.anchor.innerText;
                this.toggle(true);
            }

            

        }

    );

})();
(function(){

	mstrmojo.requiresCls(
		"mstrmojo.Widget",
        "mstrmojo._Formattable");
	
	
	mstrmojo.DocHTMLContainer = mstrmojo.declare(
		
		mstrmojo.Widget,
		
		
        [mstrmojo._Formattable],
		
        
		{
			scriptClass: "mstrmojo.DocHTMLContainer",
			
			scrolling: "auto",
			
	        markupString: '<iframe id="{@id}" class="mstrmojo-DocHTMLContainer" title="{@tooltip}" style="{@domNodeCssText}" src="{@v}" scrolling="{@scrolling}"></iframe>',

            formatHandlers: {
                domNode: [ 'RW', 'B', 'F', 'background-color', 'text-align', 'white-space', 'fx' ]
            },
			
			markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },
            
            
            update: function update(node) {
                this.v = node.data.v;
                
                
                if(mstrApp && mstrApp.isTouchApp()) {
                	this.scrolling = "no";
                }
                
                
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }                
                
                this.thresholdId = node.data.tid;
                this.set('visible', !node.data.hidden);
            }
		}
	);
	
})();
(function() {
    mstrmojo.requiresCls("mstrmojo._IsInputControl");

    
    mstrmojo.DefaultDIC = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        null,
        
        {
            scriptClass: 'mstrmojo.DefaultDIC',
            
            isDummy: true,
            
            showInPopup: function(){
                mstrmojo.alert('The control style has not been supported yet.');
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.Widget");

    
    mstrmojo.StickySections = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        null,
        
        {
            scriptClass: "mstrmojo.StickySections",

            markupString: '<div id="{@id}" style="{@cssText};overflow:hidden">' +
                              '<div class="mstrmojo-StickySections {@cssClass}">{@currentSectionTitle}</div>' +
                          '</div>',

            
            oncurrentSectionTitleChange: function oncurrentTitleChange(evt) {
                this.domNode.lastChild.innerHTML = this.currentSectionTitle;
            },


            
            onMove: function onMove(info) {
                var value = 0;

                
                if (info.isNextRowNewSection) {
                    
                    var position = info.position,
                        rowStart = info.rowStart,
                        directionValue = (rowStart > position) ? (this.domNode.offsetHeight + 1) : 0;

                    
                    value = (rowStart - position) - directionValue;
                }
                
                
                mstrmojo.dom.translate(this.domNode.lastChild, 0, value, 0, "", true);
                
                
                if (info.sectionName && info.sectionName !== this.currentSectionTitle) {
                    this.set('currentSectionTitle', info.sectionName);
                }
            }
        }
    );

}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Widget",
        "mstrmojo._Formattable");
    
    
    mstrmojo.DocRoundRectangle = mstrmojo.declare(
        mstrmojo.Widget,
        
        [mstrmojo._Formattable],

        
        {
            scriptClass: "mstrmojo.DocRoundRectangle",
            
            markupString: '<div id="{@id}" class="mstrmojo-DocRoundRectangle" title="{@tooltip}" style="{@domNodeCssText}">' +
                            '<div class="mstrmojo-DocRoundRectangle-l1" style="{@tCornersCssText}{@tCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l2" style="{@tCornersCssText}{@tCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l3" style="{@tCornersCssText}{@tCornersCssGradText}"></div>' +
                            '<div style="{@rectNodeCssText}{@rectNodeGradCssText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l3" style="{@bCornersCssText}{@bCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l2" style="{@bCornersCssText}{@bCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l1" style="{@bCornersCssText}{@bCornersCssGradText}"></div>' +
                        '</div>', 
                        
            markupSlots: {
            	rectNode: function(){ return this.domNode.childNodes[3]; }
            },
            
            markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },	
            
            formatHandlers: {
                domNode: [ 'top', 'left', 'width', 'z-index', 'fx' ],
                rectNode: [ 'height', 'background-color' ],
                tCorners: [ 'background-color' ],
                bCorners: [ 'background-color' ]
            },
            
            update: function update(node) {
                
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
                this.set('visible', !node.data.hidden);
            },
            
            
            preBuildRendering: function preBuildRendering() {
            	var rtn = this._super();

            	var f = this.getFormats(),
            		topOnly = !!this.defn.topc,							
            		delta = (topOnly) ? 4 : 8,							
            		$2 = '(\\d*px)',									
            		h = Math.max(parseInt(f.height, 10) - delta, 0);	
            	
            	
            	if (f.height === '100%') {
            		
            		$2 = '(100%)';
            		
            		h = this.parent.height() - delta;
            	}
            	
            	
            	this.rectNodeCssText = this.rectNodeCssText.replace(new RegExp('(.*height:)' + $2 + '(.*)'), '$1' + h + 'px$3');
            	
            	
            	if (topOnly) {
            		
            		this.bCornersCssText = 'display:none;';
            	}
            	
            	return rtn;
            },
            
            
            formatGradient: function formatGradient(gp, flt) {
            	
            	var gd = mstrmojo.css.buildGradient(gp.t, gp.sc, gp.ec);
            	
            	
            	if (!gd) {
            		
            		return;
            	}
            	
            	var gdt = gd.n + ':' + gd.v + ';',
            		bc = 'background-color:';
            	
            	
            	this.rectNodeGradCssText = gdt;
            	
            	
            	if (gp.t === 0) {
            		
            		this.tCornersCssGradText = bc + gp.sc + ';';
            		this.bCornersCssGradText = bc + gp.ec + ';';
            	} else {
            		
            		this.tCornersCssGradText = this.bCornersCssGradText = gdt;
            	}
            }
            
        }
    );
    
})();
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo.css",
        "mstrmojo.Widget"
    );

    var $CSS = mstrmojo.css;

    
    mstrmojo.VisTooltip = mstrmojo.declare(

        mstrmojo.Widget,

        null,

        
        {
            scriptClass: 'mstrmojo.VisTooltip',

            cssClass: 'vis-tooltip',

            markupString:
                '<div class="{@cssClass}">' +
                    '<div class="vis-tooltip-container">' +
                        '<table class="vis-tooltip-table">' +
                        '</table>' +
                    '</div>' +
                '</div>',

            markupSlots: {
                domContainer: function () { return this.domNode.firstChild; },
                domTable: function () { return this.domNode.firstChild.firstChild; }
            },

            toggle: function toggle(show){
                if (show) {
                    this.domNode.style.display = 'block';
                } else {
                    this.domNode.style.display = 'none';
                }
            },

            displayInfo: function displayInfo(infoArr, pos) {
                var i, n, item, tbody, tr, td0, td1, td2,
                    doc = document,
                    table = this.domTable;

                table.innerHTML = '';
                n = infoArr.length;

                for (i = 0; i < n; i++) {
                    item = infoArr[i];
                    tbody = doc.createElement('tbody');
                    tr = doc.createElement('tr');
                    td0 = doc.createElement('td');
                    td1 = doc.createElement('td');
                    td2 = doc.createElement('td');
                    td0.setAttribute('class', 'vis-tooltip-name');
                    td1.setAttribute('class', 'vis-tooltip-space');
                    td2.setAttribute('class', 'vis-tooltip-value');

                    if (item === null) { 
                        tr.setAttribute('class', 'vis-tooltip-tr separator');
                    } else {
                        tr.setAttribute('class', 'vis-tooltip-tr');
                        td0.innerHTML = item.n + ':';
                        td2.innerHTML = item.v;
                    }

                    tr.appendChild(td0);
                    tr.appendChild(td1);
                    tr.appendChild(td2);
                    tbody.appendChild(tr);
                    this.domTable.appendChild(tbody);
                }

                if (pos) {
                    var loc = mstrmojo.dom.position(doc.body),
                        w = this.domNode.offsetWidth,
                        h = this.domNode.offsetHeight,
                        dx = pos.x + w - loc.x - loc.w,
                        dy = pos.y + h - loc.y - loc.h;

                    if (dx > 0) {
                        pos.x -= dx;
                    }
                    if (dy > 0) {
                        pos.y -= dy;
                    }

                    this.domNode.style.left = pos.x + 'px';
                    this.domNode.style.top = pos.y + 'px';
                }
            },

            doLayout: function doLayout(tableMaxWidth) {
                var table = this.domTable,
                    ttpStyle = $CSS.getComputedStyle(this.domNode),
                    tds = table.firstChild.firstChild.childNodes,
                    valueTDs = table.getElementsByClassName('vis-tooltip-value'),
                    i;

                var maxWidthForValue = tableMaxWidth - parseInt(ttpStyle.paddingLeft) - parseInt(ttpStyle.paddingRight);
                
                maxWidthForValue -= tds[0].offsetWidth;
                
                maxWidthForValue -= 10;
                

                for(i = 0; i < valueTDs.length; i++) {
                    valueTDs[i].style.maxWidth = maxWidthForValue + 'px';
                }
            },

            
            posTo: function posTo(pos){
                this.domNode.style.left = pos.x + 'px';
                this.domNode.style.top = pos.y + 'px';
            }
        }
    );

}());
(function(){
        
    mstrmojo.requiresCls(
        "mstrmojo.boxmodel",
        "mstrmojo.array",
        "mstrmojo.hash",
        "mstrmojo.dom",
        "mstrmojo.css",
        "mstrmojo.Widget",
        "mstrmojo.Arr",
        "mstrmojo._HasLayout",
        "mstrmojo._ListBase2Selections",
        "mstrmojo.ListSelector",
        "mstrmojo._TouchScrolling",
        "mstrmojo._PagingList");

    var _H = mstrmojo.hash,
        _A = mstrmojo.array,
        _B = mstrmojo.boxmodel,
        _D = mstrmojo.dom;
    
    function _callSelector(w, fn, evt) {
        var s = w.listSelector;
        if (s) {
            s[fn](w, w.itemsContainerNode, evt);
        }
    }
    
    function _lastPagePos(me, dragId){
        var lpp = me.lastPagePos;
        
        if (!lpp || lpp.dragId !== dragId) {
            lpp = _B.offset(me.itemsContainerNode);
            lpp.dragId = dragId;
            me.lastPagePos = lpp;
            var sbn = me.scrollboxNode;
            me.lastScrollPos = {
                left: sbn.scrollLeft, 
                top: sbn.scrollTop,
                width: sbn.clientWidth,
                height: sbn.clientHeight
            };
        }
    }
    
    
    function _whereDrop(me, c, cache){
        
        var el = c && c.node;
            
        
        if (el === me.dropCueNode || el === me.dropCueNode.firstChild) {
            
            return me.dropCuePos;
        }

        
        
        var lm = me.listMapper;
        var at = lm && lm.whereDrop(
                        me, 
                        me.itemsContainerNode, 
                        el, 
                        c.pos, 
                        {
                            left: me.lastPagePos.left - me.lastScrollPos.left,
                            top: me.lastPagePos.top - me.lastScrollPos.top,
                            width: me.lastScrollPos.width,
                            height: me.lastScrollPos.height
                        });
        
        
        var atWas = me.dropCuePos;
        return ((cache !== false) && atWas && at && (atWas.idx === at.idx) && (atWas.left === at.left) && (atWas.top === at.top)) ?
                atWas : at;
    }    

    var _AEL = "attachEventListener";
    
    
    function _initItems(me, its) {
        if (me.makeObservable) {
            
            its = its || [];
            if (!its[_AEL]) {
                mstrmojo.hash.make(its, me.itemsScriptClass || mstrmojo.Arr);
            }
        }
        return its;
    }

    
    function _attItems(me, its) {
        if (its && its[_AEL]) {
            me._sub_its = its;
            me._sub_add = its[_AEL]("add", me.id, "preadd");
            me._sub_rmv = its[_AEL]("remove", me.id, "preremove");
        }
    }
    
    
    function _detItems(me){
        
        if (me._sub_its) {
            var p = mstrmojo.publisher;
            p.unsubscribe(me._sub_add);
            p.unsubscribe(me._sub_rmv);
            delete me._sub_add;
            delete me._sub_rmv;
            delete me._sub_its;
        }
    }
    
    
    
    mstrmojo.ListBase2 = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        [ mstrmojo._ListBase2Selections, mstrmojo._TouchScrolling, mstrmojo._PagingList, mstrmojo._HasLayout ],
        
        
        {
            
            scriptClass: "mstrmojo.ListBase2",
            
            
            items: null,

            
            markupString: '<div id="{@id}" class="mstrmojo-ListBase2 {@cssClass}" style="position:relative;{@cssText}" mstrAttach:mousedown,mouseup,dblclick>'
                            + '<div class="mstrmojo-ListBase2-itemsContainer" style="position:relative;{@itemsContainerCssText}">{@itemsHtml}</div>'
                            + '<div class="mstrmojo-ListBase2-dropCue {@cssClass}"><div class="mstrmojo-ListBase2-dropCue-inner"></div></div>'
                            + '</div>',
            
            
            markupSlots: {
                scrollboxNode: function(){return this.domNode;},
                itemsContainerNode: function(){return this.domNode.firstChild;},
                dropCueNode: function(){return this.domNode.lastChild;}
            },
            
            
            markupMethods: {
                onvisibleChange: function(){this.domNode.style.display = this.visible ? this.cssDisplay : 'none';},
                ondropCuePosChange: function(){
                    var dcn = this.dropCueNode,
                        s = dcn && dcn.style;
                    if (!s) {
                        return;
                    }
                    var pos = this.dropCuePos,
                        vis = !!pos;
                    if (vis) {
                        s.left = pos.left + 'px';
                        s.top = pos.top + 'px';
                    }
                    s.display = vis ? 'block' : 'none';
                },
                onpageChange: function() {
                    if (this.usePaging && !this._inScroll) {
                        this._inPaging = true;
                        this.listMapper.toPage(this, this.page);
                        this._inPaging = false;
                    }
                }
            },
            
            
            autoHide: false,
            
            
            renderOnScroll: false,
                                      
                                  
            firstRenderBlockSize: 50,

                                  
            renderBlockSize: 50,

            
            listMapper: null,
            
            
            listBuilder: null,
            
            
            listSelector: mstrmojo.ListSelector,

            
            animate: false,

                        
            itemsEffect: null,
            
            
            containerResizable: true,
            
            
            init: function init(props) {
                this._super(props);
                
                
                this.items = this.initItems(this.items);
                
                var h = this.selectedIndices,
                    a = this.selectedIndicesList,
                    i = this.selectedIndex,
                    o = this.selectedItem;
                this.selectedIndices = {};
                this.selectedIndex = -1;
                delete this.selectedIndicesList;
                delete this.selectedItem;
                if (h || a || (i>-1) || o) {
                    this.initSelections(h, a, i, o);
                }
                
                
                if (this.postInitItems) {
                    this.postInitItems();
                }
            },
                
            initItems: function initItems(its){
                return _initItems(this,its);
            },
            
            
            preBuildRendering: function preBR(){
                
                
                var lb = this.listBuilder,
                    c = lb.newContext(this);
                this.ctxtBuilder = c;

                
                
                var ms = this.markupSlots,
                    eros = !!(this.renderOnScroll && this.renderBlockSize && ms && ms.scrollboxNode),
                    its = this.items,
                    len = (its && its.length) || 0,
                    top = eros ? this.firstRenderBlockSize : len,
                    bot = eros ? this.firstRenderBlockSize : 0;
                this._eros = eros;
                this.paused = false;
                    
                
                this.itemsHtml = this.listMapper.buildItemWrappers(
                                    its,
                                    lb,
                                    this,
                                    c,
                                    top,
                                    bot).join('');

                
                this.itemsContainerCssText = 'visibility: hidden';
                
                if (this._super) {
                    this._super();
                }
            },
            
            
            postBuildRendering: function pstBR(){
                
                delete this.itemsHtml;

                
                var lm = this.listMapper;
                if (lm && lm.postBuildRendering) {
                    lm.postBuildRendering(
                        this.itemsContainerNode, 
                        this.items,
                        this.listBuilder,
                        this,
                        this.ctxtBuilder);
                }

                
                _attItems(this, this.items);
    
                
                if (this._eros || this.usePaging) {
                    if (!this._cb_scroll) {
                        var id = this.id;
                        this._cb_scroll = function(){
                            var me = mstrmojo.all[id];
                            me.onscroll();
                        };
                    }
                    mstrmojo.dom.attachEvent(this.scrollboxNode, "scroll", this._cb_scroll);
                    
                    
                    this.onscroll();
                }

                
                if (this.animate) {
                    for (var i=0, fxs=['itemsEffect', 'scrollEffect'], len=fxs.length; i<len; i++) {
                        var n = fxs[i],
                            fx = this[n];
                        if (fx && fx.constructor === Object) {
                            fx = mstrmojo.insert(mstrmojo.hash.clone(fx));
                            fx.widget = this;
                            this[n] = fx;
                        }
                    }
    
                    
                    if (this.itemsEffect) {
                        this.itemsEffect.play();
                    }
                }

                
                this.itemsContainerNode.style.visibility = 'inherit';                

                
                if (this.containerResizable && this.itemsContainerNode.scrollWidth < this.domNode.scrollWidth) {
                    this.itemsContainerNode.style.width = this.domNode.scrollWidth + 'px';
                }
                
                if (this._super) {
                    this._super();
                }
            },

            
            unrender: function unrn(ignoreDom){
                
                _detItems(this);
                
                
                if (this._eros) {
                    mstrmojo.dom.detachEvent(this.scrollboxNode, "scroll", this._cb_scroll);
                    delete this._cb_scroll;
                }
                
                for (var i=0, ns=['itemsEffect', 'scrollEffect'], len = ns.length; i<len; i++){
                    var fx = this[ns[i]];
                    if (fx && fx.isPlaying) {
                        fx.cancel();
                    }
                }
                
                this._super(ignoreDom);
            },
            
            
            pauseScrollRendering: function pau(pause, onInterval, onComplete) {
                
                if (pause !== false) {
                    pause = true;
                }
                if (this.paused === !!pause) {
                    return;
                }
                this.paused = !!pause;
                if (pause) {
                    
                    if (this._fillTmr) {
                        window.clearTimeout(this._fillTmr);
                        delete this._fillTmr;
                    }
                } else {
                    
                    this.fill(onInterval, onComplete);
                }
            },
            
            
            onscroll: function scll() {
                
                if (this.paused) {
                    return;
                }
                if (this._eros) {
                    
                    if (!this._fillTmr) {
                        var me = this;
                        this._fillTmr = self.setTimeout(
                                            function(){
                                                me.fill();
                                                me = null;
                                            }, 50);
                    }
                }
                if (this._super) {
                    this._super();
                }
            },
            
            fill: function fll(onInterval, onComplete){
                if (this._fillTmr) {
                    window.clearTimeout(this._fillTmr);
                    delete this._fillTmr;
                }
                
                
                var len = (this.items && this.items.length)||0;
                if (!len) {
                    if (onComplete) {
                        onComplete();
                    }
                } else {
                    var sbn = this.scrollboxNode,
                    icn = this.itemsContainerNode,
                    off = mstrmojo.boxmodel.offset(icn, sbn),
                    im = this.listMapper,
                    idxs = im.findScrollRange(
                            icn, 
                            len, 

                            
                            
                            (this.usesTouches && this.pos && parseInt(this.pos.y,10)) || sbn.scrollTop,

                            sbn.clientHeight,

                            
                            
                            (this.usesTouches && this.pos && parseInt(this.pos.x,10)) || sbn.scrollLeft,

                            sbn.clientWidth,
                            off.left,
                            off.top);

                    
                    if (this.fillAt(idxs.start, idxs.end)) {
                        if (onInterval) {
                            onInterval();
                        }
                        var id = this.id;
                        this._fillTmr = window.setTimeout(
                                        function(){mstrmojo.all[id].fill(onInterval, onComplete);},
                                        100);
                    } else {
                        if (onComplete) {
                            onComplete();
                        }
                    }
                }
            },
            
            
            fillAt: function fllAt(start, end) {
                var im = this.listMapper;
                if (im) {
                    return im.fillItemWrappers(
                            this.itemsContainerNode, 
                            this.items,
                            this.listBuilder,
                            this,
                            this.ctxtBuilder,
                            start, 
                            end, 
                            this.renderBlockSize);
                } else {
                    return false;
                }
            },
            
            
            add: function add(arr, at){
                if (!arr || !arr.length) {
                    return -1;
                }
                
                var its = this.items;
                
                
                if (at == null) {
                    
                    at = _H.min(this.selectedIndices, false, true);
                    if (at !== null && at !== undefined) {
                        at ++;
                    }
                    
                }
                if (at == null || at === -1){
                    
                    at = (its && its.length)|| 0;
                }

                if (its && its.add) {
                    
                    its.add(arr, at);
                } else {
                    
                    this.set(
                        'items', 
                        its ? 
                            _A.insert(its.concat(), at, arr) :
                            arr
                    );
                }
                return at;
            },

            
            preadd: function pa(evt){
                if (this.hasRendered) {
                    
                    var lm = this.listMapper;
                    if (lm) {
                        lm.onadd(this, this.itemsContainerNode, this.ctxtBuilder, evt);
                    }
                        
                    
                    var lb = this.listBuilder;
                    if (lb) {
                        lb.onadd(this, this.ctxtBuilder, evt);
                    }
                    
                    var ls = this.listSelector;
                    if (ls) {
                        ls.onadd(this, evt);
                    }                    
                    
                    if (this._eros) {
                        
                        this.onscroll();
                    } else {
                        
                        var i = evt.index,
                            len = evt.value.length;
                        this.fillAt(i, i+len-1); 
                    }
                }
                
                if (this.onadd) {
                    this.onadd(evt);
                }
                if (this._super) {
                    this._super(evt);
                }
            },            

            
            remove: function rmv(arr) {
                if (arr == null) {
                    return -1;
                }
                if (arr.constructor !== Array) {
                    return this._remove(arr);
                }
                var its = this.items;
                if (its) {
                    var i;
                    if (its.remove) {
                        for (i=arr.length-1; i>-1; i--) {
                            its.remove(arr[i], 1);
                        }
                    } else {
                        its = its.concat();
                        for (i=arr.length-1; i>-1; i--){
                            its.splice(arr[i], 1);
                        }
                        this.set("items", its);
                    }
                    return arr[0];
                }
                return -1;
            },
            
            
            _remove: function rmv(item) {
                
                var its = this.items;
                if (!its || (item == null)) {
                    return -1;
                }
                var idx;
                if (!isNaN(item)) {
                    
                    idx = item;
                } else {
                    
                    idx = this.itemIndex(item);
                }                            
                if (idx > -1) {
                    
                    if (its.remove) {
                        
                        its.remove(idx, 1);
                    } else {
                        
                        its = its.concat();
                        its.splice(idx, 1);
                        this.set('items', its);
                    }
                }
                return idx;            
            },
            
            duplicate: function dup(item, at, config){
                var its = this.items,
                    idx = -1;
                if (!its || (item == null)) {
                    return -1;
                }
                if (!isNaN(item)) {
                    
                    if (at === null || at === undefined) {
                        
                        at = item + 1;
                    }
                    item = its[item];
                } else {
                    if (at === null || at === undefined) {
                        
                        at = this.itemIndex(item) + 1;
                    }
                }
                if (item) {
                    var it;
                    
                    it = _H.copy(config, _H.clone(item));
                    
                    idx = this.add([it], at);
                } 
                return idx;            
            },
            
            preremove: function prm(evt){
                if (this.hasRendered) {
                    
                    var lm = this.listMapper;
                    if (lm) {
                        lm.onremove(this, this.itemsContainerNode, this.ctxtBuilder, evt);
                    }

                    
                    var lb = this.listBuilder;
                    if (lb) {
                        lb.onremove(this, this.ctxtBuilder, evt);
                    }                        
                        
                    
                    var ls = this.listSelector;
                    if (ls) {
                        ls.onremove(this, evt);
                    }                    

                    
                    if (this._eros) {
                        this.onscroll();
                    }
                }
                
                if (this.onremove) {
                    this.onremove(evt);
                }
                if (this._super) {
                    this._super(evt);
                }
            },
            
            
            move: function mv(arr, idx){
                
                
                function noMove(from, count){
                    return (idx >= from) && (idx <= from+count);
                }
                
                
                var max = (this.items && this.items.length)||0;
                if (idx === -1 || idx == null || isNaN(idx)){
                    idx = max;
                } else {
                    idx = Math.min(idx, max);
                }
                
                
                var its, at, idxs, len;
                if (arr.constructor === Array) {
                    
                    at = arr;
                    idxs = arr;
                    len = (at && at.length)||0;
                    if (noMove(arr[0], arr.length)) {
                        return false;
                    }
                    its = _A.get(this.items, arr);
                } else if (typeof(arr) === 'object') {
                    
                    its = [arr];
                    len = 1;
                    
                    at = this.itemIndex(its[0]);
                    idxs = [at];
                    if (noMove(at, 1)){
                        return false;
                    }
                } else {
                    
                    at = arr;
                    idxs = [arr];
                    len = 1;
                    if (noMove(at,1)){
                        return false;
                    }
                    its = [this.items[at]];
                }
                
                
                for (var i=0; i<len; i++){
                    if (idxs[i] <= idx){
                        idx--;
                    }
                }
                
                if(its[0] != null){
                    
                    
                    this.remove(at);
                    
                    
                    this.add(its, idx);
                }

                return true;
            },
            
            
            itemIndex: function ix(item){
                if (item == null) { 
                    return -1;
                }
                var f = this.itemIdField;
                return f ?
                        _A.find(this.items, f, item[f]) :
                        _A.indexOf(this.items, item);
            },
            
            
            prechange: function pchg(evt) {
                
                if (this.hasRendered) {
                    var arr = [this.listBuilder, this.listMapper];
                    for (var i=0, len=arr.length; i<len; i++) {
                        var o = arr[i];
                        if (o && o.onchange) {
                            o.onchange(this, this.itemsContainerNode, this.ctxtBuilder, evt);
                        }
                    }
                }
            },
            
            
            makeObservable: false,
            
            
            _set_items: function stits(n, v) {
                var was = this.items;
                v = this.initItems(v);
                this.items = v;
                if (was !== v) {
                    var me = this,
                        fn = function (){
                            
                            
                            
                            
                            

                            if (me.autoHide) {
                                me.set('visible', !!(v && v.length));
                            }
                            me = null;
                        },
                        hr = this.hasRendered;
                    if (hr) {
                        this.refresh(fn);
                    } else {
                        fn();
                    }
                }
                return was !== v;
            },
            
            
            premousedown: function pmd(evt){
                _callSelector(this, "premousedown", evt);
            },

            
            premouseup: function pmu(evt){
                _callSelector(this, "premouseup", evt);
            },
            
            scrollTo: function st(item){
                var idx,
                    lm = this.listMapper;
                if (lm && lm.toItem) {
                    if (!isNaN(item)) {
                        
                        idx = item;
                    } else {
                        
                        idx = this.itemIndex(item);
                    }                   
                    if (idx >= 0) {
                        lm.toItem(this, idx);
                    }
                }
            },
            
            draggable: false,
            
            
            getDragData: function(c){
                
                _lastPagePos(this, c.id);
            
                
                var at = _whereDrop(this, c.src),
                    idx = at && at.idxActual;
                if ((idx > -1) && this.selectedIndices[idx]) {
                    var idxs = this.sortSelectedIndices(),
                        arr = _A.get(this.items, idxs) || [];
                    switch(arr.length){
                        case 1:
                            
                            
                            return _H.copy(arr[0], {html: arr[0][this.itemDisplayField], index: idxs[0]});
                        case 0:
                            
                            return null;
                        default:
                            
                            
                            return _H.copy({html: arr.length + ' selections', indices: idxs}, arr);
                    }
                }
            },

                        
            dropZone: false,
            
            ondragenter: function(c) {
                
                
                _lastPagePos(this, c.id);

                
                this.set("dropCuePos", _whereDrop(this, c.tgt));
            },
            
            ondragover: function(c) {
                this.set("dropCuePos", _whereDrop(this, c.tgt));
            },
            
            ondragleave: function(c) {
                
                this.set("dropCuePos", null);
            },
            
            ondragstart: function(c){
                
                
                
                
                if (!(c && c.src && c.src.data)) {
                    return false;
                }
            },

            
            allowCopy: false,
            
            ondragend: function(c){
                
                
                
                
                
                
                var t = c && c.tgt,
                    w = t && t.widget;
                if (w === this) {
                    
                    
                } else if (this.tree && w && w.tree === this.tree) {
                    
                    
                    
                    if (!this.allowCopy || !_D.ctrlKey(t.hWin, t.e)) {
                        
                        var d = c.src && c.src.data;
                        if (d && (d.indices || (d.index !== null)) ){
                            this.remove(d.indices || d.index);
                        }
                    }
                }
            },
            
            
            ondrop: function(c) {
                
                var s = c && c.src,
                    d = s && s.data;

                if (d) {
                    
                    var at = _whereDrop(this, c.tgt, false),
                        idx = at && at.idx,
                        isArr = (d && d.constructor === Array);
                        
                    
                    
                    
                    
                    
                    
                    
                    var its = this.items;
                    idx = Math.min(idx, (its && its.length)||0);

                    var chg = true;
                    if (s.widget === this){
                        
                        
                        
                        chg = this.move(this.sortSelectedIndices(), idx);
                    } else {                    
                        
                        this.add(isArr ? d : [d], idx);
                    }
                    
                    
                    if (chg) {
                        var len = isArr ? d.length : 1,
                            sel = {};
                        for (var i=0; i<len; i++){
                            sel[idx+i] = true;
                        }
                        this.set("selectedIndices", sel);
                    }                    
                }
                                
                
                this.set("dropCuePos", null);
            }
            
        });
        
})();



(function(){
    var regExH = /"height", "[0-9.]+"/g;
    var regExW = /"width", "[0-9.]+"/g;
    var regExH1 = /height="?[0-9.]+"?/g;
    var regExW1 = /width="?[0-9.]+"?/g;
    
    mstrmojo.requiresCls("mstrmojo.Widget", 
                         "mstrmojo._Formattable",
                         "mstrmojo._IsSelectorTarget");
    
    
    mstrmojo.DocVisualization = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        
        [mstrmojo._Formattable, mstrmojo._IsSelectorTarget],
        
        
        {
            scriptClass: "mstrmojo.DocVisualization",

            markupString:   '<div id={@id} class="mstrmojo-docvisualization" title="{@tooltip}" style="{@domNodeCssText}">{@htmlText}</div>',
            
            formatHandlers: {
                domNode: [ 'RW', 'T', 'B', 'fx']
            },
                            
            
            update: function update(node) {
                if (this._super) {
                    this._super(node);
                }
                
                var d = node.data;
                this.htmlText = d.htmlText;
                this.jsText = d.jsText;
                this.selData = d.selData;
                this.ctrLink = d.ctrLink;
                this.vp = d.vp;
            	this.eg = d.eg;
            	
            	if (this.eg) {
            		this.htmlText = this.eg;
            	}
            },
            
            preBuildRendering: function () {
                if (this._super) {
                    this._super();
                }
                var fmts = this.getFormats();
                if (!fmts) {
                    return;
                }
                var h = fmts.height;
                if (h) { 
                    h = h.replace('px','');
                }
                var w = fmts.width;
                if (w) {
                    w = w.replace('px','');
                }
                if (this.jsText) {
                    this.jsText = this.jsText.replace(regExH, '"height", "' + h + '"').replace(regExW, '"width", "' + w + '"');
                }
            },
            
            postBuildRendering: function pstBldRnd(){
                if (this._super) {
                    this._super();
                }
                
                eval(this.jsText);

            }, 
            
            resize: function () {
                if (this.eg) {
                    
                    return;
                }
                var embedNode = this.domNode.firstChild.firstChild.firstChild;
                if (!embedNode) {
                    return;
                }
                var fmts = this.getFormats();
                var h = fmts.height;
                if (h) {
                    h = h.replace('px','');
                }
                var w = fmts.width;
                if (w) {
                    w = w.replace('px','');
                }
                if(mstrmojo.dom.isIE){ 
                    embedNode.firstChild.setAttribute("height", h);
                    embedNode.firstChild.setAttribute("width", w);
                }else{
                    embedNode.innerHTML = embedNode.innerHTML.replace(regExH1, 'height="' + h + '"').replace(regExW1, 'width="' + w + '"');
                }

            },
            
            makeSelections: function (selections) {
                var shuffledData = {},
                    i, j, attId, e;
                
                
                for (i = 0; i < selections.length; i++) {
                    var attIdI = selections[i].attId;
                    if (!shuffledData[attIdI]) {
                        shuffledData[attIdI] = [];
                    }
                    shuffledData[attIdI] = shuffledData[attIdI].concat(selections[i].values);    
                }

                var sep = '\u001E',
                    sep1 = '\u001F';
                var ckJoined = '',
                    eidJoined = '',
                    cklJoined = '';
                var tksArray = [];
                for (attId in shuffledData) {
                
                    var sd = this.getSelectionData(attId);
                    if (!sd) {
                    	
                    	continue;
                    }
                    var ctrLink = this.ctrLink[attId];
                    var values = shuffledData[attId];

                    if (sd && values && values.length>0) { 
                        
                        sd.sel = values;
                        sd.ias = false;
                        for (e in values) {
                            if (e === "u;") {
                                sd.ias = true; 
                                break;
                            }
                        }
                    }
                    
                    if (ctrLink.gbTargets) {
                        var t = ctrLink.targets = [],
                            gbt = ctrLink.gbTargets,
                            cgbmap = this.model.getCGBMap();
                        for(j = 0; j < gbt.length; j++) {
                            var targetKey = cgbmap[gbt[j]];
                            if (targetKey) {
                                t.push(targetKey);
                            }
                        }
                        delete ctrLink.gbTargets;
                    }
                    ckJoined += ctrLink.ctxt + sep1;
                    eidJoined += values.join(sep) + sep1;
                    cklJoined += ctrLink.ck + sep1;
                    tksArray = tksArray.concat(ctrLink.targets);

                } 
                
                
                ckJoined = ckJoined.substring(0, ckJoined.length-1);
                eidJoined = eidJoined.substring(0, eidJoined.length-1); 
                cklJoined = cklJoined.substring(0, cklJoined.length-1);
				
				if(tksArray.length == 0)
				{ 
					return;
				}
                var evt = {
                        ck: ckJoined,
                        eid: eidJoined,
                        src: this.k,
                        tks: tksArray.join(sep),
                        type: this.defn.t,
                        ctlKey: cklJoined,
                        include: true,
                        isDocVis: true 
                    };
                this.model.slice(evt);
            },
            
            getAllSelectionData: function () {
                return this.selData;
            },
            
            getSelectionData: function (attId) {
                var selData = this.selData,
                    k;
                
                if (selData && selData.attl){
                    var attl = selData.attl;
                    if (attId) {
                        return attl[attId];
                    }
                    else {
                        for (k in attl) {
                            
                            return attl[k];
                        }
                    }
                }
            },
            
            saveVisProps: function (widgetPropsXml) {
				var props = {};                                                               
                props[this.k] = {
                	FormattingWidget: "WidgetProps" + '\u001F' + widgetPropsXml
                };
                        
                mstrApp.docModel.saveRWProps(this.k, props , 1, false, {success:function() {}});
            }
        }
    );
}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.array", "mstrmojo.css", "mstrmojo.string", "mstrmojo.dom");
    
    var $A = mstrmojo.array,
        $C = mstrmojo.css,
        $S = mstrmojo.string,
        $D = mstrmojo.dom,
        _US = 'unselected',
        CSS_DISPLAY = 'inline-block';
    
    mstrmojo.ImageToggle = mstrmojo.declare(
        mstrmojo.Widget,
        null,
        
        {
            scriptClass: 'mstrmojo.ImageToggle',
            
            
            unset: null,
            
            useAnimation: true,
            
            markupString: '<div class="mstrmojo-ImageToggle {@cssClass}" style="{@cssText}" tabindex="{@tabIndex}"  mstrAttach:click,blur,keydown ></div>',
            
            tabIndex: 0,
            
            markupMethods: {
                onimageListChange: function() {
                    var imgs = this.imageList && this.imageList.slice(), 
                        me = this,
                        ust = this.unset, i, div, img;
                    
                    if(!$S.isEmpty(ust) && imgs) {
                        imgs.push({n: ust, v: ust, _ust: true});
                    }
                    if(this.domNode && imgs) {
                        me.domNode.innerHTML = '';
                        me.domNode.style.minHeight = Math.min(20, me.height) + 'px';
                        me.domNode.style.minWidth = Math.min(20, me.width) + 'px';
                        me._loadedImgs = imgs.length;
                        mstrmojo.array.forEach(imgs, function(imgObj, i) {
                            div = document.createElement('div');
                            div.style.cssText = 'display:none;font-size:0px !important;line-height:' + me.height + 'px !important;';
                            
                            img = document.createElement('img');
                            img.alt = img.title = imgObj.v;
                            img.style.verticalAlign = 'middle';
                            img.style.maxHeight = me.height + 'px';
                            
                            img.style.maxWidth = (me.width - 1) + 'px'; 
                            
                            if (!mstrmojo.dom.isIE) {
                                
                                img.onerror = function() {
                                    this.src = '../images/image_not_found.jpg';
                                };
                            }
                            div.appendChild(img);
                            me.domNode.appendChild(div);
                            img.src = imgObj.n || '../images/image_not_found.jpg';
                            
                            
                            if(imgObj._ust) {
                                me.ustImgIdx = i;
                            }
                            me._imgs[i] = div;
                        });
                        
                        this._setSelectedValue();
                    } 
                },
                onvalueChange: function() {
                    this._setSelectedValue();
                }
            },
            
            imageList: null,
            
            value: null,
            
            selectedIndex: -1,
            
            preBuildRendering: function preBldRnd() {
                if(this._super) {
                    this._super();
                }
                
                this._imgs = [];
            },

            _setSelectedValue: function setSltV() {
                var me = this, 
                    s = this.selectedIndex, 
                    imgs = this.imageList;
                
                if(imgs) {
                    
                    if(imgs[s]) {
                        me._imgs[s].style.display = 'none';
                    }
                    $A.forEach(this.imageList, function(img, i) {
                        if(img.v == me.value) {
                            $C.removeClass(me.domNode, _US);
                            me.selectedIndex = i;
                            me._imgs[i].style.display = CSS_DISPLAY;
                            return ;
                        }
                    });
                    
                    if(this.selectedIndex === -1) {
                        if(!this.unset) {
                            
                            $C.addClass(this.domNode, _US);
                        } else {
                            var div = this._imgs[this.ustImgIdx],
                                img = div.lastChild;
                            
                            img.alt = img.title = this.value;
                            div.style.display = CSS_DISPLAY; 
                        }
                    }
                }
            },
            
            onclick: function onclk() {
                var imgs = this.imageList,
                    len = imgs && imgs.length,
                    d = 300,
                    s = this.selectedIndex,
                    ls = s,
                    p = this.domNode,
                    e1, e2, c, t, me = this;
                
                c = (s === -1 && this.ustImgIdx !== null) ? this._imgs[this.ustImgIdx] : this._imgs[s];
                s = (s + 1) % len;
                t = this._imgs[s];
                $C.removeClass(p, _US);
                this.selectedIndex = s;
                
                if (this.useAnimation){
                    e2 = new mstrmojo.fx.FadeIn({
                        duration: d,
                        
                        interval: ($D.isIE8 ? (d/3) : (d/10)),
                        target: t,
                        preStart: function(){
                            this.target.style.display = CSS_DISPLAY;
                        }
                    });
                    
                    e1 = new mstrmojo.fx.FadeOut({
                        duration: d,
                        
                        interval: ($D.isIE8 ? (d/3) : (d/10)),
                        target: c,
                        onEnd: function() {
                            c.style.display = 'none';
                            
                            if(ls === -1) {
                                me._imgs.splice(me.ustImgIdx, 1);
                                p.removeChild(c);
                                delete me.ustImgIdx;
                            }
                            e2.play();
                        }
                    });
    
                    
                    if(c) {
                        e1.play();
                    }else {
                        e2.play();
                    }
                }else {
                    if (c){
                        c.style.display ='none';
                        if(ls === -1) {
                            me._imgs.splice(me.ustImgIdx, 1);
                            p.removeChild(c);
                            delete me.ustImgIdx;
                        }
                    }
                    t.style.display = CSS_DISPLAY;
                }
                
                this.value = this.imageList[s].v;
            },
            
            onkeydown: function(evt){
                var hWin = evt.hWin, 
                    e = evt.e || hWin.event;
                
                if (e.keyCode === mstrmojo.Enum_Keys.SPACE){ 
                    mstrmojo.dom.preventDefault(hWin, e);
                    this.onclick();
                }
            }
        }
    );
}());
(function() {
	mstrmojo.requiresCls("mstrmojo.array",
						 "mstrmojo.BarcodeReader",
						 "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton");
	
	var $ARR = mstrmojo.array;
	
	mstrmojo.android.inputControls.BarcodeDIC = mstrmojo.declare(
			
		mstrmojo.Widget,
		
		[mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton],
		
		{
			scriptClass: 'mstrmojo.android.inputControls.BarcodeDIC',
			
			markupString: '<div></div>',
			
			
            showInPopup: function(){
            	var me = this;
            	var callback = {
	                success: function (val) {
	                	if (val !== '') {
	                		
	                		
	                		if (!!me.dic.em) {
	                			me.value = me.dic.vls[parseInt(val, 10)].v;
	                		} else {
	                			me.value = val;
	                		}
	                		
		                	me.applyChanges();
	                	}
	                },
	                
	                failure: function (val) {}
	            };
            	
            	
            	var params = {'barcodeDIC': true};
            	
            	if (!!me.dic.em) {
            		var vls = [];
            		$ARR.forEach(me.dic.vls, function(o, i){
            			
            			vls[i] = o.m || o.v;
            		});
            		
            		params.vls = vls;
            	}
            	
            	mstrmojo.BarcodeReader.readBarcodes(params, callback, this.popupTitle);
            }
		}
	)
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.dom");

    var baseCssClass = 'mstrmojo-Image';

    
    mstrmojo.Image = mstrmojo.declare(

        mstrmojo.Widget,

        null,

        
        {
            scriptClass: "mstrmojo.Image",

            markupString: '<div id="{@id}" class="' + baseCssClass + ' {@cssClass}" style="{@cssText}" mstrAttach:click>' +
                              '<image src="{@src}" mstrAttach:load />' +
                          '</div>',


            markupSlots: {
                imgNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onsrcChange: function () {
                    
                    var imgNode = this.imgNode;
                    if (imgNode) {
                        
                        imgNode.src = this.src || '../javascript/mojo/css/images/1ptrans.gif';
                    }
                },
                oncssClassChange: function () {
                    
                    var domNode = this.domNode;
                    if (domNode) {
                        
                        domNode.className = this.cssClass || baseCssClass;
                    }
                },
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            
            src: '',

            
            getImageSize: function getImageSize() {
                var imgNode = this.imgNode;
                return {
                    w: imgNode.clientWidth,
                    h: imgNode.clientHeight
                };
            }
        }
    );

    
    mstrmojo.Image.baseCssClass = baseCssClass;

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    

    var $C = mstrmojo.css,
        $EF = mstrmojo.emptyFn,
        $D = mstrmojo.dom,
        $HANDLE_WIDTH = 32,
        $CSS = mstrmojo.css,

        types = { 
            SINGLE: 1,
            INCLUDE: 2,
            EXCLUDE: 3
        },

        f = { 
            CONTINUOUS_STEPS: -1,
            UNSET: -4641
        },

        tmp = {}, 

        
        getSliderWidth = function (t) {
            if (!tmp[t.id + "cw"]) {

                var width = parseInt($C.getComputedStyle(t.sliderContainer).width, 10);
                if (isNaN(width)) {

                    width = parseInt($C.getComputedStyle(t.domNode.parentNode).width, 10);
                }

                tmp[t.id + "cw"] = width;
            }
            return tmp[t.id + "cw"];
        },

        
        getSingleStep = function (t, left, handle) {
            var range = t.type !== types.SINGLE,
                handleWidth = $HANDLE_WIDTH,
                l = !!left ? (left - (handleWidth / 2)) :  parseInt(handle.style.left, 10),
                st = t.steps,
                contWidth = getSliderWidth(t) - handleWidth,
                gap = Math.round(contWidth / (st - (!range ? 1 : 0))), 
                maxStep = range ? t.rightStep : st - 1;

            return Math.min(maxStep, Math.round(l / gap));
        },

        
        getRightStep = function (t) {
            var rcStyle = t.rangeContainer.style,
                width = parseInt(rcStyle.width, 10) - $HANDLE_WIDTH,
                left = parseInt(rcStyle.left, 10),
                st = t.steps, 
                contWidth = getSliderWidth(t) - $HANDLE_WIDTH,
                gap = Math.round(contWidth / st);

            return Math.max(0,
                            Math.min(Math.round((left + width) / gap),
                                     st));
        },

        
        getLeftForSingle = function (t, step) {
            var st = t.steps,
                w = getSliderWidth(t),
                hs = $HANDLE_WIDTH;
            return Math.min(w - hs, Math.max(0, ((w / (st - 1) * step) - hs / 2))) + "px";
        },

        
        getLeftForRange = function (t, leftStep) {

            var st = t.steps,
                w = getSliderWidth(t) - $HANDLE_WIDTH;

            return ((w / st) * leftStep) + "px";
        },

        
        getWidthForRange = function (t, leftStep, rightStep) {
            var st = t.steps, 
                w = getSliderWidth(t) - $HANDLE_WIDTH,
                ch = rightStep - leftStep;

            return ((ch * w) / st) + $HANDLE_WIDTH + "px";
        },

        
        positionSingleStep = function (t, step) {
            var singleHandle = t.singleHandle;
            if (singleHandle) {
                singleHandle.style.left = getLeftForSingle(t, step);
            }
        },

        
        positionRangeStep = function (t, leftStep, rightStep) {
            var ic = t.rangeContainer,
                sty,
                handleWidth = (t.rangeLHandle.clientWidth || $HANDLE_WIDTH) + 5;

            if (ic) {
                var ircStyle = t.innerRangeContainer.style;

                sty = ic.style;
                sty.left = getLeftForRange(t, leftStep);
                sty.width = getWidthForRange(t, leftStep, rightStep);

                
                ircStyle.left = parseInt(sty.left, 10) + handleWidth + 'px';
                ircStyle.width = Math.max(parseInt(sty.width, 10) - (2 * handleWidth), 0) + 'px';
            }
        },

        
        snapHandle = function (t, l, handle) {
            var range = t.type !== types.SINGLE,
                step = getSingleStep(t, l, handle), 
                stepName = range ? "leftStep" : "singleStep",
                func;

            if (step !== t[stepName]) {
                t.set(stepName, step);
                this.step = step;
            } else {
                func = range ? positionRangeStep : positionSingleStep;
                func(t, step, t.rightStep);
            }
        },

        
        snapRangeHandles = function (t, left, handle) {
            var rangeContainer = t.rangeContainer,
                step,
                leftStep = t.leftStep,
                grabDrag = (handle === rangeContainer || handle === t.innerRangeContainer);

            if (handle === t.rangeRHandle || grabDrag) {
                step = getRightStep(t);
                leftStep += grabDrag ? step - t.rightStep : 0; 

                positionRangeStep(t, leftStep, step);
                if (t.rightStep !== step) {
                    t.set("rightStep", step);
                    if (grabDrag) {
                        t.set("leftStep", leftStep);
                    }
                }
            } else if (handle === t.rangeLHandle) {
                snapHandle(t, left, rangeContainer);
            }
        },

        
        snapHandles = function (t, target) {
            switch (t.type) {
            case types.SINGLE:
                snapHandle(t, null, t.singleHandle);
                break;
            case types.EXCLUDE:
            case types.INCLUDE:
                snapRangeHandles(t, null, target);
                break;
            }
        },


        
        jumpRangeHandle = function (t, tapPosition) {
            var rangeContainer = t.rangeContainer,
                rcStyle = rangeContainer.style,
                width = parseInt(rcStyle.width, 10),
                left = parseInt(rcStyle.left, 10),
                leftStep = t.leftStep,
                rightStep = t.rightStep,
                nuRs = rightStep,
                nuLs = leftStep;

            if (tapPosition > 0 && tapPosition < left && leftStep > 0) {
                nuRs--;
                nuLs--;
            } else if (tapPosition > (left + width) && tapPosition < getSliderWidth(t)) {
                nuRs++;
                nuLs++;
            }
            positionRangeStep(t, nuLs, nuRs);
            t.set("leftStep", nuLs);
            t.set("rightStep", nuRs);
        },


        
        moveHandle = function (slider, node, handle, position, deltaX) {

            
            var width = handle.style.width;

            
            if (width === '') {
                
                width = $C.getComputedStyle(handle).width;
            }

            
            position = Math.min(Math.max(0, position + (deltaX || 0)), getSliderWidth(slider) - parseInt(width, 10));

            
            node.style.left = position + 'px';

            return position;
        },

        
        moveRangeLHandle = function (t, originalPosition, originalWidth, deltaX) {
            var rangeContainer = t.rangeContainer,
                rangeLHandle = t.rangeLHandle,
                contWidth = getSliderWidth(t) - $HANDLE_WIDTH,
                gap = Math.round(contWidth / t.steps), 
                newWidth = originalWidth - deltaX,
                handlePos;

            if (newWidth >= (gap + $HANDLE_WIDTH)) {
                handlePos = moveHandle(t, rangeContainer, rangeLHandle, originalPosition, deltaX);

                if ((originalPosition + deltaX) > 0) {
                    rangeContainer.style.width = newWidth + "px";
                }
                return handlePos;
            }
        },


        moveRangeRHandle = function (t, originalPosition, originalWidth, deltaX) {
            var rangeContainer = t.rangeContainer,
                max = getSliderWidth(t) - parseInt(rangeContainer.style.left, 10),
                newWidth = originalWidth + deltaX,
                contWidth = getSliderWidth(t) - $HANDLE_WIDTH,
                gap = Math.round(contWidth / t.steps), 
                handlePos;

            if (newWidth >= (gap + $HANDLE_WIDTH)) {
                handlePos = Math.min(max, newWidth);
                rangeContainer.style.width = handlePos + "px";

                return handlePos;
            }
        },

        
        prepareSummary = function (t) {
            var singleStep, leftStep, rightStep, summary;
            switch (t.type) {
            case types.SINGLE:
                singleStep = parseInt(this.step, 10) === f.UNSET ?  getSingleStep(t, null, t.singleHandle) : this.step;
                summary = t.buildSummary(singleStep);
                this.step = f.UNSET;
                break;
            case types.EXCLUDE:
            case types.INCLUDE:
                leftStep = getSingleStep(t, null, t.rangeContainer);
                rightStep = getRightStep(t);
                summary = t.buildSummary(null, leftStep, rightStep);
                break;
            }

            return summary;
        };

    
    mstrmojo.android.selectors.MobileSliderSelector = mstrmojo.declare(

        mstrmojo.Widget,

        [ mstrmojo._TouchGestures, mstrmojo._ListSelections ],

        
        {

            

            width: 0, 

            type : f.UNSET, 

            value : f.UNSET, 

            steps : f.UNSET, 

            include : f.UNSET,

            

            

            initState : $EF, 

            buildSummary : $EF, 

            updateMinMaxLabels : $EF, 

            flushSelections : $EF, 

            

            step: f.UNSET,  

            singleStep : f.UNSET, 

            leftStep : f.UNSET, 

            rightStep : f.UNSET, 

            cssDisplay: 'block',

            scriptClass: "mstrmojo.android.selectors.MobileSliderSelector",

            useRichTooltip: true,

            markupString : '<div class="mstrmojo-sliderSel" id="{@id}">' +
                                '<div></div>' + 
                                '<div class="mstrmojo-sliderSelSummary">&nbsp;</div>' + 
                                '<div class="mstrmojo-sliderSelScrollerContainer">' + 
                                    '<div class="mstrmojo-sliderSelScrollerHandle" style="display:none;">' + 
                                        '<div class="mstrmojo-sliderSelScrollerHandle1 leftHandle"><div></div></div>' + 
                                        '<div class="mstrmojo-sliderSelScrollerHandle1 rightHandle"><div></div></div>' + 
                                    '</div>' +
                                   '<div class="mstrmojo-sliderSelScrollerHandle2" style="display:none;"><div></div></div>' + 
                                   '<div class="mstrmojo-sliderSelScrollerHandleArea" style="display:none;position:absolute"></div>' +
                               '</div>' +
                               '<div class="mstrmojo-sliderSelLabels">' + 
                                   '<label class="mstrmojo-sliderSelLL">&nbsp;</label>' +
                                   '<label class="mstrmojo-sliderSelLR">&nbsp;</label>' +
                               '</div>' +
                           '</div>',

            markupSlots : {
                editor: function () { return this.domNode.childNodes[0]; },
                summary: function () { return this.domNode.childNodes[1]; },
                sliderContainer: function () { return this.domNode.childNodes[2]; },
                innerRangeContainer: function() {return this.domNode.childNodes[2].childNodes[2];},
                rangeContainer: function () { return this.domNode.childNodes[2].childNodes[0]; },
                rangeLHandle: function () { return this.domNode.childNodes[2].childNodes[0].childNodes[0]; },
                rangeRHandle: function () { return this.domNode.childNodes[2].childNodes[0].childNodes[1]; },
                singleHandle: function () { return this.domNode.childNodes[2].childNodes[1]; },
                minLabel: function () { return this.domNode.childNodes[3].childNodes[0]; },
                maxLabel: function () { return this.domNode.childNodes[3].childNodes[1]; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                
                ontypeChange: function () {
                    var s,
                        i = "none",
                        scClassName = "mstrmojo-sliderSelScrollerContainer",
                        handleClassName = "Handle1";

                    switch (this.type) {
                    case types.SINGLE:
                        s = 'block';
                        break;
                    case types.EXCLUDE:
                        scClassName = "mstrmojo-sliderSelScrollerContainerExcl";
                        handleClassName = "Handle2";
                        i = 'block';
                        break;
                    case types.INCLUDE:
                        i = 'block';
                        break;
                    }

                    this.rangeContainer.style.display = i;
                    this.innerRangeContainer.style.display = i;
                    this.sliderContainer.className = scClassName;
                    this.rangeLHandle.className = "mstrmojo-sliderSelScrollerHandleX leftHandle".replace("HandleX", handleClassName);
                    this.rangeRHandle.className = "mstrmojo-sliderSelScrollerHandleX rightHandle".replace("HandleX", handleClassName);

                    this.singleHandle.style.display = s;
                },
                onconstantsChange: function () {
                    this.updateMinMaxLabels();
                },
                onvalueChange: function () {
                    prepareSummary(this);
                }
            },

            postBuildRendering: function postBuildRendering() {
                var rtn = this._super();
                this.initState();

                var d = this.tooltipNode || this.domNode;

                $D.detachEvent(d, 'mouseover', this._ontooltipover);
                $D.detachEvent(d, 'mouseout', this._ontooltipout);

                return rtn;
            },

            onsingleStepChange : function () {
                positionSingleStep(this, this.singleStep);
            },

            onleftStepChange : function () {
                positionRangeStep(this, this.leftStep, this.rightStep);
            },

            onrightStepChange : function () {
                positionRangeStep(this, this.leftStep, this.rightStep);
            },

            
            touchSwipeBegin: function (touch) {
                var target = touch.target;
                if (!target) {
                    return false;
                }

                this.touchTap(touch);

                
                var glowTargets = this._glowing = [];

                
                $CSS.addClass(target, 'glow');
                glowTargets.push(target);

                
                this._sliderTarget = target;

                var singleHandle = this.singleHandle,
                    rangeContainer = this.rangeContainer,
                    left,
                    style;

                switch (target) {
                case singleHandle:
                    left = singleHandle.style.left;
                    
                    tmp.shl = parseInt(!!left ? left : 0, 10);
                    break;

                case rangeContainer:
                case this.innerRangeContainer:
                case this.rangeLHandle:
                case this.rangeRHandle:
                    style = rangeContainer.style;
                    left = style.left;
                    
                    tmp.icl = parseInt(!!left ? left : 0, 10);
                    
                    tmp.icw = parseInt(style.width, 10);
                    break;
                case this.sliderContainer:
                    
                    $CSS.addClass(singleHandle, 'glow');
                    glowTargets.push(singleHandle);
                    break;

                default:
                    this.bubbleTouchEvent(touch);
                }

                this._initTooltip();

                if (this.type === types.SINGLE) {
                    this.touchSelectMove(touch, true);
                }
            },

            
            touchSwipeMove: function (touch, ignoreNodeWidth) {
                var target = touch.target;
                if (!target) {
                    return false;
                }

                
                target = this._sliderTarget;

                var singleHandle = this.singleHandle,
                    rangeContainer = this.rangeContainer,
                    rangeLHandle = this.rangeLHandle,
                    rangeRHandle = this.rangeRHandle,
                    deltaX = touch.delta.x,
                    leftPos;


                switch (target) {
                case singleHandle:
                    leftPos = moveHandle(this, singleHandle, singleHandle, tmp.shl, deltaX);
                    break;
                case rangeRHandle:
                    leftPos = moveRangeRHandle(this, tmp.icl, tmp.icw, deltaX);
                    break;
                case rangeLHandle:
                    leftPos = moveRangeLHandle(this, tmp.icl, tmp.icw, deltaX);
                    break;
                case rangeContainer:
                case this.innerRangeContainer:
                    if (this.type === types.INCLUDE) {
                        leftPos = moveHandle(this, rangeContainer, rangeContainer, tmp.icl, deltaX);
                    }
                    break;
                case this.sliderContainer:
                    leftPos = moveHandle(this, singleHandle, singleHandle, touch.clientX - $D.position(this.sliderContainer, true).x);
                    break;
                }

                this._updateTooltip(touch.evt, target, leftPos, ignoreNodeWidth);
            },

            
            touchSwipeEnd: function (touch) {

                var target = (touch.target === this.sliderContainer) ? this.singleHandle : this._sliderTarget,
                    l = this.leftStep,
                    r = this.rightStep,
                    s = this.singleStep;

                
                mstrmojo.array.forEach(this._glowing, function (glowTarget) {
                    
                    $CSS.removeClass(glowTarget, 'glow');
                });

                
                
                snapHandles(this, target);

                if (l !== this.leftStep || r !== this.rightStep || s !== this.singleStep) {
                    this.flushSelections();
                }

                this.hideTooltip(touch.evt, this);
            },

            
            touchTap: function (touch) {
                var target = touch.target;
                if (!target) {
                    return false;
                }

                var sliderContainer = this.sliderContainer,
                    clientX = touch.clientX,
                    containerTapped = (sliderContainer === target),
                    tapPosition = clientX - $D.position(sliderContainer, true).x,
                    l = this.leftStep,
                    r = this.rightStep,
                    s = this.singleStep;

                switch (this.type) {
                case types.SINGLE:
                    if (containerTapped) {
                        snapHandle(this, tapPosition, this.singleHandle);
                    }
                    break;
                case types.INCLUDE:
                    if (containerTapped) {
                        jumpRangeHandle(this, tapPosition);
                    }
                    break;
                    
                }

                if (l !== this.leftStep || r !== this.rightStep || s !== this.singleStep) {
                    prepareSummary(this);
                    this.flushSelections();
                }
            },

            touchSelectBegin: function (touch) {
                this.touchSwipeBegin(touch);
            },
            touchSelectMove: function (touch) {
                this.touchSwipeMove(touch, true);
            },
            touchSelectEnd: function (touch) {
                this.touchSwipeEnd(touch);
            },

            touchEnd: function touchEnd(touch) {
                this.hideTooltip(touch.evt, this);
            },

            _initTooltip: function _initTooltip() {

                this.set('richTooltip', {refNode : this.domNode,
                                         posType: mstrmojo.tooltip.POS_BOTTOMCENTER,
                                         contentNodeCssClass: 'mstrmojo-sliderTip'});
            },

            _updateTooltip: function _updateTooltip(event, target, leftPos, ignoreNodeWidth) {

                this.showTooltip(event, this);
                var containerNode = $D.position(this.sliderContainer, false),
                    dposDomNode = $D.position(this.domNode, false),
                    boxContainer = mstrmojo.boxmodel.offset(this.sliderContainer),
                    breachedTopBoundary = (containerNode.y < 90),
                    ttN = this.richTooltip,
                    content = prepareSummary(this),
                    nodeWidth;

                if (ignoreNodeWidth) {

                    nodeWidth = ($HANDLE_WIDTH / 2);
                } else {

                    nodeWidth = target.style.width;

                    if (nodeWidth === "") {
                        nodeWidth = $C.getComputedStyle(target).width;
                    }
                    nodeWidth = parseInt(nodeWidth, 10) / 2;
                }

                ttN.content = '<div class="mstrmojo-sliderTip-top">' + content + '</div>' +
                              '<div class="mstrmojo-sliderTip-bottom' + (breachedTopBoundary ? ' down' : '') + '">' + '</div>';

                ttN.top = dposDomNode.y - boxContainer.top - 20 + (breachedTopBoundary ? 100 : 0);
                ttN.left = leftPos + nodeWidth + (dposDomNode.x - boxContainer.left);

                this.richTooltip = null;
                this.set('richTooltip', ttN);
            },

            onselectionChange: function onselChg() {
                
                if (this.onchange) {
                    this.onchange();
                }

                if (this.makeSelection) {
            		this.makeSelection({
            			selItem: this.type === types.SINGLE ? this.singleHandle : this.rangeContainer
            		});
            	}
            },

            
            slideHosted: function (single, left, right) {
                if (single !== null && single !== undefined) {
                    this.set("singleStep", single);
                }
                if (left !== null && left !== undefined) {
                    this.set("leftStep", left);
                }
                if (right !== null && right !== undefined) {
                    this.set("rightStep", right);
                }
                this.flushSelections();
                prepareSummary(this);
            }

        }
    );

    var $MSL = mstrmojo.android.selectors.MobileSliderSelector;

    $MSL.TYPES = types;
    $MSL.FLAGS = f;

}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Widget",
        "mstrmojo._Formattable");

    
    mstrmojo.DocLine = mstrmojo.declare(
        mstrmojo.Widget,
        
        [mstrmojo._Formattable],

        
        {
            scriptClass: "mstrmojo.DocLine",

            markupString: '<div id="{@id}" class="mstrmojo-DocLine" title="{@tooltip}" style="{@domNodeCssText}"></div>', 
            
            formatHandlers: {
                domNode: [ 'RW', 'border-top', 'border-left', 'fx' ]
            },
			
			markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },
            
            update: function update(node) {
                
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
				
				this.set('visible', !node.data.hidden);

                if (this._super) {
                    this._super(node);
                }
            },
            
            getFormats : function getFormats(){
                var fmts = this._super();
                if(fmts && parseInt(fmts.height, 10) === 0) { 
                    fmts.height = "1px";
                }
                return fmts;
            }
        }
    );
    
})();
(function () {
    mstrmojo.requiresCls("mstrmojo._TouchGestures",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.hash");

    
    mstrmojo.android.ui._IsTouchLink = mstrmojo.provide(
        'mstrmojo.android.ui._IsTouchLink',

        
        mstrmojo.hash.copy(mstrmojo._TouchGestures, {
            _mixinName: 'mstrmojo.android.ui._IsTouchLink',

            ontouchend: function (evt) {
                
                if (!this.linkEnabled) {
                    return;
                }

                
                if (!evt.e.handled) {
                    
                    var domNode = this.domNode,
                        mask = document.createElement('div'),
                        id = this.id;

                    
                    mask.className = 'activeLink on';
                    domNode.appendChild(mask);

                    
                    window.setTimeout(function () {
                        
                        var link = mstrmojo.all[id];
                        if (link && link.hasRendered) {
                            mstrmojo.dom.attachOneTimeEvent(mask, 'webkitTransitionEnd', function () {
                                
                                domNode.removeChild(mask);
                            });

                            
                            mstrmojo.css.removeClass(mask, 'on');
                        }
                    }, 200);

                    
                    this.onclick();
                }
            }
        })
    );
}());
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo._TouchGestures",
        "mstrmojo.TouchScroller"
    );

    var $forEachArray = mstrmojo.array.forEach,
        $forEachHash = mstrmojo.hash.forEach,
        $D = mstrmojo.dom;

    
    function translate(node, c) {
        var i;
        for (i in node) {
            $D.translate(node[i], c[0], c[1], c[2]);
        }
    }

    
    function preventMove(t) {
        var abs = Math.abs;
        return {
            x: (abs(t.accelDelta.x) < abs(t.accelDelta.y)),
            y: (abs(t.accelDelta.y) < abs(t.accelDelta.x))
        };
    }

    
    function raiseScrolledOutEvent(scroller, e) {
        scroller.raiseEvent({
            name: 'scrolledOut',
            value: e.value,
            axis: e.axis,
            direction: e.direction
        });
    }

    
    function setupScroller(el, offset, v, h, frameRate, showBar, friction, indEl) {
        var scroller = new mstrmojo.TouchScroller({
            scrollEl: el,
            vScroll: v,
            hScroll: h,
            frameRate: frameRate,
            showScrollbars: showBar,
            offset: offset,
            origin: {
                x: 0,
                y: 0
            },
            bounces: false,    
            useTranslate3d: false, 
            indicatorEl: indEl
        });

        
        if (friction) {
            scroller.friction = friction;
        }

        return scroller;
    }

    
    function stopDeceleration(scroller) {
        var i;
        
        for (i in scroller) {
            
            if (scroller[i].decelerating) {
                scroller[i].stopDeceleration();
            }
        }
    }

    
    var PREVENT_MOVEMENT = {
        x: false,
        y: false
    };

    
    function getAxis() {
        var prevent = PREVENT_MOVEMENT;

        
        if (!prevent.x) {
            return 'x';
        }
        if (!prevent.y) {
            return 'y';
        }
        
        return null;
    }

    
    var isContainerScrollElement = {
        x: false,
        y: false
    };

    
    function syncScrollEl(xtab, d) {
        
        var currentAxis = getAxis(),
            scrollPast = xtab.scrollerConfig.scrollPast;

        
        if (!currentAxis || !scrollPast) {
            
            return !!currentAxis && !scrollPast;
        }

        function syncHelper(axis) {
            var container = xtab.viewport,
                node = xtab._TSN[axis],
                scroller = xtab._scroller[axis],
                curPosition = xtab.tPos[axis],
                newPosition = d[axis],
                isCntrScrllEl = isContainerScrollElement[axis],
                otherAxis = (axis === 'x') ? 'y' : 'x',
                otherScroller = xtab._scroller[otherAxis],
                isContainerOnOtherAxis = isContainerScrollElement[otherAxis],
                i;

            
            
            if (!otherScroller[0].decelerating && isContainerOnOtherAxis) {
                
                
                syncHelper(otherAxis);
            }

            
            if (curPosition <= 0 && newPosition > 0) {

                if (!isCntrScrllEl) {
                    if (isContainerOnOtherAxis) {
                        
                        return false;
                    }

                    
                    translate(node, [0, 0, 0]);

                      
                    for (i in scroller) {
                        scroller[i].scrollEl = container;
                    }

                    
                    isContainerScrollElement[axis] = true;
                }
            } else {

                if (isCntrScrllEl) {
                    
                    translate([container], [0, 0, 0]);

                    
                    for (i in scroller) {
                        scroller[i].scrollEl = node[i];
                    }

                    
                    isContainerScrollElement[axis] = false;
                }
            }

            
            return true;
        }

        
        return syncHelper(currentAxis);
    }

    function handleScrollEvents(xtab, evt) {
        var axis = evt.axis,
            incRender = xtab.scrollboxHeightFixed,
            evtName = evt.name;

        if (xtab.ss) {
            
            var rowInfo = xtab.zones._BR.getRowInfoByPosition(evt[axis]);

            
            rowInfo.position = evt[axis];

            
            xtab.ss.onMove(rowInfo);
        }

        
        
        xtab.tPos[axis] = evt[axis];

        if (evtName === 'scrollDone') {
            
            $forEachHash(xtab._scroller, function (scrollers) {
                $forEachArray(scrollers, function (scroller) {
                    scroller.toggleScrollBars(false);
                });
            });

            
            if (!syncScrollEl(xtab, evt)) {
                return true;
            }
        }

        
        if (axis === 'y') {

            
            var fnEnd = function (newPosition) {
                
                if (!xtab._isDownloading && (-newPosition <= xtab._TMAX[axis])) {
                    
                    if (xtab.onScrolledToLastRow) {
                        xtab.onScrolledToLastRow();
                    }
                }
            };

            
            if (evtName === 'scrollDone') {
                
                delete xtab._isDecelerating;

                
                if (xtab._cachedDownload) {
                    
                    xtab.dataDownloaded();
                } else {
                    
                    fnEnd(evt.y);
                }

                
                if (incRender) {
                    
                    var newPosition = evt.y;

                    xtab.notifyScrollListeners({
                        x: evt.x,
                        y: Math.max(newPosition, 0)
                    });
                }

            } else if (evtName === 'scrollDecel') {
                
                xtab._isDecelerating = true;

                
                fnEnd(evt.fY);

                
                if (incRender) {
                    
                    xtab.notifyScrollListeners({
                        x: evt.fX,
                        y: evt.fY
                    });
                }
            } else if (evtName === 'scrollOut') {
                
                xtab._isDecelerating = true;

                
                fnEnd(evt.y.position);
            }
        }
    }

    function getScrollerOffsets(widget, axis) {
        var abs = Math.abs,
            offset = {};

        
        var axisOffset = offset[axis] = {
            start: widget._TMIN[axis],
            end: abs(widget._TMAX[axis])
        };

        
        offset.scrollPast = widget.scrollerConfig.scrollPast;

        
        if (axis === 'y') {
            
            if (widget.useSeamlessIncFetch) {
                
                axisOffset.incFetch = !widget.endFetching;

                
                axisOffset.pageSize = widget.scrollboxHeight - ((parseInt(widget.gridData.rh, 10) || 25) * 4);
            }
        }

        return offset;
    }

    function createScrollers(widget) {
        
        widget._scroller = {
            x: [],
            y: []
        };

        var viewportCoords = widget._viewportCoords;

        
        $forEachHash(widget._TSN, function (nodes, axis) {
            var offset = getScrollerOffsets(widget, axis),
                isY = (axis === 'y'),
                isX = (axis === 'x'),
                len = nodes.length;

            
            $forEachArray(nodes, function (node, idx) {
                
                var scroller = setupScroller(node,
                        offset,
                        isY,
                        isX,
                        widget.frameRate,
                        (idx === len - 1) && widget.scrollerConfig.showScrollbars,
                        widget.scrollerFriction,
                        widget.domNode);

                scroller.updateScrollBars(viewportCoords, widget.domNode);

                widget._scroller[axis][idx] = scroller;
            });

            
            
            var zeroScroller = widget._scroller[axis][0],
                evts = [ 'scrollDone', 'scrollMoved' ];

            if (zeroScroller) {
                
                if (isY) {
                    
                    evts = evts.concat([ 'scrollDecel', 'scrollOut' ]);
                }

                
                $forEachArray(evts, function (evtName) {
                    
                    zeroScroller.attachEventListener(evtName, widget.id, function (evt) {
                        
                        evt.axis = axis;
                        handleScrollEvents(widget, evt);
                    });
                });
            }
        });
    }

    
    function updateOffsets(dimension) {
        
        if (this.hasRendered) {
            
            this[dimension + 'Limit'] = parseInt(this[dimension], 10);

            
            if (this.zones) {
                
                var me = this; 
                window.setTimeout(function () {
                    if (me.hasRendered) {
                        
                        me.setOffsets();
                        
                        
                        me.setupScrollers();
                    }
                }, 0);
            }
        }
    }

    
    mstrmojo._HasXtabTouchScroll = mstrmojo.provide(
        "mstrmojo._HasXtabTouchScroll",
        
        {
            
            noScrolling: false,

            
            useTouchScrolling: true,

            
            scrollerConfig: {
                showScrollbars: false,
                scrollPast: false
            },

            
            _TSN: null,

            
            tPos: {
                x: 0,
                y: 0
            },

            
            _TMIN: {
                x: 0,
                y: 0
            },

            
            setupTNs: function setupTNs() {
                
                this._TSN.x = this._TSN.y = [this.domNode];
            },

            
            touchBegin: function touchBegin(touch) {
                
                if (!this.noScrolling) {
                    
                    touch.stop();

                    if (!this._isDownloading) {
                        if (this.toolbarMgr) {
                            this.toolbarMgr.closeToolbar();
                        }

                        var scrollers = this._scroller,
                            min = this._TMIN,
                            max = this._TMAX;

                        
                        $forEachHash(this.tPos, function (position, axis) {
                            
                            
                            if (position >= min[axis] && position <= Math.abs(max[axis])) {
                                
                                stopDeceleration(scrollers[axis]);
                            }
                        });
                    }

                    
                    
                    var xScrollers = this._scroller.x;
                    $forEachHash(xScrollers, function (scroller) {
                        scroller.origin.x = xScrollers[0].origin.x;
                    });
                }

                
                return true;
            },

            
            touchSwipeBegin: function touchSwipeBegin(touch) {
                
                if (this.noScrolling) {
                    
                    return this.bubbleTouchEvent(touch);
                }

                
                if (this._isDownloading) {
                    
                    return false;
                }

                PREVENT_MOVEMENT = preventMove(touch);

                
                var axis = PREVENT_MOVEMENT.y ? 'x' : 'y',
                    scroller = this._scroller[axis][0],
                    offset = scroller.offset,
                    offsetVal = offset[axis][touch.direction[axis] ? 'end' : 'start'];

                
                if (!offset.scrollPast && offsetVal === scroller.origin[axis]) {
                    var bubbleTouchEvent = this.bubbleTouchEvent(touch);

                    
                    
                    if (bubbleTouchEvent !== undefined) {
                        return bubbleTouchEvent;
                    }
                }

                
                var s = this._scroller;

                
                if (!syncScrollEl(this, touch.delta)) {
                    return true;
                }

                
                
                if (!PREVENT_MOVEMENT.x) {
                    stopDeceleration(s.x);
                }
                if (!PREVENT_MOVEMENT.y) {
                    stopDeceleration(s.y);
                }

                
                $forEachHash(this._scroller, function (scrollers, axis) {
                    
                    if (!PREVENT_MOVEMENT[axis]) {
                        
                        $forEachArray(scrollers, function (scroller) {
                            scroller.toggleScrollBars(true);
                        });
                    }
                });

                return true;
            },

            
            touchSwipeMove: function touchSwipeMove(touch) {
                
                
                if (!syncScrollEl(this, touch.delta)) {
                    return true;
                }

                var scrollers = this._scroller;

                $forEachArray([ 'x', 'y' ], function (axis) {
                    if (!PREVENT_MOVEMENT[axis]) {
                        $forEachHash(scrollers[axis], function (scroller) {
                            scroller.scroll(touch);
                        });
                    }
                });
            },

            
            touchSwipeEnd: function touchSwipeEnd(touch) {
                var prevent = PREVENT_MOVEMENT,
                    axis = null,
                    delta = touch.delta,
                    direction = touch.direction;

                if (!prevent.x && delta.x !== 0) {
                    axis = 'x';
                    direction = direction.x ? 'left' : 'right';
                }
                if (!prevent.y && delta.y !== 0) {
                    axis = 'y';
                    direction = direction.y ? 'up' : 'down';
                }

                if (axis) {
                
                    raiseScrolledOutEvent(this, {
                        axis: axis,
                        value: this.tPos[axis],
                        direction: direction
                    });

                    
                    var scroller = this._scroller[axis],
                        i;
                    if (!prevent[axis]) {
                        for (i in scroller) {
                            scroller[i].scrollEnd(touch);
                        }
                    }
                }

            },

            
            gridPagesRendered: function gridPagesRendered() {
                if (this._super) {
                    this._super();
                }

                this.setOffsets();
            },

            
            renderEmptyGrid: function renderEmptyGrid() {
                if (this._super) {
                    this._super();
                }

                this.noScrolling = true;
            },

            postBuildRendering: function postBuildRendering() {

                if (this._super) {
                    this._super();
                }

                
                if (this.zones && !this.gridData.eg) {
                    var me = this;

                    
                    
                    window.setTimeout(function () {
                        
                        if (me.hasRendered) {
                            me._TSN = {
                                x: [],        
                                y: []         
                            };

                            
                            me.setupTNs();
                            
                            
                            me.setupScrollers();
                        }
                    }, 0);
                }
            },

            
            setOffsets: function setOffsets() {
                var me = this,
                    domNode = this.domNode,
                    zones = this.zones,
                    TR = zones._TR,
                    BL = zones._BL,
                    isDocNotFullScreen = (!this.isFullScreenWidget && this.isDocXtab),
                    viewportCoords = this._viewportCoords = {
                        top: TR ? TR.cp.rc * parseInt(this.gridData.rh, 10) : 0,
                        
                        right: isDocNotFullScreen ? this.widthLimit : parseInt(this.width, 10),
                        bottom: isDocNotFullScreen ? this.heightLimit : parseInt(this.height, 10),
                        left: BL ? BL.totalColWidth : 0
                    };

                
                $forEachHash(this._scroller, function (scrollers, axis) {
                    
                    $forEachArray(scrollers, function (scroller) {
                        
                        scroller.offset = getScrollerOffsets(me, axis);

                        
                        scroller.updateScrollBars(viewportCoords, domNode);

                        
                        var origin = scroller.origin;
                        if (origin) {
                            
                            scroller.scrollTo(origin.x, origin.y);
                        }
                    });
                });
            },
            
            
            setupScrollers: function setupScrollers() {
                
                var gd = this.gridData,
                    MAX_OFFSETS = this._TMAX,
                    noScrolling = this.noScrolling = ((gd && gd.co) || (!this.scrollerConfig.scrollPast && MAX_OFFSETS.x === 0 && MAX_OFFSETS.y === 0));

                
                if (!noScrolling && !this._scroller) {
                    
                    isContainerScrollElement = {
                        x: false,
                        y: false
                    };

                    
                    
                    translate(this._TSN.x, [0, 0, 0]);
                    translate(this._TSN.y, [0, 0, 0]);

                    
                    createScrollers(this);
                }
            },

            
            onwidthChange: function onwidthChange() {
                updateOffsets.call(this, 'width');

                
                if (this._super) {
                    this._super();
                }
            },

            
            onheightChange: function onheightChange() {
                updateOffsets.call(this, 'height');

                
                if (this._super) {
                    this._super();
                }
            },

            
            unrender: function unrender(ignoreDom) {
                 
                $forEachHash(this._scroller, function (scrollers) {
                    
                    $forEachArray(scrollers, function (scroller) {
                        
                        scroller.destroy();
                    });
                });
                
                
                delete this._scroller;

                if (this._super) {
                    this._super(ignoreDom);
                }
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.TouchScroller");
            
    
    var OFFSET_PROP = {
        v: {
            axis: 'y',
            dimension: 'height'
        }, 
        h: {
            axis: 'x',
            dimension: 'width'
        }
    };

    
    mstrmojo.android._IsIncFetchList = mstrmojo.provide(

        "mstrmojo.android._IsIncFetchList",

        
        {
            _mixinName: 'mstrmojo.android._IsIncFetchList',

            
            supportsIncFetch: true,

            
            ifDataHelper: null,
            
            
            ifDirection: 'v',
            
            
            supportedEdges: mstrmojo.TouchScroller.EnumIncFetchEdges.end,

            
            initScroller: function initScroller(scroller) {
                this._super(scroller);

                
                var dataHelper = this.ifDataHelper;
                if (dataHelper) {
                    
                    scroller.attachEventListener('incFetch', this.id, function (evt) {
                        
                        if (!this.supportsIncFetch) {
                            
                            return;
                        }
                        
                        
                        var me = this;
                        dataHelper.next({
                            success: function (e, items) {
                                me.addItems(items || e.items);
                                me._scroller.STATUS_INC_FETCH = false;
                            },

                            failure: function (res) {
                                mstrmojo.alert("Error in fetching next: " + res);
                            }
                        }, evt.edge);
                    });
                }
            },

            
            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    incFetch = this.supportsIncFetch,
                    dir = this.ifDirection,
                    offsetProp = OFFSET_PROP[dir];

                
                if (cfg[dir + 'Scroll']) {
                    var offset = cfg.offset[offsetProp.axis];

                    
                    offset.incFetch = incFetch;
                    offset.supportedEdges = this.supportedEdges;
                    offset.pageSize = incFetch ? (parseInt(this[offsetProp.dimension], 10) - 100) : 0;

                    
                    this.scrollerConfig = cfg;
                }

                return cfg;
            },

            
            addItems: function addItems(items) {
                
                this._super(items);

                
                this.supportsIncFetch = ((this.ifDataHelper.totalSize === -1) || (this.items.length < this.ifDataHelper.totalSize));

                
                if (this.updateScroller) {
                    
                    this.updateScroller();
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom","mstrmojo.TouchScroller");
    
    var $D = mstrmojo.dom,
    	$M = Math;
    
    function constrainPoint(value, offset) {
        return (offset) ? $M.max($M.min($M.round(value), offset.end), offset.start) : value;
    }

    
    mstrmojo._NeedSyncScroller = mstrmojo.provide(

        "mstrmojo._NeedSyncScroller",

        
        {
           init: function init(props){
	    	   if(this._super){
	    		   this._super(props);
	    	   }
	    	   
	        	 if(!this.lisenters){
	        		 this.lisenters = [];
	        	 }  
        	 
           },

           initScroller : function initScroller(scroller) {
        	   if(this._super){
        		   this._super(scroller);
        	   }
        	   
				
				this._scrollMovedListener = this._scroller.attachEventListener('scrollMoved', this.id, function (evt) {
					this.onScrollMoved(evt);
				});
				
				
				this._scrollDoneListener = this._scroller.attachEventListener('scrollDone', this.id, function (evt) {
					this.onScrollDone(evt);
				});
           },
           
           onScrollMoved: function onScrollMoved(evt){
        	   if(this._super){
        		   this._super(evt);
        	   }
        	   this.syncScroller(evt, true);
           },
           
           onScrollDone: function onScrollDone(evt){
        	   if(this._super){
        		   this._super(evt);
        	   }
        	   
        	   this.syncScroller(evt, false);
        	   
        	   
           },
           
           syncScroller: function sScroller(evt, showScrollBar){
        	   if(!evt || evt.x == undefined || evt.y == undefined){
        		   return;
        	   }
        	   var lisenters = this.lisenters,
        	   		lisCount = this.lisenters.length;
        	   for(var i = 0 ; i < lisCount; i++ ){
        		   var scroller = lisenters[i]._scroller,
        		   		offset = scroller.offset;
      				
      				
        		   scroller.origin = {
       					x : scroller.hScroll ? evt.x : 0,
       					y : scroller.vScroll ? evt.y : 0
       				};
        		   $D.translate(scroller.scrollEl, -scroller.origin.x, -scroller.origin.y, 0, scroller.transform, scroller.useTranslate3d);
        		   
        		   scroller.toggleScrollBars(showScrollBar);
        		   mstrmojo.hash.forEach(scroller._scrollBarEls, function (bar, axis) {
        	            var isX = (axis === 'x'),
        	                position = evt[axis],
        	                length = bar.length,
        	                ratio = bar.ratio,
        	                viewportSize = bar.viewportSize,
        	                minScale = 6 / length,
        	                minPosition = bar['base' + ((isX) ? 'Left' : 'Top')],
        	                maxPosition = minPosition + viewportSize - length,
        	                newPosition = $M.round(minPosition + (ratio * position));

        	            
        	            if (newPosition < minPosition) {
        	                newPosition = minPosition - position;
        	                length += position;
        	            } else if (newPosition > maxPosition) {
        	                var delta = (position - scroller.offset[axis].end) * ratio;
        	                newPosition = $M.min(maxPosition + delta, viewportSize + minPosition - 6) - 1;
        	                length -= delta;
        	            }

        	            
        	            var v = 0,
        	                translate = [v, v, v],
        	                scale = [1, 1, 1],
        	                idx = (isX) ? 0 : 1;

        	            translate[idx] = (newPosition - minPosition);
        	            scale[idx] = $M.min($M.max(length / bar.length, minScale), 1);

        	            $D.translate(bar, translate[0], translate[1], translate[2], ' scale3d(' + scale.join(',') + ')');
        	        });
        		   
        	   }
           },
           
           addSyncScroller: function addSyncScroller(l){
        	   this.lisenters.push(l);
           },
           
           destroy: function destroy(){
        	   this.lisenters = null;
        	   
        	   
	            if(this._scrollDoneListener){
	            	this._scroller.detachEventListener(this._scrollDoneListener);
	            	delete this._scrollDoneListener;
	            }
	            if(this._scrollMovedListener){
	            	this._scroller.detachEventListener(this._scrollMovedListener);
	            	delete this._scrollMovedListener;
	            }
	            
        	   this._super();
           }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.TouchScroller",
                         "mstrmojo.hash");

    var $HASH = mstrmojo.hash;

    
    mstrmojo._HasTouchScroller = mstrmojo.provide(

        "mstrmojo._HasTouchScroller",

        
        {
            _meta_usesSuper: true,

            
            scrollerConfig: {},

            
            allowTouchBubble: true,

            
            scrollerSetupDelay: undefined,

            init: function init(props) {
                this._super(props);

                
                this.scrollerConfig = $HASH.clone(this.scrollerConfig);
            },

            
            updateScrollerConfig: function updateScrollerConfig() {
                return this.scrollerConfig;
            },

            
            updateScroller: function updateScroller(noScrollToOrigin, duration) {
                var scroller = this._scroller;

                
                if (scroller) {
                    
                    var cfg = this.updateScrollerConfig();

                    
                    scroller.initScroller(cfg);

                    
                    if (!noScrollToOrigin) {
                        
                        var origin = cfg.origin;
                        if (origin) {
                            
                            scroller.scrollTo(origin.x, origin.y, duration);
                        }
                    }

                    
                    scroller.updateScrollBars();
                }
            },

            
            initScroller: mstrmojo.emptyFn,

            
            useSelectScroll: false,

            
            postBuildRendering: function postBuildRendering() {
                var scroller = this._scroller;

                
                if (!scroller) {
                    
                    scroller = this._scroller = new mstrmojo.TouchScroller();

                    
                    this.initScroller(scroller);
                } else {  
                    scroller.haltScroller();
                }

                
                if (!this.layoutConfig) {
                    var $this = this,
                        delay = this.scrollerSetupDelay;

                    if (!isNaN(delay)) {
                        window.setTimeout(function () {
                            $this.updateScroller();
                        }, delay);

                    } else {
                        
                        this.updateScroller();
                    }
                }

                
                if (this._super) {
                    this._super();
                }
            },

            
            afterLayout: function afterLayout() {
                this._super();

                
                this.updateScroller();
            },

            getScrollPos: function getScrollPos() {
                return $HASH.copy(this._scroller.origin || {
                    x: 0,
                    y: 0
                });
            },

            
            shouldTouchBubble: function shouldTouchBubble(touch) {
                
                if (!this.allowTouchBubble) {
                    
                    return false;
                }

                
                var scroller = this._scroller,
                    isVertical = touch.isVertical,
                    axis = (isVertical) ? 'y' : 'x';

                
                return (!scroller[((isVertical) ? 'v' : 'h') + 'Scroll'] || scroller.offset[axis][touch.direction[axis] ? 'end' : 'start'] === scroller.origin[axis]);
            },

            
            touchBegin: function touchBegin(touch) {
                
                this._scroller.haltScroller();

                return (this._super && this._super(touch)) || true;
            },

            
            touchSwipeBegin: function touchSwipeBegin(touch) {
                
                if (this.shouldTouchBubble(touch)) {
                    
                    if (this.bubbleTouchEvent(touch) === false) {
                        
                        this._touchCanceled = true;
                    }

                    
                    return;
                }

                
                if (this._super) {
                    
                    this._super(touch);
                }

                
                this._scroller.toggleScrollBars(true);
            },

            
            touchSelectBegin: function touchSelectBegin(touch) {
                
                if (this._super) {
                    
                    this._super(touch);
                }

                
                if (this.useSelectScroll) {
                    
                    this.touchSwipeBegin(touch);
                }
            },

            
            touchSwipeMove: function touchSwipeMove(touch) {
                
                if (!this._touchCanceled) {
                    
                    if (this._super) {
                        
                        this._super(touch);
                    }
                }

                
                this._scroller.scroll(touch);
            },

            
            touchSelectMove: function touchSelectMove(touch) {
                
                if (!this._touchCanceled) {
                    
                    if (this._super) {
                        
                        this._super(touch);
                    }
                }

                
                if (this.useSelectScroll) {
                    
                    this.touchSwipeMove(touch);
                }
            },

            
            touchSwipeEnd: function touchSwipeEnd(touch) {
                
                touch.evt.handled = true;

                
                if (!this._touchCanceled) {
                    
                    if (this._super) {
                        
                        this._super(touch);
                    }
                }

                
                this._scroller.scrollEnd(touch);
            },

            
            touchSelectEnd: function touchSelectEnd(touch) {
                
                if (this._touchCanceled) {
                    
                    return;
                }

                
                if (this._super) {
                    
                    this._super(touch);
                }

                
                if (this.useSelectScroll) {
                    
                    this.touchSwipeEnd(touch);
                }
            },

            touchEnd: function touchEnd(touch) {
                
                if (this._touchCanceled) {
                    
                    delete this._touchCanceled;
                    return;
                }

                if (this._super) {
                    this._super(touch);
                }
            },

            unrender: function unrender(ignoreDom) {

                
                var scroller = this._scroller;
                if (scroller) {
                    
                    scroller.unrender();
                }

                
                delete this.scrollerConfig.scrollEl;

                this._super(ignoreDom);
            },


            
            destroy: function destroy() {
                
                if (this._scroller) {
                    
                    this._scroller.destroy();
                    delete this._scroller;
                }

                
                if (this._super) {
                    
                    this._super();
                }
            }

        }
    );

}());
(function(){
    mstrmojo.requiresCls("mstrmojo.TouchScroller", "mstrmojo.dom");

    var LOCK_OFF = 0,
        LOCK_ROW = 1,
        LOCK_COL = 2,
        LOCK_BOTH =3,
        
        TAB_INFO = 'CellInfo',
        TAB_DRILL = 'Drill',
        TAB_LINK = 'Link',

        
        TOUCH_OFFSET = 25,
        CONTENT_LINE_HEIGHT = 40,
        TITLE_HEIGHT = 55,
        TITLE_BORDER_HEIGHT = 6,
        MAX_ENTRIES = 4,
        isTablet = false,
        
        CSS_TAB = 'InfoViewer-Tab',
        CSS_TAB_WRAPPER = 'InfoViewer-TabWrapper',
        CSS_SCOLL_TAB = 'InfoViewer-nTab',
        CSS_SHOW_ALL = 'showAll',
        CSS_DRILL_TO = 'drillTo',
        CSS_LINK_TO = 'linkTo',
        CSS_GLOW = 'glow',
        
        $CSS = mstrmojo.css,

        EVENT_HANDLERS = [];
        
        
        EVENT_HANDLERS[CSS_TAB] = EVENT_HANDLERS[CSS_SCOLL_TAB] = function(dom){
            var cssClass = dom.className;
            
            
            if (cssClass == CSS_TAB){
                cssClass = dom.parentNode.className;
            }
            
            
            for (var i = 0, len = this.tabs.length; i < len; i++){
                if (cssClass.indexOf(this.tabs[i].name) > -1){
                    this.setCurrentTab(i);
                    break;
                }
            }
            
            
            this.xtab.magnifier.resizeAndPosition();
        };
    
        
        EVENT_HANDLERS[CSS_DRILL_TO] = function(){
            mstrApp.closeDialog();
            this.xtab.controller.onDrill(this.xtab, this.drillPaths[0].act);
        };
        
        
        EVENT_HANDLERS[CSS_LINK_TO] = function(dom){
            mstrApp.closeDialog();
            this.xtab.controller.onLink(this.xtab, this.linkPaths[dom.getAttribute('lnk')].act);
        };
        
        
        EVENT_HANDLERS[CSS_SHOW_ALL] = function(dom){
            
            this.tabs[this.currentTabIndex].expanded = true;
            
            $CSS.removeClass(this.xtab.magnifier.containerNode, 'hideMore');
            
            
            this.xtab.magnifier.resizeAndPosition();
        };
    
    
    mstrmojo.XtabMagnifierHelper = mstrmojo.declare(
            
        mstrmojo.Obj,
        
        null,
        
        {
            xtab: null,
            
            cellInfo: null, 
            
            selectedCell: null,
            
            drillPaths: null,
            
            linkPaths: null,
            
            tabs: [],
            
            currentTabIndex: 0,
            
            init: function(props){
                this._super(props);
                
                isTablet = mstrApp.isTablet();
                
                
                var dpi = mstrMobileApp.getDeviceDPI();
                if (dpi <= 120) { 
                    CONTENT_LINE_HEIGHT = 26;
                    TITLE_HEIGHT = 35; 
                    TOUCH_OFFSET = 15; 
                } else if (dpi <= 160) { 
                    CONTENT_LINE_HEIGHT = 35;
                    TITLE_HEIGHT = 46; 
                    TOUCH_OFFSET = 20;
                } else if (dpi <= 213) {
                    CONTENT_LINE_HEIGHT = 46;
                    TITLE_HEIGHT = 61;
                    TOUCH_OFFSET = 26;
                } else if (dpi <= 240){ 
                    CONTENT_LINE_HEIGHT = 53;
                    TITLE_HEIGHT = 69;
                    TOUCH_OFFSET = 30;
                } else { 
                    CONTENT_LINE_HEIGHT = 70;
                    TITLE_HEIGHT = 92;
                    TOUCH_OFFSET = 40;
                }
                
                if (!isTablet) {
                
                	MAX_ENTRIES = 3;
                }
                
                this.titleHeight = TITLE_HEIGHT;
            },
            
            
            glowOnTap: function(dom){
                var glowCssClass = [CSS_TAB_WRAPPER, CSS_SHOW_ALL, CSS_DRILL_TO, CSS_LINK_TO],
                    cssClass = dom.className;

                if (cssClass == CSS_TAB){
                    dom = dom.parentNode;
                    cssClass = dom.className;
                }
                
                for (var i = 0, len = glowCssClass.length; i < len; i++){
                    if (cssClass.indexOf(glowCssClass[i]) > -1){
                        $CSS.addClass(dom, CSS_GLOW);
                 
                        
                        setTimeout(function(){
                            $CSS.removeClass(dom, CSS_GLOW);
                        }, 200);
                        
                        break;
                    }
                }
            },
            
            
            handleTouchTap: function(dom){
                this.glowOnTap(dom);
                
                
                for (n in EVENT_HANDLERS){
                    if (dom.className.indexOf(n) > -1){
                        EVENT_HANDLERS[n].call(this, dom);
                    }
                }
            },
            
            
            handleTouchSwipe: function(touch){
                
                if (!isTablet){
                    var directionX = touch.direction.x,
                        delta = touch.delta,
                        idx = this.currentTabIndex,
                        tabLen = this.tabs.length,
                        totalWidth = parseInt(this.xtab.magnifier.width, 10),
                        minDeltaX = isNaN(totalWidth) ? 50 : totalWidth * 0.2; 
                    
                    
                    if (Math.abs(delta.x) > minDeltaX){
                        if (delta.x > 0){
                            
                            idx = (idx + tabLen - 1) % tabLen;
                        }else {
                            idx = (idx + tabLen + 1) % tabLen;;
                        }
                        
                        
                        if (idx != this.currentTabIndex){
                            this.setCurrentTab(idx);
                            
                            this.xtab.magnifier.resizeAndPosition();
                        }
                    }
                }
            },
            
            
            resolveTouchEvent: function(touch){
                var x = touch.pageX, y = touch.pageY,
                    dom = document.elementFromPoint(x, y),
                    xtab = this.xtab, zones = xtab.zones, td, z;
                
                
                while (dom){
                	var c = dom.className;
                    
                    if (!td && dom.tagName === 'TD' && c && c.toLowerCase().indexOf('xtab-td') >= 0){
                        td = dom;
                    }
                    
                    if (/mstrmojo-XtabZone/.test(c)){
                        
                        for (var i in zones){
                            if (dom == zones[i].domNode){
                                z = zones[i];
                            }
                        }
                        
                        break;
                    }
                    dom = dom.parentNode;
                }

                
                if (td && z){
                    return {
                        cell: td,
                        zone: z,
                        pos: {x: x - TOUCH_OFFSET, y: y - TOUCH_OFFSET, w: TOUCH_OFFSET*2, h: TOUCH_OFFSET*2}
                    };
                }
                
                
                return null;
            },
            
             
            resolveInfoToDisplay: function(touchObj){
                var td = touchObj.cell,
                    zone = touchObj.zone,
                    xtab = this.xtab,
                    lv = xtab.lockHeadersCase,
                    r = parseInt(td.getAttribute('r'), 10),
                    colTitleCell, umCells, row, i, tdIndex, 
                    si, rhc, colIdx, c, cs, i, iLen, j, jLen, k, kLen, listOfPairs = [], me = this,
                    addPair = function(title, value, isSelected){
                        if (isSelected){
                            me.selectedCell = value;

                            
                            listOfPairs.unshift({
                                title: title,
                                value: value
                            });
                        }else {
                            listOfPairs.push({
                                title: title,
                                value: value
                            });
                        }
                    };
                
                
                delete this.selectedCell;
                    
                
                if (lv == LOCK_OFF || lv == LOCK_ROW){
                    
                    r = r - (Math.max(xtab.titlesCP.rc, xtab.chsCP.rc) || 0);
                }else if (zone.slot == '_TR' || zone.slot == '_TL'){
                    r = -1;
                }
                
                
                if (r < 0){
                    
                    colTitleCell = xtab.getCellForNode(td);
                    
                    
                    if (colTitleCell && colTitleCell.o !== undefined){
                        addPair(xtab.model.getCellTitleInfo(colTitleCell).title, colTitleCell, true);
                    }else {
                        return null;
                    }
                }else{
                    umCells = xtab.rhsCP.getUnmergedCells(r) || [];

                    row = {
                        rh: umCells.concat(xtab.rhsCP.getRowCells(r)),
                        vs: xtab.valuesCP.getRowCells(r),
                        ch: []
                    };
                   
                    for( i = 0, iLen = xtab.chsCP.rc; i < iLen; i++) {
                        row.ch.push(xtab.chsCP.getRowCells(i));
                    }
                    
                    
                    tdIndex = td.cellIndex;

                    
                    if (lv == LOCK_OFF || lv == LOCK_COL || zone.slot == '_BL'){ 
                      
                        if (td.parentNode.sectionRowIndex === 0){
                            si = tdIndex;
                        }else {
                            
                            si = tdIndex + umCells.length;
                        }
                    }else { 
                        
                        si = tdIndex + row.rh.length;
                    }
                    
                    rhc = row && row.rh.length;
                    
                    
                    if (si >= rhc){
                        
                        si -= rhc;
                        
                        for (j = 0, jLen = row.ch.length; j < jLen; j++) {
                            colIdx = 0;
                            for (k = 0, kLen = row.ch[j].length; k < kLen; k++) {
                                c = row.ch[j][k];
                                cs = (c && c.cs) || 1; 
                
                                
                                if((si >= colIdx) && (si < colIdx + cs)) {
                                    if(c.mix !== undefined) { 
                                        addPair(c, row.vs[si], true);
                                    } else if (c.ui != null || c.tui != null){ 
                                        addPair(xtab.model.getCellTitleInfo(c).title, c); 
                                    }
                                    break;
                                }
                                
                                colIdx += cs;
                            }
                        }
                        
                        
                        if (!this.selectedCell ){
                            addPair(null, row.vs[si], true);
                        }
                        
                        
                        si = -1;
                    }
                    
                    
                    for(i = 0, iLen = rhc; i < iLen; i++) {
                        c = row.rh[i];
                        addPair(xtab.model.getCellTitleInfo(c).title , c, i == si);
                        
                        
                        if (i == si){
                            break;
                        }
                    }
                }
                
                this.cellInfo = listOfPairs;

                
                if (this.cellInfo){
                    this.tabs = [];
                    
                    
                    this.tabs.push({name: TAB_INFO, label: mstrmojo.desc(10638, 'Info'), expanded: false, content: this.cellInfo});
                    
                    
                    var selectedCell = this.selectedCell,
                        drillable = (selectedCell.v !== undefined) && !!(selectedCell.at & 1),
                        linkable = !!(selectedCell.at & 4);
                
                    if (drillable){
                        this.drillPaths = [];
                        this.drillPaths.push({
                            n: xtab.model.getCellDrillsInfo(selectedCell).n,
                            act: xtab.model.getDrillAction([selectedCell])
                        });
                        
                        this.tabs.push({name: TAB_DRILL, label: mstrmojo.desc(145, 'Drill'), expanded: false, content: this.drillPaths});
                    }else {
                        this.drillPaths = null;
                    }
                    
                    if (linkable){
                        this.linkPaths = [];
                        var lInf = xtab.model.getCellLinksInfo(selectedCell);
                        for (var i = 0, len = lInf.links.length;i < len;i++){
                            this.linkPaths.push({
                                n: lInf.links[i].n, 
                                act: xtab.model.getLinkAction(selectedCell, i)
                            });
                        }
                        
                        this.tabs.push({name: TAB_LINK, label: mstrmojo.desc(8149, 'Link'), expanded: false, content: this.linkPaths});
                    }else{
                        this.linkPaths = null;
                    }
                }
                
                return this.cellInfo;
            },
            
            
            createTitle: function(parentNode){
                var mks = [], 
                    i = 0,
                    tabs = this.tabs,
                    len = tabs.length,
                    tab, idx;
                
                for (; i < len; i++){
                    tab = tabs[i];

                    if (isTablet){
                        mks.push('<div class="', CSS_TAB_WRAPPER, ' ', tab.name, '" style="height:' + (TITLE_HEIGHT - TITLE_BORDER_HEIGHT) + 'px;" >');
                        mks.push('<div class="', CSS_TAB, '">', tab.label, '</div>');
                        mks.push('</div>');
                    } else {
                        mks.push('<div class="', CSS_SCOLL_TAB , ' ', tab.name, '" >', tab.label, '</div>');
                    }
                }
                
                parentNode.style.lineHeight = parentNode.style.height = TITLE_HEIGHT + 'px';
                parentNode.innerHTML = mks.join('');
                
                
                this.setCurrentTab();
            },
            
            
            createContent: function(parentNode){
                var info = this.cellInfo, 
                    drillPaths = this.drillPaths,
                    linkPaths = this.linkPaths,
                    mks = [], rows = [],
                    xtab = this.xtab,
                    addPair = function(l, r, selected) {
                        function _cellMarkup(c, cs) {          
                            var cmk = [],
                                lineHeight = (cs === 'value' && !isTablet) ? CONTENT_LINE_HEIGHT/2 : CONTENT_LINE_HEIGHT;
                            
                            cmk.push('<td><div class="', cs, '" style="line-height:', lineHeight, 'px;max-height:', CONTENT_LINE_HEIGHT, 'px;" >');
                            
                            if (c){
                                if (c.ts == 4){ 
                                    var imgURL = (c.n || c.v),
                                        ds = xtab.controller && xtab.controller.model && xtab.controller.model.dataService;
                                    if ( ds && ds.getImage ) {
                                        imgURL = ds.getImage(imgURL);
                                    }
                                    cmk.push('<img src="' + imgURL + '"/>');
                                }else{
                                    cmk.push(c.n || c.v || '&nbsp;');
                                }
                            }
                            
                            cmk.push('</div></td>');
                            return cmk.join('');
                        };
                        rows.push('<tr style="height:', CONTENT_LINE_HEIGHT, 'px">', _cellMarkup(l, 'title'), _cellMarkup(r, 'value'), '</tr>');
                    },
                    i, len;
                    
                
                if (info == null){
                    return;
                }
                
                
                for (i = 0, len = info.length; i < len; i++){
                    addPair(info[i].title, info[i].value);
                }
                mks.push('<table class="content">');
                mks.push(rows.join(''));
                mks.push('</table>');
                
                
                
                if (drillPaths){
                    mks.push('<div class="actionMenu hide">');
                    for (var i = 0, len = drillPaths.length; i < len; i++){
                        mks.push('<div class="drillTo" style="line-height:', CONTENT_LINE_HEIGHT, 'px">', drillPaths[i].n, '</div>');
                    }
                    mks.push('</div>');
                }
                
                if (linkPaths){
                    mks.push('<div class="actionMenu hide">');
                    for (var i = 0, len = linkPaths.length; i < len; i++){
                        mks.push('<div class="linkTo" style="line-height:', CONTENT_LINE_HEIGHT, 'px" lnk="', i, '">', linkPaths[i].n, '</div>');
                    }
                    mks.push('</div>');
                }
                mks.push('<div class="', CSS_SHOW_ALL, '" style="line-height:', CONTENT_LINE_HEIGHT, 'px" >' + mstrmojo.desc(8995, 'See all...') + '</div>');
                
                parentNode.innerHTML = mks.join('');  
            },

            
            setCurrentTab: function(idx){
                var tabIndex = idx || 0,
                    tabs = this.tabs,
                    tab = tabs[tabIndex],
                    tabLen = tabs.length,
                    magnifier = this.xtab.magnifier,
                    tabs = magnifier.titleNode.children,
                    contents = magnifier.containerNode.children,
                    i, len, contentInfo;
                
                this.currentTabIndex = tabIndex;
                
                
                for (i = 0 ; i < tabLen; i++){
                    $CSS.toggleClass(tabs[i], 'selected', i == tabIndex);
                    
                    if (!isTablet){
                        if (tabLen <= 2){
                            $CSS.toggleClass(tabs[i], 'left', i != tabIndex);
                        }else {
                            $CSS.toggleClass(tabs[i], 'left', i == (tabIndex + tabLen - 1) % tabLen);
                        }
                        $CSS.toggleClass(tabs[i], 'right', i == (tabIndex + tabLen + 1) % tabLen);
                    }
                }
                
                
                for (i = 0, len = contents.length - 1; i < len; i++){
                    $CSS.toggleClass(contents[i], 'hide', i != tabIndex);
                    
                    if (i == tabIndex){
                        this.contentNode = contents[i];
                    }
                }
                
                
                $CSS.toggleClass(magnifier.containerNode, 'hideMore', !tab.expanded && tab.content.length > MAX_ENTRIES);
            },
            
            
            
            getContentHeight: function(){
                function calculateHeight(tab){
                    var content = tab.content,
                        entryNum = content.length,
                        expanded = tab.expanded;
                    
                    return (!expanded && entryNum > MAX_ENTRIES) ? (CONTENT_LINE_HEIGHT + 1) * (MAX_ENTRIES + 1) : (CONTENT_LINE_HEIGHT + 1) * entryNum;
                }
                
                var tabs = this.tabs;
                
                if (isTablet){
                    return calculateHeight(tabs[this.currentTabIndex]);
                }else{
                    var max = 0;
                    for (var i = 0, len = tabs.length; i < len; i++){
                        max = Math.max(calculateHeight(tabs[i]), max);
                    }
                    return max;
                }
            }
        });
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android.selectors._SupportsHoriz",
                         "mstrmojo.css");

    
    mstrmojo.android.selectors.CheckList = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList, mstrmojo._HasTouchScroller, mstrmojo.android.selectors._SupportsHoriz ],

        
        {
            scriptClass: "mstrmojo.android.selectors.CheckList",

            hasEvenRows: true,

            init: function init(props) {
                this._super(props);

                
                var cls = [ 'selector-checklist' ];

                
                if (this.multiSelect) {
                    
                    cls.push('multi');
                }

                
                mstrmojo.css.addWidgetCssClass(this, cls);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android._IsList",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css;

    
    function selectNode(touch, mthName) {
        var item = $DOM.findAncestorByAttr(touch.target, 'idx', true, this.domNode);
        if (item) {
            var v = item.value,
                ir = this.itemRenderer;

            ir[mthName](item.node, this.items[v], v, this);
        }
    }

    
    mstrmojo.android.SimpleList = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo.android._IsList, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        
        {
            scriptClass: "mstrmojo.android.SimpleList",

            scrollerConfig: {
                bounces: false,
                showScrollbars: false
            },

            
            highlightOnSelect: false,

            
            hasEvenRows: false,

            
            rowHeight: -1,
            
            
            itemsFloat: false,

            
            init: function init(props) {
                this._super(props);

                
                if (!mstrApp.isTouchApp()) {
                    
                    $CSS.addWidgetCssClass(this, [ 'hosted' ]);
                }
            },

            
            updateItem: function updateItem(idx) {
                
                var div = document.createElement('div'),
                    item = this.items[idx],
                    me = this;

                
                div.innerHTML = this.itemRenderer.render(this.items[idx], idx, this);

                
                var newEl = div.firstChild;
                this.itemsContainerNode.replaceChild(newEl, this._getItemNode(idx));

                
                mstrmojo.array.forEach(item.dependents, function (d) {
                    me.updateItem(d._renderIdx);
                });

                return newEl;
            },

            
            setDimensions: function setDimensions(h, w) {
                
                if (this.height !== h || this.width !== w) {
                    
                    this.height = h;
                    this.width = w;

                    
                    var dn = this.domNode;
                    if (dn) {
                        dn.style.height = h;
                        dn.style.width = w;

                        
                        this.updateScroller();
                    }
                }
            },
            
            buildRendering: function buildRendering() {
                var rtn = this._super();
                
                
                if (this.itemsFloat) {
                    
                    var clearDiv = document.createElement('div');
                    clearDiv.className = 'clear-me';

                    
                    this.itemsContainerNode.appendChild(clearDiv);
                }

                return rtn;
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    icn = this.itemsContainerNode,
                    h = parseInt(this.height, 10);

                
                if (isNaN(h)) {
                    
                    h = this.domNode.clientHeight;
                }

                
                cfg.scrollEl = icn;

                
                cfg.noHScroll = true;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                
                var offsetIdx = cfg.offsetIdx;
                if (offsetIdx) {
                    
                    delete cfg.offsetIdx;

                    
                    cfg.origin.y = this.getItemOffset(offsetIdx);
                }

                
                var offsetEnd = Math.max(this.getItemsContainerHeight() - h, 0);

                
                var enableScroll = cfg.vScroll = (offsetEnd !== 0 && cfg.noVScroll !== true);
                if (enableScroll) {
                    
                    cfg.offset = {
                        y: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                } else {
                    
                    cfg.offset = null;
                }

                return cfg;
            },

            
            getItemOffset: function getItemOffset(idx) {
                var node = this._getItemNode(idx);
                return Math.max(node.offsetTop - parseInt($CSS.getStyleValue(node, 'marginTop'), 10), 0);
            },

            
            getOffsetIndex: function getOffsetIndex() {
                var cfg = this.scrollerConfig,
                    origin = cfg && cfg.origin,
                    y = origin && origin.y;

                
                if (y) {
                    
                    var rowHeight = this.rowHeight;
                    if (this.hasEvenRows && rowHeight !== -1) {
                        
                        return Math.round(y / rowHeight);
                    }

                    var nodes = this.itemsContainerNode.childNodes,
                        min = 0,
                        max = nodes.length - 1;

                    
                    while (max >= min) {
                        var mid = min + max >> 1,
                            testNode = nodes[mid],
                            nodeY = testNode.offsetTop,
                            nodeH = testNode.offsetHeight;

                        
                        if (y < nodeY - nodeH) {
                            
                            max = mid - 1;

                        
                        } else if (y > nodeY + (nodeH * 2)) {
                            
                            min = mid + 1;

                        } else {
                            
                            return mid;
                        }
                    }
                }

                
                return 0;
            },

            
            scrollToItem: function scrollToItem(idx, duration) {
                
                var scroller = this._scroller;
                if (scroller) {
                    
                    scroller.scrollTo(0, this.getItemOffset(idx), duration || 0);
                }
            },

            
            getItemsContainerHeight: function getItemsContainerHeight() {
                var hasEvenRows = this.hasEvenRows,
                    rtn;

                
                if (!hasEvenRows || this.rowHeight === -1) {
                    
                    if (hasEvenRows) {
                        
                        var firstItem = this._getItemNode(0);
                        if (firstItem) {
                            
                            this.rowHeight = firstItem.offsetHeight;
                        }
                    } else {
                        
                        this.rowHeight = -1;
                    }

                    
                    rtn = this.itemsContainerNode.offsetHeight;
                } else {
                    
                    var items = this.items;
                    rtn = (this.rowHeight * ((items && items.length) || 0));
                }

                return rtn;
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                
                if (this.highlightOnSelect) {
                    
                    selectNode.call(this, touch, 'select');
                }

                this._super(touch);
            },

            touchSelectMove: function touchSelectMove(touch) {
                
                this._selectMove = true;

                this._super(touch);
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                var wasMoved = this._selectMove;
                delete this._selectMove;

                
                if (!wasMoved) {
                    
                    this.touchTap(touch);

                } else {
                    
                    if (this.highlightOnSelect) {
                        
                        selectNode.call(this, touch, 'unselect');
                    }
                }
            },
            
            
            touchend: mstrmojo.emptyFn
        }
    );
}());
(function () {

	mstrmojo.requiresCls("mstrmojo.Widget",
						 "mstrmojo.VisHeatMapColorTheme",
						 "mstrmojo._TouchGestures",
						 "mstrmojo._HasTouchScroller",
						 "mstrmojo.dom",
						 "mstrmojo.css"
						 );
	
	var STEP_X = 1200,
		STEP_Y = 800;
	
	var LABEL = {
		ON: 0,
		OFF: 1,
		PROPORTIONAL: 2
	};
	
	var FMT = {
		LABEL_CTNR_THRES: 6, 
        LABEL_CTNR_WIDTH_THRES: 32,
		LGD_GUTTER: 5, 
        LABEL_PADDING: 2 
	};
	
	var CSSATTR = {
		"heatmap-one-level-1": {},
		"heatmap-two-level-2": {},
		"heatmap-multi-level-1": {},
		"heatmap-multi-level-2": {},
		"heatmap-multi-level-3": {},
		init: false
	};
	
	function getCSSColor(rgb) {
		var c = 0x1000000 + rgb; 
		var str = '#' + c.toString(16).substring(1).toUpperCase();
		return str;
	}
	
	function wfs(root, f) {
		var arr = [root];
		while (arr.length !== 0) {
			var node = arr.shift();
			if (node === undefined || node.deleted) {
				continue;
			}
			
			f(node);
			
			var children = node.entityChildren;
			if (children !== undefined) {
				var l = children.length;
				for (var i = 0; i < l; i++) {
					arr.push(children[i]);
				}
			}
		}
	}
	
	function dfs(root, f, indexString) {
		if(root.deleted) {
			return;
		}
		if(indexString === undefined){
			f(root);
		}else{
			f(root, indexString);
		}
		
		if(root.entityChildren === undefined){
			return;
		}
		var arr = root.entityChildren,
			l = arr.length;
		for(var i = 0; i < l; i++){
			var e = arr[i];
			if(indexString === undefined){
				dfs(e, f);
			}else{
				var param = indexString;
				if (!param) {
					param = i.toString();
				} else {
					param = param + ":" + i;
				}
				dfs(e, f, param);
			}
		}					
	}
	
	function getLabelCSS(l, n) {
		var css;
		if (n === 1) {
			if (l === 0) {
				css = "heatmap-one-level-1";
			}
		} else if (n === 2) {
			if (l === 0) {
				css = "heatmap-multi-level-1";
			} else if (l === 1) {
				css = "heatmap-two-level-2";
			}
		} else if (n >= 3) {
			if (l === 0) {
				css = "heatmap-multi-level-1";
			} else if (l === 1) {
				css = "heatmap-multi-level-2";
			} else if (l === 2) {
				css = "heatmap-multi-level-3";
			}
		}

		return css;
	}

	function intersect(lhs, rhs) {
        if(!lhs || !rhs) {
                return false;
        }
		if (rhs.x >= lhs.x + lhs.w ||
			rhs.y >= lhs.y + lhs.h ||
			rhs.x + rhs.w <= lhs.x ||
			rhs.y + rhs.h <= lhs.y) {
			return false;
		} else {
			return true;
		}
	}
	
	function rectIntersection(a, b) {
		var x = Math.max(a.x, b.x);
		var y = Math.max(a.y, b.y);
		var w = Math.min(a.x + a.w, b.x + b.w) - x;
		var h = Math.min(a.y + a.h, b.y + b.h) - y;
		if (w < 0 || h < 0) {
			return {
				x : NaN,
				y : NaN,
				w : NaN,
				h : NaN
			};
		}
		return {
			x : x,
			y : y,
			w : w,
			h : h
		};
	}
	
	mstrmojo.VisHeatMapCanvas = mstrmojo.declare(
		
		mstrmojo.Widget,
		
		null,
		
		{
			scriptClass: 'mstrmojo.VisHeatMapCanvas',
			
			parent: null,
			
			root: null,
			
			colorTheme: null,
			
			attributes: [],
			
			scale: 1.0,
			
			labelSetting: 0, 
			
			showMetric: false,
			
			bgColor: '#333333',
			
			numImages: 0,
			
			offsetX: 0,
			offsetY: 0,
			
			markupString: 
			'<div style="position:absolute; width:{@width}px; height:{@height}px">' +
				'<canvas width={@width} height={@height} style="visibility: hidden; z-index:0"></canvas>' +
				'<span></span>' +
			'</div>',
			
			markupSlots: {
				domCanvas:	function () { return this.domNode.firstChild; },
				domSpan:	function () { return this.domNode.childNodes[1]; },
				domImage:	function () { return this.domNode.childNodes[2]; }
			},
			
			buildRendering: function () {
				var that = this;
				var backup = mstrmojo.string.apply;
				mstrmojo.string.apply = function (tmpl, obj) {
					if (!tmpl) {
						return "";
					}
					return tmpl.replace(/\{([^\}]+)\}/gm,
						function tokenRepl(token, prop) {						
							var s = token.replace(/@/g, 'that.');
							var res = eval(s);
							return res === undefined ? '' : res;
						}
					);
				};
				
				if (this._super) {
					this._super();
				}
				
				mstrmojo.string.apply = backup;
			},
			
			postBuildRendering: function () {
				this.initCSSATTR();
				
				this.draw();

				if (this._super) {
					this._super();
				}
			},
			
			removeImageAndLabels: function () {
				var dom = this.domNode,
					labels = dom.childNodes,
					n = labels.length;
				for (var i = n-1; i > 1; i--) {
					var node = labels[i];
					dom.removeChild(node);
				}
				this.numImages = 0;
			},
			
			removeLabels: function () {
				var dom = this.domNode,
					labels = dom.childNodes,
					n = labels.length,
					stop = 1 + this.numImages;
				for (var i = n-1; i > stop; i--) {
					var node = labels[i];
					dom.removeChild(node);
				}
			},
			
			updateOffsets: function (x, y) {
				this.offsetX = x;
				this.offsetY = y;
				this.removeLabels();
				this.drawLabels();
			},
			
			draw: function (x, y) { 
				if (x !== undefined)	this.offsetX = x;
				if (y !== undefined)	this.offsetY = y;
				this.removeImageAndLabels();
				this.drawRects();
				this.drawLabels();
			},
			
			drawRects: function () {
				var w = this.width,
					h = this.height,
					k = this.scale,
					cw = Math.ceil(w * k),
					ch = Math.ceil(h * k),
					cvs = this.domCanvas,
					dom = this.domNode,
					fragment = document.createDocumentFragment(),
					row = Math.ceil(ch / STEP_Y),
					col = Math.ceil(cw / STEP_X),
					count = 0;
				
				for (var i = 0; i < row; i++) {
					for (var j = 0; j < col; j++) {
						var window = {
							x: j * STEP_X,
							y: i * STEP_Y,
							w: STEP_X,
							h: STEP_Y
						};
						if (i + 1 === row) { 
							window.h = ch - window.y;
						}
						if (j + 1 === col) { 
							window.w = cw - window.x;
						}

						cvs.setAttribute('width', window.w);
						cvs.setAttribute('height', window.h);
						var cxt = cvs.getContext("2d");
						cxt.fillStyle = this.bgColor;
						cxt.fillRect(0, 0, window.w, window.h);
						
						var drawPiece = function (e, idx) {
							var rect = e.size;
							if (e.entityChildren === undefined && !e.deleted && intersect(window, rect)) {
								var x1 = Math.max(rect.x - window.x, 0),
									y1 = Math.max(rect.y - window.y, 0),
									x2 = Math.min(rect.x + rect.w - window.x, window.w),
									y2 = Math.min(rect.y + rect.h - window.y, window.h);
								cxt.fillStyle = e.color;
								cxt.fillRect(x1, y1, x2-x1, y2-y1);
							}
							e.idx = idx; 
						};

						dfs(this.root, drawPiece, '');
						
						var res = cvs.toDataURL();
						var img = document.createElement('img');
						img.src = res;
						img.style.position = 'absolute';
						img.style.left = window.x + 'px';
						img.style.top = window.y + 'px';
						img.setAttribute("draggable", "false");
						img.setAttribute("orgx", window.x);
						img.setAttribute("orgy", window.y);
						fragment.appendChild(img);
						count++;
					}
				}
				
				cvs.setAttribute('width', 0);
				cvs.setAttribute('height', 0);
				dom.style.width = cw + 'px';
				dom.style.height = ch + 'px';
				dom.appendChild(fragment);
				this.numImages = count;
			},
			
			drawLabels: function () {
				var l = this.attributes.length,
					that = this,
					dom = this.domNode,
					gut = FMT.LGD_GUTTER,
                    padding = FMT.LABEL_PADDING,
					window = {
						x: this.offsetX,
						y: this.offsetY,
						w: this.width,
						h: this.height
					};
				
				var caches = [],
					layout = [{}, {}, {}];
					
				var ext = Math.floor( Math.log(this.scale) / Math.log(2) ); 
				ext = Math.min(ext, l - 3);
				ext = Math.max(ext, 0);
				this._ext = ext; 
				
				var drawText = function (e) {
					if (e === that.root || e.deleted) {
						return;
					}
					
					var rect = e.size,
						w = rect && rect.w,
						h = rect && rect.h;

					if (!intersect(window, rect)) {
						return;
					}
						
					if (w < FMT.LABEL_CTNR_WIDTH_THRES + 2 * FMT.LABEL_PADDING || h < FMT.LABEL_CTNR_THRES) { 
						return;
					}
					
					var str = e.text,
						idx = e.idx,
						level = e.level - ext;
						
					if (level >= 0 && level < 3) {
						var tw, th, 
							labelCSS = getLabelCSS(level, l),
							font = CSSATTR[labelCSS].font,
							fontSize = CSSATTR[labelCSS].fontSize,
							o = {
								s: {},
								e: e,
								m: 0, 
								css: labelCSS
							};
							
						if (that.showMetric === true && e.entityChildren === undefined) {
							var loc = {};
							mstrmojo.hash.copy(rect, loc);
							
							if (l > 1 && level === 0) { 
								loc.w -= 2 * gut;
								loc.h -= gut;
							} else {
								loc.w -= 2*padding;
							}
							
							var lh, txtS; 
							
							if (that.labelSetting === LABEL.PROPORTIONAL) {
								lh = 9;
								var step = 8,
									shrink = false,
									txtS = that.getTextSize(str, font, lh, true, false, loc.w); 

								while (step >= 1) {
									if (txtS.h < loc.h) {
										lh += step;
									} else {
										if (lh === 9) { 
											break;
										}
										if (lh >= loc.w) {
											break;
										}
										if (!shrink) {
											step /= 2;
										}
										shrink = true;
										lh -= step;
									}
									
									txtS = that.getTextSize(str, font, lh, true, false, loc.w);
									
									if (shrink) {
										step = step >> 1;
									}
								}
								
								if (txtS.h > loc.h && lh > 9) {
									lh--;
								}
								if (lh > loc.w) {
									lh = loc.w;
								}

                                o.fs = lh;
								
							} else {
								lh = fontSize;
							}
							
							o.lh = lh; 
							
							txtS = that.getTextSize(str, font, lh, true, false, loc.w);
							
							tw = Math.min(txtS.w, loc.w);
							th = txtS.h;
							
							if (th > loc.h) {
								th = Math.floor(loc.h / lh) * lh;
							}
						} else {
							if (caches[level] === undefined) {
								caches[level] = {};
							}
							
							var cache = caches[level];
								
							if (cache[str] === undefined) {
								var txtS = that.getTextSize(str, font, fontSize, true),
								tw = txtS.w,
								th = txtS.h;
								if (l > 1 && level === 0) {
									tw += 2 * gut;
									th += gut;
								}
								cache[str] = {w: tw, h: th};
							} else {
								tw = cache[str].w;
								th = cache[str].h;
							}
							
							if (th > h) return;
							
							o.lh = th;
							
                            var p ;
                            if (l > 1 && level === 0) {
                                    p = 2 * gut;
                            } else {
                                    p = 2 * padding;
                            }
							if (tw > w - p) {
								var trunw = tw >> 1,
                                    lineCount = Math.floor(h/o.lh);
                                
								if (trunw > (w - p)*lineCount) {
                                        return;
                                }
                                tw = w - p;
                                
                                if( (l == 1 && level == 0) || (l == 2 && level == 1) || (l >2 && level == 2) ) {
                                        
                                        var ts = that.getTextSize(str, font, fontSize, true, false, w-p, true);
                                        th *= Math.floor(Math.min(ts.h, h) / o.lh);
                                        o.isLowestLevel = true;
                                }
							}
						}
						
						var x = rect.x + ((w - tw) >> 1),
							y = rect.y + ((h - th) >> 1);
						
						o.s = {x: x, y: y, w: tw, h: th};
						layout[level][idx] = o;
					}
					
				};
				
				if (that.labelSetting !== LABEL.OFF) {
					wfs(this.root, drawText);
					this.layoutLabels(layout);
				}
			},
			
			layoutLabels: function (layout) {
				var that = this,
					doc = document,
					fragment = doc.createDocumentFragment();
			
				function generateLabel(o) {
					var s = o.s,
						e = o.e,
						css = o.css,
						color = that.getLabelColor(s, e),
						hasM = o.fs !== undefined;
						
					var div = doc.createElement('div'); 
					if (hasM) {
                        div.setAttribute('style', 'font-size: ' + o.fs + 'px' + ' !important');
						
						div.className = css + ' heatmap-showMetric-text';
					} else {
						div.className = css + ' heatmap-trun-text';
					}
					div.style.position = 'absolute';
					div.style.color = color;
					div.style.backgroundColor = 'rgba(255, 255, 255, 0)';
					div.style.zIndex = '1';
					div.style.left = s.x + 'px';
					div.style.top = s.y + 'px';
					div.style.width = s.w + 'px';
					div.style.height = s.h + 'px';
					div.style.lineHeight = o.lh + 'px';
                    if(o.isLowestLevel) {
                            div.style.textOverflow = 'ellipsis';
                            div.style.wordBreak = 'normal';
                    }
					
					
					div.setAttribute("idx", e.idx);
					div.innerHTML = e.text;
					fragment.appendChild(div);
				}
				
				var L0 = layout[0],
					L1 = layout[1],
					L2 = layout[2],
					idx;
				
				for (idx in L1) {
					var info = L1[idx],
						bbox = info.s,
						node = info.e,
						prt = node.parentEntity,
						pinfo = L0[prt.idx];
					
					if (pinfo === undefined) {
                        generateLabel(info);
                        continue;
                    }

					var pbox = pinfo.s,
						inter = rectIntersection(bbox, pbox);
					
					var rmIt = false;
					if (inter.w > 5 || inter.h > 5) { 
						if (pbox.y <= bbox.y) {
							var delta = ((pbox.y + pbox.h - bbox.y) >> 1) + 1;
							if (pinfo.m !== 2 && (pbox.y - delta >= prt.size.y) && (bbox.y + bbox.h + delta <= node.size.y + node.size.h)) {
								pbox.y -= delta;
								bbox.y += delta;
								pinfo.m = 1;
							} else {
								rmIt = true;
							}
						} else {
							var delta = ((bbox.y + bbox.h - pbox.y) >> 1) + 1;
							if (pinfo.m !== 1 && (pbox.y + pbox.h + delta <= prt.size.y + prt.size.h) && (bbox.y - delta >= node.size.y)) {
								pbox.y += delta;
								bbox.y -= delta;
								pinfo.m = 2;
							} else {
								rmIt = true;
							}
						}
					}
					
					if (rmIt !== true) {
						generateLabel(info);
					}
				}

				for (idx in L0) { 
					generateLabel(L0[idx]);
				}
				
				for (idx in L2) {
					rmIt = false;
					
					var info2 = L2[idx],
						node2 = info2.e,
						node1 = node2.parentEntity,
						node0 = node1.parentEntity,
						idx1 = node1.idx,
						idx0 = node0.idx,
						info1 = L1[idx1],
						info0 = L0[idx0];
						
					if (info1 !== undefined) {
						var inter12 = rectIntersection(info1.s, info2.s);
						if (!isNaN(inter12.w)) {
							rmIt = true;
						}
					}
					if (rmIt === false && info0 !== undefined) {
						var inter02 = rectIntersection(info0.s, info2.s);
						if (!isNaN(inter02.w)) {
							rmIt = true;
						}
					}
						
					if (rmIt !== true) {
						generateLabel(info2);
					}
				}
				
				this.domNode.appendChild(fragment);
			},
			
			getLabelColor: function (s, e) {
				var level = e.level - this._ext;
				if (level === 0) {
					return '#FFFFFF';
				}
			
				var ct = this.colorTheme;
				if (e.entityChildren === undefined) {
					return getCSSColor(ct.getContrastColor( parseInt(e.color.substring(1, e.color.length), 16) ));
				}
			
				var stack = [e],
					ls = 0,
					ds = 0;
			
				while (stack.length !== 0) {
					var node = stack.shift(),
						ch = node.entityChildren,
						n = node.entityChildren.length;
					
					for (var i=0; i<n; i++) {
						var child = ch[i];
						if (child.deleted)	continue;
						
						var rect = rectIntersection(s, child.size);
						if (child.entityChildren === undefined) {
							if (!isNaN(rect.w)) {
								if (ct.isBrightColor( parseInt(child.color.substring(1, child.color.length), 16) )) {
									ls += rect.w * rect.h;
								} else {
									ds += rect.w * rect.h;
								}
							}
						} else {
							if (!isNaN(rect.w)) {
								stack.push(child);
							}
						}
					}
				}
				
				if(ls > ds){
					return '#000000';
				} else {
					if (level === 1) {
						return '#e6e7e8';
					} else {
						return '#d1d3d4';
					}
				}
			},
			
			getEntity: function (pos) {
				var ox = pos.x,
					oy = pos.y,
					target;
					
				var hitTest = function (node) {
					if (node.entityChildren === undefined && !node.deleted && node.size) {
						var size = node.size,
							x1 = size.x,
							y1 = size.y,
							x2 = x1 + size.w,
							y2 = y1 + size.h;
						
						if (ox >= x1 && ox <= x2 && oy >= y1 && oy <= y2) {
							target = node;
						}
					}
				};
				
				var dfsReturnOnFound = function (root, f) {
					if(root.deleted) {
						return;
					}
					
					f(root);
					
					var arr = root.entityChildren;
					if (arr !== undefined) {
						var l = arr.length;
						for (var i = 0; i < l; i++) {
							var e = arr[i];
							dfsReturnOnFound(e, f);
							if (target !== undefined) {
								return;
							}
						}
					}
				};
				
				dfsReturnOnFound(this.root, hitTest);
				
				return target;
			},
			
			initCSSATTR: function () {
				if (CSSATTR.init === false) {
					var dom = this.domSpan;
					for (var css in CSSATTR) {
						if (css === 'init')	continue;
						dom.setAttribute('class', css);
						var res = document.defaultView.getComputedStyle(dom);
						CSSATTR[css].fontSize = parseInt(res['fontSize']);
						CSSATTR[css].font = res['fontFamily'];
					}
				}
			},
			
			getTextSize: function (str, fontName, fontSize, isBold, isItalic, width, normalBreak) {
				var dom = this.domSpan,
                    breakMethod = 'break-all';
                if (normalBreak) {
                        breakMethod = 'normal';
                }

                dom.className = '';
				dom.innerHTML = str;
				dom.style.cssText = "position:absolute; visibility:hidden; z-index:-1; font-family:" + fontName + 
				"; font-size:" + fontSize + "px; font-weight:" + (isBold ? 'bold' : 'normal') + 
				"; font-style:" + (isItalic ? 'italic' : 'normal') + "; line-height:" + fontSize + "px;";
				
				var w = dom.offsetWidth;
				if (width !== undefined && w > width) {
					dom.style.cssText += "overflow:hidden; word-break:" + breakMethod + "; width:" + width + "px;";
					w = dom.offsetWidth;
				}
				
				return {w: w, h: dom.offsetHeight};
			}
		}
	);

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._Formattable",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.hash");

    
    mstrmojo.android.HTMLContainer = mstrmojo.declare(
        mstrmojo.Widget,

        
        [ mstrmojo._Formattable, mstrmojo._HasTouchScroller, mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.HTMLContainer",

            markupString:   '<div id="{@id}" class="mstrmojo-HTMLContainer {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div>{@v}</div>' +
                            '</div>',

            markupSlots: {
                valueNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode:  [ 'RW', 'B', 'F', 'P', 'background-color', 'fx', 'text-align', 'white-space' ]
            },

            
            update: function update(node) {
                var d = node.data,
                    v = d.v || '';

                
                var div = document.createElement('div');
                div.innerHTML = '<textarea>' + v + '</textarea>';
                v = '<div style="display:none">&nbsp;</div>' + div.firstChild.value + '&nbsp;';     

                
                div = null;

                
                this.v = v;
                
                
                if (this.thresholdId || d.tid) {
                	
                	delete this.fmts;
                }

                
                this.thresholdId = d.tid;

                
                this.scrollerConfig = {
                    bounces: false,
                    showScrollbars: false
                };
            },

            
            postBuildRendering: function postBuildRendering() {

                
                var scripts = this.domNode.getElementsByTagName('script'),
                    len = scripts.length,
                    i;

                for (i = 0; i < len; i++) {
                    
                    eval(scripts[i].innerHTML);
                }

                return this._super();
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    scrollEl = this.valueNode,
                    domNode = this.domNode,
                    fmts = this.getFormats(),
                    iterator = {
                        'Height': {
                            a: 'y',
                            s: 'v'
                        },
                        'Width': {
                            a: 'x',
                            s: 'h'
                        }
                    },
                    offset = {};

                
                cfg.scrollEl = scrollEl;

                mstrmojo.hash.forEach(iterator, function (info, dimension) {
                    
                    if (cfg['no' + info.s.toUpperCase() + 'Scroll']) {   
                        
                        return;
                    }

                    
                    var widgetSize = parseInt(fmts[dimension.toLowerCase()], 10);

                    
                    if (isNaN(widgetSize)) {
                        
                        widgetSize = domNode['client' + dimension];
                    }

                    
                    var offsetEnd = Math.max(scrollEl['offset' + dimension] - widgetSize, 0),
                        enableDimensionScroll = cfg[info.s + 'Scroll'] = (offsetEnd !== 0);

                    
                    if (enableDimensionScroll) {
                        
                        offset[info.a] = {
                            start: 0,
                            end: offsetEnd
                        };
                    }
                });

                
                cfg.offset = offset;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                return cfg;
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android.selectors._SupportsHoriz",
                         "mstrmojo.color",
                         "mstrmojo.css");

    
    function getItemRenderMethod(isSelected) {
        return function (el, item, idx, widget) {
            
            var style = el.style,
                clsMethod = 'remove',
                bgColor = 'transparent',
                color = 'inherit';

            
            if (isSelected) {
                
                clsMethod = 'add';
                bgColor = widget.selColor;
                color = widget._txtColor;
            }

            
            style.backgroundColor = bgColor;
            style.color = color;

            
            mstrmojo.css[clsMethod + 'Class'](el, mstrmojo.android._IsList.SELECTED_CLS);
        };
    }

    
    mstrmojo.android.selectors.LinkBar = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList, mstrmojo._HasTouchScroller, mstrmojo.android.selectors._SupportsHoriz ],

        
        {
            scriptClass: "mstrmojo.android.selectors.LinkBar",

            
            selColor: '#60b1f6',

            minItemHeight: 29,

            getItemMarkup: function (item) {
                var itemMarkup = this._itemMarkup;
                if (!itemMarkup) {
                    
                    this._itemMarkup = itemMarkup = this._super(item).replace('{@n}', '<div>{@n}<div style="background-color:' + (this.parent.getFormats().color || '#000') + ';"></div></div>');
                }

                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx);

                
                if (props.sel) {
                    
                    props.style += 'color:' + this._txtColor + ';background-color:' + this.selColor + ';';
                }

                return props;
            },

            preBuildRendering: function preBuildRendering() {
                
                this.cssClass += ' selector-linkbar';

                
                this._txtColor = mstrmojo.color.getContrastingColor(this.selColor, ['#ffffff', '#000000']);

                return this._super();
            }
        }
    );

    var linkBar = mstrmojo.android.selectors.LinkBar.prototype,
        itemRenderer = linkBar.itemRenderer;

    
    linkBar.itemRenderer = {
        render: itemRenderer.render,
        select: getItemRenderMethod(true),
        unselect: getItemRenderMethod(false)
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $A = mstrmojo.array,
        $CSS = mstrmojo.css,
        $D = mstrmojo.dom,
        FirstMonthIdx = 1,
        SELECTED_CSS_CLASS = 'selected',
        HTML_ATTR_DAY = 'd',
        HTML_ATTR_MONTH = 'm',
        HTML_ATTR_YEAR = 'y';

    function processSelectedDate(node, d, m, y) {
        var i,
            sel = this.selected = this.selected || [],
            date;

        for (i = 0; i < sel.length; i++) {
            date = sel[i];
            if (date.day === d && date.month === m && date.year === y) {
                sel.splice(i, 1);
                return false;
            }
        }

        
        var newItem = {
            node: node,
            day: d,
            month: m,
            year: y
        };
        newItem.n = mstrmojo.date.formatDateInfo(newItem, mstrmojo.locales.datetime.DATEOUTPUTFORMAT);
        sel.push(newItem);

        return true;
    }
    
    function updateMonthViewHTML(y) {
        this.contentNode.innerHTML = this.markupBuilder.getContentHTML({
            m: 0, 
            y: y
        }, {
            m: 11,
            y: y
        }, {
            incl: false
        });
    }
    
    function updateItemsSelection(optionalItems, add) {
        var monthsHTML = this.contentNode.children,
        datesHTML;
    
        $A.forEach(optionalItems || this.selected, function(item) {
            
            if (item && item.year === this.current.y) {
                var selectedDateObj = new Date(item.year, item.month - FirstMonthIdx, 1);
                
                $A.forEach(monthsHTML, function(monthNode) {
                    if (parseInt(monthNode.getAttribute(HTML_ATTR_MONTH), 10) === item.month) {
                        $CSS.toggleClass(monthNode.getElementsByClassName('mstrmojo-CalendarMV-DatesList')[0].children[item.day + (selectedDateObj.getDay()) - 1], SELECTED_CSS_CLASS, add);
                        return false;
                    }
                });
            }
            
            datesHTML = undefined;
        }, this);
    }
    
    
    function scrollToMonth(m, oldM) {
        var monthCache = this.MONTH_CACHE,
            current = monthCache[parseInt(m, 10)],
            prev = monthCache[parseInt(oldM, 10)],
            SELECTED_MONTH_CSS_CLASS = 'selectedMonth';
        
        if (oldM !== undefined) {
            $CSS.toggleClass(prev.node, SELECTED_MONTH_CSS_CLASS, false);
        }
        
        $CSS.toggleClass(current.node, SELECTED_MONTH_CSS_CLASS, true);
        
        
        if (this._scroller) {
            this._scroller.scrollTo(0, current.top, 200);
        }
        
        
        if (!(mstrApp.isTablet() && mstrApp.isLandscape())) {
            this.headerNode.innerHTML = this.markupBuilder.getHeaderHTML(m, this.current.y);
        }
    }
    
    
    function updateCurrentYear(year, month) {
        
        updateMonthViewHTML.call(this, this.current.y);
        
        
        this.updateScroller();
    
        
        var i = 0,
            h = parseInt(this.height, 10) - this.headerNode.clientHeight, 
            contentNode = this.contentNode,
            rootOffsetTop = contentNode.offsetTop,
            children = contentNode.children,
            selected = this.selected,
            yearSelected = $A.find(selected, 'year', year),
            hasSelected = yearSelected !== -1, 
            monthCache = this.MONTH_CACHE = [{}];
        
        for (i = 0; i < children.length - 1; i ++) {
            var node = children[i],
                nodeHeight = node.clientHeight;
            
            monthCache.push({
                node: node,
                top: node.offsetTop - rootOffsetTop - (h - nodeHeight) / 2,
                height: nodeHeight
            });
        }
        
        
        this._scroller.scrollTo(0, 0);
        
        
        scrollToMonth.call(this, month || (hasSelected && selected[yearSelected].month) || FirstMonthIdx);
        
        this.selectItems();
    }
    
    
    mstrmojo.android.ui.CalendarMonthView = mstrmojo.declare(

        
        mstrmojo.Widget,

        
        [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

        
        {
            scriptClass: "mstrmojo.android.ui.CalendarMonthView",

            config: undefined,

            markupString: '<div id="{@id}" class="mstrmojo-Calendar-MonthView">' +
                              '<div class="mstrmojo-CalendarMV-Header"></div>' +
                              '<div class="mstrmojo-CalendarMV-Content">' + 
                                  '<div></div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                headerNode: function () { return this.domNode.firstChild; },
                contentNode: function () { return this.domNode.lastChild.lastChild; }
            },

            
            range: undefined,

            
            selected: undefined,

            
            multiSelect: true,

            
            current: undefined,
            
            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                showIndicators: false
            },

            postCreate: function postCreate() {
                
                if (this._super) {
                    this._super();
                }

                var calMonthWidget = this,
                    initialYear = this.initialYear,
                    initialMonth = this.initialMonth;
                
                if (isNaN(initialMonth) || isNaN(initialYear)) {
                    throw new Error(mstrmojo.desc(96, 'Error'));
                }
                
                
                this.current = new mstrmojo.Obj({
                    m: initialMonth,
                    y: initialYear,
                    
                    onyChange: function onyChanged() {
                        updateCurrentYear.call(calMonthWidget, this.y);
                    },
                    
                    _set_m: function _set_m(n, v) {
                        var valueWas = this.m;
                        
                        
                        this.m = v;
                        
                        scrollToMonth.call(calMonthWidget, this.m, valueWas);
                    }
                });
            },

            postBuildRendering: function postBuildRendering() {
                var builder = this.markupBuilder,
                    current = this.current;

                
                this._super();

                
                this.headerNode.innerHTML = builder.getHeaderHTML(current.m, current.y);
                
                
                updateCurrentYear.call(this, current.y, current.m);
                
                
                this._scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    var monthCache = this.MONTH_CACHE,
                        abs = Math.abs,
                        scrolledPos = evt.y,
                        curr,
                        next,
                        newIdx,
                        i;
                    
                    
                    for (i = 1; i < monthCache.length - 1; i ++) {
                        curr = monthCache[i].top;
                        next = monthCache[i + 1].top;
                        
                        
                        if ((curr <= scrolledPos) && (scrolledPos <= next)) {
                            
                            newIdx = i + ((abs(next - scrolledPos) < abs(curr - scrolledPos)) ? 1 : 0);
                            
                            
                            break;
                        }
                    }
                    
                    this.current.set('m', newIdx);
                });
            },

            touchTap: function touchTap(touch) {
                
                var monthObj = $D.findAncestorByAttr(touch.target, HTML_ATTR_MONTH, true, this.domNode);
                
                if (monthObj) {
                    var item = touch.target,
                        d = parseInt(item.getAttribute(HTML_ATTR_DAY), 10),
                        m = parseInt(monthObj.value, 10),
                        y = parseInt(monthObj.node.getAttribute(HTML_ATTR_YEAR), 10);

                    if (!isNaN(d)) {
                        if (this.singleSelect) {
                            $A.forEach(this.selected, function(date) {
                                $CSS.toggleClass(date.node, SELECTED_CSS_CLASS, false);
                            });

                            this.selected = [];
                        }

                        $CSS.toggleClass(item, SELECTED_CSS_CLASS, processSelectedDate.call(this, item, d, m, y));
                        
                        this.raiseEvent({
                            name: 'selectionChanged',
                            items: this.selected
                        });
                    }
                    
                    if (!isNaN(m)) {
                        this.current.set('m', m);
                    }
                }
                
                
                return false;
            },
            
            
            selectItems: function selectItems(newItems) {
                updateItemsSelection.call(this, newItems, true);
            },
            
            unselectItems: function unselectItems(removedItems) {
                updateItemsSelection.call(this, removedItems, false);
            },
            
            touchSelectBegin: function touchSelectBegin(touch) {
            },

            touchSelectMove: function touchSelectMove(touch) {
            },

            touchSelectEnd: function touchTap(touch) {
            },
            
            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    icn = this.contentNode,
                    h = parseInt(this.height, 10);

                
                if (isNaN(h)) {
                    
                    h = this.domNode.clientHeight;
                }

                
                cfg.scrollEl = icn;

                
                cfg.noHScroll = true;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                
                var offsetIdx = cfg.offsetIdx;
                if (offsetIdx) {
                    
                    delete cfg.offsetIdx;

                    
                    cfg.origin.y = this.getItemOffset(offsetIdx);
                }

                
                var offsetEnd = Math.max(icn.clientHeight + this.headerNode.clientHeight - h, 0);

                
                var enableScroll = cfg.vScroll = offsetEnd !== 0;
                if (enableScroll) {
                    
                    cfg.offset = {
                        y: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                } else {
                    
                    cfg.offset = null;
                }

                return cfg;
            },
            
            destroy: function destroy() {
                
                if (this.current) {
                    this.current.destroy();
                    delete this.current;
                }
                
                
                delete this.MONTH_CACHE;
                
                this._super();
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.Container",
                         "mstrmojo.ListBase",
                         "mstrmojo.android._IsList",
                         "mstrmojo.android._IsIncFetchList",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller");
    
    var $A = mstrmojo.array,
        $HC = mstrmojo.hash.copy,
        EDGES_ENUM = mstrmojo.TouchScroller.EnumIncFetchEdges,
        EDGE_START = EDGES_ENUM.start,
        INC_FETCH_SIZE = 50,
        BUFFER_SIZE = 20,
        NO_DELAY = false;
    
    
    function createIncFetchDataHelper(start, end) {
        
        if (this.end === null || isNaN(this.end) || this.start === null || isNaN(this.start)) {
            this.ifDirection = 'h';
            
            
            this.supportedEdges = 0;
            $A.forEach(['start', 'end'], function (edge) {
                this.supportedEdges += isNaN(this[edge]) ? EDGES_ENUM[edge] : 0;
            }, this);
            
            var $this = this,
                i;
            
            
            this.ifDataHelper = new mstrmojo.Obj({
                totalSize: -1,
                
                next: function next(callbacks, edge) {
                    
                    var evtItems = [],
                        adjustedIndex = -1;
                    
                    
                    evtItems = evtItems.concat($this.items);
                    
                    if (edge === EDGE_START) {
                        for (i = 0; i < INC_FETCH_SIZE; i ++) {
                            evtItems.splice(0, 0, {
                                n: --start
                            });
                        }
                        
                        
                        evtItems = evtItems.splice(0, INC_FETCH_SIZE + BUFFER_SIZE);
                        
                        
                        end = start + INC_FETCH_SIZE + BUFFER_SIZE - 1;
                        
                        
                        adjustedIndex = INC_FETCH_SIZE;
                    } else {
                        
                        for (i = 0; i < INC_FETCH_SIZE; i ++) {
                            evtItems.push({
                                n: ++end
                            });
                        }
                        
                        
                        evtItems = evtItems.splice(evtItems.length - INC_FETCH_SIZE - BUFFER_SIZE);
                        
                        
                        start = end - INC_FETCH_SIZE - BUFFER_SIZE;
                        
                        
                        adjustedIndex = BUFFER_SIZE - 3;
                    }
                    
                    
                    $this.set('items', evtItems);
                    
                    window.setTimeout(function() {
                        
                        NO_DELAY = true;
                        
                        
                        $this.singleSelect(adjustedIndex);
                    }, 0);
                    
                    
                    callbacks.success({
                        items: undefined
                    });
                }
            });
        }
    }
    
    
    mstrmojo.android.ui.CalendarYearList = mstrmojo.declare(

        
        mstrmojo.ListBase,

        
        [ mstrmojo.android._IsList, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo.android._IsIncFetchList ],
        
        
        {
            scriptClass: "mstrmojo.android.ui.CalendarYearList",
            
            
            years: undefined,
            
            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                scrollPast: true
            },
            
            getItemMarkup: function (item, idx) {
                return '<{@tag} class="item {@cls}" idx="{@idx}" style="{@style}">' +
                           '<span>{@n}</span>' +
                           '<div class="marker"></div>' +
                       '</{@tag}>';
            },
            
            postCreate: function postCreate(props) {
                
                if (this._super) {
                    this._super();
                }
                
                var start = (this.start) || (new Date(0)).getFullYear(),
                    end = (this.end) || ((new Date()).getFullYear() + 5),
                    current = start,
                    items = this.items = this.items || [];
                
                
                while (end >= current) {
                    items.push({
                        n: current++
                    });
                }
                
                
                createIncFetchDataHelper.call(this, start, end);
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                
                var width = this.ITEMS_NODE_WIDTH = this.itemsNode.clientWidth;
                
                
                this.updateScroller();
                
                
                this.singleSelectByField(this.initialYear, 'n');
                
                this._scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    
                    var fraction = (evt.x + (parseInt(this.width, 10) - width)/2) / width,
                        intVal = Math.floor(fraction),
                        newIdx = intVal;
                    
                    
                    newIdx += ((fraction - intVal) > 0.3) ? 1 : 0;
                    
                    
                    if (newIdx !== this.selectedIndex) {
                        
                        this.singleSelect(newIdx);
                    } else {
                        
                        this.onchange();
                    }
                    
                });
            },
            
            
            onchange: function() {
                var idx = this.selectedIndex;
                
                if (idx >= 0) {
                    var itemWidth = this.ITEMS_NODE_WIDTH,
                        scrollToPos = (idx * itemWidth) - (parseInt(this.width, 10) - itemWidth)/2;

                    
                    this._scroller.scrollTo(scrollToPos, undefined, NO_DELAY ? 0 : 200);
                    
                    
                    this.raiseEvent({
                        name: 'yearChanged',
                        value: this.selectedItem.n
                    });
                    
                    
                    NO_DELAY = false;
                }
            },
            
            
            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    icn = this.itemsContainerNode,
                    w = parseInt(this.width, 10);

                
                if (isNaN(w)) {
                    
                    w = this.domNode.clientWidth;
                }

                
                cfg.scrollEl = icn;

                
                cfg.noVScroll = true;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                
                var offsetEnd = Math.max(icn.clientWidth - w, 0),
                    
                    enableScroll = cfg.hScroll = (offsetEnd !== 0);
                
                
                if (enableScroll) {
                    cfg.offset = {
                        
                        
                        x: $HC({
                            start: 0,
                            end: offsetEnd
                        }, cfg.offset && cfg.offset.x)
                    };
                    
                } else {
                    cfg.offset = undefined;
                }
                
                return cfg;
            },
            
            
            destroy: function destroy() {
                if (this.ifDataHelper) {
                    this.ifDataHelper.destroy();
                    delete this.ifDataHelper;
                }
                
                this._super();
            }
            
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsPanelStack",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.TouchScroller",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        $M = Math,

        SWITCH_DURATION = 700;

    function clearAnimationTimeout() {
        
        var handle = this._animHandle;
        if (handle) {
            
            window.clearTimeout(handle);
            delete this._animHandle;
        }
    }

    function clearAnimationFlag() {
        
        delete this._animHandle;

        
        this._isAnimating = false;
    }

    
    function applyTransform(duration, value, force, simulateEvt) {
        
        var lastValue = this._translateX;
        if (force || value !== lastValue) {




            
            this._translateX = value;

            
            clearAnimationTimeout.call(this);

            
            if (duration) {
                
                this._isAnimating = true;
            }

            
            var nodeStyle = this.containerNode.style;
			nodeStyle[$DOM.CSS3_TRANSITION_DURATION] = duration + 'ms';
			nodeStyle[$DOM.CSS3_TRANSFORM] = $DOM.createTranslateString(-value);

            
            if (simulateEvt) {
                var id = this.id;
                this._animHandle = window.setTimeout(function () {
                    
                    var w = mstrmojo.all[id];

                    
                    if (mstrmojo.all[id]._isAnimating) {

                        
                        clearAnimationFlag.call(w);
                    }
                }, duration * 3);
            }

            if (this._scroller) {
                this._scroller.raiseEvent({
                    name: 'transformAnim',
                    x: value,
                    y: 0
                });
            }
        }
    }

    
    function renderSelector() {
        
        if (!this.defn.dk) {
            return;
        }
        var panels = this.children,
            i = 0,
            cnt = panels.length,
            selectedIdx = this.selectedIdx,
            btnMarkup = [];

        
        for (i = 0; i < cnt; i++) {
            
            btnMarkup.push('<div idx="' + i + '" class="');

            
            if (i === selectedIdx) {
                btnMarkup.push('on');
            }

            
            btnMarkup.push('"><div></div></div>');
        }

        
    	var selectorBtnsNode = this.selectorBtns,
    		dpi = mstrMobileApp.getDeviceDPI();

		
    	
		var tabWidths = {
				160:	26,
				213:	26,
				240:	38,
				320:	57
			},
			btnWidth = tabWidths[dpi] || ( tabWidths[160] * dpi / 160 );  
		
        selectorBtnsNode.style.width = (cnt * btnWidth) + 'px';

        
        selectorBtnsNode.innerHTML = btnMarkup.join('');

        
        this.selector.style.display = 'block';
    }

    
    mstrmojo.android.DocPanelStack = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._Formattable, mstrmojo._IsSelectorTarget, mstrmojo._HasBuilder, mstrmojo._HasTouchScroller, mstrmojo._IsPanelStack, mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.DocPanelStack",

            btnMarkup: '',

            markupString: '<div id="{@id}" title="{@tooltip}" class="mstrmojo-DocPanelStack {@cssClass}" style="{@domNodeCssText}">' +
                            '<div></div>' +
                            '<div class="mstrmojo-PanelSelector">' +
                                '<div class="mstrmojo-SelectorBtns"></div>' +
                            '</div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; },
                selector: function () { return this.domNode.lastChild; },
                selectorBtns: function () { return this.domNode.lastChild.firstChild; }
            },

            formatHandlers: {
                domNode: [ 'RW', 'B' ]
            },

            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                vScroll: false,
                hScroll: true
            },

            
            addChildren: function addChildren(panels, idx, silent) {

                this._super(panels, idx, silent);

                var containerNodeStyle = this.containerNode.style,
                    formats = this.getFormats(),
                    width = this._pnlWidth = parseInt(formats.width, 10),
                    height = parseInt(formats.height, 10),
                    selectedIdx = this.selectedIdx;

                
                var newPosition = this.selectedIdx * width;

                
                containerNodeStyle.width = (width * panels.length) + 'px';

                
                if (!$DOM.isWinPhone) {
                    applyTransform.call(this, 0, newPosition);
                } else {
                    containerNodeStyle.msTransform = newPosition;
                }

                
                var i = 0,
                    cnt = panels.length;

                for (i = 0; i < cnt; i++) {
                    var panel = panels[i];

                    
                    panel.visible = true;

                    
                    panel.selected = (i === selectedIdx);

                    
                    panel.updatePanelDimensions(i * width, height, width);
                }

                
                renderSelector.call(this);

                
                this.updateScroller();

                return true;
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                
                renderSelector.call(this);

                
                var id = this.id;
                mstrmojo.dom.attachEvent(this.containerNode, $DOM.CSS3_TRANSITION_END, function (evt) {

                    var widget = mstrmojo.all[id];
                    if (evt.target !== widget.containerNode) {
                        return true;
                    }





                    
                    clearAnimationTimeout.call(widget);

                    
                    evt.stopPropagation();

                    
                    clearAnimationFlag.call(widget);

                    return false;
                });

                return true;
            },

            
            setInfoWindowDimensions: function setInfoWindowDimensions(d) {
                
                var parent = this.parent;
                if (parent.scriptClass === 'mstrmojo.DocPortlet') {
                    
                    parent.setInfoWindowDimensions(d);
                }

                var h = d.h,
                    w = d.w,
                    domNodeStyle = this.domNode.style,
                    panels = this.children,
                    len = panels.length,
                    px = 'px',
                    i;

                
                domNodeStyle.height = h + px;
                domNodeStyle.width = w + px;

                
                this.containerNode.style.width = (w * len) + px;

                
                this._pnlWidth = w;

                
                this._translateX = (this.selectedIdx || 0) * w;

                
                for (i = 0; i < len; i++) {
                    
                    panels[i].updatePanelDimensions(i * w, h, w, true);
                }

                
                this.updateScroller();
            },

            getTitle: function getTitle() {
                
                return this.title;
            },

            
            initScroller: function initScroller(scroller) {
                
                scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    
                    this._translateX = evt.x;
                });
            },

            
            updateScrollerConfig: function updateScrollerConfig() {
                var children = this.children,
                    length = children && children.length,
                    cfg = this._super();

                
                cfg.noVScroll = true;

                
                if (length) {
                    var position = this._translateX || 0,
                        width = this._pnlWidth,
                        offset;

                    
                    offset = {
                        start: $M.max(position - width, 0),                                      
                        end: $M.min(position + width, length * width - width)                    
                    };

                    
                    mstrmojo.hash.copy({
                        scrollEl: this.containerNode,

                        offset: {
                            x: offset,
                            scrollPast: false
                        },

                        origin: {
                            x: position,
                            y: 0
                        }
                    }, cfg);
                }

                return cfg;
            },

            onselectedIdxChange: function onselectedIdxChange(evt) {
                var selector = this.selectorBtns,
                    buttons = selector && selector.childNodes;

                
                if (buttons) {
                    
                    $CSS.addClass(buttons[evt.value], 'on');
                    $CSS.removeClass(buttons[evt.valueWas], 'on');
                }
            },

            
            onselectedKeyChange: function onselKeyChg(evt) {

                this._super(evt);

                
                var width = this._pnlWidth,
                    position = this.selectedIdx * width;

                
                if ($DOM.isWinPhone) {
                    
                    var containerNode = this.containerNode;
                    containerNode.style.position = 'relative';

                    
                    (new mstrmojo.fx.AnimateProp({
                        props: {
                            left: {
                                isStyle: true,
                                start: position,
                                stop: this.prevSelectIdx * width,
                                suffix: 'px',
                                ease: mstrmojo.ease.linear
                            }
                        },
                        duration: 0,
                        target: containerNode
                    })).play();

                } else {
                    
                    applyTransform.call(this, 0, position);
                }

                
                this.updateScroller(true);
            },

            touchBegin: function touchBegin(touch) {
                
                if (this._isAnimating) {
                    
                    touch.stop();





                    
                    return false;
                }

                
                if (!this.defn.sw && !$DOM.contains(this.selector, touch.target, true, this.domNode)) {
                    
                    return false;
                }





                return this._super(touch);
            },

            touchTap: function touchTap(touch) {
                var target = touch.target,
                    domNode = this.domNode;

                
                if ($DOM.contains(this.selector, target, true, domNode)) {
                    var selectorBtnsNode = this.selectorBtns,
                        panelIdx = -1;

                    
                    if ($DOM.contains(selectorBtnsNode, target, true, domNode)) {
                        
                        panelIdx = $DOM.findAncestorByAttr(target, 'idx', true, selectorBtnsNode).value;
                    } else {
                        
                        panelIdx = this.selectedIdx + ((touch.clientX - domNode.offsetLeft < (this._pnlWidth / 2)) ? -1 : 1);
                    }

                    
                    if (panelIdx > -1) {
                        
                        var panel = this.children[panelIdx];
                        if (panel) {
                            
                            this.selectPanel(panel.k);
                        }
                    }
                } else {
                    
                    var ctrl = this.controller;
                    if (ctrl && ctrl.viewTap) {
                        
                        ctrl.viewTap();
                    }
                }
            },

            touchSwipeBegin: function touchSwipeBegin(touch) {




                
                if (this.defn.sw || $DOM.contains(this.selector, touch.target, true, this.domNode)) {
                    return this._super(touch);
                }

                
                return this.bubbleTouchEvent(touch);
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                
                touch.evt.handled = true;

                
                mstrmojo.TouchScroller.ScrollIndicators.hideAll();

                var x = this._translateX || 0,
                    width = this._pnlWidth,
                    offset = this._scroller.offset.x,                                           
                    position = $M.max($M.min(x - touch.delta.x, offset.end), offset.start),     
                    delta = x - position,                                                       
                    absDelta = $M.abs(delta),                                                   
                    duration = SWITCH_DURATION,
                    isRevertAction = (absDelta < width * 0.2);

                
                if (isRevertAction) {
                    
                    position = x;
                    duration *= absDelta / width;
                } else {
                    
                    position = x + ((delta < 0) ? width : -width);
                    duration *= (width - absDelta) / width;
                }





                
                applyTransform.call(this, $M.round(duration), position, true, isRevertAction);
                
                this.selectPanel(this.children[position / width].k, true);
            }
        }
    );

}());
(function () {
        mstrmojo.requiresCls("mstrmojo._HasTouchScroller",
                             "mstrmojo.dom");

        var $D = mstrmojo.dom;

        function rectIntersection(a, b) {
                var x = Math.max(a.x, b.x);
                var y = Math.max(a.y, b.y);
                var w = Math.min(a.x + a.w, b.x + b.w) - x;
                var h = Math.min(a.y + a.h, b.y + b.h) - y;
                if (w < 0 || h < 0) {
                        return {
                                x : NaN,
                                y : NaN,
                                w : NaN,
                                h : NaN
                        };
                }
                return {
                        x : x,
                        y : y,
                        w : w,
                        h : h
                };
        }

        function copyRect (a){
                return {x: a.x, y: a.y, w: a.w, h: a.h};
        }

        mstrmojo.SmoothScroll = mstrmojo.provide(
                
                
                "mstrmojo.SmoothScroll",
                {

                        
                        
                        viewRect: null,
                        
                        scrollerRect: null,

                        
                        unitRect: null,

                        cachedUnits: [],

                        demarcationUnits: {left: null, right: null, top: null, bottom: null},

                        
                        viewCutX: function(){
                        },

                        storeUnits: function() {
                                this.cachedUnits = [];
                                var ir = copyRect(this.unitRect),
                                    len = Math.ceil(this.scrollRect.h / ir.h),
                                    i;

                                for(i = 0; i < len; i++, ir.y += ir.h){
                                        
                                        var unit = this.getUnitFromPoint(ir.x + ir.w/2, ir.y+ir.h/2);
                                        if(!unit){
                                                continue;
                                        }
                                        this.cachedUnits.push(unit);
                                        
                                }
                        },

                        appendUnits: function(i1, i2) {
                                var cus  = this.cachedUnits,
                                    i;
                                for(i = i1; i <= i2; i++){
                                        var unit = cus[i];
                                        if(!unit){
                                                return ;
                                        }
                                        if(unit.outside == true){
                                                unit.outside = false;
                                                var p = unit._parentNode,
                                                    cn = p.children;
                                                p.insertBefore(unit, cn[unit._oldIndex]);
                                                p.style.paddingTop = '';
                                                delete unit._parentNode;
                                                delete unit._oldIndex;
                                        }
                                }
                                console.log(i2-i1+1 + ' units added.');
                        },
                        removeUnits: function(i1, i2) {
                                var cus  = this.cachedUnits,
                                    i;
                                for(i = i1; i <= i2; i++){
                                        var unit = cus[i];
                                        if(!unit){
                                                return ;
                                        }
                                        if(unit.outside != true){
                                                var p = unit.parentNode,
                                                    cn = p.children;
                                                unit._parentNode = p;
                                                
                                                unit._oldIndex = 0;
                                                p.removeChild(unit);
                                                p.style.paddingTop = this.unitRect.h + 'px';
                                                unit.outside = true;
                                        }
                                }
                                console.log(i2-i1+1 + ' units removed.');
                        },
                                    

                        
                        viewCutY: function(e) {
                                if(!this.viewRect || !this.scrollRect || !this.unitRect){
                                        return;
                                }
                                var y1 = e ? e.y : this._scroller.origin.y,
                                    y2 = y1 + this.viewRect.h;
                                if(!this._scroller || !this._scroller.scrollEl){
                                        console.log("no scrollEl.");
                                        return ;
                                }

                                var scrollEl = this._scroller.scrollEl;

                                var i1 = Math.floor(y1 / this.unitRect.h),
                                    i2 = Math.floor(y2 / this.unitRect.h),
                                    cus = this.cachedUnits,
                                    len = cus.length;
                                    delta = 0;
                                this.removeUnits(0,i1-1);
                                
                                this.appendUnits(i1,i2);
                                this.removeUnits(i2+1, len);
                                
                                delta = i1;
                                
                                console.log("do viewCut.");
                        },

                        updateScroller: function(o, d) {
                                if(this._super){
                                        this._super(o, d);
                                }
                                var $P = mstrmojo.dom.position;
                                if(!this.unitRect || !this.unitRect.w || !this.unitRect.h){
                                        var su = this.cachedUnits[0];
                                        if(!su){
                                                return ;
                                        }
                                        this.unitRect =  $P(su);
                                }
                                if(this.viewNode){
                                        this.viewRect = $P(this.viewNode);
                                }
                                this.scrollRect = {x: this.unitRect.x, y: this.unitRect.y, w: this.unitRect.w, h:this.unitRect.h * this.cachedUnits.length}; 
                                if(!this.viewRect || !this.scrollRect || !this.unitRect){
                                        return;
                                }
                                
                                this.viewCutY(this._scroller.origin);
                        },
                        

                        getUnitFromPoint: function (x, y) {
                                var cache = [],
                                    found = false;
                                do{
                                        var target = document.elementFromPoint(x,y);
                                        if(target == lastTarget){
                                                break;
                                        }
                                        if(target.offsetHeight == this.unitRect.h && target.offsetWidth == this.unitRect.w){
                                                found = true;
                                        }else{
                                                target.__metaDisplay = target.style.display;
                                                cache.push(target);
                                                target.style.display = 'none';
                                        }
                                        var lastTarget = target;
                                }while(!found && target != document.body);
                                
                                var ret = target;
                                
                                while(cache.length){
                                        var target = cache.pop();
                                        target.style.display = target.__metaDisplay;
                                        delete target.__metaDisplay;
                                }

                                if(found){
                                        return ret;
                                }else{
                                        return null;
                                }
                        },

                        
                        postBuildRendering: function(c) {
                                if(this._super){
                                        this._super(c);
                                }
                                console.log("event binded!");
                                this.smoothSwipeListener = this._scroller.attachEventListener("scrollMoved", this.id, this.viewCutY);
                        },

                        unrender: function () {
                                
                                if(this._super){
                                        this._super();
                                }
                        }






                        










                }
        );
        
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android.selectors._SupportsHoriz",
                         "mstrmojo.css");

    var itemMarkup,
        LINE_REG_EXP = /line-height:(\d*)px/,
        $CSS = mstrmojo.css;
    
    
    function toggleGlow(doGlow) {
        
        if (this.parent.defn.ct !== '4') {
            
            return;
        }

        mstrmojo.css[((doGlow) ? 'add' : 'remove') + 'Class'](this.domNode, 'glow');
    }

    
    mstrmojo.android.selectors.ButtonBar = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList, mstrmojo._HasTouchScroller, mstrmojo.android.selectors._SupportsHoriz ],

        
        {
            scriptClass: "mstrmojo.android.selectors.ButtonBar",

            cssClass: 'selector-btnbar',

            getItemMarkup: function getItemMarkup(item) {
                if (!itemMarkup) {
                    itemMarkup = this._super(item).replace('{@n}', '<div>{@n}</div>');
                }

                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx),
                    style = props.style,
                    lineHeight = style.match(LINE_REG_EXP);

                
                if (lineHeight) {
                    
                    props.style = style.replace(LINE_REG_EXP, 'line-height:' + (parseInt(lineHeight[1], 10) - 2) + 'px');
                }

                return props;
            },
            
            touchBegin: function touchBegin() {
                toggleGlow.call(this, true);
            },
            
            touchEnd: function touchEnd() {
                toggleGlow.call(this);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Label",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._TouchGestures");

    mstrmojo.android.TextArea = mstrmojo.declare(
        mstrmojo.Label,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        {
            scriptClass: "mstrmojo.android.TextArea",

            markupString: '<div id="{@id}" class="mstrmojo-TextArea {@cssClass}" style="{@cssText}">' +
                              '<div>{@text}</div>' +
                          '</div>',

            markupMethods: {
                ontextChange: function () { this.domNode.firstChild.innerHTML = this.text || ''; },
                oncssTextChange: function () { this.domNode.style.cssText = this.cssText || ''; },
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                onheightChange: function () { this.domNode.style.height = this.height || 'auto'; }
            },

            
            allowTouchBubble: false,

            updateScrollerConfig: function updateScrollerConfig() {

                var cfg = this._super(),
                    domNode = this.domNode,
                    scrollEl = domNode.firstChild,
                    h = parseInt(this.height, 10);

                
                if (isNaN(h)) {
                    
                    h = domNode.clientHeight;
                }

                
                cfg.bounces = false;

                
                cfg.scrollEl = scrollEl;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                
                var offsetEnd = Math.max(scrollEl.offsetHeight - h, 0);

                
                var enableScroll = cfg.vScroll = (offsetEnd !== 0);
                if (enableScroll) {
                    
                    cfg.offset = {
                        y: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                }

                return cfg;
            }
        }
    );

}());
(function(){


    mstrmojo.requiresCls("mstrmojo._HasBuilder",
                         "mstrmojo._HasLayout",
                         "mstrmojo.Container");

    var DARK_BORDER_WIDTH = 1;

    mstrmojo.maps.androidmap.AndroidDocMapInfoWindow = mstrmojo.declare(
        
        mstrmojo.Container,
        
        
        [ mstrmojo._HasBuilder, mstrmojo._HasLayout ],
        
        
        {
            scriptClass: "mstrmojo.maps.androidmap.AndroidDocMapInfoWindow",
            
            markupString: '<div class="mstrmojo-androidmap-DocInfoWindow-wrapper">' +
                              '<div id="{@id}" class="mstrmojo-androidmap-DocInfoWindow"></div>' +
                          '</div>',

            markupSlots: {
                infoNode: function() { return this.domNode.firstChild; },
                containerNode: function() { return this.domNode.firstChild; }
            },
                        
            getChildren: function getChildren(){
                
                var m = this.model,
                    c = m.getLayoutDataCache(m.getCurrentLayoutKey())[this.psId],
                    f = c.defn.fmts;
                
                
                f.left = DARK_BORDER_WIDTH + 'px';
                f.top = DARK_BORDER_WIDTH + 'px';
                
                return [c];
            }
        });

}());


(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Container",
        "mstrmojo._HasBuilder",
        "mstrmojo._Formattable",
        "mstrmojo._HasToolbar");
    
    var ELEM_SEP = "\u001E";
    
    var GD = 1;
    var GP = 2;
    
    
    var ggHelper = {
            
        TOP: 0,
        
        BOTTOM: 1,
        
        LEFT: 2,
        
        RIGHT: 3,
        
        vert: [ 'height', 'width', 'top' ],
        
        horiz: [ 'width', 'height', 'left' ],
        
        updateStyle: function (gg) {
            var qsm = gg.defn.qsm;
            if (!qsm) {
                return;
            }
            if (gg.getFormats().width) {
                return;
            }
            var child = null;
            if (qsm == GD) {
                child = gg.containerNode.firstChild; 
            }
            else {
                child = gg.containerNode.lastChild; 
            }
            if(!child){
                return;
            }
            var h = child.clientHeight + 'px';
            var w = child.clientWidth + 'px';
            
            var dnStyle = gg.domNode.style;
            dnStyle.height = h;
            dnStyle.width = w;
            
            if (gg.parent.updateStyle){
                gg.parent.updateStyle(h, w);
            }

        },
        
        repositionChildren: function (gg) {
        
            var f = gg.getFormats(),
                h = parseInt(f.height, 10),                                 
                w = parseInt(f.width, 10);                                    
        
            var ch = gg.children,
                gdf = ch[0].getFormats(),    
                gpf = ch[1].getFormats();    
            
            var isVert = (gg.defn.gp < this.LEFT),    
                x = (isVert) ? h : w,
                y = (isVert) ? w : h,
                dd = this[((isVert) ? 'vert' : 'horiz')];
            
            
            var gs = Math.round(x * (gg.defn.ga / 100));
            
            
            gdf[dd[0]] = gs + 'px';    
            gdf[dd[1]] = y + 'px';    
            
            
            gpf[dd[0]] = (x - gs) + 'px';     
            gpf[dd[1]] = y + 'px';            
            
            
            if ((gg.defn.gp % 2) === 0) {
                
                gpf[dd[2]] = gs + 'px';
            } else {
                
                gdf[dd[2]] = (x - gs) + 'px';
            }
            this.resizeChildren(ch[0], ch[1]);
        },
        stackChildren: function(gg) {
            var ch = gg.children,
            f = gg.getFormats(),
            gf;
            
            for (var i = ch.length - 1; i >= 0; i --){
              gf = ch[i].getFormats();
              gf.width = f.width;
              gf.height = f.height;
            }
            this.resizeChildren(ch[0], ch[1]);
        },
        resizeChildren: function(gd, gp) {
            
            gd.renderPortalState();

            
            var gpf = gp.getFormats();
            gp.resizeForDisplayState(parseInt(gpf.height, 10), parseInt(gpf.width, 10), true);
        },
        
        
        
        changeVisibility: function(gg, show) {
            var cd = gg.children,
                qsm = gg.defn.qsm,
                gds = show && (!qsm || gg.viewMode === GD),
                gps = show && (!qsm || gg.viewMode === GP);
            
            if(cd && cd.length > 0) {
                if (cd[0].visible !== gds) {
                    cd[0].set('visible', gds);
                }
                if (cd[1].visible !== gps){
                    cd[1].set('visible', gps);
                }
            }
            gg.visible = show;
        },
        
        
        setViewMode: function setViewMode(gg) {
            var cd = gg.children,
                vs = gg.visible;
            
            if(gg.defn.qsm && cd && cd.length > 0) {
                var ggm = gg.viewMode;
                cd[0].set('visible', (ggm == GD) && vs );
                cd[1].set('visible', (ggm == GP) && vs);
            }
        },
        
        clearFormatCache: function clearFormatCache(gg) {
            var cd = gg.children;
            for (var i = 0, len = cd && cd.length || 0; i < len; i ++) {
                cd[i].clearCache();
            }
        }
        
    };
    
    
    mstrmojo.DocGridGraph = mstrmojo.declare(
        
        mstrmojo.Container,
        
        
        [ mstrmojo._HasBuilder, mstrmojo._Formattable, mstrmojo._IsSelectorTarget],
        
        
        {
            scriptClass: "mstrmojo.DocGridGraph",
            
            markupString: '<div id="{@id}" title="{@tooltip}" class="mstrmojo-DocGridGraph" style="{@domNodeCssText}">' +
                            '<div class="mstrmojo-DocGridGraph-msg"></div>' +
                            '<div class="mstrmojo-DocGridGraph-container"></div>' +
                          '</div>',
                        
            markupSlots: {
                msgNode: function(){ return this.domNode.firstChild; },
                containerNode: function(){ return this.domNode.lastChild; }
            },
            
            formatHandlers: {
                
                domNode: [ 'RW', 'B', 'background-color', 'fx', 'font' ]
            },
            
            
            viewMode: null,
            
            visible: true,
            
            resize: function resize() {
                
                this.clearCache();                
                
                ggHelper.clearFormatCache(this);
                var f = this.getFormats(),
                w = parseInt(f.width,10),
                h = parseInt(f.height,10);
                
                if (w > 0 && h > 0) {
                    ggHelper.changeVisibility(this, true);
                    
                    if (!this.defn.qsm) {
                        ggHelper.repositionChildren(this);
                    } else {
                        ggHelper.stackChildren(this);
                    }
                }else {
                    
                    ggHelper.changeVisibility(this, false);
                }
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                var eg = this.node.data.eg;
                if (eg === undefined) {
                    
                    this.msgNode.style.display = "none";
                    
                    this.containerNode.style.display = "block";
                } else {
                    this.msgNode.innerHTML = eg;
                    this.msgNode.style.display = "block";
                    this.containerNode.style.display = "none";
                }
                
                
                var qsm = this.defn.qsm;
                if(!this.viewMode && qsm) {
                    this.viewMode = qsm;
                }
                
                
                var d = this.node.defn;
                
                
                
                
                d.attachEventListener("qsmChange", this.id, function (evt){
                    
                    this.viewMode = evt.value;
                    
                    
                    ggHelper.setViewMode(this);
                    
                    
                    this.model.getDataService().setQuickSwitchViewMode(this.defn.tt + ELEM_SEP + this.k, this.viewMode);
                    
                    ggHelper.updateStyle(this);
                });

                ggHelper.setViewMode(this);
                ggHelper.updateStyle(this);
                
                
                if(!qsm) {
                    this.resize();
                }
            },

            getGridWidget: function() {
                return this.children[0];
            },
            
            getGraphWidget: function() {
                return this.children[1];
            },
            
            
            updateGraph: function(node) {
                var gp = this.getGraphWidget();
                
                if(gp) {
                    gp.update(node);
                    gp.refresh();
                }
            },
                                    
            quickSwitch: function quickSwitch() {
                
                var gd = this.viewMode != GP;                
                
                
                this.defn.set('qsm', (gd ? GP : GD));
                
                return true;
            }
        }
    );
    
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.func", "mstrmojo.Container", "mstrmojo._HasPopup");
    
    
    var fnPositionPopup = function() {
        var ddb = this.opener;
        
        
        if (ddb.direction.toLowerCase() === 'up') {
            this.domNode.style.top = -ddb.domNode.offsetHeight + 'px';
        }
    };

    
    mstrmojo.DropDownButton = mstrmojo.declare(
        
        mstrmojo.Container,
        
        
        [mstrmojo._HasPopup],
        
        
        {
            scriptClass: "mstrmojo.DropDownButton",
                        
            
            height: '19px',
            
            
            text: '',
            
            
            direction: 'down',
            
            enabled: true,
            
            title : '',
            
            markupString: '<div id="{@id}" class="mstrmojo-DropDownButton {@cssClass} {@direction}" style="{@cssText}">' +
                            '<div class="mstrmojo-DropDownButton-boxNode {@cssClass}-boxNode" title="{@title}" mstrAttach:mousedown>' +
                                '<div class="mstrmojo-DropDownButton-iconNode {@cssClass}-iconNode">{@text}</div>' +
                            '</div>' +
                            '<div class="mstrmojo-DropDownButton-popupNode {@cssClass}-popupNode"></div>' +
                        '</div>',
            
            markupSlots: {
                boxNode: function() { return this.domNode.firstChild; },
                iconNode: function() { return this.domNode.firstChild.firstChild;},
                popupNode: function() { return this.domNode.lastChild; }
            },

            markupMethods: {
                onheightChange: function() { this.boxNode.style.height = this.height || ''; },
                ontextChange: function() { this.iconNode.innerHTML = this.text;},   
                ontitleChange: function(){ this.boxNode.title = this.title;},
                onenabledChange: function(){ 
                    mstrmojo.css[this.enabled ? 'removeClass' : 'addClass'](this.domNode, ['disabled']);
                },
                onvisibleChange: function(){
                    this.domNode.style.display = this.visible ? 'block' : 'none';
                }
            },
            
            
            preBuildRendering: function preBuildRendering() {
                if (this._super) {
                    this._super();
                }
                
                
                var pr = this.popupRef;
                if (pr) {
                    
                    if (pr.nudge) {
                        
                        pr.nudge = mstrmojo.func.composite([ pr.nudge, fnPositionPopup ]);
                    } else if (this.direction.toLowerCase() !== 'down') {
                        
                        pr.nudge = fnPositionPopup;
                    }
                }
            },
            
            
            popupRef: null,
            
            
            
            popupOpenConfig: null,
            
            
            destroy: function destroy(skipCleanup){
                var pr = this.popupRef;
                if(pr && pr.hasRendered){
                    pr.destroy(false);
                }                   
                if(this._super){
                    this._super(skipCleanup);
                }             
            },
           
            togglePopup: function togglePopup() {
                var p = this._lastOpened;
                if (p && p.visible) {
                    this.closePopup();
                } else {
                    
                    this.openPopup("popupRef", this.popupOpenConfig);
                }
            },
            
            
            premousedown: function premousedown(evt) {
                this.togglePopup();
            }
        }
    );

})();
(function(){

    mstrmojo.requiresCls("mstrmojo.Container",
        "mstrmojo._Formattable",
        "mstrmojo._ContainsDocObjects",
                         "mstrmojo._CanGrowOrShrink",
        "mstrmojo.boxmodel");
    
    
    mstrmojo.DocSubsection = mstrmojo.declare(
        
        mstrmojo.Container,
        
        
        [ mstrmojo._Formattable, mstrmojo._ContainsDocObjects, mstrmojo._HasBuilder, mstrmojo._CanGrowOrShrink ],
        
        
        {
            scriptClass: "mstrmojo.DocSubsection",

            markupString: '<div id="{@id}" class="mstrmojo-DocSubsection" style="{@domNodeCssText}"></div>',
            
            markupSlots: {
                containerNode: function() { return this.domNode; }
            },
            
            formatHandlers: {
                domNode: [ 'D', 'B', 'background-color', 'fx' ]
            },
            
            update: function update(node) {
                
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
                
                if (this._super) {
                    this._super(node);
                }
            },
            
            postBuildRendering: function postBldRndr() {
                var d = this.defn;
            
                
                if (d.hc || d.vc) {
                    var dn = this.domNode,
                        f = this.getFormats(),
                        id = this.id,
                        oH = f.height,  
                        oW = f.width;
                    
                    
                    d.attachEventListener('resized', id, function () {
                        if ('height' in f) {
                            dn.style.height = f.height;
                        }
                        
                        if ('width' in f) {
                            dn.style.width = f.width;
                        }
                    });
                    
                    
                    d.attachEventListener('adjustSize', id, function (e) {
                        var ds = dn.style,
                        	orgHeight = ds.height;
                        
                        
                        if (d.hc && ds.width !== oW) {
                            
                            ds.width = oW;
                        }
                        
                        
                        if (d.vc && ds.height !== oH) { 
                            
                            ds.height = oH;
                        }
                        
                        this.performCanGrowCanShrink(this.children);

                        
                        e.heightReduced = (parseInt(orgHeight, 10) > parseInt(ds.height, 10));
                    });
                }
                
                return (this.renderMode !== 'scroll') ? this._super() : true;
            },

            childRenderOnAddCheck: function childRenderOnAddCheck(children) {
                return (this.renderMode !== 'scroll') ? this._super(children) : false;
            },
            
            
            onchildRenderingChange: function chRnChg(obj) {
                this._super(obj);
                
                
                if (this.renderMode !== 'scroll') {
                	var parentSlot = this.parent.slot, 
                	    dontShrink = parentSlot === 'fixedHeaderNode' || parentSlot === 'fixedFooterNode'; 
                    this.performCanGrowCanShrink([ (obj && obj.src) || obj ], dontShrink);
                }
            },
            
            
            portalMaximized: function portalMaximized() {
                var d = this.defn,
                    vc = d.vc,    
                    hc = d.hc;    
                
                
                if (!hc && !vc) {
                    
                    return {};
                }
                
                
                delete d.vc;
                delete d.hc;
                delete d.ck;    
                
                var f = this.getFormats(),
                    m = this.model,
                    ss = this.domNode,
                    me = this;

                
                var props = {
                    HideIfEmpty: -1
                };

                
                var fn = function (h, v, s) {
                    var p = h.toLowerCase(),
                        as = parseInt(ss.style[p], 10);    
                    
                    
                    v = ((v === undefined) ? as : Math.max(parseInt(v, 10), as)) + 'px';
                    
                    
                    if (f[p] !== v) {
                        
                        f[p] = v;

                        
                        props[h] = mstrmojo.boxmodel.px2Inches(m, v);
                        
                        
                        delete me['_fixed' + h];
                    }
                    
                    
                    s = s || '';
                    props['Max' + h] = 0;
                    props['CanGrow' + s] = 0;
                    props['CanShrink' + s] = 0;
                };

                
                if (vc) {
                    fn('Height', f.normHeight);
                }
                
                
                if (hc) {
                    fn('Width', f.normWidth, 'Horizontal');
                }
                
                
                d.raiseEvent({
                    name: 'resized'
                });
                
                return props;
            },
            
            adjustSectionSize: function adjustSectionSize() {
                var d = this.defn;
                
                if (d.vc || d.hc) {
                    return d.raiseEvent({
                        name: 'adjustSize'
                    });
                }
                
                return null;
            },
            
            refresh: function refresh() {
                if (!this.hasRendered) {
                    return;
                }
                                    
                var c = this.children || [];
                for (var i = c.length - 1; i >= 0; i--) {
                	c[i].refresh && c[i].refresh();
                }
            },
            
            
            preserveChildDomOrder: false
        }
    );
    
}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.array",
        "mstrmojo.Container",
        "mstrmojo._CanRenderChildrenOnShow");
        
    var _A = mstrmojo.array;

    
    mstrmojo.StackContainer = mstrmojo.declare(
        
        mstrmojo.Container,
        
        
        [mstrmojo._CanRenderChildrenOnShow],
        
        
        
        {
            
            scriptClass: "mstrmojo.StackContainer",

            isStack: true,
            
            
            markupString: '<div id="{@id}" class="mstrmojo-StackContainer {@cssClass}" style="{@cssText}"></div>',

            
            markupMethods: {
                onwidthChange: function(){
                    if(!isNaN(parseInt(this.width))){
                        this.domNode.style.width = this.width;
                    }
                },
                onheightChange: function(){
                    if(!isNaN(parseInt(this.height))){                    
                        this.domNode.style.height = this.height;
                    }
                },
                onborderChange: function(){ this.domNode.style.border = this.border || ''; },
                onbackgroundChange: function(){ this.domNode.style.background = this.background || ''; }
            },
            
            
            markupSlots: {
                containerNode: function(){ return this.domNode; }
            },

            
            _set_selected: function stsel(n, v) {
                var was = this.selected;
                if (was === v) {
                    return false;
                }
                
                if (was) {
                    was.set("visible", false);
                }
                this.selected = v;
                if (v) {
                    v.set("visible", true);
                }
                return true;
            },


            
            addChildren: function ac(ch, idx, silent) {
                
                
                var sel = this.selected,
                    c;
                for (var i=0, len = (ch && ch.length) || 0; i <len; i++){
                    c = ch[i];
                    if(c && c.set){
                        c.set("visible", c === sel);
                    }
                }
            
                
                return this._super(ch, idx, silent);
            },
            
            
            removeChildren: function rc(c, silent){
                var ret = this._super(c, silent);
                if (!c || (c === this.selected)) {  
                    this.set("selected", null);
                }
                return ret;
            },
            
            
            destroy: function dst(skipCleanup) {
                this._super(skipCleanup);
                this.selected = null;
            },
            
            renderMode: "onshow"
        }
    );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo._ContainsDocObjects",
                         "mstrmojo._HasBuilder",
                         "mstrmojo.css",
                         "mstrmojo.array");

    var $CSS = mstrmojo.css;

    var ITEM_SPA = 2;
    
    function passDirtyKeyToAncestorPanel(pnl, methodName, key) {
        
        var p = pnl.parent.parent;

        
        if (p && p instanceof mstrmojo.DocPanel) {
            
            p[methodName + 'DirtyKey'](key);
        }
    }

    
    function setDirtyChildrenOnDescendant(key, panel, allDirty) {
        
        if (key === panel.k) {
            
            mstrmojo.array.forEach(panel.children, function (child) {
                
                if (child.setDirtyChildren) {
                    
                    child.setDirtyChildren(allDirty);
                }
            });
        }
    }

    
    mstrmojo.DocPanel = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [ mstrmojo._Formattable, mstrmojo._ContainsDocObjects, mstrmojo._HasBuilder ],

        
        {
            scriptClass: "mstrmojo.DocPanel",

            
            visible: false,

            
            selected: false,

            cssDisplay: 'block',

            
            
            topStart: ITEM_SPA,
            
            
            contentWidth: 0,
            
            markupString: '<div id="{@id}" class="mstrmojo-DocPanel {@cssClass}" style="{@cssText}{@domNodeCssText}">' +
                              '<div class="mstrmojo-DocSubPanel-content" style="height:100%;width:100%;position:absolute;{@containerNodeCssText}"></div>' +
                          '</div>',

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; }
            },

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                containerNode: [ 'background-color', 'fx' ]
            },

            title: '',

            
            init: function init(props) {
                this._super(props);

                
                if (!this.title) {
                    
                    this.title = this.node.defn.ttl || '';
                }
                
            },

            
            childRenderCheck: function childRenderCheck(c) {
                return (this._super(c) && this.selected);
            },

            postBuildRendering: function postBuildRendering() {
                var c = $CSS.addClass;
                
                if (!this.defn.l && !this._forceRender) {
                    
                    c(this.domNode, 'placeholder');
                }

                return this._super();
            },

            onselectedChange: function onselectedChange(evt) {
                this.set('visible', !!evt.value);
                
                if (evt.value) {
                    
                    this.renderChildren();
                }
                this.model && this.model.raiseEvent({name: 'panelSelected',panelId:this.id, panelVisible:!!evt.value});
            },

            
            refresh: function refresh() {
                
                if (!this.hasRendered) {
                    
                    return;
                }

                
                
                if (!this.selected) {
                    
                    if (!this.children) {
                        this.builtChildren = false;
                    }

                    
                    this._forceRender = true;

                    
                    this._super();

                    
                    delete this._forceRender;

                } else {
                    
                    var c = this.children || [],
                        i;

                    for (i = c.length - 1; i >= 0; i--) {
                        c[i].refresh();
                    }
                    
                    
                    if (this._isFP()) {
                        this.refreshFP();
                    }
                }
            },

            
            setDirty: function setDirty(isDirty) {
                var mth = ((isDirty) ? 'add' : 'remove') + 'DirtyKey';
                this[mth](this.k);
            },

            
            addDirtyKey: function addDirtyKey(key) {
                
                var d = this.defn,
                    hash = d.dirtyKeys || {};

                
                hash[key] = true;

                
                d.dirtyKeys = hash;

                
                setDirtyChildrenOnDescendant(key, this, true);

                
                passDirtyKeyToAncestorPanel(this, 'add', key);
            },

            
            removeDirtyKey: function removeDirtyKey(key) {
                
                passDirtyKeyToAncestorPanel(this, 'remove', key);

                
                setDirtyChildrenOnDescendant(key, this, false);

                
                var defn = this.defn,
                    dk = defn.dirtyKeys;

                
                if (!dk) {
                    
                    return;
                }

                
                delete dk[key];

                
                if (!mstrmojo.hash.isEmpty(dk)) {
                    
                    return;
                }

                
                delete defn.dirtyKeys;
            },
            
            renderChildren: function rnCh() {   
                var ch = this.children;
                if (ch && (this._isFP() || this._isFSP())) {
                    
                    for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                        ch[i].orgPos = i;
                    }
                    
                    ch.sort(function(l,r) {
                        var lz = (l.getFormats() && l.getFormats()['z-index']) || 0,
                            rz = (r.getFormats() && r.getFormats()['z-index']) || 0;
                        
                        
                        return lz - rz || l.orgPos - r.orgPos;
                    });                                                   
                }
                
                if (this._isFP()) {     
                    if (ch) {
                        
                        
                        var ocw = this.domNode.clientWidth - 2 * ITEM_SPA
                        
                        
                        this.topStart = ITEM_SPA + 1;
                        
                        for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                            var cw = this.domNode.clientWidth - 2 * ITEM_SPA;
                            this.contentWidth = (cw > 0) ? cw : 0;
                            
                            if (cw != ocw) {    
                                
                                this.topStart = ITEM_SPA;
                                for (var j=0; j<i; j++) {
                                    var oc = ch[j];
                                    oc.refresh();                                                                  
                                    if (oc.getContainerHeight) {
                                        this.topStart += oc.getContainerHeight() + ITEM_SPA;
                                    }
                                }
                            }
                            
                            var c = ch[i];
                            if (this.childRenderCheck(c)) {
                                c.render(null);    
                                                           
                                if (c.getContainerHeight) {
                                    this.topStart += c.getContainerHeight() + ITEM_SPA;
                                }
                            }
                        }
                    }
                } else {
                    this._super();
                } 
            },

            
            refreshFP: function() {
                if (!this.hasRendered) {
                    return;
                }
                
                var ch = this.children;
                this.topStart = ITEM_SPA;  
                var cw = this.domNode.clientWidth - 2 * ITEM_SPA;
                this.contentWidth = (cw > 0) ? cw : 0;
                
                
                for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                    var c = ch[i];
                    if (c.relocate) {
                        c.relocate(this.topStart, this.contentWidth);
                    }
                                                   
                    if (c.getContainerHeight) {
                        this.topStart += c.getContainerHeight() + ITEM_SPA;
                    }
                }
            },
            
            getChildren: function getChildren(){                
                var ch = this.model.getChildren(this.node, false);
                
                if (this._isFP() || this._isFSP()) {
                    for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                        var c = ch[i];
                        if (this._isFP() && !c.defn.iifp) {
                            c.defn.iifp = true; 
                        }
                        if (this._isFSP() && !c.defn.iifs) {
                            c.defn.iifs = true; 
                        }
                    }
                }
                
                return ch;
            },
            
            
            _isFP: function() { 
                return this.parent.defn.ifp;
            },
            
            
            _isFSP: function() {
                return this.parent.defn.ifsp;
            }
                
        }
    );

}());
(function(){
	mstrmojo.requiresCls('mstrmojo.Container', 'mstrmojo.css');
	
	
	var C_PREFIX = '',	
        R_PREFIX = 'row-',
        TABLE = mstrmojo.css.DISPLAY_TABLE;

	mstrmojo.Table = mstrmojo.declare(
		
		mstrmojo.Container,
		
		null,
		
		{
			scriptClass: 'mstrmojo.Table',
			cellCssClass: '',
			
			rows: -1,
			
			cols: -1,
			
			_trows: -1,
			
			cellPadding: 0,
			cellSpacing: 0,
			
			
			layout: null,
			markupString: '<table id="{@id}" class="mstrmojo-Table {@cssClass}" style="{@cssText}" cellpadding="{@cellPadding}" cellspacing="{@cellSpacing}">{@tableHtml}</table>',
			markupSlots: {
				containerNode: function() { return this.domNode; }
			},
            markupMethods: {
                onvisibleChange: function() { this.domNode.style.display = this.visible ? TABLE : 'none'; }
            },
			preBuildRendering: function preBR () {
				
				var rs = [],
					ccc = this.cellCssClass;
				if (this.layout){
					var rlen = this._trows = this.layout.length;
					
					for (var i = 0; i < rlen; i ++ ){
						var r = this.layout[i],
							cells = r.cells,
							clen = cells.length,
							cs =[];
						
						for (var j = 0; j < clen; j ++) {
							var c = cells[j], 
								att = '';
							att += ((c.cssClass || ccc)? ' class="' + (c.cssClass || ccc) + '"' : '');
							att += (c.cssText? ' style="' + c.cssText + '"' : '');
							att += (c.rowSpan? ' rowspan="' + c.rowSpan + '"' : '');
							att += (c.colSpan? ' colspan="' + c.colSpan + '"' : '');
							cs[j] = '<td' + att + '></td>';
						} 
						var rAtt = '';
						rAtt += (r.cssClass? ' class="' + r.cssClass + '"' : '');
						rAtt += (r.cssText? ' style="' + r.cssText + '"' : '');
						rs[i] = '<tr' + rAtt + '>' + cs.join('') + '</tr>';
					} 
				} else{
					this._trows = this.rows;
					var att = (ccc? ' class="' + ccc + '"' : ''),
						cs = [];
					
					for (var i = 0; i < this.rows; i ++) {
						for (var j = 0; j < this.cols; j ++) {
							cs[j] = '<td' + att + '></td>';
						}
						rs[i] = '<tr>' + cs.join('') + '</tr>';
					}
				}
				this.tableHtml = rs.join('');
				
				if (this._super) {
				    this._super();
			    }
			},
			
			postBuildRendering: function postBuildRendering() {
				
				if (this._trows){
					var slots = {},
						trs = this.containerNode.rows,
						rlen = trs.length;
					
					for (var i = 0; i < rlen; i ++) {
						var cells = trs[i].cells,
							clen = cells.length;
						slots[R_PREFIX + i] = trs[i];
						
						for (var j = 0; j < clen; j ++) {
							slots[C_PREFIX + i + ',' + j] = cells[j];
						}						
					}
					
					this.addSlots(slots);
				}
				
				this._super();
			},
			
			childRenderCheck: function childRndrChk( child) {
				if (child && !child.hasRendered) {
					var slotName = child.slot || this.defaultChildSlot;  
					return !!this[slotName] || slotName.match(/^([\d]+),([\d]+)$/);
				}
				return false;
			},
			
			on_child_change_rendering: function onChldChngRndr( obj) {
				var child = (obj && obj.src) || obj,
				d = child && child.domNode;
				if (d) {
					
					var s = child.slot;
					
					if (!this[s]) {
						
						
						var match = s && s.match(/^([\d]+),([\d]+)$/);
						if (match) {
							
							
							var ri = parseInt(match[1], 10), 
								ci = parseInt(match[2], 10), 
								cn = this.containerNode,	 
								rslot = this[(R_PREFIX + ri)],	
								slots = [];
							
							if (!rslot) {
								var rs = cn.rows,
								rlen = rs && rs.length || 0;
								
								for (var i = rlen; i <= ri; i ++) {
									slots[R_PREFIX + i] = cn.insertRow(); 
								}
								
								rslot = slots[R_PREFIX + ri];
							}
							
							var cLen = rslot.cells && rslot.cells.length || 0;
							for (var i = cLen; i <= ci; i++) {
								var td = rslot.insertCell(i);
								slots[C_PREFIX + ri + ',' + i] = td;
								if (this.cellCssClass) {
									td.className = this.cellCssClass;
								}
							}
							this.addSlots(slots);
						}
					}
				}
				
				this._super(obj);
				
			}
		}
	);
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo.EnumRWUnitType");

    var HTML_CONTAINER = mstrmojo.EnumRWUnitType.HTMLCONTAINER;

    
    mstrmojo.DocTextfield = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [ mstrmojo._Formattable ],

        
        {
            scriptClass: "mstrmojo.DocTextfield",

            markupString:   '<div id="{@id}" class="mstrmojo-DocTextfield {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div class="mstrmojo-DocTextfield-valueNode" style="{@valueNodeCssText}" mstrAttach:click >{@v}</div>' +
                                '{@buttonNodeMarkup}' +
                            '</div>',

            markupSlots: {
                valueNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode:  [ 'T', 'z-index' ],
                valueNode: [ 'D', 'B', 'F', 'P', 'background-color', 'fx', 'text-align', 'white-space', 'overflow' ]
            },

            markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            
            update: function update(node) {
                var d = node.data,
                    v = d.v || '';

                
                if (node.defn.t === HTML_CONTAINER) {
                    
                    var div = document.createElement('div');
                    div.innerHTML = '<textarea>' + v + '</textarea>';
                    v = '<div style="display:none">&nbsp;</div>' + div.firstChild.value;
                    
                    div = null;
                }

                
                this.v = v;

                
                if (this.thresholdId || d.tid) {
                    
                    delete this.fmts;
                }

                
                this.thresholdId = d.tid;

				this.set('visible', !node.data.hidden);

                if (this._super) {
                    this._super(node);
                }
            },

            
            postBuildRendering: function postBuildRendering() {

                var $D = mstrmojo.dom,
                    f = this.getFormats(),
                    rotateValue = f.fx && f.fx.rt,
                    i,
                    len;

                
                if (rotateValue && !$D.isIE && $D.supports($D.cssFeatures.TEXT_ROTATION)) {
                    
                    
                    var dn = this.domNode;

                    
                    switch (rotateValue) {
                    case 1:    
                        
                        
                        
                        
                        dn.style.left = (parseInt(f.left, 10) + dn.offsetHeight) + 'px';
                        break;

                    case 3: 
                        
                        dn.style.top = (parseInt(f.top, 10) + dn.offsetWidth) + 'px';
                        break;
                    }
                }

                
                if (this.defn.t === HTML_CONTAINER) {
                    
                    var scripts = this.domNode.getElementsByTagName('script');
                    for (i = 0, len = scripts.length; i < len; i++) {
                        
                        eval(scripts[i].innerHTML);
                    }
                }

                return this._super();
            },

            getAnchor: function getAnchor() {
                return this.valueNode;
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable");

    mstrmojo.DocImage = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [mstrmojo._Formattable],

        
        {
            scriptClass: "mstrmojo.DocImage",

            markupString: '<div id="{@id}" class="mstrmojo-DocImage" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div style="{@shadowNodeCssText}"><img src="{@v}" style="{@imgNodeCssText}" mstrAttach:click></div>' +
                                '{@buttonNodeMarkup}' +
                          '</div>',

            markupSlots: {
                imgNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },	

            
            update: function update(node) {
                var ds = this.model.getDataService(),
                    v = node.data.v;

                this.v = (ds && ds.getDocImage && ds.getDocImage(v)) || v;

                
                if (this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }

                this.thresholdId = node.data.tid;
                this.set('visible', !node.data.hidden);

                
                if (this._super) {
                    this._super(node);
                }
            },

            formatHandlers: {
                domNode: ['left', 'top', 'z-index' ],
                shadowNode: ['width', 'height', 'B', 'fx' ],
                imgNode: [ 'height', 'width' ]
            },

            preBuildRendering: function preBuildRendering() {
                if (this._super) {
                    this._super();
                }

                
                if (!mstrmojo.dom.isIE7) {
                    var fmt = this.getFormats(),
                        ds = (fmt.fx && fmt.fx.ds) || 0,  
                        border = mstrmojo._Formattable.getBorderWidths(this);

                    this.domNodeCssText += 'width:' + ((parseInt(fmt.width, 10) || 0) + ds + border.w) + 'px;' + ' height: ' +  ((parseInt(fmt.height, 10) || 0) + ds + border.h) + 'px;';
                }
            },
            
            getAnchor: function getAnchor() {
            	return this.imgNode;
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo.array");

    var $ARR = mstrmojo.array,
        $LAYOUT = {
            containerNode: '100%',
            node1: '100%',
            node2: '100%'
        };

    
    mstrmojo.android.ui.ViewSwitcher = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        
        {
            scriptClass: "mstrmojo.android.ui.ViewSwitcher",

            markupString: '<div id="{@id}" class="mstrmojo-AndroidSwitcher {@cssClass}" style="{@cssText}">' +
                              '<div class="switch-slider">' +
                                  '<div class="switch-page"></div>' +
                                  '<div class="switch-page"></div>' +
                              '</div>' +
                              '<div class="overlay"></div>' +
                          '</div>',

            markupSlots: {
                
                containerNode: function () { return this.domNode; },
                sliderNode: function () { return this.domNode.firstChild; },
                node1: function () { return this.domNode.firstChild.firstChild; },
                node2: function () { return this.domNode.firstChild.lastChild; },
                overlayNode: function () { return this.domNode.lastChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },

            layoutConfig: {
                h: $LAYOUT,
                w: $LAYOUT
            },

            
            getSlots: function getSlots() {
                var curVisSlot = this._curSlot || 'node1',
                    nextVisSlot = (curVisSlot === 'node1') ? 'node2' : 'node1';

                return {
                    current: this[curVisSlot],
                    next: this[nextVisSlot],
                    slot: nextVisSlot
                };
            },

            
            addChildren: function addChildren(children, idx, silent) {
                
                $ARR.forEach(children, function (child) {
                    
                    if (child.slot === 'overlayNode') {
                        
                        child.ignoreLayout = true;
                    }
                });

                this._super(children, idx, silent);
            },

            
            prepareNewView: function prepareNewView(view, slot) {
                
                view.height = this.height;
                view.width = this.width;

                
                view.visible = true;

                
                view.slot = slot;
            },

            
            switchView: function switchView(view, isBackOperation) {
                
                var currentChild = this.getCurrentView();

                
                if (view === currentChild) {
                    
                    return;
                }

                var slotInfo = this.getSlots(),
                    newCtrl = this.getViewController(view),
                    oldCtrl = this.getViewController(currentChild);

                
                if (currentChild) {
                    
                    if (oldCtrl && oldCtrl.beforeViewHidden) {
                        
                        oldCtrl.beforeViewHidden(isBackOperation);
                    }
                }

                
                this.prepareNewView(view, slotInfo.slot);

                
                if (newCtrl && newCtrl.beforeViewVisible) {
                    
                    newCtrl.beforeViewVisible(isBackOperation);
                }

                
                this.addChildren([ view ]);

                
                if (currentChild) {
                    
                    this.removeChildren(currentChild);
                    currentChild.unrender();

                    
                    if (oldCtrl && oldCtrl.afterViewHidden) {
                        
                        oldCtrl.afterViewHidden(isBackOperation);
                    }
                }

                
                if (newCtrl && newCtrl.afterViewVisible) {
                    
                    newCtrl.afterViewVisible(isBackOperation);
                }

                
                this.stackViews(slotInfo.slot);

                
                this.afterSwitch(view);
            },

            
            replaceView: function replaceView(view, targetView, noDestroy) {
                var idx = $ARR.indexOf(this.children, targetView);

                
                if (idx === -1) {
                    
                    return;
                }

                
                var currentSlot = targetView.slot;

                
                $ARR.forEach([ view, targetView ], function (v) {
                    
                    if (v.parent === this) {
                        
                        this.removeChildren(v, true);
                        v.unrender();
                        
                        if(!noDestroy) { 
                        	v.destroy();
                        }
                    }
                }, this);

                
                this.prepareNewView(view, currentSlot);

                
                this.addChildren([ view ]);

                return view;
            },

            
            stackViews: function stackViews(slotName) {
                
                $ARR.forEach([ 1, 2 ], function (idx) {
                    
                    var name = 'node' + idx,
                        slot = this['node' + idx];

                    
                    if (slot) {
                        
                        slot.style.zIndex = (name === slotName) ?  3 : 1;
                    }
                }, this);
            },

            
            getCurrentView: function getCurrentView() {
                var slot = this._curSlot || 'node2',
                    view;

                
                $ARR.forEach(this.children, function (child) {
                    
                    if (child.slot === slot) {
                        
                        view = child;
                        return false;
                    }
                });

                return view;
            },

            
            getViewController: function getViewController(view) {
                return view ? view.controller || view : null;
            },

            
            afterSwitch: function afterSwitch(view) {
                
                this._curSlot = view.slot;
            },
            
            doLayout: function doLayout() {
                var node1 = this.node1.style,
                    node2 = this.node2.style;
                
                
                node1.height = node2.height = this.height;
                node1.width = node2.width = this.width;
                
                this._super();
            }

        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.Container"); 
    
    mstrmojo.requiresDescs(9936, 9937);
    
    
    var IMAGE_MARGIN_BOTTOM = 25,
    	$DESC = mstrmojo.desc;

    
    mstrmojo.android.ui.NoProjectsView = mstrmojo.declare(
        mstrmojo.Container,

        null,

        
        {
            scriptClass: "mstrmojo.android.ui.NoProjectsView",

            markupString: '<div id="{@id}" class="mstrmojo-NoProjectsView">' +
            				'<div>' + 
                              '<div class="mstrmojo-NoProjectsViewImage"></div>' +
                              '<div class="mstrmojo-NoProjectsViewMsg1">{@msg1}</div>' +
                              '<div class="mstrmojo-NoProjectsViewMsg2">{@msg2}</div>' +
                            '</div>' + 
                          '</div>',

            markupSlots: {
                wrapperNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },            	

            preBuildRendering: function preBuildRendering(){
            	
            	this.msg1 = $DESC(9936, 'No projects have been configured.');
            	this.msg2 = $DESC(9937, 'Contact your administrator');
            },
            
            postBuildRendering: function postBuildRendering() {
            	
            	this._super();
            	
            	var wrapperNode = this.wrapperNode;
            	
            	wrapperNode.style.marginTop = (-(wrapperNode.clientHeight/2) - IMAGE_MARGIN_BOTTOM) + 'px';
            }           
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._CanMeasureChildren",
                         "mstrmojo._CanRenderDocOnScroll",
                         "mstrmojo.dom");

    
    mstrmojo.DocLayout = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [mstrmojo._Formattable, mstrmojo._HasBuilder, mstrmojo._CanMeasureChildren, mstrmojo._CanRenderDocOnScroll],

        
        {
            scriptClass: "mstrmojo.DocLayout",

            markupString: '<div id="{@id}">' +
                              '<div class="mstrmojo-DocLayout {@cssClass}" style="{@domNodeCssText}"></div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; },
                popupNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode: [ 'B', 'background-color', 'D', 'min-height', 'width' ]
            },

            alias: 'docLayout',
            markupMethods: {
                onminHeightChange: function () {
                    var mh = this.minHeight;
                    if (!mh) {
                        var fmts = this.getFormats();
                        mh = fmts && fmts['min-height'];
                    }
                    if (mh) {
                        this.containerNode.style[mstrmojo.css.MINHEIGHT] = mh;
                    }
                }
            },

            getHeight: function getHeight() {
                var h = 0;

                
                mstrmojo.array.forEach(this.children, function (child) {
                    h += child.height();
                });

                
                return h || this.containerNode.offsetHeight;
            },

            getWidth: function getWidth() {
                
                var children = this.children;
                return (children && children.length) ? children[0].width() : this.containerNode.offsetWidth;
            },

            preBuildRendering: function preBuildRendering() {
                var f = this.getFormats();

                
                if (f && f['min-width'] !== undefined) {
                    
                    f.width = f['min-width'];
                }

                this._super();
            },

            
            renderChildren: function renderChildren() {
                this._super();

                this.resizeOrReposition();
            },

            
            resizeOrReposition: function resizeOrReposition() {
                var containerNode = this.containerNode;

                
                if (!!this.defn.aw) {
                    
                    var aws = this.model.getAutoWidthIDs(),
                        len = (aws && aws.length) || 0,
                        mx = 0,             
                        all = mstrmojo.all,
                        i;

                    
                    if (!len) {
                        
                        return;
                    }

                    
                    for (i = 0; i < len; i++) {
                        
                        mx = Math.max(this._getWidgetRightMostPosition(all[aws[i]]), mx);
                    }

                    
                    mx = Math.max(this.getLayoutMinWidth(), mx);

                    
                    if (mx > parseInt(this.getFormats().width, 10)) {
                        
                        containerNode.style.width = mx + 'px';
                    }
                }

                
                var zoomToFit = this.model.zt;
                if (mstrApp.isMobile && zoomToFit) {

                    
                    var viewerNode = this.parent.domNode;
                    if (viewerNode) {

                        
                        var controller = this.model.controller,
                            isPortrait = !!controller.orientation,
                            verticalMargin = 0,                        
                            parent = this.parent,
                            parentHeight = parent.getHeight() - parent.fixedHeaderNode.clientHeight - parent.fixedFooterNode.clientHeight; 

                        
                        if (zoomToFit === 2) {

                            
                        	
                            if (!controller.toolBarDelegated) {
                            	parentHeight -= controller.getBottomToolBarHeight();
                            }

                            
                            verticalMargin = Math.round(isPortrait ? Math.max((parentHeight - this.getHeight()), 0) / 2 : 0) + 'px';
                        }

                        
                        containerNode.style.margin = verticalMargin + ' auto';

                        
                        var me = this;
                        window.setTimeout(function () {
                            controller.nudgeWidget(me.id, {
                                left: containerNode.offsetLeft,
                                top: containerNode.offsetTop
                            });
                        }, 0);
                    }
                }
            },

            
            getLayoutMinWidth: function getLayoutMinWidth() {
                return 0;
            },

            
            _getWidgetRightMostPosition: function getLayoutMinWidth(w) {
                return parseInt(w.getFormats().left, 10) + (w.getDim && w.getDim().w || w.domNode.offsetWidth);
            },

            
            renderCtrlsInViewport: function renderCtrlsInViewport() {
                this._super();

                this.resizeOrReposition();
            },

            
            adjustAutoWidth: function adjustAutoWidth(w) {
                
                if (!this.defn.aw || !w) {
                    
                    return;
                }

                
                var cs = this.containerNode.style,
                    wd = parseInt(cs.width, 10) || 0;      

                
                var me = this;
                window.setTimeout(function(){
                    var mx = me._getWidgetRightMostPosition(w);

                    
                    if (mx > wd) {
                        
                        cs.width = mx + 'px';
                    }
                }, 1);
            },

            
            _getModelChildNodes: function _getModelChildNodes(node, isPartial, start, count, includeTotal) {
                
                
                var nds = this.model.getNonFixedSections(node, isPartial);

                
                var len = nds.length;

                count = isNaN(count) ? len : count;
                start = start || 0;

                if (start > 0 || count < len) {
                    nds = nds.slice(start, start + count);
                }

                return includeTotal ? {
                    nodes: nds,
                    total: len
                } : nds;
            },
            
            getChildren: function getChildren(node, isPartial, start, count, includeTotal) {
                return this._getModelChildNodes(node || this.node, isPartial || false, start, count, includeTotal);
            },

            getCaptureDimensions: function getCaptureDimensions() {
            	var domNode = this.domNode,
            		position = {};

            	if(!this.domNode) {
            		return;
            	}

            	position = mstrmojo.dom.position(domNode);

            	position.w = Math.min(domNode.offsetWidth, position.w);
            	position.h = Math.min(domNode.offsetHeight, position.h);

            	return position;
            },

            preserveChildDomOrder: false,

            postBuildRendering: function postBuildRendering(){

            	if (window.mstrMobileApp !== undefined) {
            		this.defn.lastOrientation = mstrMobileApp.getOrientation();
            	}

            	this._super();
            }

        }
    );

}());
(function(){

	mstrmojo.requiresCls("mstrmojo.Container",
						 "mstrmojo._HasScrollbox",
						 "mstrmojo._HasLayout",
						 "mstrmojo._ShowsStatus");
	

	function getDimension(dimension) {
	    var domNode = this.domNode,
	    x = parseInt(this[dimension.toLowerCase()], 10);

	    return (isNaN(x)) ? domNode['offset' + dimension] : x;
	}	
	
	
	mstrmojo.DocLayoutViewer = mstrmojo.declare(
		
		mstrmojo.Container,
		
		
		[mstrmojo._Formattable, mstrmojo._HasScrollbox, mstrmojo._HasLayout, mstrmojo._ShowsStatus],
		
		
		{
			scriptClass: "mstrmojo.DocLayoutViewer",
			
			markupString: '<div id="{@id}" class="mstrmojo-DocLayoutViewer {@cssClass}" style="{@domNodeCssText}">' +
							'<div></div>' +
							'<div>' +
								'<div class="mstrmojo-progress" style="display:none">' +
									'<div class="mstrmojo-progress-barbg">' +
										'<div class="mstrmojo-progress-bar"></div>' +
									'</div>' +
									'<div class="mstrmojo-progress-text"></div>' +
								'</div>' +
								'<div id="{@id}_fh"></div>' + 
								'<div id="{@id}_scrollboxNode" class="mstrmojo-DocLayoutViewer-layout" style="{@_scrollCssText}"></div>' +
								'<div id="{@id}_ff"></div>' + 
							'</div>' +
							'<div></div>' +
						  '</div>',
						
			markupMethods: {
				onvisibleChange: function(){ this.domNode.style.display = this.visible ? 'block' : 'none'; },
				onborderChange: function(){ if (this.border) { this.domNode.style.border = this.border; }}
			},
			
			markupSlots: {
				groupBy: function(){ return this.domNode.firstChild; },
				layout: function() { return this.domNode.childNodes[1].childNodes[2]; },
				scrollboxNode: function() { return this.domNode.childNodes[1].childNodes[2]; },
				containerNode: function() { return this.domNode.childNodes[1].childNodes[2]; },
				incFetchNode: function() { return this.domNode.lastChild; },
				fixedHeaderNode: function() {return this.domNode.childNodes[1].childNodes[1]; },
				fixedFooterNode: function() {return this.domNode.childNodes[1].childNodes[3]; },
				
				_STATUS: function(){ return this.domNode.childNodes[1].firstChild; },
				_STATUS_TXT: function(){ return this.domNode.childNodes[1].firstChild.lastChild; },
				_STATUS_BAR: function(){ return this.domNode.childNodes[1].firstChild.firstChild.firstChild; }
			},
			
			layoutConfig: {
				h: {
					groupBy: 'auto',
					fixedHeaderNode: 'auto',
					layout: '100%',
					fixedFooterNode: 'auto',
					incFetchNode: 'auto'
				},
				w: {
					layout: '100%'
				}
			},

			
			scrollboxHeightFixed: true,
			scrollboxWidthFixed: true,
			
			
			getHeight: function getHeight() {
			    return getDimension.call(this, 'Height');
			},

			
			getWidth: function getWidth() {
			    return getDimension.call(this, 'Width');
			},   
            
			
			afterLayout: function afterLayout() {
				this._super();

				
				this.notifyScrollListeners();
			},
			
			preBuildRendering: function preBuildRendering() {
				
				
				
				if ( this.parent ) {
					var p = this.parent[this.slot].style,
						h = this.height,
						w = this.width;
					
					this.height = (h !== 'auto') ? h : p.height;
					this.width = (w !== 'auto') ? w : p.width;
				}
				
				
				this.zf = this.model.zf;
				this.bs = this.model.bs;
				
				






























				
				return this._super ? this._super() : true;
			},
			setSlotDimensions: function setSlotDimensions(slot, h, w) {
				
				if (slot === 'layout') {
					
					
					
					this.scrollboxHeight = parseInt(h, 10);
					this.scrollboxWidth = parseInt(w, 10);
				}
				
				this._super(slot, h, w);
			}, 
			
			onaddChild: function onaddChild(evt) {
				if (!isNaN(evt.index)) {
					var nc = this.children[evt.index];
					if (nc && nc.slot === "groupBy") {
						this.docGroupBy = nc;
					}
				}
			}
		}
	);
	
}());
(function(){


    mstrmojo.requiresCls("mstrmojo._HasBuilder",
                         "mstrmojo._HasLayout",
                         "mstrmojo.Container");

    var DARK_BORDER_WIDTH = 1;

    mstrmojo.maps.jsmap.AndroidDocMapInfoWindow = mstrmojo.declare(
        
        mstrmojo.Container,
        
        
        [ mstrmojo._HasBuilder, mstrmojo._HasLayout ],
        
        
        {
            scriptClass: "mstrmojo.maps.jsmap.AndroidDocMapInfoWindow",
            
            markupString: '<div class="mstrmojo-DocInfoWindow-wrapper">' +
                              '<div id="{@id}" class="mstrmojo-DocInfoWindow"></div>' +
                          '</div>',

            markupSlots: {
                infoNode: function() { return this.domNode.firstChild; },
                containerNode: function() { return this.domNode.firstChild; }
            },
                        
            getChildren: function getChildren(){
                
                var m = this.model,
                    c = m.getLayoutDataCache(m.getCurrentLayoutKey())[this.psId],
                    f = c.defn.fmts;
                
                
                f.left = DARK_BORDER_WIDTH + 'px';
                f.top = DARK_BORDER_WIDTH + 'px';
                
                return [c];
            }
        });

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.selectors.MobileSliderSelector",
                         "mstrmojo.hash");
    
    var $M = mstrmojo.android.selectors.MobileSliderSelector,
        $F = $M.FLAGS,
        $T = $M.TYPES;
    
    
    mstrmojo.android.selectors.Slider = mstrmojo.declare(

        mstrmojo.android.selectors.MobileSliderSelector,

        null,
        
        
        {
            scriptClass: "mstrmojo.android.selectors.Slider",
            
            items : $F.UNSET,
            
            initState: function initState() {
                if (!!this.items) {
                    
                    this.leftStep = this.rightStep = this.singleStep = null;
                    
                    this.set('type', (!this.multiSelect) ? $T.SINGLE : (this.include) ? $T.INCLUDE : $T.EXCLUDE);
                    this.set('steps', this.items.length);
                    this.value = null;
                    this.set('value', this.selectedIndices);
                }
            },
            
            
            onvalueChange : function onvalueChange() {
                var values = this.value,
                    mn = mstrmojo.hash.any(values, true),
                    mx = mn;
                
                if (this.type === $T.SINGLE) {
                    this.set('singleStep', parseInt(mn) || 0);
                    
                } else {
                    var p;
                    
                    for (p in values) {
                        mn = Math.min(p, mn);
                        mx = Math.max(p, mx);
                    }
                    
                    
                    mn = mn || '0';
                    if (mx === undefined || mx === null) {                        
                        mx = String(this.steps - 1);
                    }
                    
                    this.set('leftStep', parseInt(mn, 10));         
                    this.set('rightStep', parseInt(mx, 10) + 1);    
                }
            },
            
            
            flushSelections: function flushSelections() {
                if (this.type === $T.SINGLE) {
                    this.select([ this.singleStep ]);
                    
                } else {
                    var s = [],
                        i = this.leftStep;
                    
                    for (; i < this.rightStep; i++) {
                        s.push(i);
                    }
                    
                    this.select(s);
                }
            },
            
            
            buildSummary: function buildSummary(singleStep, leftStep, rightStep) {
                var items = this.items,
                    s = (singleStep !== null) ? singleStep : leftStep;
                
                
                if (s === undefined || s === null || isNaN(s) || !items.length) {
                    
                    return;
                }
                
                var summary = (singleStep === null && leftStep !== rightStep - 1) ? items[leftStep].n + " - " + items[rightStep - 1].n : (items[s] && items[s].n) || '';
                
                this.summary.innerHTML = summary;
                
                return summary;
            }
            
        }
    );
    
}());
(function () {    

    
    mstrmojo.requiresCls(
            "mstrmojo.Label",
            "mstrmojo.css",
            "mstrmojo.hash");
    
    
    mstrmojo.TristateCheckBox = mstrmojo.declare(
            
            mstrmojo.Label,
            
            
            null,
            
            
            {
                scriptClass:'mstrmojo.TristateCheckBox', 
                grayed: true,
                checked: true,
                cssClass: 'tristate',                
                onclick: function() {
                    if (this.grayed) {
                        this.set('grayed', !this.grayed);
                    } else {
                        this.set('checked', !this.checked);
                    }
                },
                markupMethods: mstrmojo.hash.copy({
                    oncheckedChange: function() {
                        mstrmojo.css.toggleClass(this.domNode, 'checked', this.checked);
                    },
                    ongrayedChange: function() {
                        mstrmojo.css.toggleClass(this.domNode, 'grayed', this.grayed);
                    },
                    onenabledChange: function() {
                        mstrmojo.css.toggleClass(this.domNode, 'disabled', !this.enabled);
                    }
                }, mstrmojo.hash.copy(mstrmojo.Label.prototype.markupMethods))
            }
    ); 
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Label",
                         "mstrmojo._TouchGestures");

    
    mstrmojo.android.ui.Label = mstrmojo.declare(

        mstrmojo.Label,

        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.ui.Label",

            
            touchTap: mstrmojo.emptyFn
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Image",
                         "mstrmojo._TouchGestures");

    
    mstrmojo.android.ui.Image = mstrmojo.declare(

        mstrmojo.Image,

        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.ui.Image",
            
            touchTap: mstrmojo.emptyFn
        }
    );
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.css", "mstrmojo.ImageToggle", "mstrmojo._IsInputControl");
    
    
    mstrmojo.ToggleDIC = mstrmojo.declare(
        mstrmojo.ImageToggle,
        
        [mstrmojo._IsInputControl],
        
        {                  
            scriptClass: 'mstrmojo.ToggleDIC',
            
            init: function(props){
                this._super(props);
                
                this.unset = this.dic.ust;
            },
            
            focus: function(){
                this.domNode.focus();
            },
            
            onvalueChange: function(){
                
            },
            
            onblur: function(e){
                var evt = e.e || e,
                    dom = this.domNode,
                    ofst = mstrmojo.boxmodel.offset(dom, document.body);
                if(evt.clientX > ofst.left && evt.clientX < ofst.left + dom.offsetWidth && evt.clientY > ofst.top && evt.clientY < ofst.top + dom.offsetHeight) {
                    this.domNode.focus();    
                } else {
                    this.applyChanges();
                }
            },
            
            postBuildRendering: function(){
                if (this._super){
                    this._super();
                }
                
                if (this.showByDefault){
                    var ops = this.openerStyle;
                    
                    this.width = ops.iw;
                    this.height = ops.ih;
                    this.set('imageList', this.dic.vls);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Stepper",
                         "mstrmojo._TouchGestures");
      
    
    mstrmojo.ui.MobileStepper = mstrmojo.declare(
        
        mstrmojo.Stepper,
            
        
        [ mstrmojo._TouchGestures ],
            
        {

            scriptClass: "mstrmojo.ui.MobileStepper",
            
            
            onclick: function onclick(evt) {
                
                if (!mstrApp.isTouchApp()) {
                    this._super(evt);
                }
                return false;
            },

            
            onmousedown: function onmousedown(evt) {
                
                if (!mstrApp.isTouchApp()) {
                    this._super(evt);
                }
                return false;
            },
            
            
            onmouseup: function onmouseup(evt) {
                
                if (!mstrApp.isTouchApp()) {
                    this._super(evt);
                }
                return false;
            },
            
            
            touchSelectBegin: function touchSelectBegin(touch) {
                
                this.startStepperInterval(touch, 'touchTap');
            },
            
            
            touchSelectEnd: function touchSelectEnd(touch) {
                
                this.stopStepperInterval();
            },
            
            
            touchTap: function touchTap(touch) {
                this.processEvent(touch.target);
            },
            
            
            touchBegin: function touchBegin(touch){
                var dom = touch.target;
                if (dom == this.nextNode || dom == this.prevNode){
                    mstrmojo.css.addClass(dom, 'glow');
                }
            },
            
            
            touchEnd: function touchEnd(touch){
                var dom = touch.target;
                if (dom == this.nextNode || dom == this.prevNode){
                    mstrmojo.css.removeClass(dom, 'glow');
                }
            }
        }
    );
    
    
    
    mstrmojo.ui.MobileStepper.prototype.markupString = mstrmojo.ui.MobileStepper.prototype.markupString.replace(',mousedown,mouseup', '');
}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.ListBase2",
        "mstrmojo.ListMapper",
        "mstrmojo.ListBuilder",
		"mstrmojo.ListSelector");
    
    
    mstrmojo.List = mstrmojo.declare(
        
        mstrmojo.ListBase2,
        
        null,
        
        
        {
            
            scriptClass: "mstrmojo.List",
            
            
            renderOnScroll: true,
                          
            
            listMapper: mstrmojo.ListMapper,

            
            listBuilder: mstrmojo.ListBuilder,

            
            listSelector: mstrmojo.ListSelector,

            
            itemIdField: "dssid",

            
            itemField: "n",

            
            itemMarkup: null,
            
            
            itemMarkupFunction: null
        });
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.ListBase2");
    
    function _destroyItemWidgets(w){
        var c = w.ctxtBuilder;
        if (c) {
            var iws = c.itemWidgets,
                i;
            for(i=iws.length-1; i>-1; i--) {
                var iw = iws[i];
                if (iw) {
                    iw.destroy(true);
                }
            }
        }
    }
    
    
    mstrmojo.WidgetListBase = mstrmojo.declare(
        
        mstrmojo.ListBase2,
        
        null,
        
        
        {
            
            scriptClass: "mstrmojo.WidgetListBase",
            
            
            unrender: function unrn(ignoreDom){
                var c = this.ctxtBuilder;
                if (c) {
                    var iws = c.itemWidgets,i;
                    for (i=iws.length-1; i>-1; i--) {
                        var iw = iws[i];
                        if (iw && iw.hasRendered) {
                            iw.unrender(true);
                        }
                    }
                }
                this._super(ignoreDom);
            },

            refresh: function refresh(postUnrender){
                _destroyItemWidgets(this);
                if(this._super){
                    this._super(postUnrender);
                }
            },
            
            
            destroy: function dst(skipCleanup) {
                _destroyItemWidgets(this);

                this._super(skipCleanup);
            }
            
        });


})();
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo.android._IsList",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    
    function cleanUpMenu() {
        
        var handler = this._tchHandler;
        if (handler) {
            
            handler.clear();
            delete this._tchHandler;
        }

        
        this.clearSelect();

        
        mstrApp.setMenuStatus(this.id, false);
    }

    
    mstrmojo.android.ui.Menu = mstrmojo.declare(
        mstrmojo.ListBase,

        [ mstrmojo.android._IsList, mstrmojo._TouchGestures ],

        
        {
            scriptClass: 'mstrmojo.android.ui.Menu',

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, 'mstrmojo-ActionMenu');
                
                this._lastVisible = this.visible;
            },

            
            setMaxWidth: false,

            markupMethods: {
                onvisibleChange: function () {
                    var isVisible = !!this.visible,
                        domNode = this.domNode,
                        domNodeStyle = domNode.style;

                    
                    domNodeStyle.display = (isVisible) ? this.cssDisplay : 'none';
                    
                    
                    if (this.parent && this.parent.propogateMenuVisibleChange && isVisible != this._lastVisible) {
                    	this._lastVisible = isVisible;
                    	this.parent.propogateMenuVisibleChange(isVisible);
                    }
                    
                    
                    if (isVisible && this.setMaxWidth) {
                        
                        domNodeStyle.maxWidth = (Math.round(mstrApp.getScreenDimensions().w * 0.98) - mstrmojo.dom.position(domNode).x) + 'px';
                    }
                }
            },

            onvisibleChange: function onvisibleChange(evt) {
                
                if (evt.value) {
                    
                    var id = this.id;
                    this._tchHandler = mstrmojo.touchManager.attachEventListener('touchesBegin', id, function (evt) {
                        
                        if (evt.srcId !== id) {
                            
                            this.set('visible', false);

                            
                            evt.ignore = true;
                        }
                    });

                    
                    mstrApp.setMenuStatus(id, true);

                } else {
                    
                    cleanUpMenu.call(this);
                }
            },

            onUnRender: function onUnRender() {
                
                cleanUpMenu.call(this);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo.array",
                         "mstrmojo.css");

    var $ARR = mstrmojo.array,
        $CSS = mstrmojo.css,
        $MATH = Math,
        cssFixed = 'fixed';

    
    function positionTabs(selectedIdx, offset) {
        var domNode = this.domNode,
            width = domNode.clientWidth,
            map = this._itemSizeMap,
            preIdx = selectedIdx - 1,
            postIdx = selectedIdx + 1;

        
        offset = offset || 0;

        
        $ARR.forEach(this.itemsContainerNode.childNodes, function (node, idx) {
            
            var left = 0;

            
            if (idx === selectedIdx) {
                
                left = (width / 2) - (map[idx] / 2);

            
            } else if (idx === postIdx) {
                
                left = width - map[idx];

            
            } else if (idx !== preIdx) {
                
                left = -(width / 2);

                
                if (idx > postIdx) {
                    
                    left = width + (-1 * left);
                }
            }

            
            var leftPosition = $MATH.round(left + offset / 2) + 'px';
            if (node.style.left !== leftPosition) {
                
                node.style.left = leftPosition;
            }

            
            node.style.left = (left + offset / 2) + 'px';
        });
    }

    
    mstrmojo.android.ui.ScrollableTabs = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList ],

        
        {
            scriptClass: 'mstrmojo.android.ui.ScrollableTabs',

            multiSelect: false,

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, 'mstrmojo-ScrollableTabs');
            },

            
            setCurrentTab: function setCurrentTab(idx) {
                
                this.clearSelect();

                
                this.singleSelect(idx, true);

                
                this.itemRenderer.select(this._getItemNode(idx), this.items[idx], idx, this);

                
                positionTabs.call(this, idx);
            },

            
            tabSelected: mstrmojo.emptyFn,


            
            postitemsChange: function postitemsChange() {
                
                var itemSizeMap = this._itemSizeMap = [],
                    items = this.items,
                    domNode = this.domNode;

                
                if (items && items.length) {
                    
                    $ARR.forEach(this.itemsContainerNode.childNodes, function (node, idx) {
                        
                        itemSizeMap[idx] = node.offsetWidth;
                    });
                } else {
                    
                    this.set('visible', false);
                }

                
                $CSS.addClass(domNode, cssFixed);

                
                positionTabs.call(this, $MATH.max(this.selectedIndex || 0, 0));

                window.setTimeout(function () {
                    
                    $CSS.removeClass(domNode, cssFixed);
                }, 0);
            },

            
            postselectionChange: function postselectionChange(evt) {
                
                var added = evt.added;
                if (added) {
                    
                    this.tabSelected(this.items[added[0]]);
                }
            },

            
            enterScroll: function enterScroll() {
                
                $CSS.addClass(this.domNode, cssFixed);
            },

            
            scroll: function scroll(delta) {
                
                positionTabs.call(this, this.selectedIndex, delta);
            },

            
            exitScroll: function exitScroll(idx) {
                
                $CSS.removeClass(this.domNode, cssFixed);

                
                this.setCurrentTab(idx);
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._IsList");

    var markup;

    
    mstrmojo.SuggestionList = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._IsList ],

        
        {
            scriptClass: 'mstrmojo.SuggestionList',

            itemField: 'n',

            getItemMarkup: function (item, idx) {
                
                if (!markup) {
                    var itemField = this.itemField;
                    markup = this._super(item).replace('>{@n}<', ' title="{@' + itemField + '}">{@' + itemField + '}<');
                }

                
                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    itemField = this.itemField;

                
                props[itemField] = item[itemField];

                return props;
            },

            onclick: function onclick(evt) {
                this._super(evt);

                var parent = this.parent,
                    opener = parent.opener;

                
                opener.suggestionShown = false;

                
                var item = this.selectedItem;
                if (item) {
                    
                    opener.handleSuggestionItemSelect(item);
                }

                
                parent.close();
            },

            bindings: {
                itemField: 'this.parent.opener.itemField',
                items: 'this.parent.opener.suggestionItems'
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo.android._IsList",
                         "mstrmojo.android._HasLingeringListSelections",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.css");

    var itemMarkup,
    	$D = mstrmojo.dom,
    	$TRANS_DURATION = $D.CSS3_TRANSITION_DURATION;

    
    mstrmojo.android.ui.ActionToolbarButtons = mstrmojo.declare(
        mstrmojo.ListBase,

        [ mstrmojo.android._IsList, mstrmojo.android._HasLingeringListSelections, mstrmojo._TouchGestures ],

        
        {
            scriptClass: 'mstrmojo.android.ui.ActionToolbarButtons',

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, 'mstrmojo-ActionToolbar-buttons');
            },

            cssDisplay: 'table',

            icnCssText: 'display:table-row',

            getItemMarkup: function getItemMarkup(item) {
                if (!itemMarkup) {
                    itemMarkup = this._super(item).replace('>{@n}', ' title="{@n}"><div></div>');
                }

                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx);

                
                props.addCls(item.cls);

                
                return props;
            },

            listHooks: {
                select: function (el) {
                    
                    el.style[$TRANS_DURATION] = 0;

                    
                    this.setClearHandler(200);
                },
                unselect: function (el) {
                    
                    el.style[$TRANS_DURATION] = '300ms';
                }
            },

            preselectionChange: function preselectionChange(evt) {
                
                if (evt.added) {
                    
                    return !!this.parent.active;
                }

                
                return true;
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.Button",
                         "mstrmojo.url");

    mstrmojo.requiresDescs(1442, 2140);
    
    var $NIB = mstrmojo.Button.newInteractiveButton;

    mstrmojo.android.inputControls.SignatureDIC = mstrmojo.declare(

        mstrmojo.Widget,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: 'mstrmojo.android.inputControls.SignatureDIC',

            markupString: '<div></div>',

            
            hasSignature: false,

            
            showInPopup: function showInPopup() {
                var ownerObj = this.ownerCell || this.owner;

                
                if (ownerObj.mdf) {
                    var me = this;
                    mstrmojo.confirm('Continuing will erase the existing signature. Do you want to proceed?', [ $NIB(mstrmojo.desc(2140, 'Cancel'), null, null), $NIB(mstrmojo.desc(1442, 'Ok'), function () {
                        me.captureSignature();
                    }, null) ]);
                } else {
                    this.captureSignature();
                }
            },

            
            captureSignature: function captureSignature() {
                mstrMobileApp.captureSignature(JSON.stringify({
                    serverURL: mstrApp.getConfiguration().getTaskUrlByProject(mstrApp.getCurrentProjectId()),
                    sessionState: mstrApp.getSessionState(),
                    showGuideLine: this.dic.sgl
                }), 'mstrmojo.all["' + this.id + '"].signatureCaptured');
            },

            
            signatureCaptured: function signatureCaptured(imagePath) {
                this.value = mstrmojo.url.getAbsoluteURL(imagePath, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());

                this.applyChanges();
            },

            renderPreview: function renderPreview() {
                var previewValue = '',
                    ownerObj = this.ownerCell || this.owner,
                    openerNode = this.openerNode,
                    sigValue = this.value;

                
                if (ownerObj.mdf && /^(http|https).+(png|jpg)$/.test(sigValue)) {
                    previewValue = '<img src="' + this.value + '" style="max-height:' + openerNode.clientHeight + 'px;max-width:' + (openerNode.clientWidth - 30) + 'px;"></img>\u00a0';
                }

                this.renderPreviewButton(openerNode, previewValue);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.OfflineTransactionModel",
                         "mstrmojo.Button");

    
    mstrmojo._CanSupportOfflineTransactions = mstrmojo.provide(
        "mstrmojo._CanSupportOfflineTransactions",
        {
            _mixinName: "mstrmojo._CanSupportOfflineTransactions",

            getTransactionNotificationController: function getTransactionNotificationController() {
                var ctl = this.txNtfCtlr;

                
                if (this.oflnTxModel && (!ctl || !mstrmojo.all[ctl.id])) {
                    ctl = this.txNtfCtlr = mstrApp.controllerFactory.newController('Transactions', {
                        model: this.oflnTxModel,
                        rootCtrl: mstrApp.rootController
                    });
                }

                return ctl;
            },

            submitTransactionQueue: function submitTransactionQueue(projectId, taskId) {
                mstrMobileApp.submitOfflineTransactions(projectId, taskId, 'mstrApp.onSubmitTransactionQueueDone');
            },

            
            onSubmitTransactionQueueDone: function onSubmitTransactionQueueDone(status, res) {
                if (this.oflnTxModel) {
                    this.oflnTxModel.onSubmitDone(status);
                }

                
                if (status) {
                    
                    mstrApp.rootController.generateActionToolbar();
                    mstrmojo.toast(mstrmojo.desc(9724, 'All pending transactions have been successfully submitted'));
                } else {
                    mstrmojo.toast(mstrmojo.desc(9261, 'A background transaction submission failed'));
                }
            },

            submitOfflineTransaction: function submitOfflineTransaction() {
                if (this.oflnTxModel) {
                    this.oflnTxModel.submitOfflineTransaction();
                }
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Button",
                         "mstrmojo.css",
                         "mstrmojo.hash");

    var $CSS = mstrmojo.css,
        $HASH = mstrmojo.hash,
        cssGlow = 'glow';

    
    var $BTN = mstrmojo.android.ui.Button = mstrmojo.declare(
        mstrmojo.Button,

        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: 'mstrmojo.android.ui.Button',

            onclick: mstrmojo.emptyFn,

            touchBegin: function touchBegin() {
                
            	if ( this.enabled ) {
                    $CSS.addClass(this.domNode, cssGlow);
            	}
            }, 

            touchTap: function touchTap(touch) {
                
            	if ( this.enabled ) {
	                this.onclick({
	                    e: touch.evt
	                });
            	}
            },

            
            touchSelectBegin: mstrmojo.emptyFn,

            touchSelectEnd: function touchSelectEnd(touch) {
                
            	if ( this.enabled ) {
                    this.onclick({
                        e: touch.evt
                    });
            	}
            },

            touchEnd: function touchEnd() {
                
                $CSS.removeClass(this.domNode, cssGlow);
            }
        }
    );

    
    $BTN.prototype.markupString = $BTN.prototype.markupString.replace(new RegExp(' mstrAttach:[a-zA-Z,]*'), '');

    
    $BTN.newButton = function newButton(text, fnClick, props) {
        
        var btn = {
            scriptClass: 'mstrmojo.android.ui.Button',
            text: text
        };

        
        if (fnClick) {
            btn.onclick = fnClick;
        }

        
        $HASH.copy(props, btn);

        return btn;
    };
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Button");
    
    
    mstrmojo.HTMLButton = mstrmojo.declare(
        
        mstrmojo.Button,
        
        
        null,
        
        
        {
            scriptClass: 'mstrmojo.HTMLButton',
                        
            markupString: '<input id="{@id}" type="button" class="mstrmojo-text mstrmojo-HTMLButton {@cssClass} {@iconClass}" '
                            + 'title="{@title}" style="{@cssText}" ' 
                            + 'mstrAttach:click />',

            markupSlots: {
                inputNode: function(){ return this.domNode; }
        	},

            markupMethods: {
                onvisibleChange: function() {this.domNode.style.display = this.visible ? 'inline' : 'none'; },
                onenabledChange: function(){ 
                    
                    mstrmojo.css[this.enabled ? 'removeClass' : 'addClass'](this.domNode, ['disabled']);
                },
                onselectedChange: function() {
                    mstrmojo.css[this.selected ? 'addClass' : 'removeClass'](this.domNode, ['selected']);
                },
                ontextChange: function() {
                	this.inputNode.value = this.text != null ? this.text : '';
                },
                oniconClassChange: function(){
                    this.domNode.className = "mstrmojo-text mstrmojo-HTMLButton " + this.cssClass + " " + this.iconClass + (this.enabled? '' : ' disabled'); 
                }
            }
        }
    );
        
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Calendar",
                         "mstrmojo._TouchGestures");
    
    
    mstrmojo.MobileCalendar = mstrmojo.declare(
        
        mstrmojo.Calendar,
        
        [mstrmojo._TouchGestures],
        
        
        {
            scriptClass: "mstrmojo.MobileCalendar",
            
            
            cssPrefix: 'mobile-calendar',

            
            monthNames: function(i){ return mstrmojo.locales.datetime.MONTHNAME_FULL[i]; },
            
            
            
            supportedViews: {
                day: true,
                month: true,
                year: true
            },
            
            
            premousedown: function premousedown(e) {
                
                if (!mstrApp.isTouchApp()) {
                    return this._super(e);
                }
            },
            
            
            touchTap: function touchTap(touch) {
                
                this.processEvent(document.elementFromPoint(touch.pageX, touch.pageY));
                
                return false;
            }
        }
    );
    
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
            "mstrmojo.color",
            "mstrmojo.css",
            "mstrmojo.GridBase");

    var $C = mstrmojo.css,
        $CLR = mstrmojo.color;
    
    
    function findContainerByMethodName(w, func) {
        var anc = w && w.parent;
        while (anc && anc.scriptClass.indexOf('DocPanelStack') === -1) {
            if(func in anc) {
                return anc;
            }
            anc = anc.parent;
        }
        return null;
    };
    
    function repaint(node) {
        var img = document.createElement('img');
        node.appendChild(img);
        node.removeChild(img);
    };
    
    function getTableRowCells(ri, grid) {
        var page = Math.floor(ri/grid.rowsPerPage),
            row = ri % grid.rowsPerPage,
            tbl = grid.tableNode.tBodies[page];
            r = tbl.rows[row].cells;

        return r;
    }
    
    
    function renderingCleanUp() {
        
        var timer = this._renderTimer;
        if (timer) {
            
            self.clearInterval(timer);
            
            
            delete this._renderTimer;
            
            
            this.renderingRows = false;
        }
    }
    
    mstrmojo.Grid = mstrmojo.declare(
        
        mstrmojo.GridBase,
        
        
        null,
        
        
        
        
        {
            scriptClass: "mstrmojo.Grid",

            
            rowsPerPage: 0,
            
            
            effectiveRh: 0,

            
            numPagesRendered: 0,
            
            
            totalPages: 0,
            
            
            pageStatus: null,
            
            
            _defaultPageHeight: 0,
            
            
            renderPause: 10,

            
            rhMin: 15,
            
            
            defaultRowsPerPage: 100,
            
            
            minRowsPerPage: 50,
                        
            
            init: function init_Grid( props) {
                
                this._super(props);
                
                
                this.forceFixedSizes = true;

            },

            
            
            
            initPageSettings: function intiPageSettings() {
                
                var p = this.parent,
                        rpp = this.defaultRowsPerPage;

                
                this.effectiveRh = this.rh || this.rhMin || 1;

                if(p && p.numRowFixed) {
                    
                    
                    
                    rpp = this.cp.getAvailableRowsCount();
                } else if (p && p.scrollboxHeightFixed) {
                    
                
                    
                    rpp = Math.ceil(p.scrollboxHeight/this.effectiveRh);
                    
                    
                    rpp = Math.max(rpp, this.minRowsPerPage);
                }

                this.pageStatus = [];
                
                
                this.rowsPerPage = rpp;

                this.initPageStatus(this.pageStatus);
                
                this._defaultPageHeight = this.rowsPerPage * this.effectiveRh;
            },            
            
            
            
            initPageStatus: function initPageStatus( pageStatus) {
                var rpp = this.rowsPerPage;
                
                this.totalPages = rpp && Math.ceil(this.cp.rc/rpp) || 0;
                pageStatus = pageStatus || this.pageStatus;

                
                for(var i=0;i< this.totalPages ;++i) {
                    
                    var startIndex = i*rpp,
                    endIndex = startIndex + rpp - 1,
                    dataAvailable = this.cp.isDataAvailable(startIndex, endIndex);

                    
                    if(!pageStatus[i]) {
                        pageStatus[i] = {};
                    }
                    
                    
                    pageStatus[i].onDemand = !dataAvailable;
                }
            },

            
            buildRendering: function buildRendering( tcn) {
                if (this.renderMode == "vscroll") {
                    
                    this.initPageSettings();

                    
                    var ps0 = this.pageStatus[0],
                            isOnDemand = ps0 && ps0.onDemand;
                    
                    this.start = 0;
                    this.end = -1;
                    
                    if(!isOnDemand) {
                        
    
                        
                        
                        this.end = Math.min(this.cp.rc, this.rowsPerPage) - 1;
                    }
                        
                    
                    
                    this.preRenderPages();
                    
                    
                    this.preRenderPage(0, !isOnDemand);
                }

                
                this._super();
                
                if (this.renderMode == "vscroll") {
                	var p = this.parent,
                	    me = this,
                    	setMinHeight = function() {
                            me.gridContainerNode.style[mstrmojo.css.MINHEIGHT] = (me.cp.rc * me.effectiveRh) + 'px';
                	    };
                    
                    
                	if (mstrmojo.dom.isIE7) {
                	    
                        this.gridContainerNode.style.zoom = '1';
                        window.setTimeout(setMinHeight,10);
                	} else {
                	    setMinHeight();
                	}
                	
                    
                    if (!this.connectedScrollbox) {
                        if (p && p.connectScrollbox) {
                            p.connectScrollbox(this);
                            this.connectedScrollbox = true;
                        }
                    }
                    
                    
                    this.postRenderPage(0, !isOnDemand);
                    this.postRenderPages();                    

                    
                    
                    var afc = p && !p.scrollboxHeightFixed && !p.numRowFixed;
                    if(afc && this.numPagesRendered >= this.totalPages && !isOnDemand) {
                        
                        this.postRenderingCleanup();
                    } else if(isOnDemand || afc) {
                        this.onscroll();
                    }
                } else {
                    this.configureActions();
                }
                
            },

            
            preRenderPages: function prePages() {
                
            },

            
            postRenderPages: function postPages() {
                this.configureActions();
            },
            
            configureActions: function configureActions() {
                
                var p = this.parent;
                if(p && p.configureActions) {
                    p.configureActions();
                }
            },
                        
            
            preRenderPage: function prePage( idx,  bFillCells) {
                
                this.pageNum = idx;
            },

            
            postRenderPage: function postPage( idx,  bFillCells,  el) {
                
                if (idx+1 > this.numPagesRendered) {
                	this.numPagesRendered = idx+1;
                }
                
                var arr = this.pageStatus,
                    status = arr[idx];
                if (!status) {
                    
                    status = arr[idx] = {};
                }
                if (bFillCells) {
                    
                    status.filled = true;
                    status.dirty = false;
                }
                
                
                
                
                var cnStyle = this.gridContainerNode.style;
                if(idx == this.totalPages - 1 && cnStyle) {
                    cnStyle[mstrmojo.css.MINHEIGHT]= '';    
                }
                
            },            
            
            
            invalidAllPages: function() {
                for(var i=0;i< this.totalPages ;++i) {
                    var ps = this.pageStatus[i];
                    if(ps.filled) {
                        ps.dirty = true;
                    }
                    ps.onDemand = true;
                    ps.filled = false;
                    ps.isDownloading = false;
                }
                this.thPosMap = [];
                this.posMap = [];
            },
            
            
            _startPageRenderThread: function startRndrThd() {
                var id = this.id;
                
                
                this.renderingRows = true;
                
                
                this._renderTimer = self.setInterval(function() {
                    try {
                        
                        var grid = mstrmojo.all[id];
                        
                        if (!grid) return;
                        
                        var pages = grid.getPagesToRender();
                        
                        
                        if (pages.length > 0) {
                            grid.preRenderPages();
                            grid.renderPages(pages);
                            grid.postRenderPages();
                            grid._postPagesClearup = true;  
                            
                        } else {
                            if (grid._postPagesClearup) {
                                grid.postRenderPagesCleanup();
                                grid._postPagesClearup = false;                                                    
                            }
                            
                            
                            renderingCleanUp.call(grid);
                            
                            if (grid.isRenderingComplete()) {
                                grid.postRenderingCleanup();
                            }
                        }
                        
                    } catch (ex) {
                        
                        renderingCleanUp.call(mstrmojo.all[id]);
                        
                        
                        throw ex;
                    }
                        
                }, this.renderPause);
            },
            
            
            onscroll: function onscroll(setMask) {
                
                if (!this.renderingRows) {
                    
                    if(setMask === true) {
                        var p = this.parent;
                        if(p && p.maskNode) {
                            $C.addClass(p.maskNode, 'wait');
                        }
                    }
                    this._startPageRenderThread();
                }
            },

            
            isRenderingComplete: function isRdrComplete() {
                
                if (this.end >= this.cp.rc - 1) {
                    
                    
                    for (var arr=this.pageStatus, i = this.totalPages-1; i >-1; i--) {
                        if (!arr[i] || !arr[i].filled) {
                        	return false;
                        }
                    }
                    return true;
                }
                return false;
            }, 
            
            
            renderPages: function renderPages( pages) {
                for(var i=0,len=pages.length;i<len;++i) {
                    this.renderPage(pages[i].idx, pages[i].fill);
                }
            },
            
            
            renderPage: function renderPage( idx,  bFillCells) {
                
                var arrStatus = this.pageStatus,
                    alreadyRendered = (this.numPagesRendered >= idx+1);
                if (alreadyRendered) {
                    
                    
                    if (!bFillCells || (arrStatus[idx] && arrStatus[idx].filled)) {
                    	return;
                    }
                }

                var rpp = this.rowsPerPage,
                    dn = this.domNode;
                
                
                this.start = idx * rpp;
                this.end = Math.min(this.start + rpp, this.cp.rc) - 1; 

                
                this.preRenderPage(idx, bFillCells);
                
                
                
                var tempTable = this.tempTable;
                if (!tempTable) {
                    tempTable = this.tempTable = dn.ownerDocument.createElement('div');
                }
                
                
                
                var tInnerHTML = bFillCells ?
                        this.buildTableRowsMarkup(this.start, this.end, '<table><tbody n="' + this.pageNum + '">', '</tbody></table>').join('') :
                            '<table><tbody n="' + this.pageNum + '"><tr><td style="height:' + (this.effectiveRh * (this.end-this.start+1))+ 'px">&nbsp;</td></tr></tbody></table>';
                        tempTable.innerHTML = tInnerHTML; 

                
                var tbody = tempTable.firstChild.tBodies[0],
                    tn = this.tableNode;
                
                
                
                if (!alreadyRendered) {
                    tn.appendChild(tbody);
                } else {
                    
                    tn.replaceChild(tbody, tn.tBodies[idx]);
                }
                                
                
                this.postRenderPage(idx, bFillCells, tbody);
            },
            
            
            getPagesToRender: function getPagesToRender() {
                var pages = [],
                    p = this.parent,
                    
                    pageSize  = this._defaultPageHeight,
                    tBodies = null,
                    stats = this.pageStatus,
                    me = this;
                    
                
                function pageHeight(idx) {
                    
                    var stat = stats[idx];
                    if (stat && (stat.filled || stat.dirty)) {
                        
                        if (!stat.height) {
                            if (!tBodies) {
                            	tBodies = me.tableNode.tBodies;
                            }
                            stat.height = tBodies[idx].offsetHeight;
                        }
                        return stat.height;
                    } else {
                        
                        return pageSize;
                    }
                }

                
                
                var y = 0,
                    topPageIdx = null,
                    bottomPageIdx = null,
                    scrollTop = p.scrollboxTop;
                for (var i=0, len=this.totalPages, arr = this.pageStatus; i<len; i++) {
                    y += pageHeight(i);
                    if (y >= scrollTop) {
                        topPageIdx = i;
                        break;
                    }
                }
                
                if (topPageIdx === null) {
                    
                    topPageIdx = bottomPageIdx = len-1;
                } else {
                    
                    var scrollBottom = p.scrollboxBottom;
                    
                    
                    
                    
                    if(isNaN(scrollBottom) && p.numRowFixed) {
                        scrollBottom = scrollTop;
                    }
                    
                    for (var j=topPageIdx+1; j<len; j++) {
                        
                        
                        
                        if (y > scrollBottom) {
                            bottomPageIdx = j-1;
                            break;
                        }
                        y += pageHeight(j);
                    }
                }
                
                if (bottomPageIdx === null) {
                    bottomPageIdx = len-1;
                }
                
                
                for(var n=this.numPagesRendered;n<topPageIdx;++n) {
                    pages.push({idx: n, fill: false});
                }                   
                
                
                
                var arrStats = this.pageStatus,
                        numRowsToDownload = 0,
                        rpp = this.rowsPerPage,
                        showStatus = false;
                
                for (var m=topPageIdx;m<=bottomPageIdx;++m) {
                    var stat = stats[m];
                    if (!stat || !stat.filled) {
                        
                        if(stat && stat.onDemand) {
                            showStatus = true;
                            
                            
                            
                            if(!stat.isDownloading && !this.isDownloading){ 
                                numRowsToDownload += rpp; 
                                stat.isDownloading = true;
                                this.isDownloading = true;
                                var startIndex = m*rpp,
                                        endIndex = startIndex + rpp - 1;
                                
                                
                                this.cp.download(startIndex, endIndex);
                                
                            }
                            
                            
                            pages.push({idx: m, fill: false});
                        } else {
                            pages.push({idx: m, fill: true});
                        }
                    }
                }

                
                if(showStatus) {
                	this.parent.showDownloadStatus(numRowsToDownload);
                } else {
                    if (this.parent.closeDownloadStatus) this.parent.closeDownloadStatus();
                }
                
                return pages;
            },            

            
            addHilitePosition: function(key, row, cell) {
                var hm = this.hiliteCellsMap[key];
                if(!hm) {
                    this.hiliteCellsMap[key] = {pos: [], nodes: []};
                }
                var r = row - (this.pageNum || 0) * this.rowsPerPage;
                this.hiliteCellsMap[key].pos.push({row: r, cell: cell, page: this.pageNum});                
            },
            
            
            setHilites: function(key, node) {
                var ei = node.getAttribute('ei'),
                    pos = this.eiMap[ei],
                    arr = this.getNodesByPositions(pos);
                
                if(!arr.length) {
                    this._super(key, node);
                    return ;
                }
                
                for(var i = 0, iLens = arr.length; i < iLens; i++) {
                    this._super(key, arr[i]);
                }
            },
            
            addExtraInfoMap: function(ei, row, cell) {
                if(!this.eiMap[ei]) {
                    this.eiMap[ei] = [];
                }
                
                this.eiMap[ei].push(this.getPosObj(row, cell));
            },            
            
            addPositionMap: function(ei, row, cell){
                
                if(!this.posMap[ei]) {
                    this.posMap[ei] = this.getPosObj(row, cell);
                }
            },
            
            addTitleHeaderPositionMap: function(row, cell, o){
                var pos = this.getPosObj(row, cell);
                pos.obj = o;
                this.thPosMap.push(pos);
            },

            getPosObj: function(r, c){
                return {row: r - this.pageNum * this.rowsPerPage, cell: c, page: this.pageNum};
            },
            
            getNodeByPosition: function(pos) {
                return this.tableNode.tBodies[pos.page].rows[pos.row].cells[pos.cell];
            },            
            
            getRowIdxByCell: function(cell) {
                var pos = this.posMap[cell._ei];
                return pos.page * this.rowsPerPage + pos.row;
            },
            
                        
            getNodesByPositions: function(pos) {
                var arr = [];
                
                for(var i in pos) {
                    var v = pos[i],
                        p = (v && v.page) || 0,
                        r = v && v.row,
                        c = v && v.cell;
                    
                    arr.push(this.tableNode.tBodies[p].rows[r].cells[c]);
                }
                
                return arr;
            },
            
            
            getPageHeight: function getPageHeight(idx) {
                var tbd = this.tableNode.tBodies;
                return (tbd && tbd[idx] && tbd[idx].offsetHeight) || 0;
            },
            
            
            getTargetCell: function(x, y) {
                var h = 0, 
                    i = 0;
                
                
                for(var len = this.totalPages; i < len; i++) {
                    h += this.getPageHeight(i);
                    if(y <= h) {
                        break;
                    }
                }
                var tbody = this.tableNode.tBodies[i];

                if (tbody){
                    
                    for(var i = 0, len = tbody.rows.length; i < len; i++) {
                        var row = tbody.rows[i];
                        
                        for(var j = 0, jLen = row.cells.length; j < jLen; j++) {
                            var cell = row.cells[j];
                            
                            if(cell.offsetTop + cell.offsetHeight >= y) {
                                
                                if(x >= cell.offsetLeft && x <= cell.offsetLeft + cell.offsetWidth) {
                                    return cell;
                                }
                            } else {
                                break;
                            }
                        }
                    }
                }
            },
            
            postRenderPagesCleanup: function _postRenderPagesCleanup() {
                var p = this.parent;
                
                if(p && p.gridData && p.gridData.afc) {
                    var tb = this.tableNode;
                    
                    if(tb && (this.lastWidth != tb.offsetWidth)) {
                        if(p.onGridWidthChanged) {
                            p.onGridWidthChanged();
                        }
                        mstrmojo.array.forEach(this.pageStatus, function(s) {
                            delete s.height;
                        });
                        this.lastWidth = tb.offsetWidth;
                    }
                    var w = findContainerByMethodName(p, 'adjustAutoWidth');
                    if(w) {
                        w.adjustAutoWidth(p);
                    }
                }
                
                if(p.gridPagesRendered) {
                    p.gridPagesRendered();
                }                
                
                
                if(mstrmojo.dom.isIE && !mstrmojo.dom.isIE8) {
                    repaint(this.domNode);
                }
                
                
                if(p && p.maskNode) {
                    $C.removeClass(p.maskNode, 'wait');
                }
                
                this.hightLightChangedCells();
            },
            
            hightLightChangedCells: function hightLightChangedCells() {
                var ucs = this.cp.getUpdatedRows(),
                    me = this, cells,
                    r, rcells, ci, i, c, ri, doms = [];
                if(ucs) {
                    
                    mstrmojo.hash.forEach(ucs, function(v, k) {
                        ri = parseInt(k, 10);
                        cells = me.cp.getRowCells(ri);
                        r = getTableRowCells(ri, me);
                        rcells = r.length;
                        ci = cells.length - 1;
                        
                        if(ci >= 0) {
                            for(i = rcells - 1; i >= 0; i--) {
                                c = r[i];
                                if(ci<0) {
                                    break;
                                }
                                if(cells[i]._d) {
                                    var bgColor = c.style.backgroundColor,
                                        ftColor = c.style.color;
                                    doms.push({dom: c, bgcolor: bgColor, ftcolor: ftColor});
                                    c.style.backgroundColor = $CLR.getHighlightColor($CLR.rgbStr2rgb(mstrmojo.css.getStyleValue(c, 'backgroundColor'), true));
                                    c.style.color = $CLR.getContrastingColor($CLR.rgbStr2hex(mstrmojo.css.getStyleValue(c, 'backgroundColor')), ['#ffffff', '#000000']);
                                    delete cells[i]._d;
                                }
                                ci--;
                            }
                        }
                    });
                    
                    if(doms.length > 0) {
                        window.setTimeout(function() {
                            mstrmojo.array.forEach(doms, function(domCell) {
                                
                                domCell.dom.style.backgroundColor = domCell.bgcolor;
                                domCell.dom.style.color = domCell.ftcolor;
                            });
                        }, 300);
                    }
                }
            },
            
            
            getRowInfoByPosition: function (y) {
                return this.cp.getRowCellInfo(y);
            },
            
            
            postRenderingCleanup: function _postRenderingCleanup() {
                var p = this.parent;
                
                if (p && this.connectedScrollbox) {
                	p.disconnectScrollbox(this);
                }
                this.connectedScrollbox = false;  
                
                
                if (p && !p.scrollboxHeightFixed) {
                   var c = findContainerByMethodName(p, 'performCanGrowCanShrink');
                   if (c) {
                	   c.performCanGrowCanShrink([p], true);
                   }
                }             
            },
            
            unrender: function unrender(ignoreDom) {
                
                renderingCleanUp.call(this);
                
                
                if (this.connectedScrollbox) {
                    this.parent.disconnectScrollbox(this);
                    this.connectedScrollbox = false;
                }
                
                this.numPagesRendered = 0;
                this.lastWidth = 0;
                this.isDownloading = false;
                
                this._super(ignoreDom);
            },
            
            dataDownloaded: function dataDownloaded() {
                this.isDownloading = false;
                this.initPageStatus();
                this.onscroll();
            }
        }
    );
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.XtabModel",
                         "mstrmojo.array",
                         "mstrmojo.func");
    
    var MX = 'Metrics',
        SELECTOR_ACTION = 2;
    
    
   function _resolveCGBToTKS(cgbMap) {
       
       if (!cgbMap) return;
       
       var scm = this.scm,
           delim = '\u001E',
           i = 0,
           id = null,
           curSelector = null,
           cgb = null,
           cgbKey = null,
           targetKey = null,
           updatedTks = false;
       
       for (id in scm) {
           curSelector = scm[id];
           cgb = curSelector.cgb;
           
           
           
           for (i in cgb) {
               cgKey = cgb[i];
               targetKey = cgbMap[cgKey];
               
               
               if (targetKey) {
                   if (!curSelector.tks){
                       curSelector.tks = targetKey;
                       updatedTks = true;
                   } else if (curSelector.tks && (curSelector.tks.indexOf(targetKey) < 0)) {
                       curSelector.tks += delim + targetKey;
                       updatedTks = true;
                   }
               }
           }
       }
       
       return updatedTks;
   }
    
    function createSelectorMap () {
        var data = this.data,
            gridTitles = data.gts;
        
        
        if (!gridTitles) {
            
            return;
        }
        
        var map;
        
        
        mstrmojo.array.forEach([ gridTitles.row, gridTitles.col ], function (axis) {
            
            for (var i = 0, cnt = axis.length; i < cnt; i++) {
                
                var unit = axis[i];
                if (unit.sc) {
                    
                    map = map || {};
                    
                    
                    map[unit.id || MX] = unit.sc;
					
					if (unit.fid) { 
						map[unit.id + "_"+ unit.fid] = unit.sc;
					}
                }
            }
        });
        
        this.scm = map;
        
        _resolveCGBToTKS.call(this, this.docModel.getCGBMap());
    }
    
    function submitToDataService(methodName, args) {
        var dataService = this.getDataService();
        dataService[methodName].apply(dataService, args);
    }

    
    mstrmojo.DocXtabModel = mstrmojo.declare(
        mstrmojo.XtabModel,
        
        null,
        
        
        {            
            scriptClass: "mstrmojo.DocXtabModel",
            
            docModel: null,
            
            init: function init(props) {
                this._super(props);
                
                this.docModel.attachEventListener('CGBMapChange', this.id, function(evt) {
                    
                });                
            },
            
            ondataChange: function ondataChange(evt) {
                createSelectorMap.call(this);
            },
            
            getMessageId: function getMessageId() {
                return this.docModel.mid;
            },
            
            getDataService: function getDataService() {
                return this.docModel.getDataService();
            },            
            
            getAction: function getAction(cells, domNode, isReselect) {
                var cell = cells[0],
                    actionType = cell && cell.at;

                var action;
                
                if (actionType) {
                    
                    if (actionType & SELECTOR_ACTION) {
                        
                        var titleInfo = this.getCellTitleInfo(cell),
                            title = titleInfo && titleInfo.title,
                            titleId = title && title.id,
                            selectorControlMap = this.scm;
                    
                        
                        this.sti = {
                            titleId: titleId || MX
                        };
                        
                        
                        var sc = (titleId && selectorControlMap[titleId]) || selectorControlMap[MX];
                        
                        
                        if (sc) {
                            var xtab = this.xtab,
                                shouldDeselectCurrentCell = (xtab.allowToggleSelections && sc.all && isReselect),
                                selectAllElements = (titleInfo.isSrcTitle || shouldDeselectCurrentCell);
                            
                            this.sti.deselectCurrent = shouldDeselectCurrentCell;
                            
                            
                            action = {
                                h: 'onGridSelector',
                                a: {
                                    type: mstrmojo.EnumRWUnitType.GRID,
                                    anchor: domNode,
                                    ck: sc.ck,
                                    tks: sc.tks,
                                    eid: selectAllElements ? 'OA:(All)' : cell._e.id,
                                    ctlKey: sc.ckey,
                                    sliceId: xtab.sid,
                                    isUConDS: sc.isUConDS
                                }
                            };
                        }        
                    }
                }
                
                
                if ( ! action ) {
                    var action = this._super(cells);
                }
                
                if ( action && action.a ) {
                    action.a.sliceId = this.xtab.sid;
                }
                return action;

            },
            
            getDownloadAction: function getDownloadAction( rowPosition,  maxRows,   colPosition,  maxCols,  widgetID,  memo) {
                
                var action = this._super(rowPosition, maxRows, colPosition, maxCols, widgetID, memo);
                action.sliceId = this.xtab.sid;
                return action;
            },
            
            
            getDrillAction: function getDrillAction(cells) {
                var action = this._super(cells);                
                action.srcMsgId = this.docModel.mid;
                
                return action;
            },    
            
            sort: function sort (params, callback) {
                
                submitToDataService.call(this, 'sort', arguments);
            },
            
            pivot: function pivot (params, callback) {
                
                submitToDataService.call(this, 'pivot', arguments);
            },
            
            drillGrid: function drillGrid (params, callback) {
                submitToDataService.call(this, 'drillGrid', arguments);
            },
            
            downloadGridData: function downloadGridData (params, callback) {
                submitToDataService.call(this, 'downloadGridData', arguments);
            },
            
            loadLayout: function loadLayout(res) {
                
                this.docModel.loadLayout(res);
            }
        }
    );
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.DocXtabModel",
                         "mstrmojo.array",
                         "mstrmojo.func");
    
    var SELECTOR_ACTION = 2;
    var ROW_AXIS = 1,
    COL_AXIS = 2;

    
    mstrmojo.DocVisModel = mstrmojo.declare(
        mstrmojo.DocXtabModel,
        
        null,        
      
        {            
            scriptClass: "mstrmojo.DocVisModel",
            
            getAction: function getAction(cells) {
                var cell = cells[0],
                    actionType = cell && cell.at;

                var action;
                
                if (actionType) {
                    
                    if (actionType & SELECTOR_ACTION) {
                        
                    	action = { 
                            h: 'onVisSelector',
                            a: this.getSelectAction(cell)
                        };       
                    }
                }
                
                
                if ( ! action ) {
                	action = this.getActionObject(cells);
                }
               
                return action;
            },
            
            getSelectAction: function getSelectAction(actionObj){
				var scObjList = actionObj.scObjList,
	        		scObjListLength = scObjList.length,
	        		action = null;
	        		
	        	if(scObjListLength > 1){
	        		
	        		action = { 
						multiSelect: true,
						type: mstrmojo.EnumRWUnitType.GRID,
						src: actionObj.k,						
						sliceId: 1,
						sid:1,
						anchor: actionObj.anchor,
						selectorObjects: []
					};
					
	        		
	        		var scTks = {};
	        		var strTks = '';
	        		for(var i = 0; i < scObjListLength; i++){
	        			var scObj = scObjList[i];
	        			
	        			
	        			var tksList = scObj.sc.tks.split("\x1E");
	        			for(var j = 0; j < tksList.length; j++){
	        				var target = tksList[j];
	        				if(!scTks[target]){
	        					scTks[target] = true;
	        					if(strTks.length > 0){
	        						
	        						strTks = strTks + '\x1E'+target;
	        					}else{
	        						strTks = target;
	        					}
	        					
	        				}
	        			}
	        				
	        		}
	        		
					for (var i = 0; i < scObjListLength; i++) {
						var scObj = scObjList[i];
						action.selectorObjects.push({ 
							ck: scObj.sc.ck,
							ctlKey: scObj.sc.ckey,
							tks: scObj.sc.tks,
							eid: scObj.eid
						});
					}
				
					if(!action.tks)
						action.tks = strTks;
					
	        	}else if(scObjListLength == 1){
	        		var scObj = scObjList[0];
	        		action = { 
						type: mstrmojo.EnumRWUnitType.GRID,
						src: actionObj.k,						
						sliceId: 1,
						sid:1,
						ck: scObj.sc.ck,
						ctlKey: scObj.sc.ckey,
						tks: scObj.sc.tks,
						eid: scObj.eid,
						anchor: actionObj.anchor
					};
	        	}
	            
	            return action;

			},
			
			getLinkAction: function getLinkAction(actionObj, idx) {
				var node = actionObj.node,
					title = node && node.titleInfo;    		
                
                return this.getLinkActionImpl(node, title, idx);
            },
            
            getPCellParentNode: function getPCellParentNode(pCell, axis){            	
            	return ( axis == ROW_AXIS ) ? pCell._lp : pCell._tp;
            },
            
            getPTitle: function getPTitle(pCell, axis){
            	return pCell.titleInfo;
            }
        }
    );
})();
(function(){

    mstrmojo.requiresCls(
            "mstrmojo.GridBase",
            "mstrmojo.Grid");

    
    mstrmojo.XtabZone = mstrmojo.declare(
        
        mstrmojo.Grid,

        
        null,

        
        {
            
            scriptClass: "mstrmojo.XtabZone",

            
            markupString: '<div id="{@id}" class="mstrmojo-XtabZone" style="position:relative;{@cssText}"></div>',

            
            markupSlots: {
                gridContainerNode: function(){ return this.domNode; }
            }
        }   
    );

}());

(function(){

    
    mstrmojo.XtabCP = mstrmojo.declare(
        null,

        
        null,

        
        {
            
            scriptClass: "mstrmojo.XtabCP",

            
            base:null,

            
            lookupBase:null,

            
            colWidths:null,

            
            forceAutoRowHeight:false,

            
            startIndexInContainer:0,

            
            updatedRows: null,

            
            preServeUpdatedRows: true,

            
            init:function init( props) {
                mstrmojo.hash.copy(props, this);
            },

            
            initContent: function initContent( startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || this.startIndexInContainer || 0;
                var s = this.base.show,
                items = this.base.items;
                this.rc =  s && items ? items.length : 0;
                this.colWidths = s && this.base.cws || [];
                this.isDownloading = false;
                this.isDownloaded = true;
                this.invalidData = false;
            },

            
            isDataAvailable:function isDataAvailable( startRow,  endRow) {
                return !this.invalidData;
            },

            
            download:function download( startRow,  endRow) {
                if(!this.isDownloaded && !this.isDownloading && this.dataSource) {
                    this.isDownloading = true;
                    this.dataSource.download(0);
                }
            },

            invalid:function invalid() {
                this.invalidData = true;
                this.isDownloading = false;
                this.isDownloaded = false;
                this.preServeUpdatedRows = true;
                if(this.gridData) {
                    this.oldGridData = this.gridData;
                    this.oldBase = this.base;
                    this.updatedRows = {};
                }
            },

            
            getRowHeight: function getRowHeight() {
                return this.gridData.rh;
            },
            
            
            getNumAutoHeightRows: function () {
                return this.forceAutoRowHeight ? this.rc : 0;
            },

            
            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.rc;
            },

            getUpdatedRows: function getUpdatedRows() {
                return this.updatedRows;
            },

            
            getRowCells: function ( ri) {
                var bi = this.base.items,
                    r = bi[ri],             
                    cells = r.items,
                    lb = this.lookupBase,
                    ics = this.interactiveCellsArray,
                    cssBase = this.gridData.css,
                    e = null,
                    totalSet = false,
                    oldGd, oldBase, oldItems, oldCells;

                if(this.oldGridData) {
                    oldGd = this.oldGridData;
                    oldBase = this.oldBase;
                    oldItems = oldBase && oldBase.items;
                    oldCells = oldItems[ri] && oldItems[ri].items;
                }

                for (var ci=0, len=cells && cells.length || 0; ci<len; ci++) {
                    var cell = cells[ci];
                    if (cell) {
                        cell.v = cell.v || cell.n;
                        if (lb && !cell._e) {
                            var unit = lb[cell.tui];
                            e = unit && unit.es[cell.idx];
                            if (e) {
                                cell.v = cell.v || e.n; 
                                if(e.rv) {
                                    cell.rv = e.rv;
                                }
                                
                                cell._e = e;
                            }
                        }
                        if(!cell.css) {
                            cell.css = cssBase[cell.cni].n;
                        }

                        
                        if(!cell._d && oldCells && this.preServeUpdatedRows) {
                            var oldCell = oldCells[ci];
                            if(!oldCell || (oldCell.rs !== cell.rs)) {
                                this.preServeUpdatedRows = false;
                                this.updatedRows = {};
                            } else if((oldCell.v && cell.v !== oldCell.v)) {
                                data = {};
                                if(cell.v !== oldCell.v) {
                                    data.v = oldCell.v;
                                }
                                if(cell.css !== oldCell.css) {
                                    data.css = oldCell.css;
                                }
                                cell._d = data;
                                
                                this.updatedRows[this.startIndexInContainer + ri] = true;
                            }
                        }

                        
                        

                        
                        
                        cell._gd = this.gridData._bidx || 0;

                        
                        if(cell.at > 0 && ics) {
                            
                            if(cell._ei === undefined || ics[cell._ei] !== cell) {
                                cell._ei = ics.push(cell) - 1;
                            }

                        }
                        
                        if(this.axis) {
                            cell.axis = this.axis;
                        }

                        
                        var parentIndices = cell.pi;
                        if(parentIndices) {
                            
                            if(parentIndices.ri !== undefined && parentIndices.ci !== undefined) {
                                
                                cell._p = bi[parentIndices.ri].items[parentIndices.ci];
                            } else {
                                
                                var ghs = this.gridData.ghs,
                                        leftPi = parentIndices.left,
                                        topPi = parentIndices.top;

                                
                                if(leftPi) {
                                    cell._lp = ghs.rhs.items[leftPi.ri].items[leftPi.ci];
                                }

                             
                                if(topPi) {
                                    cell._tp = ghs.chs.items[topPi.ri].items[topPi.ci];
                                }
                            }
                        }

                    }
                }

                return cells;
            },

            
            getUnmergedCells: function getUnmergedCells(ri) {
                var ac = [],
                    rows = this.base.items,
                    cssBase = this.gridData.css,
                    cell = rows[ri].items[0], 
                    pi = cell && cell.pi, 
                    r = pi && pi.ri, 
                    c = pi && pi.ci; 

                while(pi && r > -1 && c > -1) {
                    
                    cell = cell._p || rows[r].items[c];
                    var _c = {};
                    
                    mstrmojo.hash.copy(cell, _c);
                    if(!_c.css) {
                        _c.css = cssBase[_c.cni].n;
                    }
                    
                    _c.rs = cell.rs - ri + r; 
                    
                    ac.splice(0, 0, _c);
                    
                    pi = cell && cell.pi;
                    r = pi && pi.ri;
                    c = pi && pi.ci;
                }

                return ac;
            }
        }
    );
})();

(function(){
    
    mstrmojo.XtabVACP = mstrmojo.declare(
        
        mstrmojo.XtabCP,

        
        null,

        
        {
            scriptClass: "mstrmojo.XtabVACP",

            
            cps:[],

            initContent: function initContent( startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || 0;
                this.rc = 0;
                this.type = 0;
                this.colWidths = [];
                for(var i=0;i<this.cps.length;++i) {
                    var cp = this.cps[i];
                    
                    cp.initContent(this.startIndexInContainer + this.rc);
                    this.rc += cp.rc;
                    this.type |= cp.type;
                    var cws = cp.colWidths;
                    
                    if(cws && (cws.length > this.colWidths.length)) {
                        this.colWidths = cws;
                    }
                }
            },

            getNumAutoHeightRows: function () {
                
                
                
                return this.cps[0].getNumAutoHeightRows();
            },

            
            getRowHeight: function getRowHeight() {
                return this.cps[0].getRowHeight();
            },            
            
            
            getRowCells: function ( ri) {
                var i = 0,
                cp = this.cps[i];

                
                while(ri >= cp.rc) {
                    
                    ri -= cp.rc;
                    cp = this.cps[++i];
                }
                return cp.getRowCells(ri);
            },

            
            
            getUnmergedCells: function(ri) {
                var i = 0,
                cp = this.cps[i];

                while(ri >= cp.rc) {
                    ri -= cp.rc;
                    cp = this.cps[++i];
                }

                return cp.getUnmergedCells(ri);
            },

            isDataAvailable:function isDataAvailable( startIndex,  endIndex) {
                var targetCPs = this._getCPs(startIndex, endIndex);

                for(var i=0;i<targetCPs.length;++i) {
                    if(!targetCPs[i].isDataAvailable(startIndex, endIndex)) {
                        return false;
                    }
                }

                return true;
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                var rowDownloaded = 0;

                for(var i=0;i<this.cps.length;++i) {
                    var cp = this.cps[i];
                    if(cp.isDataAvailable()) {
                        rowDownloaded += cp.getAvailableRowsCount();
                    }
                }

                return rowDownloaded;
            },

            _getCPs: function getCPs( startIndex,  endIndex) {
                var i = 0,
                cp = this.cps[i],
                si = cp && cp.startIndexInContainer,
                targetCPs = [];

                
                if(cp) {
                    startIndex -= si;
                    endIndex -= si;
                }

                
                while(cp && startIndex >= cp.rc) {
                    
                    startIndex -= cp.rc;
                    endIndex -= cp.rc;

                    
                    cp = this.cps[++i];
                }

                
                while(cp && endIndex >= cp.rc) {
                    endIndex -= cp.rc;
                    targetCPs.push(cp);
                    
                    cp = this.cps[++i];
                }

                
                if(cp) {
                    targetCPs.push(cp);
                }

                return targetCPs;
            },

            invalid: function invalid() {
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    tcp.invalid();
                }
                this.updatedRows = {};
            },

            getUpdatedRows: function getUpdatedRows() {
                var v = {};
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    if(!tcp.preServeUpdatedRows) {
                        return {};
                    } else {
                        mstrmojo.hash.copy(tcp.getUpdatedRows(), v);
                    }
                }
                this.updatedRows = v;
                return v;
            },

            download: function download( startIndex,  endIndex) {
                var targetCPs = this._getCPs(startIndex, endIndex);

                for(var i=0;i<targetCPs.length;++i) {
                    var tcp = targetCPs[i];
                    tcp.download(startIndex, endIndex);
                }
            }
        }
    );
})();

(function(){
    
    mstrmojo.XtabHACP = mstrmojo.declare(
        
        mstrmojo.XtabCP,

        
        null,

        
        {
            scriptClass: "mstrmojo.XtabHACP",

            
            cps:[],

            initContent: function initContent( startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || 0;
                this.type = 0;
                this.colWidths = [];

                for(var i=0;i<this.cps.length;++i) {
                    this.cps[i].initContent(this.startIndexInContainer);
                    this.type |= this.cps[i].type;

                    var cw = this.cps[i].colWidths;

                    
                    
                    if(cw) {
                        this.colWidths = this.colWidths.concat(cw);
                    }
                }

                this.rc = Math.max(this.cps[0].rc, this.cps[1].rc);

                
                
            },

            getNumAutoHeightRows: function () {
                return Math.max(this.cps[0].getNumAutoHeightRows(), this.cps[1].getNumAutoHeightRows());
            },

            getRowCells: function ( ri) {
                var cps = this.cps,
                    cells = [];
                for (var i=0,len=cps.length; i<len; i++) {
                    
                    
                    if (cps[i].getAvailableRowsCount() > 0 && cps[i].rc > ri) {
                        var tmp = cps[i].getRowCells(ri);
                        if (tmp) {
                            cells = cells.concat(tmp);
                        }
                    }
                }
                return cells;
            },

            
            getRowHeight: function getRowHeight() {
                return this.cps[0].getRowHeight();
            },            
            
            getUnmergedCells: function(ri) {
                return this.cps[0].getUnmergedCells(ri);
            },

            isDataAvailable:function isDataAvailable( startIndex,  endIndex) {
                
                return this.cps[1].isDataAvailable(startIndex, endIndex);
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return Math.max(this.cps[0].getAvailableRowsCount(), this.cps[1].getAvailableRowsCount());
            },

            invalid: function invalid() {
                var i, len, cp;
                for(i=0,len=this.cps.length; i<len; ++i) {
                    cp = this.cps[i];
                    cp.invalid();
                }
                this.updatedRows = {};
            },

            getUpdatedRows: function getUpdatedRows() {
                var v = {};
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    if(!tcp.preServeUpdatedRows) {
                        return {};
                    } else {
                        mstrmojo.hash.copy(tcp.getUpdatedRows(), v);
                    }
                }
                this.updatedRows = v;
                return v;
            },

            download: function download( startIndex,  endIndex) {
                var cp = this.cps[1];
                cp.download(startIndex, endIndex);
            }
        }
    );
})();

(function(){

    
    mstrmojo.XtabTitlesCP = mstrmojo.declare(
        
        mstrmojo.XtabCP,

        
        null,

        
        {
            scriptClass: "mstrmojo.XtabTitlesCP",

            init:function init( props) {
                this._super(props);
            },

            download:function download( startRow,  endRow) {
            },

            initContent: function initContent( startIndexInContainer) {
                this.startIndexInContainer = 0;
                
                
                if (!this.cts) {
                    this.cts = mstrmojo.hash.clone(this.gridData.gts.col);
                }
                
                
                var gts = this.gridData.gts,
                    isLockHeaders = (this.gridData.lhv !== 0),
                    rts = gts.row || [],
                    dataCts = gts.col || [],
                    s = gts.show,
                    rec = gts.rec,                  
                    cts = this.cts || [],
                    nRts = rts.length,              
                    nCts = cts.length,              
                    cssBase = this.gridData.css;    

                this.base = {
                    items:[]
                };

                
                this.rc = s && cts.length || 0;

                if (this.rc === 0 && s) {
                    
                    this.rc = nRts > 0 ? 1 : 0;
                }

                this.colWidths = s && gts.cws || [];

                
                if(!this.rc) {
                    return;
                }

                
                var cells = {items:[]},
                    lrs = 1,
                    lastCell,               
                    i;

                
                for(i = 0; i < nRts; ++i) {
                    rts[i].axis = 1;                    
                    rts[i].ui = i;
                    cells.items.push(rts[i]);
                }

                
                if (nCts > 0) {
                    cts[0].axis = 2;                    
                    cts[0].ui = 0;
                    dataCts[0].axis = 2;               
                    dataCts[0].ui = 0;
                    
                    lrs = cts[0].rs || 1;

                    
                    if (isLockHeaders && lrs > 1) {
                        
                        cts[0].rs = 1;
                        
                        
                        lastCell = mstrmojo.hash.clone(cts[0], {});

                        
                        lastCell.n = '&nbsp;';
                        
                        
                        cts[0].cni = cssBase.push({
                            n: (cssBase[cts[0].cni].n || '') + ' fsbp_1'
                        }) - 1;
                    }

                    cells.items.push(cts[0]);
                }

                var bi = this.base.items;
                bi.push(cells);

                
                for(i = 1; i < nCts; ++i) {
                    
                    if (lrs > 1) {
                       
                       var cnt = lrs;

                       
                        while(cnt-- > 1) {
                            
                            if (isLockHeaders) {
                                
                                var clone = mstrmojo.hash.clone(lastCell, {});

                                
                                clone.cni = cssBase.push({
                                    n: (cssBase[clone.cni].n || '') + ' fsbp_' + ((cnt == 1) ? '3' :  '2')
                                }) - 1;
                                
                                
                                bi.push({
                                    items: [ clone ]
                                });
                            } else {
                                
                                bi.push({items:[]});
                            }
                        }
                    }
                    
                    cts[i].axis = 2;
                    cts[i].ui = i;
                    dataCts[i].axis = 2;             
                    dataCts[i].ui = i;
                    
                    lrs = cts[i].rs || 1;

                    
                    if (isLockHeaders && lrs > 1) {
                        
                        cts[i].rs = 1;
                        lastCell = mstrmojo.hash.clone(cts[i], {});
                        lastCell.n = '&nbsp;';
                        
                        
                        cts[i].cni = cssBase.push({
                            n: (cssBase[cts[i].cni].n || '') + ' fsbp_1'
                        }) - 1;
                    }

                    bi.push({items:[cts[i]]});
                }

                this.rc = bi.length;

                
                if(rec) {
                    this._removeExtraColumn(rts, cts);
                }
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.rc;
            },

            isDataAvailable:function isDataAvailable( startRow,  endRow) {
                return true;
            },

            
            _removeExtraColumn: function removeExtraColumn(rts, cts) {
                var nRts = rts && rts.length,
                         nCts = cts && cts.length,
                         gts = this.gridData.gts,
                         mRts = gts.row || [],
                         mCts = gts.col || [],
                         mnRts = mRts.length,
                         mnCts = mCts.length;

                
                if(!nRts || !nCts) {
                    
                    if(nCts === 1) {
                        

                        
                        var lct = cts[nCts-1];

                        if(lct.otp == -1) {
                            
                            
                            if(mnCts > 0) {
                                mCts[mnCts-1]._hid = true;
                            }

                            
                            this.base.items=[];
                            this.rc = 0;
                        }
                    }
                    return;
                }

                var lrt = rts[nRts-1], 
                    rc = this.rc, 
                    bi = this.base.items; 

                
                
                if(lrt) {
                    
                    if(lrt.otp == -1) {
                        
                        if(mnRts > 0) {
                            mRts[mnRts-1]._hid = true;
                        }
                        bi[0].items.splice(nRts-1, 1);
                    } else {
                        

                        
                        
                        var idx = rc > 1 ? rc -1 : 0,
                                r = bi[idx],
                                len = r.items.length;

                        
                        if(len > 0 && mnCts > 0) {
                            mCts[mnCts-1]._hid = true;
                        }

                        
                        var afi = lrt.fix;
                        
                        if(afi) {
                            
                            for(var i = 0; i < afi; i++) {
                                r.items[len - 1 + i] = rts[nRts - afi + i];
                            }
                        } else {
                            
                            r.items[len-1] = lrt;
                        }

                        
                        
                        
                        for(var j = 0, iLen = nCts -1; j < iLen; j++) {
                            cts[j].cs = afi ? afi : lrt.cs;
                        }

                        
                        
                        var rm = afi ? afi : 1;
                        bi[0].items.splice(nRts- rm, rm);
                    }
                }
                return;
            }
        }
    );
})();

(function(){
        mstrmojo.XtabOnDemandCP = mstrmojo.declare(
            
            mstrmojo.XtabCP,

        
        null,

        
        {
            scriptClass: "mstrmojo.XtabOnDemandCP",

            
            blockNum:0,

            listeners: null,

            initContent: function initContent( startIndexInContainer) {
                if(startIndexInContainer !== undefined) {
                    this.startIndexInContainer = startIndexInContainer;
                }
                this.isDownloaded = (this.base !== null);
                this.isDownloading = false;

                if(this.base) {
                    this._super(this.startIndexInContainer);
                    this.notifyListeners();
                }
            },

            addCPListener: function addCPListener(cp) {
                if(!this.listeners) {
                    this.listeners = [];
                }

                this.listeners.push(cp);
            },

            notifyListeners: function notifyListeners() {
                var i, cps = this.listeners,
                    count = (cps && cps.length) || 0;

                for(i = 0; i < count; i++) {
                    if(cps[i] && cps[i].onDemandDataReady) {
                        cps[i].onDemandDataReady(this);
                    }
                }
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.isDownloaded ? this.rc : 0;
            },

            download:function() {
                if(!this.isDownloaded && !this.isDownloading) {
                    this.isDownloading = true;
                    this.dataSource.download(this.blockNum);
                }
            },

            invalid: function() {
                if(this._super) {
                    this._super();
                }
                this.isDownloaded = false;
                this.isDownloading = false;
            },

            isDataAvailable:function isDataAvailable( startRow,  endRow) {
                return this.isDownloaded;
            }
        }
    );
})();


(function(){

    
    var TITLE = 1,
        COL_HEADERS = 2,
        ROW_HEADERS = 4,
        VALUES = 8,        
        STACK_TOP = 1,
        STACK_MIDDLE = 2,
        STACK_BOTTOM = 3,
        NO_STACK = 4,
        FULL_STACK = 5,
        GROUPING_SECTION = 6,
        TITLE_ROW = 7,
        RHMAP = {},
        DPICONVERSION = {
            120: 0.75,
            240: 1,
            320: 1.5
        },
        RHConstants = {
            1: 30, 
            2: 26, 
            3: 20, 
            4: 70, 
            5: 40, 
            6: 34, 
            7: 40 
        },        
        BASEFORM_PICTURE = 4,
        SUBTOTAL = 1,
        CSS = {
            TITLE: 'ig-title',
            GROUPING: 'iggroup',
            BANDING: 'igbanding',
            RIGHT_ALIGN: 'rtAlign',
            LEFT_ALIGN: 'leftAlign',
            TOTAL_ROW: 'total'
        },
        $H = mstrmojo.hash,
        $A = mstrmojo.array;
    
    
    function hasGroupingEnabled(cps, gd) {
        var cp = cps[0],
            gts = gd.gts,
            gridTitleCount = gts.cws.length;

        return (gd.vp.gr === '1' && (gridTitleCount > 1));

    }

    
    function updateCellCSS(cell, info) {
        var applyCSS = function(cell, css) {
            if (css && cell && cell.css && cell.css.indexOf(css) < 0) {
                cell.css += ' ' + css;
            }
        };

        
        var type = info.type,
            col = info.col,
            colCount = (col && col.cl) || 0,
            isTitle = (type === COL_HEADERS || type === TITLE);

        
        if (type === COL_HEADERS || type === VALUES) {
            applyCSS(cell, CSS.RIGHT_ALIGN);
        } else if (type === TITLE || type === ROW_HEADERS) {
            applyCSS(cell, CSS.LEFT_ALIGN);
        }
        
        
        if (isTitle) {
            
            
            if (col && col.tg && colCount > 1) {
                
                
                if (!cell._v) {
                    
                    
                    cell._v = cell.v;
                    
                    
                    cell.v = "<span class='toggleHeader'>" + cell.v + "</span>";
                }
            }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            applyCSS(cell, CSS.TITLE);
        }
        
        
        $A.forEach(info.extraCss, function(css) {
            applyCSS(cell, css);
        });
    }

    function findAttributeCPIndex(cg) {
        return 0;
    }

    
    function getStackLevel(cols) {
        var i, cg = cols.cg, len = cg && cg.cgc, v = 1;
        for(i = 0; i < len; i++) {
            
            if(cg && cg[i] && !cg[i].tg && cg[i].cl > v) {
                v = cg[i].cl;
            }
        }
        return v;
    }
    
    function getStackPos(index, stackLevel) {
        
        var pos = NO_STACK;
        if(stackLevel > 1) {
            if(index === 0) {
                pos = STACK_TOP;
            } else if (index === stackLevel - 1) {
                pos = STACK_BOTTOM;
            } else {
                pos = STACK_MIDDLE;
            }
        }
        return pos;
    }
    
    
    function getColumnIndex(colStacks, ciis, index, vp) {
    	var cg = vp && vp.cols && vp.cols.cg,
    		i,
    		totalIndex = 0,
    		sum = 0;
    	if (cg) {
    		for (i=0; i<ciis; i++) {
    			if (colStacks[i]) {
    				totalIndex += colStacks[i].length;
    			}
    		}
    		totalIndex += (index+1);
    		for (i=0; i<cg.cgc; i++) {
    			sum += cg[i].cl;
    			if (sum >= totalIndex) {
    				return i;
    			}
    		}
    	}
    	return -1;
    }

    
    function getStackedRow(colStacks, index, stackLevel, vp) {
        var a = [], c, i, len, size;

        for(i = 0, len = colStacks.length; i < len; i++) {
            
            
            if(colStacks[i].length === 1) {
                
                c = colStacks[i][0];
                
                c.rowType = (c.rowType !== TITLE_ROW) ? getStackPos(index, stackLevel) : TITLE_ROW;

                
                c.singleStack = (stackLevel > 1);
                
                
                c = $H.copy(c);
                
                
                if(c.ts === BASEFORM_PICTURE) {
                    
                    if(stackLevel === 1) {
                        c.rowType = NO_STACK;
                        
                        c.colIdx = getColumnIndex(colStacks, i, index, vp);
                    } else if(!index) {
                        
                    	
                        
                    	c.colIdx = getColumnIndex(colStacks, i, index, vp);
                    } else {
                        
                        delete c.ts;
                        c.v = '';
                    }
                
                } else if(index) {
                    c.v = '';
                }
            } else {
                
                c = colStacks[i][index];
                if(!c) {
                    
                    
                    size = colStacks[i].length;
                    c = $H.copy(colStacks[i][size-1], {});
                    c.v = '';
                    if (c.hasOwnProperty('ts')) {
                    	delete c.ts;
                    }
                } else if (c.ts ===BASEFORM_PICTURE) {
                	c.colIdx = getColumnIndex(colStacks, i, index, vp);
                }
                
                c.rowType = (c.rowType !== TITLE_ROW) ? getStackPos(index, stackLevel) : TITLE_ROW;
            }
            a.push(c);
        }
        return a;
    }

    
    function getOriginRowIndex(ri) {
        if(ri === 0) {
            return 0;
        }
        
        var sc = this.sectionMap[ri - 1] || 0;
        
        
        return Math.floor((ri - sc)/this.stackLevels);
    }


    
    function getSectionInfo(offset) {
        var i, s, si = this.sectionInfo,
            len = si.length,
            rh = this.srh,
            ls = this.lastSectionIndex;

        
        s = si[ls];
        if(offset >= s.rs && offset < (s.rs + rh)) {
            return s;
        }
        
        if(offset < s.rs) {
            
            i = ls-1;
            if(i <= 0) {
                this.lastSectionIndex = 0;
                return null;
            }

            do {
                s = si[i];
                if(offset > s.rs && offset <= (s.rs + rh)) {
                    this.lastSectionIndex = i;
                    return s;
                }
            } while(offset < s.rs && --i > 0);

            this.lastSectionIndex = i;
            return s;
        
        } else {
            i = ls+1; 
            if(i >= len) {
                this.lastSectionIndex = len - 1;
                return null;
            }

            do {
                s = si[i];
                if(offset > s.rs && offset <= (s.rs + rh)) {
                    this.lastSectionIndex = i;
                    return s;
                }
            } while(offset > (s.rs + rh) && ++i < len);

            this.lastSectionIndex = i-1;
            return null;
        }
    }
    
    
    function addExtraColumnCell(cells, tgcc, ei, rh) {
        var c = cells[0],
            i, len = cells.length,
            rt = c && c.rowType,
            nc = {v: '', css: 'empty-igcell', rowType: rt};

        if(ei !== undefined && c && (rt === STACK_TOP || rt === NO_STACK || rt === FULL_STACK)) {
            nc = {
                v: '<div><div class="IG-ActionArrow-IMG" style="height:' + rh + 'px;top:-' + (0.5*RHMAP[rt]) + 'px;"></div></div>', 
                css: 'IG-ActionArrow',
                _ei: ei
            };
        }
        
        
        for(i = len - 1; i >= len - tgcc; i--) {
            c = cells && cells[i];
            if(c) {
                c.css += ' IG-lastdatacolumn';
            }
        }
        cells.push(nc);
    }
    
        
    function calculateCWS(vp, width, isTdWidths) {
        var cols = vp.cols,
            cg = cols.cg,
            extraColumn = [{w: '0px'}];

        
        if (cols && width) {
            var cws = cols.cws,
                cwsInPx = [],
                len = cws.length,
                excludeWidth = 0,
                autoColWidth = (parseInt(vp.ar, 10) === 1) ? (width / len) : -1,
                w, cw, unsignedcol = false, excludeCol = 0,
                adjustedWidth = width,
                totalW = 0,
                i;
    
            
            for (i = 0; i < len; i++) {
                cw = cwsInPx[i] = cws[i];
                w = cw.w;
                if(w === "") {
                    unsignedcol = true;
                } else if(cw.xc) {
                    excludeWidth += parseInt(w);
                    adjustedWidth -= excludeWidth;
                    excludeCol++;
                } else {
                    totalW += parseFloat(w, 10);
                }
            }
            
            if(unsignedcol || totalW < 100) {
                autoColWidth = adjustedWidth/(len-excludeCol);
            }

            for (i = 0; i < len; i++) {
                cw = cws[i];
                if(cw.xc) {
                    
                    continue;
                
                } else if (autoColWidth === -1) {
                    
                    w = parseInt(cw.w, 10) * adjustedWidth / 100;
    
                    
                    if (!w && w !== 0) {
                        w = parseInt(adjustedWidth / cg.cgc, 10);
                    }
                } else {
                    
                    w = (parseInt(cw.w, 10) < 0) ? 0 : autoColWidth;
                }
    
                
                cwsInPx[i] = {w: w + 'px'};
            }
            
            if (isTdWidths) {
            	
            	return cwsInPx;
            }
            
            var newCWS = [],
                cnt = 0;
            
            
            for (i = 0; i < len; i ++) {
                var c = cg[i],
                    
                    count = c.tg ? c.cl : 1, 
                    j = 0;
                
                
                for (j = 0; j < count; j++) {
                    var wi = '0px';
                    
                    if (j === c.cc) {
                        wi = cwsInPx[i].w;
                    }
                    
                    newCWS[cnt+j] = {w: wi};
                }
                
                
                cnt += count;
            }
            return newCWS.concat(extraColumn);
        } else {
        	if (isTdWidths) {
        		
        		return null;
        	} else {
        		return cp.cws.concat(extraColumn);
        	}            
        }
    }
    
    function clearStackCols () {
        delete this.lastStackCols;
        delete this.lastAttRow;
        delete this.lastMtxRow;
    }
    
    
    mstrmojo.InteractiveGridHACP = mstrmojo.declare(
        
        mstrmojo.XtabHACP,

        
        null,

        
        {
            scriptClass: "mstrmojo.InteractiveGridHACP",

            
            sectionMap: [],

            
            stackLevels: 1,

            gridWidth: 480,
            
            tdWidths: null,
            
            lastSectionIndex: 0,

            adjustCPMaps: function adjustCPMaps() {
                var cps = this.cps,
                    attCP = this.cps[0],
                    rc = Math.max(cps[0].rc, cps[1].rc);

                
                if(attCP.type !== TITLE) {
                    var gd = this.gridData,
                        getParentElement = function(cp, n) {
                            var items = cp.base.items,
                                es = cp.lookupBase[0].es,
                                tgt = items[n].items[0],
                                cell = es && es [tgt.idx];
                            return (cell && cell.n) || ((tgt.pi && es[tgt.pi.ri || 0]) || '');
                        },
                        i, j, sc = 1, count, lastSection, curP,
                        start = 0, end = -1,
                        m, cpc, lastRow = 0,
                        shouldGroupEls = this.groupEnabled;

                    for(m = 0, i = 0, cpc = attCP.cps ? attCP.cps.length : 1; m < cpc; m++) {
                        var cp = attCP.cps ? attCP.cps[m] : attCP,
                            cprc = cp.rc;
                        
                        start = end + 1;
                        end = start + cprc - 1;
                        
                        if(cp.isDataAvailable(start, end)) {
                            
                            if(cp.lastRow) {
                                lastRow = cp.lastRow;
                                lastSection = cp.lastSection;
                            } else {
                                i = lastRow || 0;
                                for(j = 0, sc = this.sectionMap[i-1] || 0; j < cprc; j++) {
                                    var stackLevel = this.stackLevels;

                                    curP = getParentElement(cp, j);
                                    
                                    if(shouldGroupEls && curP !== lastSection) {
                                        lastSection = curP;
                                        this.sectionInfo.push({
                                            sn: curP, 
                                            rs: this.srh*sc + this.stackedRh*Math.floor((i-sc)/this.stackLevels) 
                                        });
                                        this.sectionMap[i] = ++sc;
                                        i++;
                                    }
                                    
                                    while(stackLevel) {
                                        this.sectionMap[i] = sc;
                                        stackLevel--;
                                        i++;
                                    }
                                }
                                
                                lastRow = cp.lastRow = i;
                                
                                cp.lastSection = curP;
                            }
                        } else {
                            
                            break;
                        }
                    }
                    
                    this.rc = (this.stackLevels > 1 ? rc * this.stackLevels : rc) + (shouldGroupEls ? sc : 0);
                }
            },

            onDemandDataReady: function onDemandDataReady() {
                this.adjustCPMaps();
            },

            initContent: function initContent( startIndexInContainer) {
                var cps = this.cps,
                    gd = this.gridData = cps[0].gridData || cps[0].cps[0].gridData,
                    vp = gd.vp = this.gridVp = this.gridVp || gd.vp, 
                    daf = vp.daf && vp.daf.split(":"),
                    cols = vp.cols,
                    cg = cols.cg,
                    cws = cols.cws,
                    attCP = cps[findAttributeCPIndex(cg)],
                    attLB = gd.gts.row,
                    gts = gd.gts,
                    grouping = hasGroupingEnabled(cps, gd),
                    notTitleCP = attCP.type !== TITLE,
                    i, len, _c, vcps, cf, cp, igcp,
                    dpi = mstrApp.isTablet() ? 240 : mstrMobileApp.getDeviceDPI();
                
                
                $H.forEach(RHConstants, function(h, rowType) {
                    RHMAP[rowType] = h * DPICONVERSION[dpi];
                });
                
                
                if(notTitleCP) {
                    if (vp.dafIdx === undefined && daf) {
                        
                        
                        for (i = 0; i < attLB.length; i++) {
                            
                            if (attLB[i].id === daf[0] && attLB[i].fid === daf[1]) {
                                
                                vp.dafIdx = i;
                                break;
                            }
                        }                        
                    }
                }
                
                
                for(i = 0; i < cg.cgc; i++) {
                    if(cg[i] && cg[i].tg) {
                        
                        break;
                    }
                }
                
                if(i === cg.cgc) {
                    gd.gts.show = false;
                    gd.ghs.chs.show = false;
                }
                

                this._super(startIndexInContainer);
                
                this.colWidths = calculateCWS(vp, this.gridWidth);
                
                this.tdWidths = calculateCWS(vp, this.gridWidth, true);
                
                
                if(notTitleCP) {
                    
                    this.stackLevels = getStackLevel(cols);

                    
                    if(this.stackLevels > 1) {
                        
                        this.srh = RHMAP[GROUPING_SECTION];
                        
                        this.rh = RHMAP[NO_STACK];
                        
                        this.mrh = RHMAP[STACK_BOTTOM];
                        
                        this.stackedRh = RHMAP[STACK_TOP] + (this.stackLevels - 2)*RHMAP[STACK_MIDDLE] + RHMAP[STACK_BOTTOM];
                    } else {
                        this.srh = RHMAP[GROUPING_SECTION];
                        this.rh = this.stackedRh = this.mrh = RHMAP[NO_STACK];
                    }
                    
                    
                    if(grouping || this.stackLevels > 1) {
                        
                        this.sectionMap = [];

                        
                        this.sectionInfo = [];

                        
                        this.groupEnabled = grouping;

                        
                        this.adjustCPMaps();
                        
                        
                        vcps = this.cps[0].cps;
                        if(vcps) {
                            igcp = this;
                            
                            for(i = 0, len = vcps.length; i < len; i++) {
                                cp = vcps[i];
                                
                                if(cp && cp.addCPListener) {
                                    cp.addCPListener(igcp);
                                }
                            }
                        }                                                
                    }
                }
            },

            getUnmergedCells: function(ri) {
                return;
            },

            
            getResolvedGroupHeader: function(r, c) {
                var gd = this.gridData,
                    es = gd.gts.row[c].es,
                    cell = gd.ghs.rhs.items[r].items[c];

                if(cell) {
                    if(!cell.css) {
                        cell.css = gd.css[cell.cni].n + ' iggroup';
                        cell.n = es[cell.idx].n;
                    }
                } else {
                    return { css: ' iggroup', n: ''};
                }

                return cell;
            },

            getRowCells: function ( ri) {
                var cps = this.cps,
                    cells = [],
                    gd = this.gridData,
                    vp = gd.vp,
                    cg = vp.cols.cg,
                    attCP = cps[findAttributeCPIndex(cg)],
                    enableGrouping = this.groupEnabled,
                    showBanding = vp.bn === "1",
                    stackCols = [],
                    oi = getOriginRowIndex.call(this, ri),
                    eiDfa, 
                    eiInteractiveRow,
                    lastToggledColumn = 1,
                    onTotalRow,
                    totalCell,
                    rowCells,
                    i, j, len, c, 
                    tc;

                
                if (enableGrouping && (this.sectionMap[ri] !== this.sectionMap[ri-1])) {
                        
                        
                        var cell = $H.copy(attCP.getRowCells(oi)[0], {});

                        
                        cell.cs = this.colWidths.length;

                        
                        cell.rowType = GROUPING_SECTION;

                        
                        updateCellCSS(cell, {
                            col: null,
                            type: attCP.type,
                            extraCss: [CSS.GROUPING]
                        });

                        return [cell];
                }

                
                if(!ri) {
                    clearStackCols.call(this);
                }
                
                
                this.lastAttRow = this.lastAttRow || (cps[0].rc ? cps[0].getRowCells(oi) : []);
                this.lastMtxRow = this.lastMtxRow || (cps[1].rc ? cps[1].getRowCells(oi) : []);

                
                rowCells = this.lastAttRow;
                len = rowCells.length;
                if (len > 0 && rowCells[0].stt) {
                    onTotalRow = true;
                    for(i = 0; i < len; i++) {
                        c = rowCells[i];
                        if(c.stt === SUBTOTAL) {
                            totalCell = c;
                            break;
                        }
                    }
                }
                
                if(!this.lastStackCols) {
                    
                    $A.forEach([this.lastAttRow, this.lastMtxRow], function(row){
                        for (i = 0; i < row.length; i++) {
                            if (row[i]._ei !== undefined) {
                                
                                if (vp.dafIdx >= 0) {
                                    tc = attCP.getRowCells(oi)[vp.dafIdx];
                                }

                                
                                eiDfa = (vp.dafIdx >= 0) ? (tc && tc._ei) : "";
                                
                                
                                return false;
                            }
                        }
                    }, this);

                    
                    var addInfo = function(cell, cp) {
                        if (cell && (cp.type === TITLE || cp.type === COL_HEADERS)) { 
                            if(colGroup.tg === false) {
                                cell.n = cell.v = "";
                            }
                            cell.rowType = TITLE_ROW;
                        }
                        
                        
                        
                        
                        updateCellCSS(cell, {
                            col: colGroup,
                            type: cp.type,
                            extraCss: [((cp.type === VALUES || cp.type === ROW_HEADERS) && showBanding && (oi % 2 === 1)) ? CSS.BANDING : null, onTotalRow ? CSS.TOTAL_ROW : null]
                        });
                        
                        if(cell) {
                            
                            cell.cs = 1;
                            
                            
                            if (cell._ei===undefined && vp.dafIdx !== undefined) {
                                cell._ei = eiDfa;
                            }
                        }

                    };

                    this.lastRowIndex = 0;
                    for (j = 0; j < cg.cgc; j++) {
                        var colGroup = cg[j],
                            mCol = colGroup['mix' + colGroup.cc],
                            isMetric = mCol !== undefined,
                            cp = cps[isMetric ? 1 : 0],
                            k, p, ci, 
                            trc = {n:'', stt: SUBTOTAL, css: 'xtab-td'};
                            arr = [];

                        
                        if(colGroup.tg) {
                            
                            for (var i = 0; i < colGroup.cl; i ++) {
                                arr = [];
                                
                                
                                ci = isMetric ? colGroup['mix' + i] : colGroup.attForms[i].idx;
                                
                                
                                var rowCells = isMetric ? this.lastMtxRow : this.lastAttRow;
                                
                                
                                c = rowCells[ci];
                                
                                
                                if(onTotalRow) {
                                    if(!c) {
                                        c = trc;
                                    } else if(c && c.stt === SUBTOTAL) {
                                        
                                        
                                        c =$H.copy(totalCell, trc);
                                    } else {
                                        c = $H.copy(c, {});
                                    }
                                } else {
                                    c = $H.copy(c, {});
                                }
    
                                
                                addInfo(c, cp);
    
                                arr.push(c);
                                
                                stackCols.push(arr);
                            }
                            
                            
                            if(j+1 === cg.cgc) {
                                lastToggledColumn = colGroup.cl;
                            }

                        
                        } else {
                            for(k = 0, len =colGroup.cl; k < len; k++) {
                                
                                if(isMetric) {
                                    p = colGroup['mix' + k];
                                    if(p!== undefined) {
                                        c = this.lastMtxRow[p];
                                    }
                                
                                } else {                                                                        
                                    p = colGroup.attForms[k];
                                    if(p) {
                                        c = this.lastAttRow[p.idx];
                                    }
                                    
                                    
                                    if (onTotalRow && !c){
                                        c = trc;
                                    }

                                }

                                
                                addInfo(c, cp);

                                arr.push(c);
                            }
                            
                            stackCols.push(arr);
                        }
                    }
                    this.lastStackCols = stackCols;
                }

                cells = getStackedRow(this.lastStackCols, this.lastRowIndex++, this.stackLevels, vp);

                if(this.lastRowIndex >= this.stackLevels) {
                    clearStackCols.call(this);
                }









                
                








                
                
                return cells;
            },

            
            getRowHeight: function getRowHeight(type) {
                var rh = RHMAP[NO_STACK];
                return RHMAP[type] || rh;
            },

            isDataAvailable:function isDataAvailable( startRow,  endRow) {
                if(!this.onDemandIF || !this.cps[1].cps) {
                    return true;
                } else {
                    var maxRow = this.sectionMap.length, s;
                    
                    if(!maxRow) {
                        return this.cps[1].isDataAvailable(startRow, endRow);
                    }
                    
                    if(endRow > maxRow) {
                        if(startRow < maxRow) {
                            s = getOriginRowIndex.call(this, startRow);
                            return this.cps[1].isDataAvailable(s, s + (endRow-startRow));
                        } else {
                            return false;
                        }
                    } else {
                        return this.cps[1].isDataAvailable(getOriginRowIndex.call(this, startRow), getOriginRowIndex.call(this, endRow));
                    }
                }
            },

            download: function download( startIndex,  endIndex) {
                var si = getOriginRowIndex.call(this, startIndex),
                    ei = si + Math.ceil((endIndex - startIndex)/this.stackLevels),
                    cp = this.cps[0], i, tcp,
                    targetCPs = !cp.cps? [cp] : this.cps[0]._getCPs(si, ei);

                for(i=0;i<targetCPs.length;++i) {
                    tcp = targetCPs[i];
                    tcp.download(si, ei);
                }
            },

            
            getRowCellInfo: function (offset) {
                
                
                var sectionInfo = getSectionInfo.call(this, offset + this.srh),
                    lastSection, i = this.lastSectionIndex;
                if(sectionInfo) {
                    lastSection = this.sectionInfo[i - 1]; 
                    return {
                        rowStart: sectionInfo.rs,
                        isNextRowNewSection: true,
                        sectionName: lastSection && lastSection.sn 
                    };
                } else {
                    return {
                        isNextRowNewSection: false,
                        sectionName: this.sectionInfo[i].sn
                    };
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.MobileCalendar",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton");

    mstrmojo.android.inputControls.CalendarDIC = mstrmojo.declare(
        mstrmojo.MobileCalendar,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: "mstrmojo.android.inputControls.CalendarDIC",

            
            onpopupResized: function onpopupResized(e) {
                var dn = this.domNode;
                if (dn) {
                    dn.style.zoom = parseInt((95 * e.width / dn.offsetWidth), 10) + '%';
                }
            }
        }
    );
}());


(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.Button");

    var $BTN = mstrmojo.android.ui.Button.newButton;

    
    mstrmojo._CanMakeServerProxyRequests = mstrmojo.provide(
        'mstrmojo._CanMakeServerProxyRequests',

        
        {
            _mixinName: 'mstrmojo._CanMakeServerProxyRequests',


            
            cancelRequests: function cancelRequests() {
            	return this.serverProxy.cancelRequests();
            },

            
            serverRequest: function serverRequest(params, callback, config) {
                var app = this;

                try {
                    
                    callback = callback || {};

                    
                    config = config || {};

                    
                    config.projectId = config.projectId || this._currentProjId;

                    
                    config.mobileConfig = this.getConfiguration();

                    
                    var mthName = config.src || (arguments.callee && arguments.callee.caller.name);

                    
                    
                    var fnHideIndicator = function (flagToCheck) {
                        
                        if (config[flagToCheck + 'Wait']) {
                            
                            app.hideMessage();
                        }

                        
                        if (config[flagToCheck + 'Progress']) {
                            mstrMobileApp.hideProgress();
                        }
                    };

                    
                    if (!config.silent) {
                        
                        callback = mstrmojo.func.wrapMethods(callback, {
                            submission: function ( userInteractionRequired ) {

                                
                                if ( !userInteractionRequired ) {

                                
                                if (config.showWait) {
                                        
                                        app.showMessage();
                                    }

                                    
                                    if (config.showProgress) {
                                    	mstrMobileApp.showProgress(config.progressStateText, !!config.useRefreshProgress );
                                    }
                                }
                            },

                            failure: function (res) {
                            	
                            	fnHideIndicator('show');

                            	
                                if (res && res.requireDeviceCertificate) {
                                	
                                	
                                        var okFn = function() {
                		                try {
                		                    mstrApp.rootController.spawn(mstrApp.controllerFactory.newController("Settings", {}), {
                                                viewFn: "getCertificateAuthenticationFieldsView"
                                            });
                		                } catch (err) {
                                            res.method = mthName;
                                            mstrApp.handleError(err, app);
                		                }
                                	};
                                	mstrmojo.confirm(
                                			'Missing/invalid/expired device certificate detected. Would you like to get a new one?',
                                			[$BTN(mstrmojo.desc(1442, 'OK'), okFn), $BTN(mstrmojo.desc(221, 'Cancel'))]
                                			);

                                    return;
                                }

                                if ( ! (config.noErrorMessage || res.noErrorMessage)) {
                                    
                                    res.method = mthName;

                                    
                                    mstrApp.handleError(res, app);
                                }
                            },

                            complete: function () {
                            	
                            	fnHideIndicator('hide');
                            },

                            canceled: function() {
                            	
                            	
                            	fnHideIndicator('show');
                            }
                        });
                    }

                    
                    
                    try {
                        app.serverProxy.request(callback, params, !!config.override, config);
                    } catch (ex1) {
                        
                        callback.failure(ex1);
                    }

                } catch (ex2) {
                    
                    mstrApp.handleError(ex2, this);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    mstrmojo.requiresDescs(221);

    var $CSS = mstrmojo.css,
        $BTN = mstrmojo.android.ui.Button.newButton;

    
    mstrmojo.android.DropDownList = mstrmojo.declare(

        mstrmojo.Widget,

        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.DropDownList",

            cssDisplay: 'block',

            markupString: '<div id="{@id}" class="mstrmojo-AndroidDropDownList {@cssClass}" mstrAttach:click><div>{@value}</div></div>',

            markupSlots: {
                valueNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                onvalueChange: function () {
                    var value = this.value,
                        options = this.options;

                    
                    if (options) {
                        var idx = mstrmojo.array.find(options, 'v', value),
                            item = options[idx];

                        
                        this.valueNode.innerHTML = item.n;

                        
                        if (value !== "-1" && options[0].v === "-1") {
                            
                            options.shift();

                            
                            idx--;
                        }

                        
                        this.idx = idx;
                    }
                }
            },

            
            options: null,

            
            value: '',

            
            name: '',

            
            idx: 0,

            singleSelectByField: function singleSelectByField(value) {
                this.set('value', value);
            },

            
            touchTap: function touchTap() {
                
                var id = this.id,
                    domNode = this.domNode,
                    app = mstrApp;

                app.showDialog({
                    autoClose: true,
                    title: this.name,
                    fadeOnClose: false,
                    cssClass: 'dropDownList',
                    onClose: function () {
                        $CSS.removeClass(domNode, 'down');
                    },
                    children: [{
                        scriptClass: 'mstrmojo.ui.MobileCheckList',
                        items: this.options,
                        multiSelect: false,
                        isElastic: true,
                        selectedIndex: this.idx,
                        hasEvenRows: true,
                        postselectionChange: function (evt) {
                            
                            
                            mstrApp.closeDialog();

                            
                            mstrmojo.all[id].set('idx', evt.added[0]);
                        }
                    }],
                    buttons: [ $BTN(mstrmojo.desc(221, 'Cancel'), function () {
                        mstrApp.closeDialog();
                    }) ]
                });

                $CSS.addClass(domNode, 'down');
            },

            touchSelect: function touchSelect() {
                this.touchTap();
            },

            onidxChange: function onidxChange() {
                
                var options = this.options;
                if (options) {
                    
                    this.set('value', options[this.idx].v);
                }
            },

            preBuildRendering: function preBuildRendering() {
                this._super();

                
                var options = this.options;
                if (options) {
                    
                    this.value = options[this.idx].v;
                }
            }
        }
    );

}());

(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.Image",
                         "mstrmojo.Label",
                         "mstrmojo.Box",
                         "mstrmojo.Button",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.android.ui.Label",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    
    var PREVIEW_CLS_NAME = mstrmojo.Image.baseCssClass + ' prv',
        $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css;

    
    function togglePreviewCtrl(preview, opacity) {
        var imgNode = preview.imgNode;
        
        
        if ( imgNode ) {
        var imgNodeStyle = preview.imgNode.style;
        imgNodeStyle[$DOM.CSS3_TRANSITION_DURATION] = opacity ? '300ms' : 0;
        imgNodeStyle.opacity = opacity;
    }
    }

    
    function openObject() {
        var params = this.imgPreview.params,
            item = params && params.item;

        
        if (item) {
            
            this.onOpenItem();

            
            mstrmojo.all[params.ctrlId].executeItem(item);
        }
    }

    
    function positionScrollNode() {
        
        if (mstrApp.isTablet()) {
            
            this.updateScroller();

            
            return;
        }

        var compStyle = this._scrollStyle,
            scrollNode = this.scrollNode,
            scrollNodeContainer = scrollNode.parentNode,
            scrollView = scrollNodeContainer.parentNode;

        
        if (!compStyle) {
            
            var scrollViewCompStyle = $CSS.getComputedStyle(scrollView),
                scrollNodeCompStyle = $CSS.getComputedStyle(scrollNode);

            
            this._scrollStyle = compStyle = {
                p: parseInt(scrollViewCompStyle.paddingLeft, 10) + parseInt(scrollViewCompStyle.paddingRight, 10),
                b: 0,    
                sp: parseInt(scrollNodeCompStyle.paddingLeft, 10) + parseInt(scrollNodeCompStyle.paddingRight, 10)
            };
        }

        var px = 'px',
            scrollViewPadding = compStyle.p,
            scrollContainerBorder = compStyle.b,
            scrollElPadding = compStyle.sp,
            widgetHeight = parseInt(this.height, 10),
            widgetWidth = parseInt(this.width, 10),
            staticNode = this.staticNode,
            staticHeight = staticNode.offsetHeight,
            staticWidth = staticNode.offsetWidth,
            scrollLeft = 0,
            scrollWidth = (widgetWidth - scrollViewPadding),
            scrollHeight = (widgetHeight - staticHeight - scrollViewPadding);

        
        if (!this.controller.orientation) {
            
            scrollLeft = staticWidth;
            scrollWidth = (widgetWidth - staticWidth - scrollViewPadding);
            scrollHeight = widgetHeight - scrollViewPadding;
        }

        
        var scrollViewStyle = scrollView.style;
        scrollViewStyle.left = scrollLeft + px;
        scrollViewStyle.width = scrollWidth + px;
        scrollViewStyle.height = scrollHeight + px;

        
        var scrollNodeContainerStyle = scrollNodeContainer.style;
        scrollNodeContainerStyle.width = (scrollWidth - scrollContainerBorder) + px;
        scrollNodeContainerStyle.height = (scrollHeight - scrollContainerBorder) + px;

        
        scrollNode.style.width = (scrollWidth - scrollContainerBorder - scrollElPadding) + px;

        
        this.updateScroller();
    }

    
    var $PV = mstrmojo.android.ui.PropertiesView = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        
        {
            scriptClass: "mstrmojo.android.ui.PropertiesView",

            markupString: '<div id="{@id}" class="mstrmojo-PropertiesView {@cssClass}" style="{@cssText}">' +
                              '<div class="mstrmojo-PropertiesViewStatic"></div>' +
                              '<div class="mstrmojo-PropertiesViewScroll">' +
                                  '<div>' +
                                      '<div></div>' +
                                  '</div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                staticNode: function () { return this.domNode.firstChild; },
                scrollNode: function () { return this.domNode.lastChild.firstChild.firstChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },

            children: [{
                scriptClass: 'mstrmojo.Image',
                slot: 'staticNode',
                alias: 'imgPreview',
                cssClass: 'prv',
                visible: false,
                onload: function () {
                    
                    togglePreviewCtrl(this, 1);
                }
            }, {
                scriptClass: 'mstrmojo.Box',
                slot: 'staticNode',
                cssClass: 'btns',
                alias: 'btns',
                children: [mstrmojo.android.ui.Button.newButton(mstrmojo.desc(1900, 'View'), function () {
                    
                    openObject.call(this.parent.parent);
                }, {
                    alias: 'btnView',
                    cssClass: 'mstrmojo-GlowButton',
                    visible: false
                }), {
                    scriptClass: 'mstrmojo.android.ui.Label',
                    alias: 'txView',
                    cssClass: 'txOffline',
                    visible: false,
                    txData: {},
                    ontxDataChange: function ontxDataChange() {
                        if (!this.txData) {
                            this.set('visible', false);

                            
                            this.txData = {};
                        }
                    },
                    touchTap: function () {
                        var ctrl = mstrApp.getTransactionNotificationController(),
                            ctrlContext = ctrl && ctrl.rootCtrl.getCurrent();
                        
                        
                        if (ctrlContext) {
                            
                            if (ctrlContext.ctrlType !== 2048) {
                                ctrlContext = ctrlContext.getController('ctrlType', 2048);
                            }
                            ctrl.showNotificationBoard(ctrlContext || ctrl.rootCtrl, this.did, this.n);
                        }
                    }
                }]
            }, {
                scriptClass: 'mstrmojo.Label',
                slot: 'scrollNode',
                alias: 'lblName',
                cssClass: 'nm',
                visible: false
            }, {
                scriptClass: 'mstrmojo.Label',
                slot: 'scrollNode',
                alias: 'lblDesc',
                cssClass: 'ds'
            }, {
                scriptClass: 'mstrmojo.Label',
                slot: 'scrollNode',
                alias: 'lblCachedOn',
                cssClass: 'ch',
                text: ''
            }],

            afterViewVisible: function afterViewVisible() {
                positionScrollNode.call(this);
            },

            rootOrientationChange: function rootOrientationChange() {
                positionScrollNode.call(this);
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    scrollEl = this.scrollNode;

                
                cfg.scrollEl = scrollEl;

                
                cfg.noHScroll = true;

                
                cfg.origin = {
                    x: 0,
                    y: 0
                };

                
                var offsetEnd = Math.max(scrollEl.offsetHeight - scrollEl.parentNode.clientHeight, 0);

                
                var enableScroll = cfg.vScroll = (offsetEnd !== 0);
                if (enableScroll) {
                    
                    cfg.offset = {
                        y: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                } else {
                    
                    cfg.offset = null;
                }

                
                $CSS.toggleClass(this.domNode, 'can-scroll', enableScroll);

                return cfg;
            },

            
            onOpenItem: mstrmojo.emptyFn,

            
            updateView: function updateView(params) {
                var imgPreview = this.imgPreview,
                    lblName = this.lblName,
                    lblDescription = this.lblDesc,
                    lblCachedOn = this.lblCachedOn,
                    btnView = this.btns.btnView,
                    btnTx = this.btns.txView,
                    item = params.item,
                    viz = 'visible',
                    txt = 'text';

                
                var txtDescription = params.desc || params.defaultMsg;
                lblDescription.set(txt, txtDescription);
                lblDescription.set(viz, !!txtDescription);

                
                if (!item) {
                    
                    imgPreview.set(viz, false);
                    lblName.set(viz, false);
                    lblCachedOn.set(viz, false);
                    btnView.set(viz, false);
                    btnTx.set(viz, false);
                    delete imgPreview.params;

                } else {
                    
                    var sizes = mstrmojo.android.ui.PropertiesView.getPreviewSizes();

                    
                    if (mstrApp.isTablet() && this.controller.orientation) {
                        
                        sizes.reverse();
                    }

                    
                    
                    
                    mstrMobileApp.getScreenShot(this.id, item.pid || mstrApp.getCurrentProjectId(), item.did, sizes[0].h, sizes[0].w);

                    
                    var oldParams = imgPreview.params;
                    if (!oldParams || oldParams.did !== params.did) {
                        
                        imgPreview.set('cssClass', PREVIEW_CLS_NAME + ' i' + params.st);

                        
                        imgPreview.set('src', '');
                    }

                    
                    imgPreview.params = params;

                    
                    imgPreview.set(viz, true);

                    
                    var txtTitle = params.ttl;
                    lblName.set(txt, txtTitle);
                    lblName.set(viz, !!txtTitle);

                    
                    var cachedTime = params.cached;
                    lblCachedOn.set(txt, cachedTime);
                    lblCachedOn.set(viz, (cachedTime !== undefined));

                    
                    if (params.avail) {
                        
                        btnView.set(viz, true);

                        
                        var did = params.did;
                        if (did) {
                            var txCtlr = mstrApp.getTransactionNotificationController(),
                                isVisible = (txCtlr && txCtlr.hasTransactionQueue(did));

                            
                            btnTx.set('did', did);
                            btnTx.set('n', params.ttl);
                            btnTx.set('visible', isVisible);

                            
                            if (isVisible) {
                                
                                txCtlr.addWidgetListener(did, btnTx);
                            }
                        }

                    } else {
                        
                        btnView.set(viz, false);
                        btnTx.set(viz, false);

                    }
                }

                positionScrollNode.call(this);
            },

            
            onPreviewReady: function onPreviewReady(src) {
                
                if (src) {
                    var imgPreview = this.imgPreview;

                    
                    if (imgPreview.src !== src) {
                        
                        togglePreviewCtrl(imgPreview, 0);

                        
                        imgPreview.domNode.className = PREVIEW_CLS_NAME;

                        
                        imgPreview.set('src', src);
                    }
                }
            }
        }
    );


    
    var phoneDpiSizes = {
            160: {
                h: 150,
                w: 200
            },
            213: {
                h: 150,
                w: 200
            },
            240: {
                h: 225,
                w: 300
            },
            320: {
                h: 300,
                w: 400
            },
            480: {
                h: 300,
                w: 400
            }
        },
        tabletPortraitDpiSizes = {
            160: {
                h: 334,
                w: 400
            },
            213: {
                h: 334,
                w: 400
            },
            240: {
                h: 501,
                w: 600
            },
            320: {
                h: 668,
                w: 800
            }
        },
        tabletLandscapeDpiSizes = {
            160: {
                h: 337,
                w: 400
            },
            213: {
                h: 337,
                w: 400
            },
            240: {
                h: 506,
                w: 930
            },
            320: {
                h: 674,
                w: 1240
            }
        };

    
    $PV.getPreviewSizes = function () {
        
        var sizes = [],
            dpi = mstrMobileApp.getDeviceDPI();

        
        if (mstrApp.isTablet()) {
            
            sizes.push(tabletLandscapeDpiSizes[dpi]);

            
            sizes.push(tabletPortraitDpiSizes[dpi]);

        } else {
            
            sizes.push(phoneDpiSizes[dpi]);

        }

        
        return sizes;
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Box",
                         "mstrmojo.android.ui._CanBeFullScreen",
                         "mstrmojo.array",
                         "mstrmojo.css",
                         "mstrmojo.android.ui.ActionToolbarButtons",
                         "mstrmojo.android.ui.Menu",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo._TouchGestures");

    var $ARR = mstrmojo.array,
        $CSS = mstrmojo.css,
        TYPE_MENU = 1,
        TYPE_BUTTON = 2,
        MENUS = mstrmojo.android.EnumMenuOptions,
        MNU_SHARE = MENUS.SHARE,
        MNU_ANNOTATION = MENUS.ANNOTATION;

    
    function useNativeMenu() {
        return false;
    }

    
    function buttonClicked(evt) {
        
        if (!this.active) {
            
            return;
        }

        var added = evt.added,                      
            src = evt.src,                          
            item = added && src.items[added[0]],    
            menu = this.menu;

        
        if (!item) {
            
            return;
        }

        
        if (item.isMenu) {
            
            if (mstrMobileApp && mstrMobileApp.genMapPreview) {
                
                mstrMobileApp.genMapPreview();
            }
            menu.set('visible', !menu.visible);

        } else {
            
            if (item.grp !== MNU_SHARE && item.grp !== MNU_ANNOTATION) {
                mstrApp.closeAllDialogs();
            } 
            
            if (src === menu) {
                
                menu.set('visible', false);
                
                if (mstrMobileApp && mstrMobileApp.showMapView) {
                    
                    mstrMobileApp.showMapView(0);
                }
            	
            	
            }

            
            mstrmojo.all[this._actController].handleMenuItem(item.grp, item.act);
        }
    }

    
    function getMenuItems() {
        var menuItems = [],
            icons = this.icons,
            groups = this.groups,
            actions = this.actions;

        
        $ARR.forEach(this.labels, function (label, idx) {
            
            menuItems.push({
                cls: 'ic' + icons[idx],
                grp: parseInt(groups[idx], 10),
                act: parseInt(actions[idx], 10),
                n: label
            });
        });

        
        return menuItems;
    }

    
    function extractButtons(maxCnt) {
        var buttons = [],
            icons = this.icons,
            groups = this.groups,
            actions = this.actions,
            labels = this.labels;

        
        $ARR.forEach(this.types, function (type, idx) {
            
            if (type === TYPE_BUTTON) {
                
                buttons.push({
                    cls: 'ic' + icons[idx],
                    act: parseInt(actions[idx], 10),
                    grp: parseInt(groups[idx], 10),
                    idx: idx,
                    n: labels[idx]
                });

                
                if (buttons.length === maxCnt) {
                    
                    return false;
                }
            }
        });

        var i;

        
        for (i = buttons.length - 1; i >= 0; i--) {
            
            var button = buttons[i],
                menuIdx = button.idx;

            
            delete button.idx;

            
            this.types.splice(menuIdx, 1);
            this.groups.splice(menuIdx, 1);
            this.labels.splice(menuIdx, 1);
            this.actions.splice(menuIdx, 1);
            this.checked.splice(menuIdx, 1);
            this.icons.splice(menuIdx, 1);
        }

        
        return buttons;
    }

    
    var $TOOLBAR = mstrmojo.android.ui.ActionToolbar = mstrmojo.declare(
        mstrmojo.Box,

        [ mstrmojo.android.ui._CanBeFullScreen ],

        
        {
            scriptClass: 'mstrmojo.android.ui.ActionToolbar',

            
            active: true,

            init: function init(props) {
                this._super(props);

                
                $CSS.addWidgetCssClass(this, 'mstrmojo-ActionToolbar');
            },

            children: [{
                scriptClass: 'mstrmojo.android.ui.ActionToolbarButtons',
                alias: 'buttons'
            }, {
                scriptClass: 'mstrmojo.android.ui.Menu',
                alias: 'menu',
                visible: false
            }],

            
            addChildren: function addChildren(children, idx, silent) {
                this._super(children, idx, silent);

                
                $ARR.forEach(this.children, function (child) {
                    child.attachEventListener('selectionChange', this.id, buttonClicked);
                }, this);
            },

            
            setActions: function setActions(id, tbCfg) {
                
                var buttonItems = [],
                    useNative = useNativeMenu();

                
                var btnCount = tbCfg.getBtnCount(tbCfg.minBtnCount, tbCfg.maxBtnCount);
                if (btnCount) {
                    
                    buttonItems = extractButtons.call(tbCfg, btnCount);
                }

                
                if (tbCfg.size()) {
                    
                    if (useNative) {
                        
                        mstrMobileApp.setSysMenu(id, tbCfg.groups, tbCfg.labels, tbCfg.actions, tbCfg.checked, tbCfg.icons);

                    } else {
                        
                        buttonItems.push({
                            cls: 'menu',
                            isMenu: true,
                            n: 'Menu'
                        });

                        
                        this.menu.set('items', getMenuItems.call(tbCfg));
                    }
                }

                
                this.buttons.set('items', buttonItems);

                
                this._actController = id;

                
                this.raiseEvent('renderComplete');

                
                this.resetFullScreen();
            },

            onactiveChange: function onactiveChange() {
                
                $CSS.toggleClass(this.domNode, 'inactive', !this.active);
            },

            
            reset: function reset() {
                
                this.menu.set('visible', false);
            },

            
            onEnterFullScreen: function onEnterFullScreen() {
                this.reset();
            },

            
            propogateMenuVisibleChange: function propogateMenuVisibleChange(isVisible) {
                mstrmojo.touchManager.raiseEvent({
                    name: 'actionBarMenuStateChange',
                    value: isVisible
                });
            }
        }
    );

    
    function addItem(type, groupId, label, action, checked, icon) {
        this.types.push(type);
        this.groups.push(String(groupId));
        this.labels.push(String(label));
        this.actions.push(String(action));
        this.checked.push(String(!!checked));
        this.icons.push(icon || -1);
    }

    
    $TOOLBAR.newToolbarConfig = function newToolbarConfig() {
        
        var cfg = {
            addMenuItem: function addMenuItem(groupId, label, action, checked, icon) {
                
                addItem.call(this, TYPE_MENU, groupId, label, action, checked, icon);

                
                this.mnuCount++;
            },

            addToolbarBtn: function addToolbarBtn(groupId, label, action, checked, icon) {
                
                addItem.call(this, TYPE_BUTTON, groupId, label, action, checked, icon);

                
                this.btnCount++;
            },

            getBtnCount: function getBtnCount(minCnt, maxCnt) {
                
                var btnCnt = this.btnCount;

                
                if (this.mnuCount) {
                    
                    btnCnt++;
                }

                
                var actualCnt = Math.min(btnCnt, maxCnt);

                
                if (actualCnt < minCnt) {
                    
                    return 0;
                }

                
                if (actualCnt === maxCnt) {
                    
                    if (!useNativeMenu() && (this.mnuCount || (btnCnt > actualCnt))) {
                        
                        actualCnt--;
                    }
                }

                
                return actualCnt;
            },

            clear: function clear() {
                
                this.btnCount = 0;
                this.mnuCount = 0;
                this.maxBtnCount = 5;
                this.minBtnCount = 1;
                this.types = [];
                this.groups = [];
                this.labels = [];
                this.actions = [];
                this.checked = [];
                this.icons = [];
            },

            size: function size() {
                return this.labels.length;
            }
        };

        
        cfg.clear();

        
        return cfg;
    };
}());
(function(){
    mstrmojo.requiresCls(
            "mstrmojo.Table",
            "mstrmojo.SelectBox",
            "mstrmojo._CanValidate");

    
mstrmojo.MCSUtil = mstrmojo.provide(
        "mstrmojo.MCSUtil",
        {
            
            _GENERIC: 1,
            _RANK: 2,
            _PERCENT: 3,

            
            OP: {
                _EQUALS: 0,
                _NOT_EQUALS: 1,
                _GREATER: 2,
                _GREATER_EQUAL: 3,
                _LESS: 4,
                _LESS_EQUAL: 5,
                _BETWEEN: 6,
                _NOT_BETWEEN: 7,
                _IN: 8,
                _NOT_IN: 9,
                _IS_NULL: 10,
                _IS_NOT_NULL: 11
            },

            
            Q: {
                _G: 0,
                _RT: 1,
                _RB: 2, 
                _PT: 3,
                _PB: 4 
            },

            MRPFN : {
                    'TOP' :1,
                    'BOTTOM' :2,
                    'BETWEEN' :3,
                    'EXCLUDETOP' :4,
                    'EXCLUDEBOTTOM' :5,
                    'NOTBETWEEN' :6,
                    'EQUALS' :7,
                    'DIFFERENTFROM' :8,

                    
                    'EQUALSDESCENDING': 15,
                    'NOTEQUALSDESCENDING': 16,  
                    'GREATERTHANDESCENDING': 4,  
                    'GREATERTHANEQUALSDESCENDING': 18,
                    'LESSTHANDESCENDING': 20,
                    'LESSTHANEQUALSDESCENDING': 1,   
                    'BETWEENDESCENDING': 13,
                    'NOTBETWEENDESCENDING': 14,
                    'INDESCENDING': 22,
                    'NOTINDESCENDING': 24,

                    
                    'EQUALSASCENDING': 7,      
                    'NOTEQUALSASCENDING': 8,    
                    'GREATERTHANASCENDING': 5, 
                    'GREATERTHANEQUALSASCENDING': 17,
                    'LESSTHANASCENDING': 19,
                    'LESSTHANEQUALSASCENDING': 2,  
                    'BETWEENASCENDING': 3,      
                    'NOTBETWEENASCENDING': 6,   
                    'INASCENDING': 21,
                    'NOTINASCENDING': 23
            },

            FN : {
                    'EQUALS' :6,
                    'NOTEQUALS' :7,
                    'GREATERTHAN' :8,
                    'GREATERTHANEQUALS' :10,
                    'LESSTHAN' :9,
                    'LESSTHANEQUALS' :11,
                    'BETWEEN' :17,
                    'NOTBETWEEN' :44,
                    'ISNULL' :54,
                    'ISNOTNULL' :55,
                    'IN' :22,
                    'NOTIN' :57,
                    'CONTAINS' :76,
                    'NOTCONTAINS' :79,
                    'BEGINSWITH' :77,
                    'NOTBEGINSWITH' :80,
                    'ENDSWITH' :78,
                    'NOTENDSWITH' :81,
                    'LIKE' :18,
                    'NOTLIKE' :43,
                    'AND' :19,
                    'OR' :20,
                    'NOT' :21,
                    'RANK' :23,
                    'RANKPERCENT' :59,
                    'TUPLE' :1000
            },

            F: [
                [6, 7, 8, 10, 9, 11, 17, 44, 22, 57, 54, 55], 
                [15, 16, 4, 18, 20, 1, 13, 14, 22, 24], 
                [7, 8, 5, 17, 19, 2, 3, 6, 21, 23] 
            ],

            getQuaByFunc: function(f, ft) {
                var $F = this.F,
                $Q = this.Q,
                $A = mstrmojo.array;

                var isTop = function(f) {
                    if ($A.indexOf($F[1], f) !== -1) {
                        return true;
                    } else {
                        return false;
                    }
                };

                if (ft === undefined || ft == this._GENERIC) {
                    return $Q._G;
                    } else {
                    if (isTop(f)) {
                        return (ft == this._RANK)? $Q._RT : $Q._PT;
                    } else {
                        return (ft == this._RANK)? $Q._RB : $Q._PB;
                    }
                }
            },

            getFuncInfo: function(operator, qualify) {
                var ft, f;
                switch(qualify) {
                case  this.Q._G:
                    ft = this._GENERIC;
                    f = 0;
                    break;

                case this.Q._RT:
                    ft = this._RANK;
                    f = 1;
                    break;

                case this.Q._RB:
                    ft = this._RANK;
                    f = 2;
                    break;

                case this.Q._PT:
                    ft = this._PERCENT;
                    f = 1;
                    break;

                case this.Q._PB:
                    ft = this._PERCENT;
                    f = 2;
                    break;

                default:
                    return {};
                }

                return {
                    ft: ft,
                    f: this.F[f][operator]
                };

            },

            
            getOpIdxByfunc: function(f, ft) {
                if (!f || !ft) { return -1; }

                var $F = this.F,
                $Q = this.Q,
                $A = mstrmojo.array,
                r = -1;

                switch(ft) {
                case  this._GENERIC:
                    r = $A.indexOf($F[0], f);
                    break;

                case this._RANK:
                case this._PERCENT:
                    r =  $A.indexOf($F[1], f);
                    if (r == -1) {
                        r = $A.indexOf($F[2], f);
                    }
                    break;

                }
                return r;
            },

            getIncludeByOp: function(op){
                var o = this.OP;
                switch(op){
                case o._EQUALS:
                case o._GREATER_EQUAL:
                case o._LESS_EQUAL:
                case o._BETWEEN:
                case o._IN:
                    return true;
                }
                return false;
            },

            formatNumber: function(qlfy, num, numFmts) { 
                if (qlfy == $M.Q._G)  {
                    var $N = mstrmojo.num;
                    return (numFmts.fm)? $N.formatByMask(numFmts.fm, num) : $N.format(numFmts.cat, numFmts.dp, numFmts.curr, num);
                } else if(qlfy == $M.Q._RB || qlfy == $M.Q._RT) {
                    return parseInt(num);
                } else if (qlfy == $M.Q._PB || qlfy == $M.Q._PT ) {
                    return parseFloat(num) + '%';
                }
            }
        });

var $M = mstrmojo.MCSUtil,
$V = mstrmojo.validation,
$E = mstrmojo.expr,
$NM = mstrmojo.num,
allOprs =   [{n: mstrmojo.desc(2795, "Equals"), v:$M.OP._EQUALS},
          {n: mstrmojo.desc(2796, "Does not equals"), v: $M.OP._NOT_EQUALS},
          {n: mstrmojo.desc(521, "Greater than"), v: $M.OP._GREATER},
          {n: mstrmojo.desc(522, "Greater than or equal to"), v:$M.OP._GREATER_EQUAL},
          {n: mstrmojo.desc(523, "Less than"), v: $M.OP._LESS},
          {n: mstrmojo.desc(524, "Less than or equal to"), v: $M.OP._LESS_EQUAL},
          {n: mstrmojo.desc(519, "Between (enter value1;value2)"), v: $M.OP._BETWEEN},
          {n: mstrmojo.desc(614, "Not between (enter value1;value2)"), v: $M.OP._NOT_BETWEEN},
          {n: mstrmojo.desc(898, "In (enter value1;value2; ...;valueN)"), v: $M.OP._IN},
          {n: mstrmojo.desc(2394, "Not In (enter value1;value2; ...;valueN)"), v: $M.OP._NOT_IN},
          {n: mstrmojo.desc(2202, "Is null"), v: $M.OP._IS_NULL},
          {n: mstrmojo.desc(2203, "Is not null"), v: $M.OP._IS_NOT_NULL}],
oprs = allOprs.slice(0, 10),
cellCss = "padding:2px 2px 2px 2px",
oprsNull = allOprs.slice(10, 12);




var checkRange = function(v, r, isPercent, unary, category) {
    if (category == 2) return r; 

    var vs = String(v).split(";"),
    invalid = $V.STATUSCODE.INVALID_VALIDATOR,
    valid = $V.STATUSCODE.VALID;

    if (unary && vs && vs.length >1) {
        r.code = invalid;
    } else {
        for (var i = 0; i < vs.length; i++) {
            var _v = parseFloat(vs[i], 10);
            if ( isNaN(_v) ||
                    (isPercent && ( (vs[i].match(/^\d+(\.\d+)?%$/) == null && vs[i].match(/^\d+(\.\d+)?$/) == null) || _v < 0 || _v > 100) ) ||
                    (!isPercent && vs[i].match(/\d+$/) == null)) {
                r.code = invalid;
            }
            if (r.code != valid) break;
        }
    }

    if (r.code != valid) {
        r.msg = mstrmojo.desc(6103, "Please fix any invalid data");
    }
    return r;
};

var calcTxtWidth = function(fs){
    fs = parseFloat(fs);
    if(isNaN(fs)){
        return "54px";
    }else{
        return (fs * 72 / 16) + "pt;";
    }
},
txtFontChange = function(me){
    if (me.hasRendered) {
        var s = me.domNode.style;
        s.font = me.font;
        s.width = calcTxtWidth(s.fontSize);
    } else {
        var m = me.font.match(/[^\s]*?pt/) || [];
        me.cssText = me.cssText + " font:" + me.font + "; width:" + calcTxtWidth(m[0]);
    }
},
isNumericDT = function(dt){
    if((dt >= 8 && dt <= 16) || (dt >= 23 && dt <= 25) || dt == 30){
        return false;
    }
    return true;
};

 mstrmojo.MetricQualification = mstrmojo.declare(
         
         mstrmojo.Table,
         
         null,
         {
             scriptClass: "mstrmojo.MetricQualification",
             cssClass: "qs",
             cssText: "width:100%",
             markupMethods: {
                 onvisibleChange: function() { this.domNode.style.display = this.visible ? mstrmojo.css.DISPLAY_TABLE : 'none'; }
             },

             getClientHeight: function getClientHeight(){
                 return this.domNode.clientHeight + 2;
             },

             rows: 1,
             cols: 4,
             layout: [{cells: [{cssText: "width:100%"}, {cssText: "width:56px"}, {cssText: "width:56px"}, {cssText: "width:18px"}]}],
             init: function(props) {
                 if (this._super)
                     this._super(props);

                 this._init();
             },

             _init: function(reset) {
                 switch(this.qua) {
                 case 0:
                     this.low = (this.da && this.da.low) || 0;
                     this.high = (this.da && this.da.high) || 0;
                     break;

                 case 1:
                 case 2:
                     this.low = 1;
                     this.high  = (this.da && this.da.cnt) || 0;
                     break;

                 case 3:
                 case 4:
                     this.low = 0;
                     this.high = 100;
                     break;
                 }


                 if (reset) {
                     this.cs = [];
                     this.f = this.ft = null;
                 }
                 var op=  $M.getOpIdxByfunc(this.f, this.ft),
                     opId;
                 if(this.qua == 0 || this.dt == 30){
                     opId = (op == $M.OP._IS_NOT_NULL || isNumericDT(this.dt)) ? (op == -1) ? $M.OP._GREATER_EQUAL : op : $M.OP._IS_NULL;
                 }else{
                     opId = (op == -1) ? $M.OP._GREATER_EQUAL : op;
                 }


                 this.set("opId", opId);

                 var in_cs = (this.cs && this.cs.length > 0)? $NM.toLocaleString(this.cs[0].v) : "";

                 if (this.opId ==  $M.OP._IN || this.opId ==  $M.OP._NOT_IN) {
                     for (var i = 1; i < this.cs.length; i++){
                         in_cs += ";" + $NM.toLocaleString(String(this.cs[i].v));
                     }
                 } else {
                     this.set("cs2", (this.cs && this.cs.length >1)? $NM.toLocaleString(this.cs[1].v) : "");
                 }
                 this.set("cs1", in_cs);

                 this.vldTbL.validate();
                 this.vldTbH.validate();

                 this.changeQual = false;
             },
             updateData: function udtDt(da, props){
                 this.da = da;

                 
                 
                 this.updateExpr(props);
             },

             updateExpr: function udtEp(props) {
                 if (props) {
                     this.cs = props.cs;
                     this.f = props.f;
                     this.ft = props.ft;
                     this.qua = props.qua;
                 }
                 this._init();
             },

             onquaChange: function onqChg(evt){
                 this._init(true);
                 this.func.items = (this.qua!=0)? oprs : isNumericDT(this.parent.dt) ? allOprs : oprsNull;
                 this.func.refresh();
                 this.changeQual = true;
                 this.onchange();
             },

             children: [{
                 slot: "0,0",
                 alias:"func",
                 scriptClass: "mstrmojo.SelectBox",
                 cssText: "width:100%",
                 size:1,
                 bindings: {
                     sv: "this.parent.opId",
                     font: "this.parent.font"
                 },

                 onfontChange:function(){
                     if (this.hasRendered) {
                         this.domNode.style.font = this.font;
                     } else {
                         this.cssText = "width:100%;font:" + this.font;
                     }
                 },
                 onsvChange: function(){
                     if (this.sv !== null && this.sv !==undefined){
                         this.set('selectedItem', {v:this.sv});
                     }
                 },
                 postCreate: function(){
                     if (mstrmojo.dom.isIE) {
                         this.itemDisplayField = 'n';
                         this.showItemTooltip = true;
                     }
                     this.items = (this.parent.qua!=0)? oprs: isNumericDT(this.parent.dt) ? allOprs : oprsNull;
                 },
                 onchange: function() {
                     var p = this.parent,
                     itm = this.selectedItem;
                     if (itm && itm.v !== null && itm.v !== undefined) {
                         p.set("opId", itm.v);
                     }

                     if(mstrApp.isMobile && (itm.v === $M.OP._IS_NULL || itm.v == $M.OP._IS_NOT_NULL)) {
                         if(p.onchange) {
                             p.onchange();
                         }
                     }
                 }

                 }, {
                 slot: "0,1",
                 alias: "vldTbL",
                 scriptClass : "mstrmojo.ValidationTextBox",
                 required: true,
                 dtp: $E.DTP.VARCHAR,
                 constraints: {
                     trigger: $V.TRIGGER.ALL,
                     validator: function(v){
                         var  r = {id: this.id, code: $V.STATUSCODE.VALID, msg: '' },
                         p = this.parent;
                         checkRange(v, r, (p.qua==3||p.qua==4),  (p.opId != 8 && p.opId !=9), (p.numFmts && p.numFmts.cat));
                         return r;
                     }
                 },
                 bindings: {
                     visible: "this.parent.opId!=10&&this.parent.opId!=11",
                     value: "this.parent.cs1",
                     font: "this.parent.font"
                 },

                 onfontChange:function(){
                     txtFontChange(this);
                 },

                 onValid: function() {
                     var p = this.parent,
                         box = this.domNode;
                     p.set("cs1", this.value);

                     if(box && box.value.length > 6){
                         box.title = box.value;
                     }else if(box){
                         box.title = "";
                     }

                 },
                 onvisibleChange: function() {
                     if(!this.visible){
                         this.parent.set("cs1", "");
                     }
                 },
                 onkeyup: function(evt){
                     var hWin = evt.hWin,
                         e = evt.e || hWin.event,
                         p = this.parent,
                         box = evt.src.domNode;
                     if (e.keyCode === 13 && p.apply && p.apply.enabled){
                         p.apply.onclick();
                     }

                 }

             }, {
                 slot: "0,2",
                 alias: "vldTbH",
                 scriptClass : "mstrmojo.ValidationTextBox",
                 required: true,
                 dtp: $E.DTP.VARCHAR,
                 constraints: {
                     trigger: $V.TRIGGER.ALL,
                     validator: function(v){
                         var  r = {id: this.id, code: $V.STATUSCODE.VALID, msg: '' },
                         p = this.parent;
                         checkRange(v, r, (p.qua==3||p.qua==4),  (p.opId != 8 && p.opId !=9), (p.numFmts &&p.numFmts.cat));
                         return r;
                     }
                 },
                 bindings : {
                     visible : "this.parent.opId ==7 ||this.parent.opId ==6", 
                     value: "this.parent.cs2",
                     font: "this.parent.font"
                 },

                 onfontChange:function(){
                     txtFontChange(this);
                 },

                 onValid: function() {
                     this.parent.set("cs2", this.value);

                     var box = this.domNode;

                     if(box && box.value.length > 6){
                         box.title = box.value;
                     }else if(box){
                         box.title = "";
                     }
                 },
                 onvisibleChange: function() {
                     if(!this.visible){
                         this.parent.set("cs2", "");
                     }
                 },
                 onkeyup: function(evt){
                     var hWin = evt.hWin,
                         e = evt.e || hWin.event,
                         p = this.parent;
                     if (e.keyCode === 13 && p.apply && p.apply.enabled){
                         p.apply.onclick();
                     }
                 }

             },  {
                    slot: "0,3",
                    alias: "apply",
                    title: mstrmojo.desc(2164, "Apply"),
                    scriptClass : "mstrmojo.Button",
                    cssClass : 'icn apply',
                    bindings: {
                        enabled: "(!this.parent.vldTbL.visible ||!this.parent.vldTbL.validationStatus.code)"+
                        "&& (!this.parent.vldTbH.visible||!this.parent.vldTbH.validationStatus.code)"
                   },

                    onclick: function(){
                        var p = this.parent,
                        isPercent = (p.qua == $M.Q._PT || p.qua == $M.Q._PB);
                        p.cs = [];

                        var toPrcnt = function(v){
                            return v + ((isPercent && !String(v).match(/^\d+%$/))? '%' : '');
                        };

                        var type = function(cat, qua){
                            return ((cat == 2 || cat == 3) && qua == 0)? 14 : 5;
                        };

                        if (p.opId == $M.OP._IN || p.opId == $M.OP._NOT_IN){
                            var _cs = String(p.cs1).split(";");
                            for (var i = 0; i < _cs.length; i++) {
                                if(!mstrmojo.string.isEmpty(_cs[i])) p.cs.push({dtp:5, v: toPrcnt(_cs[i])});
                            }
                        }  else {
                            if (p.vldTbL.visible) p.cs.push({dtp: type((p.numFmts && p.numFmts.cat), p.qua), v: toPrcnt(p.cs1)});
                            if (p.vldTbH.visible)  p.cs.push({dtp:  type((p.numFmts && p.numFmts.cat), p.qua), v: toPrcnt(p.cs2)});
                        }

                        if (p.onchange) {
                            p.onchange();
                        }

                        if (p.makeSelection) {
                        	p.makeSelection();
                        }
                    }
             }]
         });
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.SuggestionList");

    var buildTooltip = function(w, item) {
        var opener = w.parent.opener,
            showDesc = opener && opener.showDesc,
            showPath = opener && opener.showPath,
            n = item[w.itemField];
      
        
        var encode = mstrmojo.string.escape4HTMLText,
            tooltip = '';
        
        
        if (showPath) {
            var its = item.anc && item.anc.items,
                len = its && its.length;
            if (len > 0) {
                for (var i = 0; i < len - 1; i ++ ) {
                    tooltip += its[i].n + ' > ';
                }
                tooltip += encode(its[len - 1].n);
            } else if (item.path) {
                tooltip += item.path;
            }
        }
        tooltip += (tooltip.length == 0 ? '' : ' > ') + encode(n);
        
        
        if (showDesc) {
            var desc = item[w.itemDescField],
                ml = 120;
            if (desc) {
                tooltip += '\r\n\r\n' + encode(desc.substring(0, ml) + (desc.length > ml ? '...' : ''));
            }
        }
        
        return tooltip;
    };
    
    var requestPath = function(w, el, item) {

        if (!el || !item) return;
        
        
        window.clearTimeout(this.pathTmr);
        
        
        this.pathTmr = window.setTimeout( function() {
            
            var path = el.path || el.getAttribute('path');
            if (path) {
                return; 
            }

            
            mstrmojo.xhr.request('POST', mstrConfig.taskURL, 
                    { 
                      success: function(res) {
                            
                            var path = pathParser(res.toString()) || '';
                            item.path = path;
                            el.path = 1;  
                            el.title = buildTooltip(w, item);  
                        }
                    },
                    {
                        taskId: 'getObjectDetails',  
                        objectID: item.did,
                        objectType: item.t,
                        sessionState: mstrApp.sessionState
                    },
                    undefined);
        }, 200);
        
    };
    
    
    var pathParser = function(pathXmlString) {
        if (window.DOMParser) {
            parser = new DOMParser();
            xmlDoc = parser.parseFromString(pathXmlString, "text/xml");
        } else {
            xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async = "false";
            xmlDoc.loadXML(pathXmlString);
        } 

        var pathNode = xmlDoc.getElementsByTagName("path")[0],
            cns = pathNode.childNodes,
            path = '';
        if (cns) {
            for (var i = 0, len = cns.length; i < len; i ++) {
                var vNode = cns[i].childNodes && cns[i].childNodes[0];
                if (vNode) {
                    path += mstrmojo.string.escape4HTMLText(vNode.nodeValue) + (i < len - 2 ? '> ' : '');
                }
            }
        }
        return path;
    };
    
    mstrmojo.LegacySuggestionList = mstrmojo.declare(

        mstrmojo.SuggestionList,

        null,

        {
            scriptClass: 'mstrmojo.LegacySuggestionList',
            
            itemDescField: 'desc',
            
            getItemMarkup: function (item, idx) {
                var opener = this.parent.opener,
                    tooltip = buildTooltip(this, item); 
                
                
                return '<div class="mstrmojo-suggest-text ' + ((opener && opener.item2textCss(item)) || '') + '" idx="' + idx + '" title="' + tooltip + '">' + 
                            opener.getHighlightedText(opener.getSearchPattern(), mstrmojo.string.escape4HTMLText(item[this.itemField])) + 
                        '</div>';
            },

            getItemProps: function getItemProps(item, idx) {
                return {};
            },
            
            onmouseover: function(evt) {
                var opener = this.parent.opener;
                
                if (opener && opener.showPath) {
                    var el = mstrmojo.dom.eventTarget(evt.hWin, evt.e),
                        idx = el.getAttribute('idx'),
                        item = idx != null ? this.items[idx] : null;
                    
                    if (item && item.t > -1) {
                        requestPath(this, el, item);
                    }
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ScrollableTabs",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.hash");

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        $HASH = mstrmojo.hash;

    
    mstrmojo.android.ui.LayoutSelector = mstrmojo.declare(

        mstrmojo.android.ui.ScrollableTabs,

        null,

        
        {
            scriptClass: 'mstrmojo.android.ui.LayoutSelector',

            init: function init(props) {
                this._super(props);

                
                var markupMethods = this.markupMethods = $HASH.copy(this.markupMethods);
                markupMethods.onvisibleChange = function () {
                    
                    var fadeHandle = this._hFade;
                    if (fadeHandle) {
                        
                        window.clearTimeout(fadeHandle);

                        
                        delete this._hFade;
                    }

                    
                    var items = this.items;
                    if (!items || items.length <= 1) {
                        
                        return;
                    }

                    var isVisible = !!this.visible,
                        domNode = this.domNode;

                    
                    if (isVisible) {
                        
                        domNode.style.marginTop = 0;
                    }

                    
                    $CSS.toggleClass(domNode, 'open', isVisible);
                };

            },

            
            initiateFade: function initiateFade(delay) {
                var id = this.id;
                this._hFade = window.setTimeout(function () {
                    
                    var widget = mstrmojo.all[id];
                    if (widget) {
                        
                        widget.set('visible', false);
                    }
                }, delay || 2000);
            },

            
            postBuildRendering: function postBuildRendering() {
                
                var id = this.id;
                $DOM.attachEvent(this.domNode, 'webkitTransitionEnd', function () {
                    
                    var widget = mstrmojo.all[id];
                    if (!widget.visible) {
                        
                        widget.domNode.style.marginTop = '-10000px';
                    }
                });

                return this._super();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._SupportsEllipsisText",
                         "mstrmojo.android.ui.Label",
                         "mstrmojo.android.ui.Menu",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css,
        cssOversize = 'oversize',
        cssMultiLine = 'multiline',
        cssTest = [ cssOversize, cssMultiLine ];

    
    mstrmojo.android.ui.TitleLabel = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._SupportsEllipsisText ],

        
        {
            scriptClass: "mstrmojo.android.ui.TitleLabel",

            markupString: '<div id="{@id}" class="mstrmojo-AndroidTitleLabel {@cssClass}" style="{@cssText}">' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            children: [{
                scriptClass: 'mstrmojo.android.ui.Label',
                alias: 'lbl',
                touchTap: function () {
                	
                	mstrApp.closeAllDialogs();
                	
                    
                    var titleLabel = this.parent,
                        list = titleLabel.list,
                        items = list.items,
                        count = items && items.length;

                    
                    if (!list.visible && count) {
                        
                        if (titleLabel._isDropDown && count === 2) {
                            
                            list.singleSelect((!list.selectedIndex) ? 1 : 0);

                        } else {
                            
                        	list.set('visible', true);
                        	
                        	if (mstrMobileApp && mstrMobileApp.genMapPreview) {
                                
                                mstrMobileApp.genMapPreview();
                        	}
                        }
                    }
                }
            }, {
                scriptClass: 'mstrmojo.android.ui.Menu',
                alias: 'list',
                selectionPolicy: 'reselect',
                visible: false,
                setMaxWidth: true
            }],

            addChildren: function addChildren(children, idx, silent) {
                this._super(children, idx, silent);

                
                this.list.attachEventListener('selectionChange', this.id, function (evt) {
                    var added = evt.added,
                        list = this.list;

                    
                    list.set('visible', false);
                    
                    if (mstrMobileApp && mstrMobileApp.showMapView) {
                       
                       mstrMobileApp.showMapView(0);
                    }
               	    


                    
                    if (!added) {
                        
                        return;
                    }

                    
                    var item = list.items[added[0]];
                    if (item.isTitle) {
                        
                        return;
                    }

                    
                    if (this._isDropDown) {
                        
                        this.setText(item.n);
                    }

                    
                    this.raiseEvent({
                        name: 'listSelectionMade',
                        item: item
                    });
                });
            },

            onRender: function onRender() {
                
                var testLbl = this._testLbl = this.lbl.domNode.cloneNode(false),
                    domNode = this.domNode;

                mstrmojo.css.addClass(testLbl, 'test');

                
                testLbl.removeAttribute('onclick');
                testLbl.removeAttribute('id');

                
                domNode.insertBefore(testLbl, domNode.lastChild);
            },

            unrender: function unrender(ignoreDom) {
                
                delete this.testLbl;

                this._super(ignoreDom);
            },

            
            setText: function setText(text) {
                
                this.checkTextFit(text);
            },

            
            checkTextFit: function checkTextFit(text) {
                var displayLabel = this.lbl,
                    displayLabelNode = displayLabel.domNode,
                    testLabelNode = this._testLbl,
                    offset = this._compOffset;

                
                text = (text === undefined) ? displayLabel.text : text;

                
                if (offset === undefined) {
                    
                    var compStyle = $CSS.getComputedStyle(displayLabelNode);
                    offset = parseInt(compStyle.paddingLeft, 10) + parseInt(compStyle.paddingRight, 10);

                    
                    this._compOffset = offset;
                }

                
                testLabelNode.style.width = (displayLabelNode.parentNode.offsetWidth - offset) + 'px';

                
                testLabelNode.innerHTML = text;

                
                var displayHeight = displayLabelNode.offsetHeight,
                    isMultiLine = (testLabelNode.offsetHeight > displayHeight);

                
                $CSS.toggleClass(displayLabelNode, cssTest, isMultiLine);

                
                displayLabel.set('text', text);

                
                if (isMultiLine) {
                    
                    if (!this.ellipsize('ttl', displayLabelNode, true)) {
                        
                        $CSS.addClass(testLabelNode, cssOversize);

                        
                        testLabelNode.innerHTML = displayLabelNode.innerHTML;

                        
                        if (testLabelNode.offsetHeight === displayHeight) {
                            
                            $CSS.removeClass(displayLabelNode, cssMultiLine);
                        }

                        
                        $CSS.removeClass(testLabelNode, cssTest);
                    }
                }
            },

            
            setListItems: function setListItems(items, selectedIdx) {
                var hasItems = (items && items.length),
                    isDropDown = (selectedIdx !== undefined),
                    list = this.list;

                
                $CSS.toggleClass(this.domNode, 'has-items', hasItems);

                
                this._isDropDown = !!isDropDown;

                
                if (hasItems) {
                    
                    if (!isDropDown) {
                        
                        items = [{
                            n: mstrmojo.desc(9850, 'RECENTLY OPENED'),
                            isTitle: true
                        }].concat(items);
                    } else {
                        
                        this.setText(items[selectedIdx].n);
                    }
                }

                
                list.set('items', items);

                
                if (isDropDown) {
                    
                    list.singleSelect(selectedIdx, true);
                }
            },

            
            clearListItems: function clearListItems() {
                
                var list = this.list,
                    rtn = {
                        items: [].concat(list.items),
                        idx: list.selectedIndex
                    };

                
                mstrmojo.css.removeClass(this.domNode, 'has-items');

                
                list.set('items', []);

                
                return (rtn.idx > -1) ? rtn : null;
            },

            
            reset: function reset() {
                
                this.list.set('visible', false);

                
                this.checkTextFit();
            }
        }
    );

}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.WidgetListBase",
        "mstrmojo.WidgetListMapper",
        "mstrmojo.WidgetListBuilder");
    
    
    mstrmojo.WidgetList = mstrmojo.declare(
        
        mstrmojo.WidgetListBase,
        
        null,
        
        
        {
            
            scriptClass: "mstrmojo.WidgetList",
            
            
            renderOnScroll: true,
            
            
            listMapper: mstrmojo.WidgetListMapper,

            
            listBuilder: mstrmojo.WidgetListBuilder,
            
            
            itemConfig: null,

            
            itemFunction: null,
            
            
            initBindings: function(){
                this._super();
                
                var c = this.ctxtBuilder,
                    iws = c && c.itemWidgets;
                if (iws) {
                    for (var i=0, len=iws.length; i<len; i++) {
                        var iw = iws[i];
                        if (iw && iw.initBindings) {
                            iw.initBindings();
                        }        
                    }
                }
            }
        });
})();
(function () {    

    mstrmojo.requiresCls(
            "mstrmojo.array",
            "mstrmojo.hash",
            "mstrmojo.css",
            "mstrmojo.Popup",
            "mstrmojo.List",            
            "mstrmojo.DropDownButton");
    
    
    mstrmojo.Pulldown = mstrmojo.declare(
            
            mstrmojo.DropDownButton,
            
            null,
            
            {
            scriptClass: 'mstrmojo.Pulldown',
            
            cssClass: 'mstrmojo-Pulldown',
            
            items: null,
            
            itemIdField: 'dssid',
            
            itemField: 'n',
            
            itemCSS: 'css',
            
            defaultSelection: 0,
            
            defaultText:null,
            
            title:'',
            
            value: null, 
            
            popupToBody: false,
            
            popupCssClass: '',
            
            popupZIndex: null,
            
            fixWidth: false,

            fixHeight: false,
            
            
            _set_items: function(n, v){
                var was = this.items;
                this.items = v || [];
                return was !== this.items;
            },
            
            markupMethods: mstrmojo.hash.copy({
                onvalueChange: function() {
                    var v = this.value, 
                        idx = this.selectedIndex, 
                        its = this.items || [], 
                        selItem, t;
                    
                    
                    if (idx === undefined || (v !== null && (idx === -1 || (idx !== -1 && its[idx] && its[idx][this.itemIdField] !== v)))) {
                        
                        idx = mstrmojo.array.find(its, this.itemIdField, v);
                        
                        idx = (idx > -1) ? idx : this.defaultSelection;
                        
                        this.selectedIndex = idx;
                    } else if (v === null) {
                        this.selectedIndex = this.defaultSelection;
                    }
                    
                    this.selectedItem = selItem = its[this.selectedIndex];
                    
                    if (selItem){
                        
                        t = selItem[this.itemField];
                    }else{
                        
                        t = this.defaultText || '';
                    }
                    
                    this.set('text', t);
                }
            }, mstrmojo.hash.copy(mstrmojo.DropDownButton.prototype.markupMethods)),
             
            prevalueChange: function(evt){
                var v = this.value,
                    idx = -1;
            
                if (v !== null) {
                    idx = mstrmojo.array.find(this.items, this.itemIdField, v);
                } 
                
                
                if(idx > -1){
                    this.selectedItem = this.items[idx];
                    this.selectedIndex = idx;
                }
            },
            
            
            togglePopup: function togglePopup() {
                if(this.popupToBody){
                    var pos = mstrmojo.dom.position(this.popupNode, true),
                        pr = this.popupRef,  
                        cfg = {
                            left:Math.round(pos.x) + 'px', 
                            top:Math.round(pos.y) + 'px'
                        };
                    
                    if(!pr.hasRendered){
                        delete pr.slot;
                        cfg.placeholder = document.body.appendChild(document.createElement('div'));
                    }
                    
                    this.popupOpenConfig = this.popupOpenConfig || {};
                    
                    mstrmojo.hash.copy(cfg, this.popupOpenConfig);
                } else {
                    this.popupRef.slot = "popupNode";
                }
                
                if(this._super){
                    this._super();
                }
                
                
                var pn = this.popupRef.domNode;
                if(pn){
                    if (this.fixWidth) {
                	    pn.style.width = (this.domNode.offsetWidth - 2) + 'px';
                    } else {
                	    pn.style.minWidth = (this.domNode.offsetWidth - 2) + 'px';
                    }
                }
            },
            
            premousedown: function premousedown(evt) {
                this.togglePopup();
            },
            
            unrender: function unrender(ignoreDom){
                var pr = this.popupRef;
                if(this.popupToBody && pr.hasRendered){
                    pr.unrender(false);
                }
                if(this._super){
                    this._super(ignoreDom);
                }
            },
            
            popupRef: {
                        scriptClass: 'mstrmojo.Popup',
                        slot: "popupNode",
                        cssClass:'mstrmojo-Pulldown-Popup',
                        autoCloses: false,
                        modal: false,
                        autoClose: true,                        
                        locksHover: true,
                        onOpen: function(){
                            var o = this.opener,
                                z = o && o.popupZIndex,
                                c = o && o.popupCssClass || '',
                                dn = this.domNode;
                            if (z){
                                dn.style.zIndex = z;
                            }
                            if(c){
                                mstrmojo.css.addClass(dn, [c]);
                            }
                            if(o && o.fixWidth) {
                            	mstrmojo.css.addClass(dn, ['fix-width']);
                            }
                            if(o && o.fixHeight) {
                                mstrmojo.css.addClass(dn, ['fix-height']);
                            }
                        },
                        children: [
                                       {
                                            scriptClass: 'mstrmojo.List', 
                                            alias: 'list',
                                            itemMarkupFunction: function(item, idx, w){
                                                return  '<div class="mstrmojo-Pulldown-listItem">' + 
                                                '<div class="mstrmojo-text '+ (item[w.itemCSS] || '') +'" ' +
                                                'title=' + '"' + item[w.itemField] + '"' + 
                                                '>' + (item[w.itemField] || '&nbsp;') + '</div>' + 
                                                '</div>';
                                            },
                                            renderOnScroll: false,
                                            bindings: {
                                               itemIdField: 'this.parent.opener.itemIdField',
                                               itemField: 'this.parent.opener.itemField',
                                               itemCSS: 'this.parent.opener.itemCSS',
                                               items: 'this.parent.opener.items',
                                               selectionPolicy: 'this.parent.opener.selectionPolicy',
                                               selectedIndex: 'this.parent.opener.selectedIndex'
                                            },
                                            onmousedown: function(){
                                               this.parent.close();
                                            },
                                            onchange: function() {
                                                var p = this.parent,
                                                    visible = p.visible,
                                                    pd = p.opener,
                                                    si = this.selectedItem;
                                                if (!pd || !si || !visible) {
                                                    return;
                                                }
                                                
                                                pd.set('value',si[this.itemIdField]);
                                            }
                                        }
                                   ]
                                    
             }
        }
    );
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.ToggleDIC",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.url",
                         "mstrmojo.array");

    mstrmojo.android.inputControls.ToggleDIC = mstrmojo.declare(

        mstrmojo.ToggleDIC,

        [ mstrmojo._TouchGestures, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: 'mstrmojo.android.inputControls.ToggleDIC',

            useAnimation: false,

            init: function init(props) {
                this._super(props);

                
                mstrmojo.array.forEach(this.dic.vls, function (v) {
                    v.n = mstrmojo.url.getAbsoluteURL(v.n, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());
                });
            },

            touchTap: function touchTap() {
                this.onclick();
            },

            onclick: function onclick() {
                this._super();
                this.applyChanges();
            },

            
            onblur: mstrmojo.emptyFn
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Box",
                         "mstrmojo._HasLayout",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.ui.Image",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $LAYOUT = {
        containerNode: '100%'
    };

    
    mstrmojo.android.ui.ResultSetView = mstrmojo.declare(

        mstrmojo.Box,

        [ mstrmojo._HasLayout, mstrmojo._TouchGestures ],

        {
            scriptClass: "mstrmojo.android.ui.ResultSetView",

            layoutConfig: {
                h: $LAYOUT,
                w: $LAYOUT
            },

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, 'mstrmojo-ResultSetView');
            },

            rootOrientationChange: mstrmojo.emptyFn,

            addChildren: function addChildren(children, idx, silent) {
                
                if (!this.btnFullScreen) {
                    
                    children = children.concat([{
                        scriptClass: 'mstrmojo.android.ui.Image',
                        alias: 'btnFullScreen',
                        cssClass: 'btnFullScreen',
                        ignoreLayout: true,
                        visible: false,
                        touchTap: function () {
                            
                            this.parent.controller.viewTap();
                        }
                    }]);
                }

                this._super(children, idx, silent);
            },

            
            delegateToolbar: function delegateToolbar(tbCfg) {
                return false;
            },

            
            setActionToolbarStatus: mstrmojo.emptyFn,

            
            getMaskNode: mstrmojo.emptyFn,

            touchTap: function touchTap() {
                
                this.controller.viewTap();
            },

            enterFullScreen: function enterFullScreen() {
                this.btnFullScreen.set('visible', true);
            },

            exitFullScreen: function exitFullScreen() {
                this.btnFullScreen.set('visible', false);
            },

            flashFullScreen: mstrmojo.emptyFn,

            cancelFlashFullScreen: mstrmojo.emptyFn,

            getPosition: function getPosition() {
                var domNode = this.domNode;
                return domNode ? mstrmojo.dom.position(domNode) : undefined;
            }
        }
    );
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.TristateCheckBox", "mstrmojo._IsInputControl");
    
    
    mstrmojo.CheckBoxDIC = mstrmojo.declare(
        mstrmojo.TristateCheckBox,
        
        [mstrmojo._IsInputControl],
        
        {
            scriptClass: 'mstrmojo.CheckBoxDIC',
            
            markupString: '<div id="{@id}" class="mstrmojo-Label {@cssClass}" style="{@cssText}" tabindex="1" mstrAttach:click,keydown></div>',
            
            cssText: 'width: 0; margin:0 auto; max-height: 18px; cursor: pointer;',
            
            onclick: function() {
                
                
                if (this.grayed) {
                    this.set('grayed', !this.grayed);
                    this.set('checked', true);
                } else {
                    this.set('checked', !this.checked);
                }
            },                        
            
            oncheckedChange: function(e) {
                this.set('value', this[this.checked ? 'onValue' : 'offValue']); 
            },
            
            preBuildRendering: function(){
                this._super();
                
                var vls = this.dic.vls;
                this.offValue = vls[0].v;
                this.onValue = vls[1].v;
                
                this.grayed = (this.onValue !== this.value) && (this.offValue !== this.value);
                this.checked = (this.onValue === this.value);
            },
            
            postBuildRendering: function(){
                this._super();
                
                this.domNode.style.height = this.openerStyle.ih + 'px';
            },
            
            onkeydown: function(evt){
                var hWin = evt.hWin, 
                    e = evt.e || hWin.event;
                
                if (e.keyCode === mstrmojo.Enum_Keys.SPACE){ 
                    mstrmojo.dom.preventDefault(hWin, e);
                    this.onclick();
                }
            },
            
            focus: function(){
                this.domNode.focus();
            }
        }
    );
})();
(function(){
    mstrmojo.requiresCls('mstrmojo.Box', 
            'mstrmojo.ListBase', 
            'mstrmojo._IsList');
    
    var DELIM = ',';
    
    
    
    mstrmojo.TableLayoutList = mstrmojo.declare (

        mstrmojo.ListBase,
        
        [mstrmojo._IsList],
        
        {
            scriptClass: 'mstrmojo.TableLayoutList',
            
            cssClass: 'mstrmojo-TableLayoutList',
            
            styleCssClass: '',
            
            itemIdField: 'v',
            
            allowUnlistedValues: false,
            
            tableLayoutCssStyle: 'auto',
            
            multiSelect: false,
            
            titleItems: null,
            
            
            items: null,
            
            
            itemsPerRow: 0,
            
            
            getLeftEndTitle: function getLeftEndTitle(idx) {
                return '';
            },
            
                        
            getRightEndTitle: function getRightEndTitle(idx) {
                return '';
            },
            
            getTitleRowMarkup: function getTitleRowMarkup() {
                var titleItems = this.titleItems;
                if (titleItems) {
                    var _tr = '<tr><td class="left_text">' + this.getLeftEndTitle(-1) + '</td>',
                        len = titleItems.length,
                        i = 0,
                        t;
                    for (; i < len; i++) {
                        t = titleItems[i];
                        _tr += '<td class="item_title" title="' + t + '">' + t + '</td>';
                    }
                    _tr += '<td class="left_text">' + this.getRightEndTitle(-1) + '</td></tr>';
                    return _tr;
                }
                return '';
            },
            
            _markupPrefix: function() {
                
                
                return '<table class="tableLayoutList" style="table-layout:' + this.tableLayoutCssStyle + '" cellspacing="0" cellpadding="0"><tbody>' + this.getTitleRowMarkup();
            },
            
            _markupSuffix: function() {
                return  '</tbody></table>';
            },
            
            getItemMarkup: function(item, idx) {
                var markup = '<{@tag} class="item {@cls}" idx="{@idx}" title="{@n}" style="{@style}">{@n}</{@tag}>',
                lt = this.getLeftEndTitle(idx),
                rt = this.getRightEndTitle(idx),
                ipr = this.itemsPerRow;

                lt = '<td class="left_text" title="' + lt + '">' + lt + '</id>',
                rt = '<td class="right_text" title="' + rt + '">' + rt + '</id>',
                ipr = this.itemsPerRow;

                if (ipr > 0) {
                    
                    
                    markup = (idx % ipr === 0 ? '<tr>' + lt : '') + '<td>' + markup + '</td>' + ((idx + 1) % ipr === 0 ? rt + '</tr>' : '');
                } else {
                    markup = '<td><div class="item_wrapper" idx="' + idx + '">' + markup + '</div></td>';
                    if (!idx) {
                        markup = '<tr>' + lt + markup;
                    } else if (idx === this.items.length - 1) {
                        markup = markup + rt + '</tr>';
                    }
                }
                return markup;
            },
            
            _getItemNode: function(idx) {
                var itemsTableNode = this.itemsNode,
                    ipr = this.itemsPerRow,
                    rowIdx = (this.titleItems ? 1 : 0) + ((ipr > 0) ? parseInt(idx/ipr, 10) : 0),
                    colIdx = 1 + ((ipr > 0) ? (idx%ipr) : idx);

                
                return itemsTableNode.rows[rowIdx].cells[colIdx].firstChild;
            },            
            
            init: function(props) {
                this._super(props);
                mstrmojo.css.addWidgetCssClass(this, this.styleCssClass);
            },
            
            onchange: function onchange(){
                var newValue, s = [];
                
                
                if (!this.multiSelect){
                    newValue = this.selectedItem.v;
                
                }else{
                    for (var i in this.selectedIndices) {
                        s.push(this.items[i].v);
                    }
                    newValue = s.join(this.delim || DELIM);
                }
                this.set('value', newValue);
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                
                var selItems = [];
                if (this.multiSelect){
                    var vs = this.value.split(DELIM);
                    
                    for (var i = 0; i < vs.length; i++){
                        selItems.push({v: vs[i]});
                    }
                }else{
                    selItems.push({v: this.value});
                }
                
                this.setSelectedItems(selItems);
            }
        }
    );
}());
(function(){
    mstrmojo.requiresCls("mstrmojo.Box");

    
    mstrmojo.maps.jsmap.InfoWindow = mstrmojo.declare(
        mstrmojo.Box,

        null,

        {            
            scriptClass: "mstrmojo.maps.jsmap.InfoWindow",
            
            rowIndex : -1,
            
            init: function init(props){
                this._super(props);
            },

            start : function start(){
                this.render();
                this.update(this.rowIndex);
            },
            
            update : function update(rowIndex){
                this.rowIndex = rowIndex;
                var res = this.containerNode,
                innerHTML = '<table><tbody>' + 
                '<tr>' + 
                '<td colspan="2" class="androidMap-infoWindowTitle">'+ mapDataObj.getAttributeName(rowIndex) + '</td>' + 
                '</tr>';
                
                innerHTML += this.getMetricInfo();
                innerHTML += '</tbody></table>';
                res.innerHTML = innerHTML;
            },
            
            getMetricInfo : function getMetricInfo(){            
                
                
                
                var metricData = JSON.parse(mapDataObj.getMetricValues(this.rowIndex).toString()),
                    res = '',
                    mdLen = metricData.length;
                                                        
                for(var i = 0; i < mdLen; i++){
                    var item = metricData[i]; 
                    if(item.ts == 4){
                        res += '<tr><td class="androidMap-infoWindowText"> '+ mapDataObj.getMetricName(i) +' </td><td><img src="' + item.v +'"></td></tr>';
                    }else{
                      
                      var fColor = 'black',
                          bColor = 'transparent';
                      
                      
                      if(mapDataObj.useThresholds()){
                          fColor = mapDataObj.getThresholdColorRGB(item.fcti); 
                          bColor = mapDataObj.getThresholdColorRGB(item.bcti); 
                      }
                      res += '<tr><td class="androidMap-infoWindowText">'+ mapDataObj.getMetricName(i) +'</td><td style="background-color:'+ bColor +';color:'+ fColor +';">'+ item.v + '</td></tr>';
                    }
                }
                return res;
            }

        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._FillsBrowser",
                         "mstrmojo._HasLayout",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.Box",
                         "mstrmojo.Label",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css;

    mstrmojo.requiresDescs(2901, 8445);

    
    function updateRootOrientationClass() {
        
        var add = 'rootPortrait',
            remove = 'rootLandscape',
            node = this.domNode;

        
        if (mstrApp.isLandscape()) {
            
            var x = add;
            add = remove;
            remove = x;
        }

        
        $CSS.removeClass(node, remove);
        $CSS.addClass(node, add);
    }

    
    mstrmojo.android.ui.RootView = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._FillsBrowser, mstrmojo._HasLayout, mstrmojo._TouchGestures ],

        
        {
            scriptClass: 'mstrmojo.android.ui.RootView',

            markupString: '<div id="{@id}" class="mstrmojo-RootView {@cssClass}" style="{@cssText}" >' +
                              '<div class="mstrmojo-RootView-title"></div>' +
                              '<div class="mstrmojo-RootView-content"></div>' +
                          '</div>',

            markupSlots: {
                titleNode: function () { return this.domNode.firstChild; },
                containerNode: function () { return this.domNode.lastChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },           

            layoutConfig: {
                h: {
                    titleNode: 'auto',
                    containerNode: '100%'
                },
                w: {
                    titleNode: '100%',
                    containerNode: '100%'
                }
            },

            preBuildRendering: function preBuildRendering() {
                
                $CSS.addClass(document.body, 'dpi' + mstrMobileApp.getDeviceDPI());

                
                if (!this.msgBox) {
                    
                    var msgBox = this.msgBox = new mstrmojo.Box({
                        placeholder: 'mainAppMsg',                     
                        cssClass: 'mstrmojo-RootViewMessage',
                        cssText: 'left:-10000px;',
                        children: [{
                            scriptClass: 'mstrmojo.Label',
                            alias: 'lbl',
                            text: mstrmojo.desc(2901, 'Loading...')
                        }]
                    });

                    
                    msgBox.render();
                }

                
                var viewFactory = mstrApp.viewFactory;
                this.addChildren([ viewFactory.newView('ActionBar', {
                    slot: 'titleNode',
                    alias: 'actionBar',
                    controller: mstrmojo.all[this.controllerId]
                }), viewFactory.newView('Switcher', {
                    slot: 'containerNode',
                    alias: 'switcher'
                })]);

                return this._super();
            },

            postBuildRendering: function postBuildRendering() {
                updateRootOrientationClass.call(this);

                
                var titleNode = this.titleNode;
                if(!this._tchHandler) {
                	this._tchHandler = mstrmojo.touchManager.attachEventListener('actionBarMenuStateChange', this.id, function (evt) {
                		if(evt.value) {
                			$CSS.addClass(titleNode, 'top');
                		} else {
                			$CSS.removeClass(titleNode, 'top');
                		}
                	});
                }
                
                return this._super();
            },

            unrender: function unrender(ignoreDom) {
            	
            	if(this._tchHandler) {
            		mstrmojo.touchManager.detachEventListener(this._tchHandler);
            		delete this._tchHandler;
            	}
            	this._super(ignoreDom);
            },
            
            
            setNavigation: function setNavigation(navItems, idx) {
                
                this.actionBar.setNavigation(navItems, idx);
            },
            
            getTitleHeight: function getTitleHeight() {
                return this.titleNode.offsetHeight;
            },


            
            clearNavigation: function clearNavigation() {
                
                this.actionBar.clearNavigation();
            },

            
            restoreNavigation: function restoreNavigation() {
                
                this.actionBar.restoreNavigation();
            },

            selectNavigationItem: function selectNavigationItem(navItem) {
                
                return this.actionBar.selectNavigationItem(navItem);
            },

            hasNavigationItems: function hasNavigationItems() {
            	return this.actionBar.getNavList().items.length > 0;
            },

            
            reset: function reset() {
                this.actionBar.reset();
            },

            
            setContent: function setContent(view, isBack) {
                
                this.reset();

                
                this.switcher.switchView(view, isBack);
            },

            
            contentUpdated: function contentUpdated() {
                
                this.reset();
            },

            
            setTitle: function setTitle(text) {
                this.actionBar.updateTitle(text);
            },

            
            setActionToolbar: function setActionToolbar(id, tbCfg) {
                this.actionBar.updateToolbar(id, tbCfg);
            },

            
            setActionToolbarStatus: function setActionToolbarStatus(isActive) {
                this.actionBar.setActionToolbarStatus(isActive);
            },

            setUpStatus: function setUpStatus(isActive) {
                this.actionBar.setUpStatus(isActive);
            },

            
            updateLastOpened: function updateLastOpened(items) {
                this.actionBar.setLastOpened(items);
            },

            
            monitorWindow: function monitorWindow() {
                
                var dimensions = mstrApp.getScreenDimensions();

                
                
                this._super({
                    currentTarget: {
                        innerWidth: dimensions.w,
                        innerHeight: dimensions.h
                    }
                });

                
                updateRootOrientationClass.call(this);

                
                mstrmojo.all[this.controllerId].set('orientation', (mstrMobileApp.getOrientation() === mstrmojo.android.EnumOrientationTypes.PORTRAIT) ? 1 : 0);

                
                window.setTimeout(function () {
                    mstrMobileApp.setWaitScreenVisibility(false);
                }, 0);
            },

            
            setDimensions: function setDimensions(h, w) {
                this._super(h, w);

                
                var msgBox = this.msgBox;
                msgBox.set('height', this.height);
                msgBox.set('width', this.width);
            },

            
            getBrowserDimensions: function () {
                var dimensions = mstrApp.getScreenDimensions(),
                    px = 'px';

                return {
                    h: dimensions.h + px,
                    w: dimensions.w + px
                };
            },

            
            getContentDimensions: function getContentDimensions() {
                var containerNode = this.containerNode;
                return {
                    h: containerNode.clientHeight,
                    w: containerNode.clientWidth
                };
            },

            
            showMessage: function showMessage(text) {
                mstrMobileApp.showProgress([ text || mstrmojo.desc(8445, 'Loading') ], false );
            },

            
            showHTMLProgress: function showHTMLProgress(text) {
                var loadingCurtain = this.msgBox,
                    loadingCurtainStyle = loadingCurtain.domNode.style,
                    loadingLabel = loadingCurtain.lbl,
                    lblNode = loadingLabel.domNode,
                    lblNodeStyle = lblNode.style;

                
                loadingLabel.set('text', text || mstrmojo.desc(2901, 'Loading...'));

                
                lblNodeStyle.left = Math.round(parseInt(this.width, 10) / 2 - lblNode.offsetWidth / 2) + 'px';
                lblNodeStyle.top = Math.round(parseInt(this.height, 10) / 2 - lblNode.offsetHeight / 2) + 'px';

                
                loadingCurtainStyle.left = 0;
                loadingCurtainStyle.top = 0;

                
                $CSS.addClass(loadingCurtain.domNode, 'active');

                
                loadingCurtainStyle.opacity = 1;
            },

            
            hideMessage: function hideMessage() {
                mstrMobileApp.hideProgress();
            },

            
            hideHTMLProgress: function hideHTMLProgress() {
                var loadingCurtain = this.msgBox.domNode,
                    loadingCurtainStyle = loadingCurtain.style;

                
                loadingCurtainStyle.opacity = 0;

                
                loadingCurtainStyle.left = '-10000px';

                
                $CSS.removeClass(loadingCurtain, 'active');
            },

            enterFullScreen: function enterFullScreen() {
                this.actionBar.enterFullScreen();
            },

            flashFullScreen: function flashFullScreen() {
                this.actionBar.flashFullScreen();
            },

            exitFullScreen: function exitFullScreen(animate) {
                this.actionBar.exitFullScreen(animate);
            },

            cancelFlashFullScreen: function cancelFlashFullScreen() {
                return this.actionBar.cancelFlashFullScreen();
            },
            
            propogateMenuVisibleChange: function propogateMenuVisibleChange(isVisible) {            	
            	this.actionBar.propogateMenuVisibleChange(isVisible);
            }
        }
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.Box", "mstrmojo._HasLayout");
    
    
    mstrmojo.Overlay = mstrmojo.declare(
        mstrmojo.Box,
        [mstrmojo._HasLayout],
        {
            markupMethods: {
                onvisibleChange: function(){ this.domNode.style.display = this.visible? 'block' : 'none'; },
                onheightChange: function() { this.domNode.style.height = this.height ? this.height : ''; },
                onwidthChange: function() { this.domNode.style.width = this.width ? this.width: ''; }
            },
            
            layoutConfig: {
                h: {
                    containerNode: '100%'
                },
                w: {
                    containerNode: '100%'
                }
            },
            
            scriptClass: "mstrmojo.Overlay"
        }
    );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.DocLayoutViewer",
                         "mstrmojo._Formattable",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.dom");

    
    function checkLinks(checkAll) {
        var links,
            newLinks = this._newLinks,
            allLinks = mstrmojo.hash.copy(newLinks, this._allLinks),
            links = checkAll ? allLinks : newLinks;
        
        this._newLinks = {};
        
        
        
        if ( mstrMobileApp.isOnline() ) {
            return;
        }

        
        var controller = this.controller,
            i,
            lnk,
            linkRequests = [],
            cacheableLinks = [],
            req;

        for (i in links) {
            lnk = links[i];
            req = controller.getLinkRequest(lnk);
            if (req) {
                linkRequests.push(req);
                cacheableLinks.push(lnk);
            }
        }

        
        var count = linkRequests.length;
        if (count) {
            
            var fnSuccess = function (res) {
                for (i = 0; i < count; i++) {
                    lnk = cacheableLinks[i];
                    lnk.src.setLinkEnabled(res[i]);
                }
            };

            if (mstrApp.isHosted()) {
                

            } else {
                this.model.getDataService().checkCachedLinkTargets(linkRequests, {
                    success: fnSuccess,
                    failure: mstrmojo.emptyFn
                });
            }
        }
    }
    
    function applyChildDimensions() {
        var ch = this.children,
        i,
        len;

        
        for (i = 0, len = (ch && ch.length) || 0; i < len; i++) {
            var child = ch[i],
                slot = child.slot;

            
            if (slot) {
                
                this.setSlotDimensions(slot, child.height, child.width);
            }
        }
    }

    
    mstrmojo.MobileDocLayoutViewer = mstrmojo.declare(
        
        mstrmojo.DocLayoutViewer,

        
        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        
        {
            scriptClass: "mstrmojo.MobileDocLayoutViewer",

            layoutConfig: {
                h: {
                    groupBy: '0',
                    fixedHeaderNode: 'auto',
                    layout: '100%',
                    fixedFooterNode: 'auto',
                    incFetchNode: '0'
                },
                w: {
                    layout: '100%'
                }
            },

            formatHandlers: {
                domNode: [ 'background-color' ]
            },

            scrollerConfig: {
                vScroll: false,
                hScroll: false,
                bounces: false,
                showScrollbars: false
            },
            

            usesTouches: true,
            
            init: function init(params) {
                this._super(params);
                this._newLinks = {};
                this._allLinks = {};
                
            },
            
            postBuildRendering: function postBuildRendering() {
            	this._super();

                
                if(this.fixedFooterNode.clientHeight > 0) {
                    applyChildDimensions.call(this);
                }
            },

            preBuildRendering: function preBuildRendering() {
                this._super();

                this._scrollCssText = 'overflow:' + ((!mstrmojo.dom.isWinPhone) ? 'hidden' : 'auto');

                var id = this.id,
                    updateScroller = this.updateScroller;

                
                if (!this.afterScrollSubscr) {
                    this.afterScrollSubscr = this.docLayout.attachEventListener('afterScroll', id, function () {
                        this.updateScroller();
                        checkLinks.call(this);
                    });

                    
                    this.model.attachEventListener('partialUpdate', id, updateScroller);
                }
            },
            
            mapID:null,
            setMapID: function setMapID(id) {
                this.mapID = id;
            },
            
            beforeViewHidden: function beforeViewHidden(isBack) {
                if (!this.mapID) return;
                var c = mstrmojo.all[this.mapID];
                if (c && c.beforeViewHidden) {
                    c.beforeViewHidden(isBack);
                }
                this.mapID = null;
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this.scrollerConfig,
                    layoutNode = this.docLayout.containerNode;

                if (layoutNode) {
                    var docLayout = this.docLayout,
                        xOffset = {
                            start: 0,
                            end: Math.max(docLayout.getWidth() - this.scrollboxWidth, 0)
                        },
                        yOffset = {
                            start: 0,
                            end: Math.max(docLayout.getHeight() - this.scrollboxHeight, 0)
                        },
                        vScroll = (yOffset.start !== yOffset.end),
                        hScroll = (xOffset.start !== xOffset.end),
                        offset;

                    
                    if (vScroll || hScroll) {
                        
                        offset = {
                            x: xOffset,
                            y: yOffset
                        };
                    } else {
                        
                        cfg.origin = {
                            x: 0,
                            y: 0
                        };
                    }

                    
                    mstrmojo.hash.copy({
                        scrollEl: this.scrollboxNode.firstChild,    
                        offset: offset,
                        vScroll: vScroll,
                        hScroll: hScroll,
                        showScrollbars: false
                    }, cfg);

                    
                    if (!cfg.origin) {
                        cfg.origin = this._origin = {
                            x: 0,
                            y: 0
                        };
                    }

                    
                    docLayout.scrollBuffer = parseInt(mstrApp.rootView.getContentDimensions().h, 10);
                }

                return this._super();
            },

            
            initScroller: function initScroller(scroller) {
                this._super(scroller);

                
                scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    
                    this._origin = {
                        x: evt.x,
                        y: evt.y
                    };

                    
                    this.notifyScrollListeners(evt);
                });
            },

            touchBegin: function touchBegin(touch) {
                var p = this.parent;
                
                if (p && p.isAnimating && p.isAnimating()) {

                    
                    touch.stop();

                    
                    return false;
                }
                return this._super(touch);
            },

            
            shouldTouchBubble: function shouldTouchBubble(touch) {
            	if(mstrmojo.dom.contains(this.scrollboxNode, touch.target, true, this.domNode)) {
            		return this._super(touch);
            	}
            	
            	return true;
            },
            
            touchSwipeBegin: function touchSwipeBegin(touch) {
                
                if (this.shouldTouchBubble(touch)) {
                    var parent = this.parent,
                    	parentCanScroll = parent.canScroll && parent.canScroll(touch);

                    
                    if (parentCanScroll) {
                        
                        this._parentScrolling = true;

                        
                        parent.beginScroll(touch);
                    }
                    
                    return parentCanScroll;
                }

                this._super(touch);
            },

            touchSwipeMove: function touchSwipeMode(touch) {
                
                if (this._parentScrolling) {
                    
                    this.parent.scroll(touch);

                    return;
                }

                this._super(touch);
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                
                touch.evt.handled = true;

                
                if (this._parentScrolling) {
                    
                    delete this._parentScrolling;

                    
                    this.parent.endScroll(touch);

                    return;
                }

                this._super(touch);
            },

            touchTap: function touchTap() {
                
                var ctrl = this.controller;
                if (ctrl && ctrl.viewTap) {
                    
                    ctrl.viewTap();
                }
            },

            
            renderChildren: function rnCh() {
                this._super();

                
                this.updateScroller();
            },

            
            unrender: function unrender() {
                
                delete this.scrollerConfig.origin;
                var scroller = this._scroller;
                if (scroller) {
                    delete scroller.origin;
                }
                if (this.subscr) {
                    mstrmojo.publisher.unsubscribe(this.subscr);
                    delete this.subscr;
                }
                if (this.afterScrollSubscr) {
                    mstrmojo.publisher.unsubscribe(this.afterScrollSubscr);
                    delete this.afterScrollSubscr;
                }
                
                this._super();
            },

            
            addLinkInfo: function addLinkInfo(id, linkInfo) {
                this._newLinks[id] = linkInfo;
            },
            
            
            onRender: function onRender() {
                this._super();

                
                
                if (!this.subscr) {
                    var publisher = mstrmojo.publisher;
                    this.subscr = publisher.subscribe(publisher.NO_SRC, publisher.CONNECTIVITY_CHANGED_EVENT, function (isOnline) {
                        
                        
                        if (isOnline) {
                            
                            var links = this._allLinks,
                                i,
                                widget;

                            for (i in links) {
                                widget = links[i].src;
                                if (!widget.linkEnabled) {
                                    widget.setLinkEnabled(true);
                                }
                            }

                        } else {
                            checkLinks.call(this, true);
                        }
                    }, this.id);
                }

                
                if ((mstrApp.useBinaryFormat || mstrApp.isHosted()) && !mstrMobileApp.isOnline() ) {
                    var me = this;
                    window.setTimeout(function () {
                        checkLinks.call(me);
                    }, 100);
                }
            },
            
            setSlotDimensions: function setSlotDimensions(slot, h, w) {
                if (slot === 'layout') {
                    
                    var winHeight = parseInt(this.height, 10),
                        headerHeight = this.fixedHeaderNode.clientHeight,
                        footerHeight = this.fixedFooterNode.clientHeight,
                        height = parseInt(h, 10),
                        actHeight = winHeight - headerHeight - footerHeight;

                    
                    if(headerHeight + footerHeight >= winHeight) {
                        h = 0;
                    } else if( height != actHeight){
                        h = actHeight + 'px';
                    }
                }

                this._super(slot, h, w);
            },
            
            getCaptureDimensions: function getCaptureDimensions() {
            	return this.docLayout.getCaptureDimensions();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocLayout");

    
    function resizeForSharedHeight(me) {
        var mh = -1,
            c = me.children,
            sec,
            six,
            ssix,
            subsec,
            subsecArr = [],
            resizeSection = function () {
                var ci;
                for (ci in subsecArr) {
                    var subsec = subsecArr[ci];
                    if (subsec._fixedHeight !== mh) {
                        subsec._fixedHeight = mh;
                        if (subsec.domNode) { 
                            subsec.domNode.style.height = mh + 'px';
                        }
                    }
                }
                mh = -1;
                subsecArr = [];
            };

        for (six in c) {
            sec = c[six];
            if (sec.node.data.bh && mh > -1) {
                
                
                resizeSection();
            }
            if (sec.defn.horiz) {
                
                for (ssix in sec.children) {
                    
                    subsec = sec.children[ssix];
                    mh = Math.max(subsec._fixedHeight || 0, mh);
                    
                    subsecArr[subsecArr.length] = subsec;
                }
            }
        }
        resizeSection();
    }

    
    mstrmojo.DocLayoutHoriz = mstrmojo.declare(
        
        mstrmojo.DocLayout,

        
        null,

        
        {
            scriptClass: "mstrmojo.DocLayoutHoriz",

            markupString: '<div id="{@id}">' +
                              '<div class="mstrmojo-DocLayout {@cssClass}" style="{@domNodeCssText}">' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; }
            },

            getWidth: function getWidth() {
                
                return this.containerNode.offsetWidth;
            },

            getHeight: function getHeight() {
                
                return this.containerNode.offsetHeight;
            },

            _renderSection: function _renderSection(sec, index) {

                
                if (sec.node.data.bh) {

                    
                    var d = document.createElement('div');
                    d.className = 'mstrmojo-DocLayout-HBox';

                    
                    var t = document.createElement('table');
                    t.className = 'mstrmojo-DocLayout-HBox-HorizContainerTable';

                    
                    this._hRow = t.insertRow(-1);

                    
                    d.appendChild(t);

                    
                    this.containerNode.appendChild(d);
                }

                
                if (sec.defn.horiz) {
                    
                    var slotName = 'hi' + index;

                    
                    sec.slot = slotName;

                    
                    var td = this._hRow.insertCell(-1);

                    
                    td.vAlign = 'top';

                    
                    var slots = {};
                    slots[slotName] = td;
                    this.addSlots(slots);
                }
                this._super(sec, index);
            },
            
            getLayoutMinWidth: function getLayoutMinWidth() {
                var minWidth = 0,              
                    currentMinWidth = 0,       
                    children = this.children,
                    len = children.length,
                    i,
                    k;

                
                for (i = 0; i < len; i++) {

                    var sec = children[i],
                        secNode = sec && sec.node,
                        secNodeData = secNode && secNode.data,
                        begin = secNodeData && (String(secNodeData.bh) === 'true' || String(secNodeData.bv) === 'true');

                    
                    if (begin) {
                        minWidth = Math.max(minWidth, currentMinWidth);
                        currentMinWidth = 0;
                    }

                    if (sec.children) {
                        
                        for (k in sec.children) {
                            currentMinWidth += sec.children[k].width();
                        }
                    } else {
                        
                        
                        currentMinWidth += 10;
                        break;
                    }
                }

                
                return Math.max(minWidth, currentMinWidth);
            },


            
            resizeOrReposition: function resizeOrReposition() {
                if (this._super) {
                    this._super();
                }

                resizeForSharedHeight(this);
            },


            
            renderCtrlsInViewport: function renderCtrlsInViewport() {
                this._super();
                resizeForSharedHeight(this);
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ViewSwitcher",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    var $MATH = Math,
        $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array;

    
    function translate(el, x, duration, easing) {
        
        if (isNaN(x)) {
            
            x = parseInt(x, 10);
        }

        
        var elementStyle = el.style;
        elementStyle[$DOM.CSS3_TRANSITION] = $DOM.CSS3_PREFIX + 'transform ' + (duration || 0) + 'ms ' + (easing || 'ease');
        elementStyle[$DOM.CSS3_TRANSFORM] = 'translateX(' + x + 'px)';
    }

    
    function insertScrollView(view, sliderX, isForward) {
        
        var slotInfo = this.getSlots(),
            currentSlot = slotInfo.current,
            nextSlot = slotInfo.next,
            nextSlotName = slotInfo.slot,
            targetPosition = 0;

        
        $ARR.forEach($ARR.filter(this.children, function (child) {
            return (child.slot === nextSlotName);
        }), function (child) {
            
            this.removeChildren(child);
            child.unrender();
        }, this);

        
        this.prepareNewView(view, nextSlotName);

        
        try {
            
            var id = this.id;
            window.setTimeout(function () {
                
                mstrmojo.all[id].addChildren([ view ]);
            }, 0);

            
            if (nextSlot && currentSlot) {
                
                targetPosition = isForward ? parseInt(this.width, 10) : 0;

                
                if (isForward) {
                    nextSlot.style.zIndex = 3;
                    currentSlot.style.zIndex = 1;
                }
            }

        } catch (e) {
            
            mstrmojo.Obj.free(view);
            throw e;
        }

        return {
            start: sliderX,
            target: targetPosition,
            newView: view,
            oldView: this.getCurrentView(),
            isForward: isForward
        };
    }


    function positionSliderNode(newPosition, oldPosition, callback, useAnimation, velocity) {
        var sliderNode = this.sliderNode,
            duration = 0,
            easing = '',
            fnPosition = function () {
                
                translate(sliderNode, -newPosition, duration, easing);

                
                if (callback) {
                    
                    if (duration) {
                        
                        window.setTimeout(callback, duration + 100);
                    } else {
                        
                        callback();
                    }
                }
            };

        
        if (useAnimation) {
            
            var delta = $MATH.abs((newPosition || 0) - (oldPosition || 0));

            
            duration = $MATH.round(delta / parseInt(this.width, 10) * 700);                     
            easing = 'ease';                                                                    

            
            if (velocity) {
                
                duration = $MATH.min(duration, $MATH.round(delta / velocity));

                
                easing += '-out';
            }

            
            this._animating = true;

            
            window.setTimeout(fnPosition, 20);

        } else {
            
            fnPosition();
        }
    }

    
    function cleanUpScroll(activeChild, inactiveChild) {
        
        this.removeChildren(inactiveChild);

        
        inactiveChild.unrender();

        
        this._curSlot = activeChild.slot;

        
        delete this._animating;
    }


    
    mstrmojo.android.ui.ViewSlider = mstrmojo.declare(

        mstrmojo.android.ui.ViewSwitcher,

        null,

        
        {
            scriptClass: "mstrmojo.android.ui.ViewSlider",

            
            switchView:  function switchView(view, isBackOperation) {
                var slotInfo = this.getSlots();

                
                translate(this.sliderNode, 0);
                translate(slotInfo.current, 0);
                translate(slotInfo.next, 0);

                this._super(view, isBackOperation);
            },

            
            isAnimating: function isAnimating() {
                return !!this._animating;
            },
                       
                        
            resetSliderNodes: function (isForward) {

                var slotInfo = this.getSlots(),
                    width = parseInt(this.width, 10),
                    sliderX = -width,                   
                    currentX = width,                   
                    nextX = 0;                          
                
                if (isForward) {
                    sliderX = 0;
                    currentX = 0;
                    nextX = width;
                }                

                
                translate(this.sliderNode, sliderX);
                translate(slotInfo.current, currentX);
                translate(slotInfo.next, nextX);
                
                return {
                	sliderX: sliderX,
                	currentX: currentX,
                	nextX: nextX
                };
            },            

            
            beginScroll: function (touch, view) {
                
                if (this.isAnimating()) {
                    
                    return false;
                }
                
                var isForward = touch.delta.x < 0,
                	positions = this.resetSliderNodes(isForward);                

                
                var info = this._scrollInfo = insertScrollView.call(this, view, positions.sliderX, isForward);

                
                this.scrollStarted(info);

                
                this.scroll(touch);
            },

            
            scroll: function scroll(touch) {
                var info = this._scrollInfo,
                    x = touch.delta.x;

                
                if (info) {
                    
                    if (info.isForward !== (x < 0)) {
                        
                        positionSliderNode.call(this, 0);

                        
                        this.beginScroll(touch);

                    } else {
                        
                        positionSliderNode.call(this, -(info.start + x));

                        
                        this.scrollProgress(info, x);

                    }
                }
            },

            
            endScroll: function endScroll(touch) {
                
                var info = this._scrollInfo;
                if (!info) {
                    
                    return;
                }

                var delta = touch.delta.x,                  
                    newPosition = -info.start,              
                    isComplete = false,                     
                    velocity = 0,                           
                    id = this.id;

                
                if ($MATH.abs(delta) / parseInt(this.width, 10) > 0.25) {
                    
                    newPosition = info.target;
                    isComplete = true;
                    velocity = touch.velocity.x;
                }

                
                this.scrollStopped(info, isComplete);

                
                positionSliderNode.call(this, newPosition, newPosition - delta, function () {
                    
                    mstrmojo.all[id]['scroll' + (isComplete ? 'Complete' : 'Canceled')](info);
                }, true, velocity);

                
                delete this._scrollInfo;
            },

            
            scrollStarted: mstrmojo.emptyFn,

            
            scrollProgress: mstrmojo.emptyFn,

            
            scrollStopped: mstrmojo.emptyFn,

            
            scrollCanceled: function scrollCanceled(info) {
                cleanUpScroll.call(this, info.oldView, info.newView);
            },

            
            scrollComplete: function scrollComplete(info) {
                cleanUpScroll.call(this, info.newView, info.oldView);
            }
        }
    );
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.registry", "mstrmojo.tooltip","mstrmojo.HBox");
    var $D = mstrmojo.dom,
        $C = mstrmojo.css,
        VALIGN_TOP = 1,
        VALIGN_MIDDLE = 2,
        VALIGN_BOTTOM = 3,
        getVerticalAlign = function(dom) {
            var va = $C.getStyleValue(dom, 'verticalAlign');
            return {'top': VALIGN_TOP, 'bottom': VALIGN_BOTTOM, 'middle': VALIGN_MIDDLE}[va] || VALIGN_TOP; 
        };
    
    mstrmojo.SliderBox = mstrmojo.declare(
        mstrmojo.Container,
        
        null,
        
        {
            scriptClass: 'mstrmojo.SliderBox',

            markupString: '<div id="{@id}" class="{@cssClass}" style="{@cssText}" tabindex="{@tabIndex}" >' +
                              '<div class="valuePart" style="{@valueCssText}">' +
                                  '<span class="valueLabel">{@valueLabel}</span>' +
                                  '<span class="valueText">{@valueText}</span>' +
                              '</div>' +
                              '<table class="sliderPart" style="{@sliderCssText}">' +
                                  '<tbody><tr>' + 
                                      '<td class="minText">{@min}</td>' +
                                      '<td class="sliderWrapper"></td>' +
                                      '<td class="maxText">{@max}</td>' +
                                  '</tr></tbody>' + 
                              '</table>' +
                          '</div>',

            markupSlots: {
                valuePartNode: function(){ return this.domNode.firstChild; },
                valueLabelNode: function(){ return this.domNode.firstChild.firstChild; },
                valueTextNode: function(){ return this.domNode.firstChild.lastChild; },
                sliderPartNode: function() { return this.domNode.lastChild; },
                minTextNode: function(){ return this.domNode.lastChild.rows[0].cells[0]; },
                maxTextNode: function(){ return this.domNode.lastChild.rows[0].cells[2]; },
                sliderNode: function(){ return this.domNode.lastChild.rows[0].cells[1]; }
            },
            
            markupMethods: {
                onmaxChange: function(){ this.maxTextNode.innerHTML = this.max; },
                onminChange: function(){ this.minTextNode.innerHTML = this.min; },
                onvalueTextChange: function(){ this.valueTextNode.innerHTML = this.valueText; },
                onunsetChange: function() {
                    var sliderNode = this.sliderBar.domNode;
                    if (sliderNode){
                        mstrmojo.css.toggleClass(sliderNode, 'unset', this.unset); 
                    }
                }
            },
            
            tabIndex: -1,
            
            sliderRef: null,
            
            valueLabel: mstrmojo.desc(4104, 'Value:'),
            
            valueText: '',
            
            min: '',
            
            max: '',
            
            interval: 0,
            
            isSequential: false, 

            unset: false,
            
            cssClass: 'mstrmojo-SliderGroup',
            
            postCreate: function postCreate() {
                
                if(!this.sliderRef) {
                    this.sliderRef = {
                        scriptClass: 'mstrmojo.Slider', 
                        isHoriz: true, 
                        ontitleChange: function() {
                            if(this.domNode && this.title) {
                                this.domNode.setAttribute('title', this.title);
                            }
                        },
                        onselectionChange: function() {
                            if(!this.hasRendered) {
                                return ;
                            }
                            var v = this.items[this.selectedIndex] && this.items[this.selectedIndex].n,
                                w = this.parent;
                            
                            if (w.unset){
                                w.unset = false;
                                $C.removeClass(this.domNode, 'unset');
                            }
                            
                            w.set('valueText', v);
                            w.set('value', v);
                            this.typeHelper.updateThumb();
                        }
                    };
                }
                
                this.sliderRef.slot = 'sliderNode'; 
                this.sliderRef.alias = 'sliderBar';
                this.addChildren(this.sliderRef);
            },
            
            preBuildRendering: function(){
                this._super();
                
                var min = this.min, 
                    max = this.max, 
                    v = mstrmojo.num.parseNumeric(this.value), 
                    items = this.items,
                    idx,
                    sliderBar = this.sliderBar;
                
                if (this.isSequential){
                    
                    idx = Math.floor((Math.max(Math.min(v, max), min) - min) / this.interval);
                    if(isNaN(v) || v < min || v > max) {
                        this.unset = true;
                    }
                }else{
                    
                    idx = mstrmojo.array.find(items, 'v', String(v));
                    if (idx == -1){
                        this.unset = true;
                        idx = 0;
                    }
                }
                
                sliderBar.set('items', items);
                sliderBar.select(idx || 0);
            },
            
            postBuildRendering: function(){
                this._super();
                
                if (this.unset){
                    $C.addClass(this.sliderBar.domNode, 'unset');
                }
            },
            
            
            alignSlider: function(baseNode, height) {

                var va = getVerticalAlign(baseNode),
                    ws, wv;

                
                if(!this.valuePartNode) {
                    wv = this.valueCssText || '';
                    ws = this.sliderCssText || ''; 
                    
                    if(va === VALIGN_TOP) {
                        this.valueCssText = 'top:0;' + wv;
                        this.sliderCssText = 'top:0;' + ws;
                    }else if(va === VALIGN_BOTTOM) {
                        this.valueCssText = 'bottom:0;' + wv;
                        this.sliderCssText = 'bottom:0;' + ws;
                    } else {
                        this.valueCssText = 'height: 100%; line-height: ' + height + 'px;' + wv;
                        this.sliderCssText = 'height: 100%;' + ws;
                    }
                
                
                } else {
                    ws = this.sliderPartNode.style;
                    wv = this.valuePartNode.style;
                    
                    
                    if(va) {
                        if(va === VALIGN_TOP) {
                            ws.top = wv.top ='0';
                        } else if(va === VALIGN_BOTTOM) {
                            ws.bottom = wv.bottom = '0';
                        } else {
                            wv.height = ws.height = '100%';
                            wv.lineHeight = inlineHeight + 'px';
                        }
                    }
                }
            }
        }
    );
})();
(function() {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.registry", "mstrmojo.tooltip");
    var $D = mstrmojo.dom;
    var $R = mstrmojo.all;

    
    mstrmojo._HasDnD = {
            
            postBuildRendering: function postBuildRendering() {
                if (this._super) {
                    this._super();
                }

                
                var id = this.id;
                this.dnd = new mstrmojo._DnDComponent({
                    target: this
                });
                this.__mouseDownEvt = function (e) {
                    $R[id].dnd.onmousedown(e);
                    return true;
                };
                $D.attachEvent(this.dndNode, 'mousedown', this.__mouseDownEvt);
            },

            unrender: function unrender() {
                
                if (this.__mouseDownEvt && this.dndNode) {
                    $D.detachEvent(this.dndNode, 'mousedown', this.__mouseDownEvt);
                }
                
                
                this.min = 0;
                this.max = (this.items && this.items.length - 1) || 0;

                this.dnd && this.dnd.clearListeners();
                this._super();
            }

    };
    
    mstrmojo._DnDComponent = mstrmojo.declare(
        
        null,
        
        null,
        
        {
                scriptClass: "mstrmojo._DnDComponent",
                
                isDragging: null,

                
                initD: null,
                
                startE: null,
                
                afterDragStart: null,
                duringDrag: null,
                afterDragEnd: null,

                
                target: null,

                
                mousemoveBuffer: 1,

                
                _mousemoveCounter: 0,
                
                init: function init_DnDComp(props) {

                    
                    mstrmojo.hash.copy(props, this);    
                },
                
                onmousedown: function onmousedown(e) {
                    
                    
                    
                    if (e && e.preventDefault) {
                        e.preventDefault();
                    }

                    if (this.dragging) {
                        return true;
                    }



                    var id = this.target.id;
                    if (!this._mousemoveCallback) {
                        this._mousemoveCallback = function(e) {
                            $R[id].dnd.onmousemove(e);
                            return true;
                        };
                    }
                    this._mousemoveCounter = 0;

                    this.startE = mstrmojo.hash.copy(e);

                    $D.attachEvent(document.body, 'mousemove', this._mousemoveCallback);

                    if (!this._cancelCallback) {
                        this._cancelCallback = function(e) {
                            $R[id].dnd.ondragcancel(e);
                            return true;
                        };
                    }

                    $D.attachEvent(document.body, 'mouseup', this._cancelCallback);
                },
                
                ondragcancel: function ondragcancel(e) {
                    
                    $D.detachEvent(document.body, 'mousemove', this._mousemoveCallback);
                    $D.detachEvent(document.body, 'mouseup', this._cancelCallback);

                    if (this.afterDragCancel) {
                    	this.afterDragCancel.apply(this.target, [e]);
                    }
                },
                
                onmousemove: function onmousemove(e) {
                    if (this.dragging) {
                        return;
                    }
                    this._mousemoveCounter++;
                    if (this._mousemoveCounter > this.mousemoveBuffer) {
                        $D.detachEvent(document.body, 'mousemove', this._mousemoveCallback);
                        $D.detachEvent(document.body, 'mouseup', this._cancelCallback);

                        this.initDrag(e);
                    }
                },
                
                initDrag: function initDrag(e) {
                    this.dragging = true;
                    var id = this.target.id;
                    if (!this._dragCallback) {
                        this._dragCallback = function(e) {
                            $R[id].dnd.ondrag(e);
                            return true;
                        };
                    }

                    $D.attachEvent(document.body, 'mousemove', this._dragCallback);

                    if (!this._dragEndCallback) {
                        this._dragEndCallback = function(e) {
                            $R[id].dnd.ondragend(e);
                            return true;
                        };
                    }
                    $D.attachEvent(document.body, 'mouseup', this._dragEndCallback);

                    
                    if (this.afterDragStart) {
                        this.afterDragStart.apply(this.target, [e]);
                    }

                    this._dragCallback(e);
                },
                
                ondrag: function ondrag(e) {
                    
                    if (this.duringDrag) {
                        this.duringDrag.apply(this.target, [e]);
                    }
                },
                
                ondragend: function ondragend(e) {
                    this.dragging = false;
                    $D.detachEvent(document.body, 'mousemove', this._dragCallback);
                    $D.detachEvent(document.body, 'mouseup', this._dragEndCallback);
                    
                    if (this.afterDragEnd) {
                        this.afterDragEnd.apply(this.target, [e]);
                    }
                },

                clearListeners: function clearListeners() {
                    
                    if(this._mousemoveCallback) {
                        $D.detachEvent(document.body, 'mousemove', this._mousemoveCallback);
                        delete this._mousemoveCallback;
                    }

                    if(this._cancelCallback) {
                        $D.detachEvent(document.body, 'mouseup', this._cancelCallback);
                        delete this._cancelCallback;
                    }


                    if(this._dragCallback) {
                        $D.detachEvent(document.body, 'mousemove', this._dragCallback);
                        delete this._dragCallback;
                    }

                    if(this._dragEndCallback) {
                        $D.detachEvent(document.body, 'mouseup', this._dragEndCallback);
                        delete this._dragEndCallback;
                    }
                }
        }
    );

    mstrmojo.requiresCls("mstrmojo.Widget", "mstrmojo._HasDnD", "mstrmojo._ListSelections");
    
    function SingleSlider(sl) {
        this.getUnit = function getUnit() {
            return sl._effLen / (sl.items.length - 1) || 1;
        };

        this.calcMinMax = function (pxMin, pxMax) {
            var p = Math.round((pxMin / sl.unit + pxMax / sl.unit) / 2);
            return {
                min: p,
                max: p
            };
        };

        this.preUpdateThumb = function () {
            sl.start = Math.min(sl.min * sl.unit, sl._effLen) + 'px';
            sl.sdCssText += sl.orCfg.posCssP + ':' + sl.start + ';';
        };

        this.updateThumb = function () {
            sl.containerNode.style[sl.orCfg.posCssP] = sl.start = Math.min(sl.min * sl.unit, sl._effLen) + 'px';
        };
    }

    
    function MultiSlider(sl) {
        this.getUnit = function () {
            return sl._effLen / sl.items.length; 
        };

        this.calcMinMax = function (pxMin, pxMax) {
            return {
                min: Math.floor(pxMin / sl.unit + 0.5),
                max: Math.floor(pxMax / sl.unit - 0.5)
            };
        };

        this.preUpdateThumb = function () {
            sl.start = (sl.min * sl.unit) + 'px';
            sl.length = Math.max(Math.round((sl.max - sl.min + 1) * sl.unit - sl.gap), 0) + 'px';
            sl.sdCssText += sl.orCfg.posCssP + ':' + sl.start + ';' + sl.orCfg.lenCssP + ':' + sl.length + ';';
        };

        this.updateThumb = function () {
            sl.start = sl.min * sl.unit + 'px';
            sl.containerNode.style[sl.orCfg.posCssP] = (sl.min * sl.unit) + 'px';
            sl.length = Math.max(Math.round((sl.max - sl.min + 1) * sl.unit - sl.gap), 1) + 'px';
            sl.containerNode.style[sl.orCfg.lenCssP] = sl.length;
        };
    }
    var _tooltipMarkup = '<span>{@content}</span>';
    
    mstrmojo.Slider = mstrmojo.declare(
            
            mstrmojo.Container,

            
            [mstrmojo._HasDnD, mstrmojo._ListSelections],

            
            {
                scriptClass: "mstrmojo.Slider",

                markupString: '<div class="mstrmojo-Slider {@cssClass} {@clsType} {@clsOrientation}" style="{@cssText}" >' +
                                '<div class="cont">' +
                                	'<div class="bk" style="{@bkCssText}"></div>' +
                                	'<div class="sdc" style="position:absolute;{@sdcCssText}">' +
	                                    '<div class="sd" style="{@sdCssText}">' +
	                                        '<div class="t1"></div>' +
	                                        '<div class="t2"></div>' +
	                                        '<div class="t3"></div>' +
	                                    '</div>' +
                                    '</div>' +
                                '</div>' +
                            '</div>',

                sdCssText: '',

                cssClass: 'sc',

                clsType: 'sc2',

                clsOrientation: 'sc-v',

                
                orCfg: null,

                
                typeHelper: null,
                
                _tooltip_pos: 0,

                useRichTooltip: true,

                init: function init(p) {
                    this._super(p);

                    
                    if (p.isHoriz) {
                        this.orCfg = {
                            posCssP : 'left',
                            marginCssP: 'marginLeft',
                            lenCssP : 'width',
                            lenP : 'clientWidth',
                            opPosCssP: 'top',
                            thickP: 'clientHeight',
                            offsetP: 'x'
                        };

                        this.clsOrientation = ' sc-h';
                        this._tooltip_pos = mstrmojo.tooltip.POS_BOTTOMLEFT;
                    } else {
                        this.orCfg = {
                            posCssP : 'top',
                            marginCssP: 'marginTop',
                            lenCssP: 'height',
                            lenP : 'clientHeight',
                            opPosCssP: 'left',
                            thickP: 'clientWidth',
                            offsetP: 'y'
                        };
                        this._tooltip_pos = mstrmojo.tooltip.POS_TOPRIGHT;
                    }
                    
                    this._exRoom = this.thumbWidth;
                    if (this.multiSelect) {
                        this._exRoom *= 2;
                    }

                    
                    if (p.multiSelect) {
                        this.typeHelper = new MultiSlider(this);
                    } else {
                        this.clsType = 'sc1';

                        this.typeHelper = new SingleSlider(this);
                    }
                },

                markupSlots: {
                    dndNode: function() {return this.domNode.childNodes[0];},    
                    bgNode: function() {return this.domNode.childNodes[0].childNodes[0];},
                    sdcNode: function() {return this.domNode.childNodes[0].childNodes[1];},
                    containerNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0];},
                    frontNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0].childNodes[0];},
                    thumbNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0].childNodes[1];},
                    endNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0].childNodes[2];},
                    tooltipNode: function(){return this.domNode.childNodes[0].childNodes[1];}
                },

                markupMethods: {
                    onvisibleChange: function(){ this.domNode.style.display = this.visible ? 'block' : 'none'; }
                },

                start: '50px',    

                length: '30px',    

                min: 0,            

                max: 0,            

                gap: 1,         

                ghost: null,    

                thumbWidth: 11,

                
                cssBkBW: 1,

                
                preBuildRendering: function preBuildRendering() {


                    
                    var d = this.orCfg.lenCssP,
                        v = this[d],
                        len = parseInt(v);

                    this._effLen = isNaN(len) ? 0 : (len - this._exRoom);

                    if (v) {
                        this.bkCssText = d + ':' + Math.max(parseInt(v, 10) - (2 * this.cssBkBW), 0) + 'px;';
                        this.sdcCssText = d + ':' + this._effLen + ';' + this.orCfg.posCssP + ':' + this._exRoom /2 + 'px;' + this.orCfg.opPosCssP + ':0px;';

                    }

                    
                    var idx = this.selectedIndices;
                    if (!mstrmojo.hash.isEmpty(idx)) {
                        this.min = this.items.length - 1;
                        this.max = 0;


                        
                        for (var i in idx) {
                            if (idx[i]) {
                                this.min = Math.min(this.min, i);
                                this.max = Math.max(this.max, i);
                            }
                        }
                    }
                    this.unit = this.typeHelper.getUnit();
                    this.typeHelper.preUpdateThumb();
                },

                postBuildRendering: function postBuildRendering() {
                    if (this._super) {
                        this._super();
                    }

                    if (this.items.length > 1 && this.dnd) {
                        
                        this.dnd.afterDragStart = this.initDrag;
                        this.dnd.duringDrag = this.ondrag;
                        this.dnd.afterDragEnd = this.ondrop;
                        this.dnd.afterDragCancel = this.cancelDrag;
                    }
                },

                
                _initGhost: function _initGhost() {
                    if (!this.ghost) {
                        var cn = this.containerNode.cloneNode(true);
                        mstrmojo.css.addClass(cn, ['gh']);

                        
                        this.ghost = {
                            containerNode: cn,
                            frontNode: cn.childNodes[0],
                            thumbNode: cn.childNodes[1],
                            endNode: cn.childNodes[2]
                        };

                        this.sdcNode.appendChild(cn);
                    }

                    
                    var gSty = this.ghost.containerNode.style,
                        cnSty = this.containerNode.style,
                        oc = this.orCfg;

                    gSty[oc.posCssP] = cnSty[oc.posCssP];
                    gSty[oc.lenCssP] = cnSty[oc.lenCssP];
                    gSty.display = 'block';

                    return this.ghost;
                },

                initDrag: function initDrag(e, hWin) {
                    hWin = hWin || window;

                    
                    var g = this._initGhost(),
                        oc = this.orCfg;

                    
                    this.dnd.initD = {
                            tP: parseInt(this.start, 10),                        
                            sL: this._effLen,                 
                            contL: g.containerNode[oc.lenP],                     
                            offset: $D.getMousePosition(this.dnd.startE, hWin)[oc.offsetP]     
                        };

                        this.dnd.initD.td = $D.eventTarget(hWin, this.dnd.startE);
                },

                ondrag: function ondrag( e, hWin){
                    hWin = hWin || window;

                    var initD = this.dnd.initD,
                        g = this.ghost,
                        cn = g.containerNode,
                        minPx,
                        maxPx,
                        lenPx,
                        min = this.min,
                        max = this.max,
                        oc = this.orCfg;

                    
                    var diff = $D.getMousePosition(e, hWin)[oc.offsetP] - initD.offset;
                    switch (initD.td) {
                        case this.thumbNode:    
                            minPx = Math.max(Math.min(initD.tP + diff, initD.sL - initD.contL), 0);
                            maxPx = minPx + initD.contL;

                            cn.style[oc.posCssP] = minPx + 'px';

                            var minmax = this.typeHelper.calcMinMax(minPx, maxPx);
                            min = minmax.min;
                            max = minmax.max;
                            break;

                        case this.frontNode:    
                            minPx = Math.max(Math.min(initD.tP + diff, initD.tP + initD.contL), 0);
                            lenPx = Math.max(Math.min(initD.contL - diff, initD.tP + initD.contL), 0);

                            cn.style[oc.posCssP] =  minPx + 'px';
                            cn.style[oc.lenCssP] =  lenPx + 'px';

                            min = Math.min(Math.floor(minPx / this.unit + 0.5), this.max);
                            break;

                        case this.endNode:        
                            lenPx = Math.max(Math.min(initD.contL + diff, initD.sL - initD.tP), 0);
                            maxPx = initD.tP + lenPx;

                            cn.style[oc.lenCssP] =  lenPx + 'px';

                            max = Math.max(Math.floor(maxPx / this.unit - 0.5), this.min);
                            break;

                        default:
                            return;

                    }

                    
                    if (min !== this.min || max !== this.max) {
                        this.min = min;
                        this.max = max;

                        
                        this.typeHelper.updateThumb();
                    }

                    this._updateTooltip();
                },

                ondrop: function ondrop( e){
                    
                    this.typeHelper.updateThumb();

                    
                    if (this.ghost) {
                        this.ghost.containerNode.style.display = "none";
                    }

                    
                    this.hideTooltip();

                    
                    if (this.items && this.items.length){ 
                    var sel = [];
                    for (var i = this.min; i <= this.max; i ++) {
                        sel.push(i);
                    }

                    this.select(sel);
                    }
                    
                    this.dnd.initD = null;
                },

                cancelDrag: function cancelDrag(e, hWin) {
                	if (this.makeSelection) {
                		hWin = hWin || window;
                		var td = $D.eventTarget(hWin, this.dnd.startE);
                		this.makeSelection({
                			selItem: td
                		});
                	}
                },

                
                showTooltip: function showTooltip(e, win) {
                    this._updateTooltip();
                    this._super(e, win);
                },

                hideTooltip: function hideTooltip(e, win) {
                    
                    if (this.dnd && this.dnd.dragging) {
                        return;
                    }
                    this._super(e, win);
                },
                
                _updateTooltip: function _updateTooltip() {

                    var oc = this.orCfg,
	                    tt = {
	                            contentNodeCssClass: 'sc-tooltip',
	                            refNode: this.domNode,
	                            posType: this._tooltip_pos 
	                        },
                    	ref = (this.ghost) ? this.ghost.containerNode : this.containerNode;

                    
                    tt[oc.opPosCssP] = 0; 
                    tt[oc.posCssP] = ref.style[oc.posCssP];

                    if (this.items && this.items.length) { 
	                    var min = this.getItemTooltip(this.items[this.min]);
                    var txt;
                    if (this.min === this.max) {
	                        txt = min;
                    } else {
	                        txt = mstrmojo.desc(146, "From:") + " \'" +
	                            min +
	                            "\' " + mstrmojo.desc(147, "To:") + " \'" +
	                            this.getItemTooltip(this.items[this.max]) + '\'';
	                    }

	                    tt.content = _tooltipMarkup.replace(/\{@content\}/g, txt);
                    } else {
                    	tt.content = '';
                    }
                    
                    this.set('richTooltip', tt);
                },

                
                getItemTooltip: function(item) {
                    return "'" + (item ? item.n : "") + "'";
                },

                unrender: function unrender(ignoreDOM) {
                    this.ghost = null;
                    this.dnd && (this.dnd.dragging = false);
                    this.hideTooltip();
                    this._super(ignoreDOM);
                },

                
                onselectionChange: function onselChg(evt) {
                    
                    if (this.onchange) {
                        this.onchange();
                    }

                	if (this.makeSelection && this.dnd && this.dnd.initD) {
                		this.makeSelection({
                			selItem: this.dnd.initD.td
                		});
                	}
                }
            }
    );
    mstrmojo.Slider.SINGLE_HANDLE_WIDTH = 11;
    mstrmojo.Slider.SCROLLHANDLEWIDTH = 11;

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.DocTextfield");


    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css,

        DPST_CAPTION_ONLY = 1,
        DPST_ICON_ONLY = 2,
        DPST_ICON_LEFT = 3,
        DPST_ICON_RIGHT = 4,
        DPST_ICON_TOP = 5,
        DPST_CUSTOM = 6,

        FE_GLOSSY = 1,
        dpstCssClass = [ '', 'CaptionOnly', 'IconOnly', 'IconLeft', 'IconRight', 'IconTop', 'Custom' ];
    
    
    var btnCfg = [];
    btnCfg[DPST_CAPTION_ONLY] = btnCfg[DPST_ICON_ONLY] = btnCfg[DPST_CUSTOM] = {
        minsp: 0,
        mincs: 0
    };
    
    btnCfg[DPST_ICON_LEFT] = btnCfg[DPST_ICON_RIGHT] = {
        minsp: 10,
        mincs: 5
    };
    
    btnCfg[DPST_ICON_TOP] = {
        minsp: 4,
        mincs: 5
    };

    
    function centerAlign(e, isH, isV, innerBox, cutoff) {
        var pos = $DOM.position(e),                     
            ppos = $DOM.position(e.parentElement),      
            es = e.style;
        innerBox = innerBox || {};
        innerBox = {'t':innerBox.t||0, 'r':innerBox.r||0, 'b':innerBox.b||0, 'l':innerBox.l||0};    
        innerBox.h = ppos.h-innerBox.t-innerBox.b;      
        innerBox.w = ppos.w-innerBox.l-innerBox.r;      
        if (cutoff) {
            if (pos.h > innerBox.h) es.height = innerBox.h + 'px';
            if (pos.w > innerBox.w) es.width  = innerBox.w + 'px';
            pos = $DOM.position(e);                     
        }
        if (isH) {
            es.top = ((innerBox.h - pos.h)/2 + innerBox.t) + 'px';
        }
        if (isV) {
            es.left = ((innerBox.w - pos.w)/2 + innerBox.l) + 'px';
        }
    }

    
    function appendAndCentralizeImg(e, src, className) {
        var img = document.createElement('img'),
            imgsty = img.style;
        e.appendChild(img);
        $DOM.attachEvent(img, 'load', function () {
            var disp = imgsty.display;
            imgsty.display = 'block'; 
            centerAlign(img, true, true);
            imgsty.display = disp;
        }, true);
        img.className = className;
        img.src = src;
    }   

    
    mstrmojo.DocButton = mstrmojo.declare(
        
        mstrmojo.DocTextfield,

        
        null,

        
        {
            scriptClass: "mstrmojo.DocButton",

            pressed: false,

            markupString: '<div id="{@id}" class="mstrmojo-DocButton {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                              '<div class="mstrmojo-DocButton-Container" mstrAttach:click,mousedown>' +
                                  '<div class="mstrmojo-DocButton-IconNode"></div>' +
                                  '<div class="mstrmojo-DocButton-ValueNode" style="{@valueNodeCssText}">{@v}</div>' +
                              '</div>' +
                              '<div class="mstrmojo-DocButton-EffectOverlay"></div>' +
                              '{@buttonNodeMarkup}' +
                          '</div>',

            markupSlots: {
                iconNode: function () { return this.domNode.firstChild.firstChild; },
                valueNode: function () { return this.domNode.firstChild.lastChild; },
                buttonContainerNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onpressedChange: function () {
                    var isPressed = !!this.pressed,
                        defn = this.defn,
                        domNode = this.domNode,
                        fmts = this.fmts;

                    
                    $CSS.toggleClass(domNode, 'pressed', isPressed);

                    
                    this.setBackgroundColor();
                    this.valueNode.style.color = isPressed ? defn.fhlc : (fmts.color || '');
                },
				onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            formatHandlers: {
                domNode:  [ 'T', 'z-index', 'D', 'B', 'P', 'background-color' ],
                valueNode: [ 'font', 'fx', 'color', 'white-space', 'overflow' ]
            },
            
            setBackgroundColor: function setBackgroundColor() {

                this.domNode.style.backgroundColor = (!!this.pressed) ? this.defn.bhlc : (this.fmts['background-color'] || '');
            },

            
            getAnchor: function getAnchor() {
                return this.domNode;
            },

            getDPI: function getDPI() {        
                return this.model.dpi;
            }, 
            
            buildRendering: function buildRendering() {
                this._super();

                var defn = this.defn,
                    dm = this.domNode,
                    bc = this.buttonContainerNode,
                    ic = this.iconNode,
                    vl = this.valueNode,
                    dpst = parseInt((defn && defn.dpst) || 1, 10),    
                    px = 'px';

                $CSS.toggleClass(dm, dpstCssClass[dpst], true);

                
                
                dm.onselectstart = dm.ondragstart = function () {
                    return false;
                };

                var fmts = this.getFormats(),
                    innerBorderWidth = parseInt($CSS.getComputedStyle(bc).borderWidth, 10) * 2;     

                
                if (isNaN(innerBorderWidth)) {
                    
                    innerBorderWidth = 0;
                }
                    
                var w = parseFloat(fmts.width) - innerBorderWidth,    
                    h = parseFloat(fmts.height) - innerBorderWidth,   
                    cfg = btnCfg[dpst],
                    minsp = cfg.minsp,             
                    mincs = cfg.mincs,             
                    icsize,                        
                    ics = ic.style,                
                    vls = vl.style;                

                function setIcsize(s) {            
                    ics.height = ics.width = s + px;
                }

                
                var buttonContainerNodeStyle = bc.style;
                buttonContainerNodeStyle.height = h + px;
                buttonContainerNodeStyle.width = w + px;

                switch (dpst) {
                case DPST_ICON_TOP:
                    var dpi = this.getDPI(),
                        outerHeight = h + $CSS.getBorderWidths(fmts['border-width'], dpi).h + $CSS.getPaddings(fmts.padding, dpi).h;
                    icsize = Math.max(0, Math.min(w, h - minsp - mincs, outerHeight * 0.6)); 
                    setIcsize(icsize);
                    centerAlign(ic, false, true);
                    centerAlign(vl, true, false, {'t':icsize+minsp}, true);
                    break;

                case DPST_ICON_LEFT:
                case DPST_ICON_RIGHT:
                    icsize = Math.max(0, Math.min(h, w - minsp - mincs));
                    setIcsize(icsize);
                    centerAlign(ic, true, false);
                    vls[(dpst === DPST_ICON_LEFT) ? 'left' : 'right'] = (icsize + minsp) + px;
                    centerAlign(vl, true, false);
                    break;

                case DPST_CAPTION_ONLY:
                    centerAlign(vl, true, false);
                    break;

                case DPST_ICON_ONLY:
                case DPST_CUSTOM:
                    
                    break;
                }

                if (FE_GLOSSY === parseInt(defn.fe, 10)) {
                    $CSS.addClass(dm, 'gloss');
                }

                
                appendAndCentralizeImg(ic, defn.nmurl, 'normal');
                appendAndCentralizeImg(ic, defn.hlurl || defn.nmurl, 'hilight');

                
                var icMaskNode = document.createElement('div');
                $CSS.addClass(icMaskNode, 'mstrmojo-DocButton-IconMaskNode');
                ic.appendChild(icMaskNode);
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.Container",
                         "mstrmojo.num",
                         "mstrmojo.HBox",
                         "mstrmojo._IsInputControl",
                         "mstrmojo._TouchGestures");

    var $D = mstrmojo.dom,
        $DAE = $D.attachEvent,
        $DDE = $D.detachEvent,
        $C = mstrmojo.css,
        _DTP = mstrmojo.expr.DTP,
        _BTN = 'mstrmojo.Button',
        _N = mstrmojo.num,
        _TR = mstrmojo.validation.TRIGGER,
        HOLD_INTERVAL = 50,
        HOLD_THRESHOLD = 500,
        DECIMAL_NUM = 10;

    function attachWinEvts() {
        var me = this;
        $DAE(window, $D.TOUCHSTART, me._evtHandler, true);
        me.isActive = true;
    }
    
    function detachWinEvts() {
        var me = this;
        $DDE(window, $D.TOUCHSTART, me._evtHandler, true);
        me.isActive = false;
    }

    function decimalFormat(v) {
        return v ? parseFloat(v.toFixed(DECIMAL_NUM)) : v;
    }

    function minusCalc() {
        var v = this.numericValue,
            max = this.max,
            min = this.min,
            itv = this.itv;

            if (!isNaN(v)) {
                if (max !== undefined && v - itv > max) {
                    this.set('numericValue', max);
                } else if (min === undefined || v - itv >= min) {
                    this.set('numericValue', decimalFormat(v - itv));
                } else if (v > min && v - itv < min) {
                    this.set('numericValue', min);
                }
            }
    }

    function plusCalc() {
        var v = this.numericValue,
            max = this.max,
            min = this.min,
            itv = this.itv;

        if (!isNaN(v)) {
            if(min !== undefined && v + itv < min) {
                this.set('numericValue', min);
            } else if (max === undefined || v + itv <= max) {
                this.set('numericValue', decimalFormat(v + itv));
            } else if (v < max && v + itv > max) {
                this.set('numericValue', max);
            }
        }
    }

    function processEvent(isPlus) {
        if (isPlus) {
            plusCalc.call(this);
        } else {
            minusCalc.call(this);
        }
    }

    function startStepperInterval(isPlus) {
        var me = this;
        this._holdTimer = setInterval(function () {
            processEvent.call(me, isPlus);
        }, HOLD_INTERVAL);
    }

    function stopStepperInterval() {
        if (this._holdTimer) {
            clearInterval(this._holdTimer);
            delete this._holdTimer;
        }
    }

    function startStepperTimeout(isPlus) {
        var me = this;
        if (!this._holdTimer && !this._startHoldTimer) {
            this._startHoldTimer = setTimeout(function () {
                delete me._startHoldTimer;
                startStepperInterval.call(me, isPlus);
            }, HOLD_THRESHOLD);
        }
    }

    function stopStepperTimeout() {
        if (this._startHoldTimer) {
            clearTimeout(this._startHoldTimer);
            delete this._startHoldTimer;
        }
        stopStepperInterval.call(this);
    }

    function isTapOnPlus(evt) {
       var v = evt.target;
       return (this.plusNode && this.plusNode == v);
    }

    function isTapOnMinus(evt) {
        var v = evt.target;
        return (this.minusNode && this.minusNode == v);
    }

    function applayChange() {
        var v = this.numericValue;
        if (!isNaN(v) && v >= this.min && v <= this.max && v != this.value) {
            this.set('value', v);
        }
    }
    
    function addTouchedClass(el) {
        $C.addClass(el, 'touched');
    }

    function createDICWidget(dic) {
        var max = dic.max,
            min = dic.min,
            itv = dic.itv;

        return {
            scriptClass: 'mstrmojo.HBox',
            alias: 'hBox',
            cssText: 'margin:auto',

            children: [{
                scriptClass: _BTN,
                alias: 'minus',
                cssClass: 'mstrmojo-StepperDIC-Operator minus',
                bindings: {
                    enabled: function() { return this.parent.parent.numericValue > min;}
                }
            }, {
                scriptClass: 'mstrmojo.ValidationTextBox',
                cssClass: 'mstrmojo-DataInputControl',
                dtp: _DTP.DOUBLE,
                required: true,
                alias: 'textInput',

                constraints: {
                    trigger: _TR.ONKEYUP | _TR.ONBLUR,
                    max: max,
                    min: min
                },

                bindings: {
                    value: 'this.parent.parent.numericValue'
                },

                onblur: function onblur(evt) {
                    var di = this.parent.parent,
                        value = _N.parseNumeric(this.value);

                    if (!di.isActive) {
                        applayChange.call(this.parent.parent);
                    }

                    this._super && this._super(evt);
                },

                onValid: function() {
                    this.parent.parent.set('numericValue', parseFloat(this.value));
                }
            }, {
                scriptClass: _BTN,
                alias: 'plus',
                cssClass: 'mstrmojo-StepperDIC-Operator plus',

                bindings: {
                    enabled: function() { return this.parent.parent.numericValue < max; }
                }
            }]
        };
    }

    
    mstrmojo.android.inputControls.StepperDIC = mstrmojo.declare(
        
        mstrmojo.Container,
        
        [ mstrmojo._IsInputControl, mstrmojo._TouchGestures ],
        
        {
            scriptClass: 'mstrmojo.android.inputControls.StepperDIC',

            cssClass: 'mstrmojo-StepperDIC',

            isActive: false,

            markupString: '<div id="{@id}" class="{@cssClass}" style="{@cssText}"></div>',

            markupSlots: {
                containerNode: function() { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: function() { this.domNode.style.display = this.visible ? 'block' : 'none'; }
            },

            init: function init(props) {
                this._super && this._super(props);

                this.max = this.dic.max;
                this.min = this.dic.min;
                this.itv = this.dic.itv;

                var _v = parseFloat(this.value);
                this.set('numericValue', isNaN(_v) ? (this.min||0) : _v);

                this.set('children', createDICWidget(this.dic));

                this.plus = this.hBox && this.hBox.plus;
                this.minus = this.hBox && this.hBox.minus;

                var me = this;
                this._evtHandler = this._evtHandler || function(evt) {
                    var t = evt.target;
                    if (!$D.contains(me.domNode, t)) {
                        $D.stopPropogation(evt.view, evt);
                        detachWinEvts.call(me);
                        applayChange.call(me);
                    }
                }
            },

            postBuildRendering: function postBuildRendering () {
                this._super();
                this.plusNode = this.plus && this.plus.domNode;
                this.minusNode = this.minus && this.minus.domNode;
            },

            touchTap: function (touch){
                if (!this.isActive) {
                    attachWinEvts.call(this);
                }
                if (isTapOnPlus.call(this, touch)) {
                    addTouchedClass(this.plusNode);
                    processEvent.call(this, true);
                } else if (isTapOnMinus.call(this, touch)) {
                    addTouchedClass(this.minusNode);
                    processEvent.call(this, false);
                }
            },

            touchBegin: function touchBegin(touch) {
                if (!this.isActive) {
                    attachWinEvts.call(this);
                }
                if (isTapOnPlus.call(this, touch)) {
                    addTouchedClass(this.plusNode);
                    startStepperTimeout.call(this, true);
                } else if (isTapOnMinus.call(this, touch)) {
                    addTouchedClass(this.minusNode);
                    startStepperTimeout.call(this, false);
                }
            },

            touchEnd: function touchEnd(touch) {
                stopStepperTimeout.call(this);
            },

            unrender: function unrender(ignoreDom) {
                if (this.isActive) {
                    detachWinEvts.call(this);
                }
                stopStepperTimeout.call(this);
                this._super(ignoreDom);
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                mstrmojo.css.addClass(this.domNode.firstChild || d, 'tx-active');
            }
        }
    );
}());
(function(){

	mstrmojo.requiresCls("mstrmojo.css", "mstrmojo._HasBuilder");
	
	mstrmojo.ToolBar = mstrmojo.declare(
		
		mstrmojo.HBox,
		
		[mstrmojo._HasBuilder],
		
		{
			scriptClass: "mstrmojo.ToolBar",
			
			cellCssClass: "mstrmojo-ToolBar-cell",

			markupString: '<table id="{@id}" class="mstrmojo-ToolBar {@cssClass}" style="{@cssText}" cellspacing="0" cellpadding="0"><tr><td class="mstrmojo-ToolBar-outercell">' +
						      '<table class="mstrmojo-ToolBar-innertable" cellspacing="0" cellpadding="0"><tr>{@tableHtml}</tr></table>' +
						  '</td></tr></table>',
									
			markupSlots: {
				containerNode: function(){ return this.domNode.rows[0].cells[0].firstChild.rows[0]; }
			},
			
			markupMethods: {
				onvisibleChange: function(){ this.domNode.style.display = this.visible ? mstrmojo.css.DISPLAY_TABLE : 'none'; }
			},
			
			
			buildChildren: function bldChd(){
				var cfg = this.buildConfig;
				if (!cfg) {
					this.buildConfig = {};
					cfg = this.buildConfig;
				}
				cfg.target = this.target;
				
				return this._super();
			}
		}
	);

})();
(function(){

	mstrmojo.requiresCls(
		"mstrmojo.Container",
		"mstrmojo.HBox",
		"mstrmojo._HasBuilder",
		"mstrmojo._CanMeasureChildren");
	
	
	var _IsDocSection = {
        
		postBuildRendering: function postBldRndr() {
			return (this.renderMode != 'scroll') ? this._super() : true;
		},

		childRenderOnAddCheck: function(children) {
			return (this.renderMode != 'scroll') ? this._super(children) : false;
		},

		preserveChildDomOrder: false
	};

	function _refresh(me) {
        if (!me.hasRendered) {
            return;
        }
                            
        var c = me.children || [];
        for (var i = c.length - 1; i >= 0; i--) {
            c[i].refresh && c[i].refresh();
        }
	}
	
	
	mstrmojo.DocSection = mstrmojo.declare(
		
		mstrmojo.Container,
		
		
        [ mstrmojo._HasBuilder, _IsDocSection, mstrmojo._CanMeasureChildren ],
		
		
		{
			scriptClass: "mstrmojo.DocSection",
			
			markupString: '<div id="{@id}" class="mstrmojo-DocSection"></div>',
			
			markupSlots: {
				containerNode: function() { return this.domNode; }
			},
            
			
			width: function width(count) {
				return this._super(1);
			},
			
            refresh: function refresh() {
				_refresh(this);
            }
		}
	);
	
	
	
	mstrmojo.DocSectionHoriz = mstrmojo.declare(
		
		mstrmojo.HBox,
		
		
		[ mstrmojo._HasBuilder, _IsDocSection, mstrmojo._CanMeasureChildren ],
		
		
		{
			scriptClass: "mstrmojo.DocSectionHoriz",
			
			
			height: function height(count) {
				return this._super(1);
			},
			
			refresh: function refresh() {
				_refresh(this);
			}
		}
	);	
	
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.DocPanel",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._CanGrowOrShrink",
                         "mstrmojo.hash");

    
    function adjustForInfoWindow() {
        
        var containerNode = this.containerNode;
        if (containerNode) {
            
            var fmts = this.getFormats(),
                parentSize = this._parentSize,
                h = Math.max((parseInt(fmts.height, 10) || 0), parentSize.height),
                w = Math.max((parseInt(fmts.width, 10) || 0), parentSize.width),
                containerNodeStyle = containerNode.style;

            
            containerNodeStyle.width = w + 'px';
            containerNodeStyle.height = h + 'px';
        }
    }

    
    var androidPanel = mstrmojo.android.AndroidDocPanel = mstrmojo.declare(
        
        mstrmojo.DocPanel,

        
        [ mstrmojo._CanGrowOrShrink, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        
        {
            scriptClass: "mstrmojo.AndroidDocPanel",

            
            scrollerSetupDelay: 0,

            postBuildRendering: function postBuildRendering() {
                
                if (this._isInfWin) {
                    
                    adjustForInfoWindow.call(this);
                }

                return this._super();
            },

            
            updatePanelDimensions: function updatePanelDimensions(left, height, width, isInfoWindow) {
                
                this._parentSize = {
                    height: height,
                    width: width
                };

                var px = 'px';

                
                if (isInfoWindow) {
                    
                    this._isInfWin = true;

                    
                    adjustForInfoWindow.call(this);
                }

                
                this.cssText = 'left:' + left + 'px;top:0;height:' + height + px + ';width:' + width + px + ';';

                
                if (this.hasRendered) {
                    
                    var ps = this.domNode.style;

                    
                    ps.left = left + px;
                    ps.height = height + px;
                    ps.width = width + px;

                    this.updateScroller();
                }
            },

            
            update: function update(node) {
                
                this.scrollerConfig = {
                    bounces: false,
                    showScrollbars: false
                };
            },

            
            onchildRenderingChange: function onchildRenderingChange(obj) {
                this._super(obj);

                
                if (this.getFormats().overflow === 'auto') {
                    
                    this.performCanGrowCanShrink([ (obj && obj.src) || obj ], (!!this._isInfWin && !mstrApp.isTablet())); 
                }
            },

            touchTap: function touchTap() {
                
                var ctrl = this.controller;
                if (ctrl && ctrl.viewTap) {
                    
                    ctrl.viewTap();
                }
            },

            getCanGrowShrinkNode: function getCanGrowShrinkNode() {
                return this.containerNode;
            },

            afterCanGrowShrink: function canGrowShrinkPerformed() {
                
                this.updateScroller();
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super();

                
                if (this.getFormats().overflow === 'auto') {
                    var scrollEl = this.containerNode,
                        widgetSize = this._parentSize,
                        iterator = {
                            'Height': {
                                a: 'y',
                                s: 'v'
                            },
                            'Width': {
                                a: 'x',
                                s: 'h'
                            }
                        },
                        offset = {};

                    
                    cfg.scrollEl = scrollEl;

                    mstrmojo.hash.forEach(iterator, function (info, dimension) {
                        
                        var size = widgetSize[dimension.toLowerCase()];

                        
                        var offsetEnd = Math.max(scrollEl['offset' + dimension] - size, 0),
                            enableDimensionScroll = cfg[info.s + 'Scroll'] = (offsetEnd !== 0);

                        
                        if (enableDimensionScroll) {
                            
                            offset[info.a] = {
                                start: 0,
                                end: offsetEnd
                            };
                        }
                    });

                    
                    cfg.offset = offset;

                    
                    cfg.origin = cfg.origin || {
                        x: 0,
                        y: 0
                    };
                }

                return cfg;
            }
        }
    );

    
    var formatHandlers = androidPanel.prototype.formatHandlers,
        nodeName = 'containerNode';

    formatHandlers[nodeName] = formatHandlers[nodeName].concat('D');

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.TextBox",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.css",
                         "mstrmojo.dom");

    var SEARCH_DELAY = 500,
        $CSS = mstrmojo.css;

    
    var delayStrategy = {
        onkeyup: function (sv, sp) {
            
            var hndl = sv._searchTimer;
            if (hndl) {
                window.clearTimeout(hndl);
            }

            sv._searchTimer = window.setTimeout(function () {
                
                sv.searchFunc(sp);

                
                delete sv._searchTimer;
            }, SEARCH_DELAY);
        },

        onEnter: function (sv, sp) {
            sv.searchFunc(sp);
        }
    };

    
    mstrmojo.android.ui.SearchBox = mstrmojo.declare(
        mstrmojo.TextBox,

        [ mstrmojo._TouchGestures ],

        
        {
            
            searchResult: null,

            
            searchStrategy: delayStrategy,

            
            searchFunc: mstrmojo.emptyFn,

            
            clearFunc: mstrmojo.emptyFn,

            monitorInputs: true,

            
            clearSearch: function clearSearch() {
                this.clearFunc();
            },

            onkeyup: function onkeyup() {
                
                
            },

            onEnter: function onEnter() {
            	                                  
                this.searchStrategy.onEnter(this, this.searchValue || this.value);
                delete this.searchValue;
            },

            onvalueChange: function onvalueChange() {
                
                $CSS.toggleClass(this.domNode, 'clear', !!this.value.length);
            },

            touchTap: function (evt) {
                var domNode = this.domNode,
                    e = evt.evt;

                
                if (evt.pageX - mstrmojo.dom.position(e.target).x > (domNode.offsetWidth - parseInt($CSS.getStyleValue(domNode, 'paddingRight'), 10))) {
                    
                    this.set('value', '');

                    
                    this.clearSearch();
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.Label",
                         "mstrmojo.TextBox",
                         "mstrmojo.css",
                         "mstrmojo.array");

    
    mstrmojo.android.ui.TextInput = mstrmojo.declare(

        mstrmojo.Container,

        null,

        
        {
            scriptClass: "mstrmojo.android.ui.TextInput",

            markupString: '<div id="{@id}" class="mstrmojo-AndroidTextInput {@cssClass}" style="{@cssText}">' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onlabelTxtChange: function () {
                    var lbl = this.lbl,
                        text = this.labelTxt;

                    
                    lbl.set('visible', !!text);

                    
                    lbl.set('text', text || '');
                },
                ontextValueChange: function () { this.txt.set('value', this.textValue || ''); },
                ontextTypeChange: function () { this.txt.set('type', this.textType || 'text'); }
            },

            
            labelTxt: '',

            
            textValue: '',

            
            textType: 'text',

            init: function init(props) {
                this._super(props);

                
                this.parent.attachEventListener('widthChange', this.id, function (evt) {
                    
                    var width = parseInt(evt.value, 10),
                        textBoxDomNode = this.txt.domNode,
                        txtStyle = mstrmojo.css.getComputedStyle(textBoxDomNode);

                    
                    mstrmojo.array.forEach([ 'padding', 'margin' ], function (prop) {
                        width -= parseInt(txtStyle[prop + 'Left'], 10);
                        width -= parseInt(txtStyle[prop + 'Right'], 10);
                    });

                    
                    textBoxDomNode.style.width = width + 'px';
                });

                
                var cfg = this.getTextCfg();

                
                cfg.alias = 'txt';
                cfg.cssDisplay = 'block';

                
                this.addChildren([ cfg, {
                    scriptClass: 'mstrmojo.Label',
                    cssClass: 'lblErr',
                    alias: 'lblErr',
                    visible: false
                } ]);
            },

            
            getTextCfg: function getTextCfg() {
                return {
                    scriptClass: 'mstrmojo.TextBox',
                    onEnter: function () {
                        var parent = this.parent,
                            fnEnter = parent.onEnter;

                        
                        if (fnEnter) {
                            
                            fnEnter.call(parent, this.value);
                        }
                    }
                };
            },

            
            getValue: function getValue() {
                return this.txt.value;
            },

            children: [{
                scriptClass: 'mstrmojo.Label',
                alias: 'lbl'
            }],

            onRender: function () {
                this._super();

                
                this.txt.focus();
            }
        }
    );
}());
(function() {

    mstrmojo.requiresCls("mstrmojo.TextBox");

    
    mstrmojo.TextArea = mstrmojo.declare(
        
        mstrmojo.TextBox,
        
        
        null,
        
        
        {
            
            scriptClass: 'mstrmojo.TextArea',
                                                
            markupString: '<textarea id="{@id}" class="mstrmojo-TextArea {@cssClass}"  style="{@cssText}" '
                                + 'title="{@tooltip}" '
                                + 'placeholder="{@placeholderText}" '
                                + 'rows="{@rows}" cols="{@cols}" maxlength="{@maxLength}" index="{@tabIndex}"' +
                                ' mstrAttach:focus,keydown,keyup,blur ' +                              
                              '></textarea>',
                          
            
            maxLength: 256,
            
            markupSlots: {
                inputNode: function(){ return this.domNode; }
            },
            
            postCreate: function() {
                this.markupMethods = mstrmojo.hash.copy(this.markupMethods);
                this.markupMethods.oncssClassChange = function() { 
                    this.domNode.className = "mstrmojo-TextArea " + (this.cssClass||'');
                    };
            },
            
            onkeydown: function(e) {
                var strLen = (this.value && this.value.length) || 0;

                if (this.maxLength <= strLen) {
                    
                    this.isDeleteKeys = e.e.keyCode === 8 || e.e.keyCode === 46;
                    this.isArrowKeys = e.e.keyCode === 37 || e.e.keyCode === 38 || e.e.keyCode === 39 || e.e.keyCode === 40;
                    
                    
                    var hasSelection = (this.domNode.selectionEnd !== undefined) ? (this.domNode.selectionEnd - this.domNode.selectionStart) > 0 :
                                       document.selection.createRange().text.length > 0;

                    if (!this.isDeleteKeys && !this.isArrowKeys && !hasSelection) {

                        
                        if (mstrmojo.dom.isIE7 || mstrmojo.dom.isIE8) {
                            var dn = this.domNode;
                            dn.blur();

                            window.setTimeout(function(){dn.focus();}, 1);
                        }

                        mstrmojo.dom.preventDefault(window, e.e);
                        return false;
                    }
                 }
             }
        }
      );
        
})();
(function() {

    mstrmojo.requiresCls("mstrmojo.TextBox","mstrmojo._CanValidate");

    var _C = mstrmojo.css,
        _V = mstrmojo.validation,
        _TR = _V.TRIGGER,
        _SC = _V.STATUSCODE,
        _MK = mstrmojo.TextBox.prototype.markupMethods;
    
    
    mstrmojo.ValidationTextBox = mstrmojo.declare(
        
        mstrmojo.TextBox,
        
        
        [mstrmojo._CanValidate],
        
        
        {
            scriptClass: 'mstrmojo.ValidationTextBox',
            
            validationDelay: 500,
            
            markupMethods: {
                onvisibleChange: _MK.onvisibleChange,
                onvalueChange: _MK.onvalueChange,
                onenabledChange: _MK.onenabledChange,
                onreadOnlyChange: _MK.onreadOnlyChange,
                ontooltipChange: _MK.ontooltipChange,                
                onvalidationStatusChange: function(){
		            var vs = this.validationStatus;
		            if(!vs) {
		                return;
		            }
		            var it = this.inputNode,
		                isInvalid = (vs.code > _SC.VALID),
		                css = this.constraints.invalidCssClass;   
		                
		            _C.toggleClass(it, css ? css : ['mstrmojo-TextBox-ErrValidation'], isInvalid);
		            if(isInvalid){
		                it.setAttribute('title', vs.msg);
		            }else{
		                if (this._original_tooltip !== undefined && this._original_tooltip !== null) {
		                    it.setAttribute('title', this._original_tooltip);
		                }
		            }                   
		        }
            },

            
            postBuildRendering: function pstBR(){
                if(this._super) {
                    this._super();
                }
                
                
                this._original_tooltip = this.inputNode.title;  
            },
            
            
            prekeyup: function pku(evt) {
                if(this._super){
                    this._super(evt);   
                }
                var tri = (this.constraints.trigger & _TR.ONKEYUP) > 0;
                if(tri){
                    if (this.validationDelay > 0){
                        if(this._valDelayTimer){
                            window.clearTimeout(this._valDelayTimer);
                        }
                        
                        if(!this._validateHandler){
                            var me = this;
                            this._validateHandler = function(){
                                me.validate();      
                                if(me._valDelayTimer){
                                    window.clearTimeout(me._valDelayTimer);
                                    delete me._valDelayTimer;
                                }                        
                            };
                        }
                        
                        this._valDelayTimer = window.setTimeout(this._validateHandler, this.validationDelay);
                    }else{
                        this.validate();
                    }
                }
            },
            
            preinput: function(evt) {
                if(this._super){
                    this._super(evt);   
                }
                var tri = (this.constraints.trigger & _TR.ONKEYUP) > 0;
                if(tri){
                    this.validate();   
                }
            },
            
            
            preblur: function pb(evt) {
                if(this._super){
                    this._super(evt);   
                }
                var tri = (this.constraints.trigger & _TR.ONBLUR) > 0;
                if(tri){
                    this.validate();   
                }
            },

            
            clearValidation: function clearValidation(){
                if(this._super){
                    this._super();   
                }
                var it = this.inputNode,
                    css = this.constraints.invalidCssClass;
                _C.removeClass(it, css ? css : ['mstrmojo-TextBox-ErrValidation']);
                it.title = this._original_tooltip; 
            }            
        });
})();            
(function() {

    mstrmojo.requiresCls("mstrmojo.Widget", "mstrmojo.css", "mstrmojo.TextBox");
    
    
    mstrmojo.TextBoxWithLabel = mstrmojo.declare(
        
        mstrmojo.TextBox,
        
        
        null,
        
        
        {
            scriptClass: 'mstrmojo.TextBoxWithLabel',
                        
            
            label: '',
            
            
            rightLabel: '',
            
            cssDisplay: 'inline',
            
            type: "text",
                 
            markupString: '<div class="mstrmojo-TextBoxWithLabel {@cssClass}" style="{@cssText}">' +
                            '<span class="mstrmojo-TextBox-label">{@label}</span>' +
                            '<input id="{@id}" class="mstrmojo-TextBox {@inputNodeCssClass}"  style="{@inputNodeCssText}" '
                                + 'title="{@tooltip}" type="{@type}" '
                                + 'value="{@value}" size="{@size}" maxlength="{@maxLength}" index="{@tabIndex}"' +
                                ' mstrAttach:focus,keyup,blur ' +                              
                              '/>' +
                              '<span class="mstrmojo-TextBox-label-right">{@rightLabel}</span>' +
                          '</div>',
                          
            markupSlots: {
                inputNode: function(){return this.domNode.firstChild.nextSibling;}
            },
            
            preBuildRendering: function() {
                this.markupMethods = mstrmojo.hash.copy({
                                          onvisibleChange: function(){ this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; },
                                          oncssClassChange: function(){this.domNode.className = "mstrmojo-TextBoxWithLabel " + (this.cssClass||'');}
                                     },
                                     mstrmojo.hash.copy(this.markupMethods));
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Popup",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._IsAnchorable",
                         "mstrmojo.dom");

    var BASE_TIP_CLS = 'mstrmojo-DocInfoWindow-tip',
        DARK_BORDER_WIDTH = 1,
        $D = mstrmojo.dom;

    function _toggleLockInfoWins(anchor, lock) {
        
        var w = $D.findWidget(anchor) || (anchor && anchor.w);

        
        while (w) {
            if (w.autoCloseLocked !== undefined) {
                w.autoCloseLocked = lock;
            }

            w = w.parent;
        }
    }

    function _getContent(me) {
        var m = me.model;
        return m.getLayoutDataCache(m.getCurrentLayoutKey())[me.psId]
    }

    mstrmojo.DocInfoWindow = mstrmojo.declare(
        
        mstrmojo.Popup,

        
        [ mstrmojo._HasBuilder, mstrmojo._IsAnchorable ],

        
        {
            scriptClass: "mstrmojo.DocInfoWindow",

            markupString: '<div class="mstrmojo-DocInfoWindow-wrapper">' +
                              '<div id="{@id}" class="mstrmojo-DocInfoWindow"></div>' +
                              '<div class="' + BASE_TIP_CLS + ' top"></div>' +
                              '<div class="mstrmojo-DocInfoWindow-curtain" mstrAttach:click></div>' +
                          '</div>',

            markupSlots: {
                infoNode: function () { return this.domNode.firstChild; },
                tipNode: function () { return this.domNode.childNodes[1]; },
                curtainNode: function () { return this.domNode.lastChild; },
                containerNode: function () { return this.domNode.firstChild; }
            },

            boundaryNodeName : "boundary",

            popupNodeName : 'infoNode',

            baseTipClass : BASE_TIP_CLS,

            anchorOffset : 1,

            anchorOrientation : 'h',

            anchor: null,

            boundary: null,

            closeOnClick : true,

            autoCloseLocked: false,

            tipNodeColor: '',

            ontouchstart: function ontouchstart() {
                this.close();
            },

            close: function close(){
                
                if (this.autoCloseLocked)
                    return;

                
                
                
                this.model.raiseEvent({
                    name: 'infoWindowClosed',
                    psKey:this.psKey
                });

                
                var me = this;
                window.setTimeout(function () {
                    if (me.anchor) _toggleLockInfoWins(me.anchor, false);
                }, 0);

                if(this._super){
                    this._super();
                }

                
                this.clearAnchorHilites();

                $D.detachEvent(document, $D.isFF ? 'DOMMouseScroll' : 'mousewheel', this.mw);
                $D.attachEvent(document, 'scroll', me.mw);
            },

            clearAnchorHilites: function clearAnchorHilites() {
                var zn = mstrmojo.dom.findWidget(this.anchor);
                if(zn && zn.clearHilites) {
                    zn.clearHilites(zn.hiliteKey);
                    delete zn.hiliteKey;
                }
            },

            prepareAnchor: function prepareAnchor() {
                if(this.children && this.children[0]) {
                var infoNodeStyle = this.infoNode.style,
                    contentChild = this.children[0],
                    contentChildNode = contentChild.dimNode || contentChild.domNode,
                    ifwWidth = contentChildNode.offsetWidth,
                    ifwHeight = contentChildNode.offsetHeight;

                
                infoNodeStyle.width = (ifwWidth + 2 * DARK_BORDER_WIDTH) + 'px';
                infoNodeStyle.height = (ifwHeight + 2 * DARK_BORDER_WIDTH) + 'px';
                }
            },

            nudge: function nudge() {
                this.positionDialog();
                this.model.raiseEvent({name: 'infoWindowRendered',
                                       id: this.id   
                                      });
            },

            onRender: function onRender() {
                this.open(this.opener);
            },

            
            open: function open(opener, config) {
                
                var ps = mstrmojo.all[this.psId];

                
                if (ps) {
                    var showFirstPanel = ps.defn.sfp,
                        currentPanelIdx = ps.selectedIdx;

                    
                    
                    if (showFirstPanel && currentPanelIdx !== 0) {
                        
                        ps.switchToPanel(0, 0);

                        
                        ps.children[currentPanelIdx].set('selected', false);
                    }
                }

                
                if (this._super) {
                    this._super(opener, config);
                }

                
                if (this.anchor) _toggleLockInfoWins(this.anchor, true);

                
                if(mstrApp.isTablet && mstrApp.isTablet()) {
                    var touchManager = mstrmojo.touchManager,
                        id = this.id,
                        infoWindowNode = this.domNode;
                    this._tchHandler = touchManager.attachEventListener('touchesBegin', id, function (evt) {

                        
                        if(this.autoCloseLocked) {
                            return;
                        }

                        
                        var isTappingOnInfoWindow = mstrmojo.dom.contains(infoWindowNode, evt.touch.target, true);

                        
                        var infoboxes = document.getElementsByClassName('heatmap-infobox'),
                            len = (infoboxes && infoboxes.length) || 0,
                            i,
                            target = evt.touch.target,
                            isTappingOnHeatMapTooltip = false;
                        for(i = 0; i < len; i++) {
                            if(mstrmojo.dom.contains(infoboxes[i], target, true)){
                                isTappingOnHeatMapTooltip = true;
                                break;
                            }
                        }

                        if (!isTappingOnInfoWindow && !mstrApp.hasOpenDialog() && !isTappingOnHeatMapTooltip) { 
                            this.closeOnTablet();
                        }
                    });
                }

                
                var me = this;
                me.mw = me.mw || function(e) {
                	
                    if (me.autoCloses &&
                    		!$D.contains(me.domNode, $D.eventTarget(self, e), true, document.body)) {
                        me.close();
                    }
                };
                $D.attachEvent(document, $D.isFF ? 'DOMMouseScroll' : 'mousewheel', me.mw);
                $D.attachEvent(document, 'scroll', me.mw);
            },


            getChildren: function getChildren() {
                return [_getContent(this)];
            },

            preBuildRendering: function preBuildRendering() {
                var c = _getContent(this),
                    f = c.defn.fmts;

                
                f.left = DARK_BORDER_WIDTH + 'px';
                f.top = DARK_BORDER_WIDTH + 'px';


                if (f.border) { 
                    var tmp = f.border.split(' ');
                    if (tmp.length >= 3) {
                        this.tipNodeColor = tmp[2];
                    }
                }

                if (this._super) this._super();
            },

            postBuildRendering: function postBuildRendering() {
                
                
                this.set('visible', true);

                if (this._super) this._super();

                
                
                if (!this.closeOnClick) {
                    this.curtainNode.style.display = 'none';
                }
            },

            
            closeOnTablet: function closeOnTablet() {
                this.close();
                if (this._tchHandler) {
                    this._tchHandler.clear();
                }
            }
        }
    );

    var factory = mstrmojo.DocInfoWindow;
    factory.PLACEMENT = {
        AUTO: 1,
        FIXED: 2,
        ABOVE: 3,
        BELOW: 4,
        LEFT: 5,
        RIGHT: 6
    };

}());
(function(){
    
    mstrmojo.requiresCls(
            "mstrmojo.css",
            "mstrmojo.array",
            "mstrmojo.dom",
            "mstrmojo._TouchGestures",
            "mstrmojo.SmoothScroll",
            "mstrmojo._HasTouchScroller"
    );
    
    var PAD_STEP = 16; 
    
    
    
    var NODE_STATE_TEXT_MAP = {
        0: "&#9654;", 
        1: "&#9660;",  
        2: "&nbsp;" 
    }; 
    
    var NODE_STATE_CSS_MAP = ["heatmap-tree-state-text collapsed", "heatmap-tree-state-text expanded", "heatmap-tree-state-text leaf"];
    
    var SELECTION_STATUS = {
    	NO: 0,
    	YES: 1,
    	PART: 2
    };
    
    
    
    mstrmojo.VisHeatMapTreeItem = mstrmojo.declare(
        
    	mstrmojo.Container, 
        
        null,
        {
            scriptClass:'mstrmojo.VisHeatMapTreeItem',
            
            
            isRoot: false,
            
            
            showRoot: false,
            
            
            rootText: "",
            
            
            idx: 0,
            
            
            buttonNodeCss: "heatmap-tree-checkbox",
            
            
            buttonNodeWidget: null,
            
            
            
            markupString: '<div id="{@id}" class="heatmap-tree" style="{@cssText}">'
                            + '<div class="heatmap-tree-div" idx="{@idx}">'
                            	+ '<div class="heatmap-tree-state">' 
                            		+ '<div class="heatmap-tree-state space">&nbsp;</div>'
                            		+ '<div class="heatmap-tree-state-text"></div>'
                            	+ '</div>'
                            	+ '<div class="heatmap-tree-text"></div>'
                            	+ '<div class="{@buttonNodeCss}">&nbsp;</div>'
                            + '</div>'
                            + '<div class="heatmap-tree-container"></div>'
                            + '</div>',
            
            
            markupSlots: {
                contentNode: function(){return this.domNode.firstChild;},
                stateNode: function(){return this.domNode.firstChild.firstChild;},
                stateSpaceNode: function(){return this.domNode.firstChild.firstChild.firstChild;},
                stateTextNode: function(){return this.domNode.firstChild.firstChild.lastChild;},
                textNode: function(){return this.domNode.firstChild.childNodes[1];},
                buttonNode: function(){return this.domNode.firstChild.childNodes[2];},
                containerNode: function(){return this.domNode.lastChild;}
            },
            
            markupMethods: {
                ontextChange: function(){ this.textNode.innerHTML = this.text;},
                onstateChange: function(){
                    
                	this.stateTextNode.className = NODE_STATE_CSS_MAP[this.state];
                	
                	
                    if (!this.isRoot) {
                    	this.containerNode.style.display = (this.state === 1) ? 'block' : 'none';
                    	if (this.state != 2) {
                    		this.tree.resized();
                    	}
                    }
                }
            },
            
            
            level: -1,
            
            
            tree: null,
            
            
            itemDisplayField: "n",
            
            
            itemChildrenField: "items",
            
            
            isSelectable: true,
            
            
            itemFunctionField: "itemFunction",
            
            
            itemIncludeFunction: function () {return true;}, 
            
            
            dataProvider: null, 
            
            
            owner: null, 

			fillData: function() {
            	var tree = this.tree || this;
            	if (this.dataProvider) {
            		this.items = this.dataProvider[this.itemChildrenField];
            		
            	}
            	var items = this.items;
            	
            	if (this.items && this.items.length) { 
            		this.childTree = [];
					
            		var childIndex = 0; 
                	for (var i = 0; i < items.length; i++) {
                		var item = items[i];
                		if (this.itemIncludeFunction(item)) {
	                		
	                		
							
	                		var text;
	                		if (tree.owner) {
	                			
                                text = item.label;
	                		} else {
	                			text = item[this.itemDisplayField];
	                		}

                            var d = new Date();
                            var t1 = (new Date()).getTime();
	                		

	                		var iw = {
	                				idx: childIndex,
	                				isRoot: false,
	                				text: text,
	                				itemFunction: item[this.itemFunctionField],
	                				buttonNodeWidget: item["buttonNodeWidget"],
	                				tree: tree,
	                				level: (this.level + 1),
	                				itemDisplayField: this.itemDisplayField,
	                                itemChildrenField: this.itemChildrenField,
	                                parent: this,
	                                parentTree: this,
	                                state: 0,
	                                
	                                isSelectable: this.isSelectable,
	                                itemIncludeFunction: this.itemIncludeFunction,
	                                buttonNodeCss: this.buttonNodeCss,
                                    
                                    fillData: this.fillData,
                                    buildTree: this.buildTree,
                                    setChildStatus : this.setChildStatus,
                                    updateSelection : this.updateSelection
                                    
	                			};

                            
	                		
	                		if (this.dataProvider) { 
	                			iw.dataProvider = item;
	                		} else { 
	                			iw.items = item[this.itemChildrenField];
	                		}
	                		this.childTree[childIndex] = iw;
	                		
	                		childIndex++;
                		}
                	}
            	}
				
            
			},
			

            renderChildrenList: function(){
                    if(!this.childTree)
                            return;
                    var len = this.childTree.length,
                        insertIndex,
                        cachedUnits;
                    if(this.tree){
                            cachedUnits = this.tree.cachedUnits;
                            insertIndex = cachedUnits.indexOf(this.contentNode) + 1;
                            if(insertIndex == 0){
                                    insertIndex = cachedUnits.length;
                            }

                    }
                    if(this.isRoot && this.showScrollbars){
                            insertIndex = 0;
                            cachedUnits = this.cachedUnits;
                    }
                    for(var i = 0; i< len; i++){
                            if(this.childTree[i].domNode){
                                    this.tree.cachedUnits.splice(insertIndex, 0, this.childTree[i].contentNode);
                                    insertIndex ++;
                                    continue;
                            }
                            var div = document.createElement('div');
                            this.containerNode.appendChild(div);
                            this.childTree[i].placeholder = div;
                            var treeItem = new mstrmojo.VisHeatMapTreeItem(this.childTree[i]);
                            if(!treeItem)
                                    alert("new failed!");
                            treeItem.childTree = this.childTree[i].childTree;
                            if(treeItem.childTree){
                                    var child = treeItem.childTree,
                                        clen = child.length;
                                    for(var j = 0; j < clen; j++){
                                            child[j].parent = treeItem;
                                            child[j].parentTree = treeItem;
                                    }
                            }

                            this.childTree[i] = treeItem;

                            this.childTree[i].render();

                            if(!isNaN(insertIndex)){
                                    cachedUnits.splice(insertIndex, 0, this.childTree[i].contentNode);
                                    insertIndex ++;
                            }
                    }
            },


            
            postBuildRendering: function () {
            	if(this._super) {
                	this._super();
                }
            	
                
                this.domNode.style.display = 'none';

            	var tree = this.tree || this;
            	if (this.dataProvider) {
            		this.items = this.dataProvider[this.itemChildrenField];
            		
            	}
            	
            	

				
					
            	if (this.isRoot) {
            		if (!this.showRoot) {
            			this.contentNode.style.display = "none";		
            		} else {
            			this.stateNode.style.display = "none";
            			this.textNode.innerHTML = this.rootText;
            		}
            		this.containerNode.className = "heatmap-tree-container root";
            	} else {
	            	if (this.buttonNodeWidget) {
	            		this.buttonNodeWidget.placeholder = this.buttonNode;
	            		var buttonWidget = mstrmojo.insert(this.buttonNodeWidget);
	            		buttonWidget.render();
	            		this.buttonNode = buttonWidget.domNode;
	            	}
	        		this.textNode.innerHTML = this.text;
	            	var padLeft = (this.level + 1) * PAD_STEP; 
	            	this.stateSpaceNode.style.width = (padLeft >= 0? padLeft: 0) + "px"; 
	            	
	            	this.textNode.style.width = this.domNode.offsetWidth - this.stateNode.offsetWidth - this.buttonNode.offsetWidth - 10 + "px";

            	}
                
                if (!(this.items && this.items.length)) {
                        this.set("state", 2); 
                        this.tree.sampleUnit = this.domNode;
                } else {
                        this.set("state", 0); 
                }
                                       

				
                this.domNode.style.display = 'block';
            },
            buildTree: function() {
                    this.fillData();

                    if(this.childTree)
                            var len = this.childTree.length;
                    for(var i = 0; i < len; i++)
                            this.childTree[i].buildTree();
            },

            
            clickHandler: function (evt) {
                    
                            
                    var target = evt.target;
                    if (this.state !== 2 && mstrmojo.dom.contains(this.stateNode, target, true, this.domNode)) {
                            this.set("state", this.state === 0 ? 1 : 0);
                            if(this.state == 1){
                                    
                                    this.renderChildrenList();
                                    this.updateChildrenSelection();
                            }else{
                                    var deleteIndex = this.tree.cachedUnits.indexOf(this.contentNode);
                                    if(deleteIndex != -1){
                                            deleteIndex ++;
                                            var len = this.childTree.length;
                                            this.tree.cachedUnits.splice(deleteIndex,len);
                                    }
                            }
                            this.tree.resized();
                            this.tree.updateScroller();
                            return;
                    }
                    
                    if (this.itemFunction) {
                            this.itemFunction(evt);
                    }
                    if (!this.isSelectable) {
                            return;
                    }
                    
                    mstrmojo.VisHeatMapAnimation.animate(this.contentNode, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});

                    if (this.selectionStatus === SELECTION_STATUS.YES) { 
                            this.selectionStatus = SELECTION_STATUS.NO;
                    } else { 
                            this.selectionStatus = SELECTION_STATUS.YES;
                    }
                    this.setChildStatus(this.selectionStatus);
                    this.updateSelection(false, true);
            },

            
            setChildStatus: function ( status) {
            	if (this.childTree) {
	            	for (var i = 0; i < this.childTree.length; i++) {
	            		var item = this.childTree[i];
                        if(!item)
                                continue;
	            		item.selectionStatus = status;
	            		item.setChildStatus(status);
	            		item.updateSelection(false, false);
	            	}
            	}
            },

            updateChildrenSelection: function(){
                    if(!this.childTree)
                            return ;
                    var len = this.childTree.length;
                    for(var i = 0; i < len; i++)
                    if(this.childTree[i])
                            this.childTree[i].updateSelection(false,false);
            },
            
            
            updateSelection: function ( checkChild,  callParent) {
            	if (checkChild && this.childTree) {
	            	var allSelected = true;
	            	var noSelected = true;
	            	var partSelected = false;
	            	for (var i = 0; i < this.childTree.length; i++) {
	            		var item = this.childTree[i];
	            		if (allSelected && item.selectionStatus !== SELECTION_STATUS.YES) {
	            			allSelected = false;
	            		}
	            		if (noSelected && item.selectionStatus !== SELECTION_STATUS.NO) {
	            			noSelected = false;
	            		}
	            		if (!allSelected && !noSelected) {
	            			partSelected = true;
	            			break;
	            		}
	            	}
	            	this.selectionStatus = allSelected? SELECTION_STATUS.YES: (noSelected? SELECTION_STATUS.NO: SELECTION_STATUS.PART);
            	}
            	var cssClass = "heatmap-tree-div";
            	switch (this.selectionStatus) {
            		case SELECTION_STATUS.YES:
            			cssClass += " selected";
            			break;
            		case SELECTION_STATUS.PART:
            			cssClass += " partSelected";
            			break;
            		case SELECTION_STATUS.NO:
            		default:
            			break; 
            	}
            	
                this.cssName = cssClass;
                if(this.contentNode)
                        this.contentNode.className = cssClass;
            	if (callParent && this.parentTree) {
            		this.parentTree.updateSelection(true, true);
            	}
            	if (this.isRoot) { 
            		this.notifyAll();
            	}
            },
            
            
            resized: function () {
            	if (this.parent.resized) {
            		this.parent.resized(this.domNode.offsetHeight);
            	}
            },
            
            
            selectionStatus: SELECTION_STATUS.NO         
        });
    
    
    mstrmojo.VisHeatMapTree = mstrmojo.declare(
    		
    		mstrmojo.VisHeatMapTreeItem,
    		[mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo.SmoothScroll],
    		
        	{
        		scriptClass: "mstrmojo.VisHeatMapTree",
        		
        		
                isRoot: true,
                
                
                showRoot: false,
                
                
                rootText: "",
                
                
                heightLimit: 0, 
                
                
                defaultSelectionStatus: SELECTION_STATUS.NO,
                
                
                markupString: '<div id="{@id}" class="heatmap-tree root {@cssClass}" style="{@cssText} mstrAttach:mousedown,mousemove,mouseup,click">' +
					                '<div class="heatmap-tree-div" style="line-height:40px;" idx="{@idx}">' +  
	                            		'<div class="heatmap-tree-state" style="display:none;">'  +
	                            			'<div class="heatmap-tree-state space">&nbsp;</div>' +
	                            			'<div class="heatmap-tree-state-text"></div>' +
	                            		'</div>' +
					            		'<div class="heatmap-tree-text"></div>' + 
					            		'<div class="{@buttonNodeCss}">&nbsp;</div>' +
					            	'</div>' +
					            	'<div style="overflow:hidden; position:relative">' + 
					            			'<div class="heatmap-tree-container"></div>' + 
                					'</div>' +
    					       '</div>',

    			markupSlots: {
                    contentNode: function(){return this.domNode.firstChild;},
                    stateNode: function(){return this.domNode.firstChild.firstChild;},
                    stateSpaceNode: function(){return this.domNode.firstChild.firstChild.firstChild;},
                    stateTextNode: function(){return this.domNode.firstChild.firstChild.lastChild;},
                    textNode: function(){return this.domNode.firstChild.childNodes[1];},
                    buttonNode: function(){return this.domNode.firstChild.childNodes[2];},
                    scrollboxNode: function(){return this.domNode.lastChild;},
                    containerNode: function(){return this.domNode.lastChild.firstChild;}
    			},
    			
    			initialized: false,
    			
    			
    			dirty: false,

                showIndicators: false, 

                showScrollbars: false,

                cachedUnits: [],
    			
    			
    			
    			
    			init: function (config) {
    				this._super(config);
    				this.observer = []; 
    			},
    			
    			register: function (widget) {
    				this.observer.push(widget);
    				this.notifyAll();
    			},
    			
    			notifyAll: function () {
    				var enabled = false;
    				if (this.childTree && this.childTree.length > 0) { 
    					enabled = true;
    				}
    				
    				if (enabled) {
    					mstrmojo.css.removeClass(this.contentNode, "disabled");
    				} else {
    					mstrmojo.css.addClass(this.contentNode, "disabled");
    				}
    				
    				if (this.selectionStatus === SELECTION_STATUS.NO) {
    					enabled = false;
    				}
    				for (var index in this.observer) {
    					this.observer[index].notify(enabled);
    				}
    			},

                buildRendering: function() {
                        if(this.isRoot){
                                this.cachedParent = this.parent;
                                delete this.parent;
                        }
                        if(this._super)
                                this._super();
                },
    			
    			postBuildRendering: function () {


                        var t0 = (new Date()).getTime();
    				

                    if(this.isRoot){
                            this.scrollerConfig = {
                                    bounces : false,
                                    showIndicators: this.showIndicators,
                                    showScrollbars : this.showScrollbars,
                                    useTranslate3d : true,
                                    vScroll: true,
                                    hScroll: false,
                                    offset : {
                                            y: {
                                                    start: 0,
                                                    end: 0 
                                            },
                                            x: {
                                                    start: 0,
                                                    end: 0
                                            }
                                    },
                                    origin: {
                                            x: 0,
                                            y: 0
                                    },
                                    scrollEl : this.containerNode
                            };
                    }

                    

                    

    				this._super();




                    

                    

                    

                    
                    this.buildTree();

                    
                    




                    
                    this.renderChildrenList();
                    

                    
                    
                    if(this.isRoot){
                            this.parent = this.cachedParent;
                            this.parent.containerNode.appendChild(this.domNode);
                    }

    				
    				if (this.heightLimit > 0) {
    					var limit = this.heightLimit - this.contentNode.offsetHeight - 2; 
    					if (limit >= 0) {
    						this.scrollboxNode.style.maxHeight = limit + "px";
    					}
    				}

                    
    				this.selectionStatus = this.defaultSelectionStatus;
            		this.setChildStatus(this.selectionStatus);
                	this.updateSelection(false, true);
            		
                    
                    this.viewNode = this.scrollboxNode;

    				this.notifyAll();
                    this.resized();
                    this.updateScroller();


                    
                    


					
					
    				

    			},

    			touchTap: function (event) {
    				var title = mstrmojo.dom.findAncestorByAttr(event.target, "id", true, this.domNode);
    				if (!title) { 
    					
    						this.clickHandler(event);
    					
    						
    					
    					return;
    				}
    				var item = mstrmojo.all[title.value];
    				if (item && item.clickHandler) {
    					item.clickHandler(event);
    				}
    			},
    			
    			resized: function ( childHeight) {
                    
                    var $P = mstrmojo.dom.position;
                    if(!this.viewRect){
                            this.viewRect = $P(this.scrollboxNode, true);
                    }
    				if (!(this.heightLimit > 0)) { 
    					return;
    				}

                    if(!this._scroller.offset){
                            return;
                    }

    				childHeight = childHeight || this.containerNode.offsetHeight;
    				if (childHeight > this.scrollboxNode.clientHeight) {
    					this._scroller.offset.y.end = childHeight - this.scrollboxNode.clientHeight ;
    				} else {
    					this._scroller.offset.y.end = 0;
    					this._scroller.scrollTo(0, 0, 0);
    				}
    			},

    			
                refresh: function () {
                	if (this.needRefresh) {
	                	this.containerNode.innerHTML = "";
	                	
	                	
	            		
	            		
						
	                	this.postBuildRendering();
	                	this.resized();
                        this.updateScroller();
	                	this.needRefresh = false;
                	}
                }
        	}
    		
    );
   
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.ui.CalendarMonthView",
                         "mstrmojo.android.ui.CalendarYearList");

    var $H = mstrmojo.hash,
        $A = mstrmojo.array,
        CLEAR_TEXT = mstrmojo.desc(2827, 'Clear'),
        CANCEL_TEXT = mstrmojo.desc(221, 'Cancel');

    
    mstrmojo.android.ui.Calendar = mstrmojo.declare(

        
        mstrmojo.Container,

        
        [mstrmojo._TouchGestures, mstrmojo._HasLayout],

        
        {
            scriptClass: "mstrmojo.android.ui.Calendar",

            config: undefined,

            markupString: '<div id="{@id}" class="mstrmojo-android-Calendar">' +
                              '<div class="mstrmojo-Calendar-Year"></div>' +
                              '<hr class="mstrmojo-Calendar-Sep"/>' +
                              '<div class="mstrmojo-Calendar-Month"></div>' +
                          '</div>',

            markupSlots: {
                yearNode: function () { return this.domNode.firstChild; },
                monthNode: function () { return this.domNode.lastChild; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            cssDisplay: '',

            
            isMultiSelect: false,

            
            selectedDates: undefined,

            
            min: undefined,

            
            max: undefined,

            init: function init(props) {
                var now = new Date(),
                    yearWidget = this.children[0],
                    monthWidget = this.children[1],
                    min = props.min = props.min || {},
                    max = props.max = props.max || {},
                    selected = props.selectedDates = props.selectedDates || [],
                    firstSelected = selected[0] || {},
                    firstYear,
                    firstMonth;

                
                $A.forEach([firstSelected, min], function (obj) {
                    if (!isNaN(obj.year) && !isNaN(obj.month)) {
                        firstYear = obj.year;
                        firstMonth = obj.month;
                        return false;
                    }
                });

                firstMonth = !isNaN(firstMonth) ? firstMonth : (now.getMonth() + 1);
                firstYear = !isNaN(firstYear) ? firstYear : now.getFullYear();


                
                $H.copy({
                    initialYear: firstYear,
                    initialMonth: firstMonth,
                    multiSelect: !!this.isMultiSelect,
                    selected: selected,
                    range: {
                        start: min,
                        end: max
                    }
                }, monthWidget);

                $H.copy({
                    initialYear: firstYear,
                    start: min.year,
                    end: max.year
                }, yearWidget);

                
                this._super(props);

            },

            postBuildRendering: function postBuildRendering() {
                
                this.monthWidget.markupBuilder = this.markupBuilder;

                
                this._super();

                
                var calList = this.target;

                
                calList.set('items', this.selectedDates);
                calList.selectItems(calList.items);

                
                this.yearWidget.attachEventListener('yearChanged', this.monthWidget.id, function (evt) {
                    this.current.set('y', evt.value);
                });

                
                this.monthWidget.attachEventListener('selectionChanged', this.id, function (evt) {
                    this.syncListItemsWithSelections([].concat(evt.items));
                });

                
                this.target.attachEventListener('selectionChange', this.id, function (evt) {
                    var target = this.target,
                        targetItems = target.items,
                        monthWidget = this.monthWidget,
                        added = $A.get(targetItems, evt.added),
                        removed = $A.get(targetItems, evt.removed);

                    
                    if (added && added.length > 0) {
                        monthWidget.selectItems(added);
                    } else {
                        var toRemove;
                        if ((removed && removed.length > 0) && (targetItems && targetItems.length > 0)) {
                            toRemove = removed;
                        }
                        monthWidget.unselectItems(toRemove);
                    }

                    if (target.parent) {
                        
                        target.parent.btnHbox.children[0].set('text', ((target.getSelectedItems().length > 0) ? CLEAR_TEXT : CANCEL_TEXT));
                    }

                    
                    monthWidget.selected = target.getSelectedItems();
                });
            },

            
            syncListItemsWithSelections: function syncTargetListSelections(newItems) {
                var target = this.target;

                
                target.glow = false;

                
                target.set('items', newItems);
                target.selectItems(newItems);

                if (target.parent) {
                    
                    target.parent.btnHbox.children[0].set('text', ((target.getSelectedItems().length > 0) ? CLEAR_TEXT : CANCEL_TEXT));

                    
                    target.parent.resizeDialog();
                }

                
                target.glow = true;
            },

            
            getSelectedDates: function getSelectedDates(format) {
                var result = [];

                
                $A.forEach(this.target.getSelectedItems(), function (sd) {
                    result.push(sd.n);
                });

                return result;
            },

            children: [{
                scriptClass: "mstrmojo.android.ui.CalendarYearList",
                alias: 'yearWidget',
                slot: 'yearNode'
            }, {
                scriptClass: "mstrmojo.android.ui.CalendarMonthView",
                alias: 'monthWidget',
                slot: 'monthNode'
            }]
        }
    );

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css,
        clsGlow = 'glow',
        $DOM = mstrmojo.dom,
        $TRANS_DURATION = $DOM.$TRANS_DURATION,
        itemMarkup;

    
    function doGlow(el) {
        var style = el.style;

        
        style[$TRANS_DURATION] = 0;
        $CSS.addClass(el, clsGlow);

        
        window.setTimeout(function () {
            
            style[$TRANS_DURATION] = '300ms';
            $CSS.removeClass(el, clsGlow);
        }, 100);
    }

    
    mstrmojo.ui.MobileCheckList = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: "mstrmojo.ui.MobileCheckList",

            
            multiSelect: true,

            
            hasEvenRows: true,

            
            glow: true,

            
            allowTouchBubble: false,

            listHooks: {
                select: function (el, item, idx) {
                    
                    if (this.glow && !this.skipEvent) {
                        
                        doGlow.call(this, el);
                    }
                },

                unselect: function (el, item, idx) {
                    
                    if (this.glow && this.multiSelect && !this.skipEvent) {
                        
                        doGlow.call(this, el);
                    }
                }
            },

            getItemMarkup: function (item) {
                
                if (!itemMarkup) {
                    
                    itemMarkup = this._super(item).replace('{@n}', '<div><h3>{@n}</h3></div>');
                }

                
                return itemMarkup;
            },

            
            init: function init(props) {
                this._super(props);

                
                var cls = [ 'mobile-checklist' ];

                
                if (this.multiSelect) {
                    
                    cls.push('multi');
                }

                
                mstrmojo.css.addWidgetCssClass(this, cls);
            }


        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList");

    
    mstrmojo.android.selectors.ListBox = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: "mstrmojo.android.selectors.ListBox",

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, [ 'selector-listbox' ]);
            },

            postBuildRendering: function postBuildRendering() {
                
                var h = parseInt(this.height, 10);
                if (h) {
                    var itemsContainerNode = this.itemsContainerNode,
                        listHeight = itemsContainerNode.offsetHeight;

                    
                    if (listHeight < h) {
                        
                        var cnt = this.items.length,
                            lineHeight = Math.round(h / this.items.length) + 'px',
                            i = 0;

                        
                        for (i = 0; i < cnt; i++) {
                            
                            itemsContainerNode.childNodes[i].style.lineHeight = lineHeight;
                        }
                    }
                }

                return this._super();
            }

        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo.css",
                         "mstrmojo.array");

    
    function resizeItems() {
        
        var cnt = this.items.length;
        if (cnt) {
            
            var itemWidth = Math.floor(parseInt(this.width, 10) / cnt),
                brdWidth = parseInt(mstrmojo.css.getStyleValue(this._getItemNode(cnt - 1), 'borderLeftWidth'), 10);

            
            mstrmojo.array.forEach(this.itemsContainerNode.childNodes, function (node, idx) {
                
                if (idx < cnt) {
                    
                    node.style.width = (itemWidth - ((idx) ? brdWidth : 0)) + 'px';
                }
            });
        }
    }

    
    mstrmojo.android.medium.ui.TxButtons = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: "mstrmojo.android.medium.ui.TxButtons",

            itemsFloat: true,

            onRender: function onRender() {
                
                resizeItems.call(this);
            },

            setDimensions: function setDimensions(h, w) {
                this._super(h, w);

                
                if (this.hasRendered) {
                    
                    resizeItems.call(this);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList");

    var itemMarkup;

    
    mstrmojo.android.ui.TxDocList = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: "mstrmojo.android.ui.TxtDocList",

            scrollerConfig: {
                bounces: false,
                showScrollbars: false
            },

            highlightOnSelect: true,

            getItemMarkup: function getItemMarkup(item) {
                
                if (!itemMarkup) {
                    
                    itemMarkup = this._super(item).replace('{@n}', '<h3>{@n}</h3><h4>{@desc}</h4><em>{@cnt}</em>');
                }

                
                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx);

                
                props.desc = item.desc;
                props.cnt = item.c;

                
                return props;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo._SupportsEllipsisText",
                         "mstrmojo.css");

    var btnMarkup;

    

    mstrmojo.android.medium.ui.HomeScreenView = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        [ mstrmojo._SupportsEllipsisText ],

        
        {
            scriptClass : 'mstrmojo.android.medium.ui.HomeScreenView',

            selectionPolicy: 'reselect',

            itemsFloat: true,

            getItemMarkup: function getItemMarkup() {
                
                if (!btnMarkup) {
                    var btnFmt = this.hsFmt.btn,
                        btnStyle = '',
                        btnCls = [ 'btn' ],
                        ttlMarkup = '<div class="ttl" style="color:' + btnFmt.c + ';">{@txt}</div>',        
                        closeMarkup = '</div>',                                                             
                        btn = [],
                        x = -1;

                    
                    if (btnFmt.sty > 1) {
                        
                        btnStyle = 'border-color:' + btnFmt.bc + ';background-color:' + btnFmt.bg + ';';
                    }

                    
                    btn[++x] = '<div class="btnC" idx="{@idx}">';
                    btn[++x] =     '<div class="' + btnCls.join(' ') + '" style="' + btnStyle + '">';
                    btn[++x] =         '<div class="{@iconClass}" style="{@iconStyle}">';

                    
                    if (this.items.length <= 4) {
                        
                        btn[++x] = ttlMarkup;

                        
                        btn[++x] = closeMarkup;
                        btn[++x] = closeMarkup;
                    } else {
                        
                        btn[++x] = closeMarkup;
                        btn[++x] = closeMarkup;

                        
                        btn[++x] = ttlMarkup;
                    }

                    
                    btn[++x] = closeMarkup;

                    
                    btnMarkup = btn.join('');
                }

                return btnMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                var iconStyle = '',
                    iconClass = '';

                
                if (item.icn) {
                    
                    iconStyle = 'background-image: url(' + item.icn + ');';
                } else {
                    
                    iconClass = ' ic' + (item.act || item.st);
                }

                return {
                    idx: idx,
                    txt: item.txt,
                    iconStyle: iconStyle,
                    iconClass: iconClass
                };
            },

            preBuildRendering: function preBuildRendering() {
                
                mstrmojo.css.addWidgetCssClass(this, (this.items.length > 4) ? 'multiCol' : 'singleCol');

                return this._super();
            },

            onRender: function onRender() {
                var itemsContainerNode = this.itemsContainerNode,
                    items = itemsContainerNode.childNodes,
                    cnt = items.length - 1,                         
                    i;

                
                if (cnt > 4) {
                    
                    for (i = 0; i < cnt; i++) {
                        
                        this.ellipsize('ttl', items[i].lastChild, true);
                    }
                }

                
                var bg = this.hsFmt.bg;
                if (bg) {
                    
                    var background = bg.v,
                        bgStyle = this.domNode.style;

                    
                    if (bg.tp !== 1) {
                        
                        background = 'transparent url(' + background + ') no-repeat 0 0';

                        
                        bgStyle.backgroundSize = '100%';
                    }

                    
                    bgStyle.background = background;
                }
            },

            
            afterViewVisible: function afterViewVisible() {
                
                var table = document.createElement('table'),
                    node = this.domNode;

                node.appendChild(table);

                window.setTimeout(function () {
                    node.removeChild(table);
                }, 100);
            }
        }
    );

}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo.android._HasLingeringListSelections");

    var itemMarkup = [],
        $DOM = mstrmojo.dom,
        $STR = mstrmojo.string;

    
    mstrmojo.android.ui.FolderView = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        [ mstrmojo.android._HasLingeringListSelections ],

        
        {
            scriptClass: "mstrmojo.android.ui.FolderView",

            
            allowTouchBubble: false,

            
            useSelectScroll: true,

            
            highlightOnSelect: true,

            
            hasEvenRows: true,

            
            listHooks: {
                select: function (el) {
                    
                    el.style[$DOM.CSS3_TRANSITION_DURATION] = 0;
                },
                unselect: function (el) {
                    
                    el.style[$DOM.CSS3_TRANSITION_DURATION] = '300ms';
                }
            },

            getItemMarkup: function (item) {
                var desc = item.desc,
                    isc = item.isc,

                    
                    markupType = ((desc) ? 1 : 0) + ((isc) ? 2 : 0);

                
                
                

                
                if (!itemMarkup[markupType]) {

                    
                    var im = '<h3>{@n}</h3>';

                    
                    if (desc) {
                        im += '<h4>{@desc}</h4>';
                    }

                    
                    im += '<div><div><div></div></div></div>';

                    
                    itemMarkup[markupType] = this._super(item).replace('{@n}', im);
                }

                return itemMarkup[markupType];
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    desc = item.desc || '',
                    cached = this.controller.isItemCached(item),
                    
                    disabled = !(cached || this.controller.isItemAvail(item, true));

                
                props.addCls('ty' + (item.st  || 2048));

                if ( props.n) {
                    
                    props.n = $STR.htmlAngles(props.n);
                }

                
                if (desc) {
                    
                    props.desc = $STR.htmlAngles(desc);

                    
                    props.addCls('desc');
                }

                
                if (cached && item.st !== 2048) {
                    props.addCls('cached');
                } else if (item.isc) {
                    
                    props.addCls('isc');
                }
                
                if (item.unread) {
                	props.addCls('new');
                }

                
                if (disabled) {
                    
                    props.addCls('disabled');
                }

                return props;
            },

            canItemLinger: function canItemLinger(item) {
                return this.controller.canItemLinger(item);
            },

            buildRendering: function buildRendering() {
                var rtn = this._super();

                
                var clearDiv = document.createElement('div');
                clearDiv.className = 'clear-me';

                
                this.itemsContainerNode.appendChild(clearDiv);

                return rtn;
            },

            preselectionChange: function preselectionChange(evt) {
                var added = evt.added,
                    removed = evt.removed;

                
                if (added) {
                    
                    var item = this.items[added[0]];
                    if (!this.controller.isItemAvail(item)) {
                        
                        if (removed && removed.length) {
                            this.select(removed, true);
                        }
                        return false;
                    }
                }

                return true;
            },

            
            touchSelectBegin: function touchSelectBegin(touch) {
                var idx = this.getItemIdxTouch(touch);
                if (idx > -1) {
                    
                    var ctrl = this.controller;
                    if (!ctrl.itemLongPressed || !ctrl.itemLongPressed(this.items[idx])) {
                        
                        this._super(touch);
                    } else {
                        
                        return false;
                    }
                }

                return true;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo.android.SimpleList",
                         "mstrmojo.OfflineTransactionModel");

    var EnumTxType = mstrmojo.OfflineTransactionModel,
        PENDING = EnumTxType.PENDING,
        FAILED = EnumTxType.FAILED;

    
    mstrmojo.android.ui.TxEditDoc = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        
        {
            scriptClass: "mstrmojo.android.ui.TxEditDoc",

            markupString: '<div id="{@id}" class="mstrmojo-TxEditDoc {@cssClass}" style="{@cssText}">' +
                              '<div></div>' +
                              '<div></div>' +
                              '<div></div>' +
                          '</div>',

            markupSlots: {
                typeNode: function () { return this.domNode.firstChild; },
                txNode: function () { return this.domNode.childNodes[1]; },
                btmNode: function () { return this.domNode.lastChild; }
            },

            
            model: null,

            
            docDid: null,

            children: [{
                scriptClass: 'mstrmojo.android.SimpleList',
                alias: 'txList',
                slot: 'txNode',
                cssClass: 'txList',
                postselectionChange: function (evt) {
                    var added = evt.added,
                        idx = added && added[0],
                        transactionView = this.parent.parent;

                    
                    if (transactionView) {
                        transactionView.enableButtons(idx !== null);
                    }
                }
            }],

            addChildren: function addChildren(children, idx, silent) {
                
                children = children.concat([mstrApp.viewFactory.newView('TransactionsTypeList', {
                    alias: 'typeList',
                    slot: 'typeNode',
                    cssClass: 'txTypeList',
                    selectionPolicy: 'reselect',
                    postselectionChange: function (evt) {
                        var added = evt.added,
                            idx = added && added[0];

                        
                        if (idx !== null) {
                            var txItems = [],
                                parent = this.parent;

                            
                            mstrmojo.array.forEach(this.parent._tx[idx ? FAILED : PENDING], function (item, idx) {
                                
                                txItems.push({
                                    n: item.n,
                                    v: item.timestamp,
                                    idx: idx
                                });
                            });

                            
                            parent.txList.set('items', txItems);

                            
                            parent.typeSelected(idx);
                        }
                    }
                })]);

                this._super(children, idx, silent);
            },

            
            getType: function getType() {
                return this.typeList.selectedIndex;
            },

            
            setType: function setType(type) {
                
                this.typeList.singleSelect(type);
            },

            
            getSelectedTx: function getSelectedTx() {
                return this.txList.getSelectedItems()[0];
            },

            
            typeSelected: mstrmojo.emptyFn,

            
            generateTypeList: function generateTypeList(defaultSelect) {
                
                var docID = this.docID;
                if (!docID) {
                    
                    return;
                }

                var model = this.model,
                    txs = (model && model.docsTx) || [],
                    documentTxs = txs[docID],
                    pendingItems = [],
                    failedItems = [];

                
                if (documentTxs) {
                    
                    pendingItems = documentTxs[PENDING];
                    failedItems = documentTxs[FAILED];
                }

                
                var tx = this._tx = {};
                tx[PENDING] = pendingItems;
                tx[FAILED] = failedItems;

                
                var typeList = this.typeList,
                    selectedIdx = Math.max(typeList.selectedIndex, 0);

                
                typeList.set('items', [{
                    n: mstrmojo.desc(9250, 'Pending'),
                    v: pendingItems.length
                }, {
                    n: mstrmojo.desc(9251, 'Failed'),
                    v: failedItems.length
                }]);

                
                if (defaultSelect) {
                    
                    selectedIdx = (failedItems.length) ? 1 : 0;
                }

                
                typeList.singleSelect(selectedIdx);
            },

            
            ondocIDChange: function ondocIDChange() {
                this.generateTypeList(true);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.TxEditDoc");

    
    mstrmojo.android.large.ui.TxEditDoc = mstrmojo.declare(

        mstrmojo.android.ui.TxEditDoc,

        null,

        
        {
            scriptClass: "mstrmojo.android.large.ui.TxEditDoc",

            layoutConfig: {
                h: {
                    typeNode: '100%',
                    txNode: '100%'
                },
                w: {
                    typeNode: '42%',
                    txNode: '58%'
                }
            },

            typeSelected: function typeSelected(idx) {
                if(this.hasRendered) {
                    var anchorNode = this.btmNode,
                    anchorStyle = anchorNode.style;
                    
                    
                    anchorStyle.left = (this.typeNode.offsetWidth - anchorNode.offsetWidth + 1) + 'px';
                    anchorStyle.top = this.typeList.getItemOffset(idx) + 'px';
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.medium.ui.TxButtons",
                         "mstrmojo.css",
                         "mstrmojo.array");

    var itemMarkup;

    
    mstrmojo.android.medium.ui.TxTypeList = mstrmojo.declare(

        mstrmojo.android.medium.ui.TxButtons,

        null,

        
        {
            scriptClass: "mstrmojo.android.medium.ui.TxTypeList",

            getItemMarkup: function () {
                
                if (!itemMarkup) {
                    
                    itemMarkup = '<div class="item {@cls}" idx="{@idx}" style="{@style}">{@n} ({@cnt})</div>';
                }

                
                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx);

                
                props.cnt = item.v;

                
                return props;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.medium.ui.TxButtons",
                         "mstrmojo.css");

    
    mstrmojo.android.medium.ui.TxActionButtons = mstrmojo.declare(

        mstrmojo.android.medium.ui.TxButtons,

        null,

        
        {
            scriptClass: "mstrmojo.android.medium.ui.TxActionButtons",

            selectionPolicy: 'reselect',

            
            enabled: false,

            items: [{
                n: mstrmojo.desc(9252, 'Delete'),
                v: 0
            }, {
                n: mstrmojo.desc(9253, 'Edit'),
                v: 1
            }],

            postselectionChange: function (evt) {
                
                var added = evt.added;
                if (added && this.enabled) {
                    
                    this.parent.parent[((added[0]) ? 'edit' : 'delete') + 'Record']();
                }
            },

            onenabledChange: function (evt) {
                
                mstrmojo.css.toggleClass(this.domNode, 'enabled', evt.value);
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ui.MobileCheckList",
                         "mstrmojo.android._IsIncFetchList",
                         "mstrmojo.mstr.WebElements",
                         "mstrmojo.array");

    var $ARR = mstrmojo.array,
        emptyElements = new mstrmojo.mstr.WebElements();

    
    function toggleIncFetch(browseElements) {
        
        this.supportsIncFetch = false;
        delete this.ifDataHelper;

        
        if (browseElements) {
            
            if (browseElements.items.length < browseElements.totalSize) {
                
                this.ifDataHelper = browseElements;

                
                this.supportsIncFetch = true;
            }
        }
    }

    
    function cacheElasticHeight() {
        
        var height = this.height;
        if (!this.elasticHeight && height) {
            
            this.elasticHeight = parseInt(height, 10);
        }
    }

    
    mstrmojo.android.ui.ElementsPicker = mstrmojo.declare(

        mstrmojo.ui.MobileCheckList,

        [ mstrmojo.android._IsIncFetchList ],

        
        {
            scriptClass: 'mstrmojo.android.ui.ElementsPicker',

            
            browseElements: null,

            
            viewAll: true,

            
            glow: true,

            
            onbrowseElementsChange: function onbrowseElementsChange() {
                
                toggleIncFetch.call(this);

                
                this._ignoreSelection = true;

                
                var bElems = this.browseElements;
                if (bElems) {
                    
                    var items = bElems.items = (bElems.items || []),
                        cfg = this._searchConfig;

                    
                    if ((!cfg || cfg.exit) && !this.viewAll) {
                        
                        items = this.getSelectedItems();
                    }

                    
                    this.set('items', items);

                    
                    if (cfg) {
                        
                        this.glow = false;

                        
                        this.selectItems(cfg.selected, true);

                        
                        this.glow = true;
                    }

                    
                    toggleIncFetch.call(this, bElems);
                } else {
                    
                    this.set('items', []);
                }

                
                this.updateScroller();

                
                this._ignoreSelection = false;
            },
            
            syncSelection: function syncSelection() {
                var cfg = this._searchConfig;

	            
	            if (cfg) {
	                this.selectItems(cfg.selected, false);
	            }
            },
            
            enterSearchMode: function enterSearchMode() {
                
                var selectedItems = this.getSelectedItems();
                this._searchConfig = {
                    elements: this.browseElements,              
                    selected: selectedItems,                    
                    clone: [].concat(selectedItems)             
                };

                
                cacheElasticHeight.call(this);

                
                this.set('browseElements', emptyElements);
            },

            
            search: function search(results) {
                
                this.set('browseElements', results);
            },

            
            exitSearchMode: function exitSearchMode(viewAll) {
                
                var cfg = this._searchConfig;

                
                cfg.exit = true;

                
                this.set('browseElements', viewAll ? cfg.elements : {items:cfg.selected});

                
                delete this._searchConfig;
            },

            
            clearSearch: function clearSearch() {
                
                var cfg = this._searchConfig;
                cfg.selected = [].concat(cfg.clone);

                
                this.set('browseElements', emptyElements);
            },

            
            postselectionChange: function postselectionChange(evt) {
                
                var cfg = this._searchConfig;
                if (!cfg || this._ignoreSelection) {
                    
                    return;
                }

                
                var selected = cfg.selected,
                    items = this.items,
                    added = evt.added;

                
                if (this.multiSelect) {
                    
                    $ARR.forEach(added, function (idx) {
                        
                        selected.push(items[idx]);
                    });

                    
                    $ARR.forEach(evt.removed, function (idx) {
                        
                        $ARR.removeItems(selected, 'v', [ items[idx] ]);
                    });

                
                } else if (added) {
                    
                    selected.splice(0);

                    
                    selected.push(items[added[0]]);
                }
            },

            
            onviewAllChange: function onviewAllChange() {
                
                var items = this.getSelectedItems(),
                    browseElements;

                
                if (this.viewAll) {
                    
                    browseElements = this.browseElements;
                    items = browseElements.items;

                } else {
                    
                    cacheElasticHeight.call(this);

                }

                
                this.glow = false;

                
                var selectedItems = this.getSelectedItems();

                
                this.set('items', items);

                
                this.selectItems(selectedItems, true);

                
                this.glow = true;

                
                toggleIncFetch.call(this, browseElements);

                
                this.updateScroller();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo.array");

    var itemMarkup = '<div class="mstrmojo-SelectBoxList-item" idx="{@idx}">' +
                         '<h2>{@n}</h2>' +
                         '<h4>{@v}</h4>' +
                     '</div>';

    
    mstrmojo.android.ui.SelectBoxList = mstrmojo.declare(
        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: 'mstrmojo.android.ui.SelectBoxList',

            selectionPolicy: 'reselect',

            getItemMarkup: function () {
                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx);

                
                props.v = item.v;

                
                return props;
            },

            
            postselectionChange: function postselectionChange(evt) {
                var added = evt.added;
                if (!added) {
                    return;
                }

                
                var idx = added[0],
                    item = this.items[idx],
                    items = item.items,
                    id = this.id;

                mstrApp.showDialog({
                    title: item.n,
                    children: [{
                        scriptClass: 'mstrmojo.ui.MobileCheckList',
                        items: items,
                        multiSelect: false,
                        isElastic: true,
                        selectedIndex: mstrmojo.array.find(items, 'on', true),
                        postselectionChange: function (evt) {
                            
                            mstrApp.closeDialog();

                            
                            mstrmojo.all[id].selectListChange(idx, items[evt.added[0]]);
                        }
                    }]
                });
            },

            
            selectListChange: mstrmojo.emptyFn
        }
    );

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ui.MobileCheckList",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.android._IsIncFetchList",
                         "mstrmojo.array");

    var BLOCK_SIZE = 50;

    function createIncFetchDataHelper() {
        return {
            next: function (cb) {
                var newEnd = Math.min(this.blockEnd + BLOCK_SIZE, this.totalSize);

                cb.success(null, this.items.slice(this.blockEnd, newEnd));

                this.blockEnd = newEnd;
            },

            init: function (begin, end, items) {
                this.blockBegin = begin;
                this.blockEnd = end;
                this.totalSize = items.length;
                this.items = items;
            }
        };
    }

    mstrmojo.android.inputControls.PullDownDIC = mstrmojo.declare(
        mstrmojo.ui.MobileCheckList,

       [mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton, mstrmojo.android._IsIncFetchList],

        {
            scriptClass: 'mstrmojo.android.inputControls.PullDownDIC',

            multiSelect: false,

            isElastic: true,

            supportsIncFetch: false,

            init: function init(props) {
                this._super(props);

               this._items = this.getItems();

                if (this._items.length > BLOCK_SIZE) {
                    this.ifDataHelper = createIncFetchDataHelper();
                    this.supportsIncFetch = true;
                }
            },

            postselectionChange: function postselectionChange(evt) {
                var idx = evt.added[0];
                if (idx < this.items.length) {
                    this.set('value', this.items[idx].v);
                }
            },

            preBuildRendering: function preBuildRendering() {
                this._super();

                var value = this.value,
                    ust = this.dic.ust || '',
                    items = this._items,
                    idx = mstrmojo.array.find(items, 'v', value);

                
                if (idx === -1) {
                    
                    items = [{
                        n: ust,
                        v: value
                    }].concat(items);
                    idx = 0;
                }

                if (this.supportsIncFetch) {
                    
                    this.ifDataHelper.init(0, BLOCK_SIZE, items);
                    
                    items = items.slice(0, BLOCK_SIZE);
                }

                this.items = items;
                this.set('selectedIndex', idx);
            },

            postBuildRendering: function postBuildRendering() {
                this._super();
                
                this._scroller.scrollTo(0, 0);
            },

            
            renderPreview: function renderPreview() {
                
                var idx = mstrmojo.array.find(this._items, 'v', this.value),
                    label = (idx >= 0) ? this._items[idx].n : (this.dic.ust !== undefined ? this.dic.ust : this.dv);

                this.renderPreviewButton(this.openerNode, this.dicChanged ? label : this.dv);
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ui.MobileCheckList",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css,
        clsSelected = 'selected';
    
    function updateTitleIcon() {
        
        var len = this.getSelectedItems().length,
            totalLen = this.items.length,
            updateStr = 'btnCheckSemi'; 
        
        if( len === 0) { 
            updateStr = 'btnCheckNone';
        } else if (len === totalLen) {
            updateStr = 'btnCheckFull'; 
        }
        
        
        this.parent.updateTitleBarButtonClass(updateStr);
    }
    
    mstrmojo.ui.MobileReviewList = mstrmojo.declare(

            mstrmojo.ui.MobileCheckList,

        null,

        
        {
            scriptClass: "mstrmojo.ui.MobileReviewList",
            
            listHooks: {
                select: function (el, item, idx) {
                    
                    mstrmojo.ui.MobileCheckList.prototype.listHooks.select(el, item, idx);
                    
                    if(this.parent.selectionHidden) {
                        this.selectedIndices = {}; 
                        return true;
                    }
                    
                    
                    updateTitleIcon.call(this);
                    
                },

                unselect: function (el, item, idx) {
                    
                    mstrmojo.ui.MobileCheckList.prototype.listHooks.unselect(el, item, idx);
                    
                    
                    updateTitleIcon.call(this);
                    
                    return this.selectionHidden;
                }
            },
            
            init: function init(props) {
                this._super(props);

                
                if (this.multiSelect) {
                    
                    $CSS.addWidgetCssClass(this, 'hidden');
                }

            },
            
            selectAll: function selectAll() {
                var methodName = 'addClass', 
                    listNode = this.domNode.childNodes[0],
                    count = listNode.childElementCount,
                    i = 0,
                    isSelectAll = true;

                
                if (this.getSelectedItems().length > 0 ) {
                    
                    methodName = ('removeClass');
                    this.selectedIndices = {};
                    isSelectAll = false;
                }


                for(i = 0; i < count; i++ ) {
                    $CSS[methodName](listNode.childNodes[i], clsSelected);
                    if(isSelectAll) {
                        this.selectedIndices[i] = true;
                    }
                }
                
                
                updateTitleIcon.call(this);
            },
        
            touchSelectBegin: function touchSelectBegin(touch) {
                if(this.parent.selectionHidden) {
                    
                    this.parent.setDeleteActions("delete");
                }
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocButton",
                         "mstrmojo._HasDrillLinks",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    
    function setPressedState(isPressed) {
        
        this.set('pressed', isPressed);
    }
    
    
    function hexToRgba(hex, alpha) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ?  
            "rgba(" + 
            parseInt(result[1], 16) + "," +
            parseInt(result[2], 16) + "," +
            parseInt(result[3], 16) + "," +
            alpha + ")"
            : '';
    }

    
    function executeLink(link) {
        this.model.executeLink(link, this.target, this);
    }

    
    function showLinkList() {
        var drillLinks = this.drillLinkItems,
            id = this.id;

        
        if (drillLinks.length === 1) {
            
            setPressedState.call(this, false);
            
            
            executeLink.call(this, drillLinks[0].url);
            return;
        }

        
        this._linksOpen = true;

        
        mstrApp.showDialog({
            title: this.defn.n,
            children: [{
                scriptClass: 'mstrmojo.ui.MobileCheckList',
                items: drillLinks,
                multiSelect: false,
                isElastic: true,
                hasEvenRows: true,
                postselectionChange: function (evt) {
                    
                    mstrApp.closeDialog();

                    
                    executeLink.call(mstrmojo.all[id], drillLinks[evt.added[0]].url);
                }
            }],
            onClose: function () {
                var btn = mstrmojo.all[id];

                
                setPressedState.call(btn, false);

                
                delete btn._linksOpen;
            },
            buttons: [ mstrmojo.android.ui.Button.newButton(mstrmojo.desc(221, 'Cancel')) ]
        });
    }
    
    
    var $BTN = mstrmojo.android.ui.DocButton = mstrmojo.declare(
        mstrmojo.DocButton,

        [ mstrmojo._HasDrillLinks ],

        
        {
            scriptClass: "mstrmojo.android.ui.DocButton",

            touchBegin: function touchBegin() {
                
                if (!this.linkEnabled) {
                    
                    return false;
                }

                
                setPressedState.call(this, true);

                return true;
            },

            touchTap: function touchTap() {
                if(this.ifw) {
                    this.model.showInfoWin(this.ifw, (this.getAnchor && this.getAnchor()) || this.domNode, 'v');
                    return;
                }
                
                var dl = this.drillLinkItems,
                	length = (dl && dl.length) || 0;
                
	            if(length > 0) {
	                
	                showLinkList.call(this);
	            }
            },

            touchSelectBegin: function touchSelectBegin() {
                this.touchTap();
            },

            touchEnd: function touchEnd() {
                
                if (!this._linksOpen) {
                    
                    setPressedState.call(this, false);
                }
            },
            
            setBackgroundColor: function setBackgroundColor() {
                var isPressed = !!this.pressed,
                defn = this.defn,
                domNode = this.domNode,
                fmts = this.fmts,
                containerNodeStyle = this.buttonContainerNode.style,
                domNodeStyle = this.domNode.style,
                containerColor = isPressed ? defn.bhlc : (fmts['background-color'] || ''),
                domColor = isPressed ? hexToRgba(defn.bhlc, 0.4) : '';
                
                containerNodeStyle.backgroundColor = containerColor;
                containerNodeStyle.borderColor = containerColor;
                domNodeStyle.borderColor = domColor;
                domNodeStyle.backgroundColor = domColor;
            },

            
            getDPI: function getDPI() {        
                return mstrMobileApp.getDeviceDPI();
            }
        }
    );

    
    $BTN.prototype.markupString = $BTN.prototype.markupString.replace(new RegExp(' mstrAttach:[a-zA-Z,]*'), '');

    
    $BTN.prototype.formatHandlers.domNode = mstrmojo.array.filter([].concat($BTN.prototype.formatHandlers.domNode), function (prop) {
        return (prop !== 'P' && prop !== 'B');
    });
}());
(function() {

    mstrmojo.requiresCls("mstrmojo.ServerProxy",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.Box",
                         "mstrmojo.TextBoxWithLabel",
                         "mstrmojo.Label",
                         "mstrmojo.hash",
                         "mstrmojo.mstr.EnumWebAPIErrorCodes");

    mstrmojo.requiresDescs(11,17,18,26,7904,5088,9935,10672);

    var $mobileLogin = 'mobileLogin',
        $chgPassword = 'changePassword',
        $BTN = mstrmojo.android.ui.Button.newButton,
        $DESC = mstrmojo.desc,
        $H = mstrmojo.hash,
        $ERRS = mstrmojo.mstr.EnumWebAPIErrorCodes,
        sessions = {},
        localeInfoMap = {},
        EnumDeviceType = { ANDROID_PHONE: 3,
                            ANDROID_TAB: 4 },
        EnumPasswordDlgType = {
            OLD_PASSWORD: 0,
            NEW_PASSWORD: 1,
            CONFIRM_NEW_PASSWORD: 2
        },
        
        
        postLoginFlag = {};

    
    function getProjectSettings(request) {
        var me = this,
            projectId = request.pid,
            realPid = request.params.projectID,
            requestId = request.id,
            sessionState = sessions[projectId],
            realPid = request.params.projectID,
            params = {
                taskId: 'getProjectSettings'
            };

        if ( sessionState ) {
            params.sessionState = sessionState;
        } else {
            
            params.projectID = realPid;
        }
        mstrApp.serverRequest(
            params,
            { 
                success: function (response) {
                    postLoginFlag[projectId] = true;
                    me.transport.serverRequest(me.id, requestId, request);
                },
                failure: function (response) {
                    var callback = request.callback;

                    if (callback.failure !== undefined) {
                        callback.failure(response);
                    }

                    callback.complete(requestId);
                }
            },
            { 
                
                
                skipLogin : true,
                
                doNotHold : true
            });
    }

    function setLocaleInfo(params) {
    	var locStr = String(mstrMobileApp.getLocaleInfo());

    	if(locStr) {
    		var locArr = locStr.split(',');

    		for(var i = 0; i < locArr.length; i++) {
    			var locInfo = locArr[i].split(':');
    			params[locInfo[0]] = locInfo[1];
    		}
    	}
    	return params;
    }

    function notifyUserNewPasswordRequired(params,cb) {
        var dialog,
            items = [],
            dialogConfig = {
                id: "new_pwd_reqd",
                title: $DESC(5088),
                cssClass: 'mstrmojo-CredentialsDialog',
                loginInfo: params.loginInfo
            },
            loginInfo = params.loginInfo,
            fnOK = function(p,callback) {
                return function() {
                    callback(p);
                };
            }(params,cb);

        
        items.push( {
            scriptClass: "mstrmojo.Label",
            cssClass: "mstrmojo-PasswordDialog-Label",
            text: "You must supply a new password."
        });

        dialogConfig.children = items;

        
        dialogConfig.buttons = [
            $BTN($DESC(221, 'Cancel'), function() {
                
                
                dialog.manualClose = true;
                mstrApp.cancelPending();
            }  ),
            $BTN($DESC(1442, 'OK'), fnOK, { enabled: true } )
        ];

        dialog = mstrApp.showDialog(dialogConfig);
    }

    function doPasswordDialog(params,cb) {
        var dialog,
        	btnOk,
            items = [],
            dialogConfig = {
                id: "password_prompt" + mstrmojo.now(),
                title: params.title,
                cssClass: 'mstrmojo-CredentialsDialog',
                loginInfo: params.loginInfo
            },
            loginInfo = params.loginInfo,
            fnOK = function(p,callback) {
                return function() {
                    var ch = dialog.children,
                        pe = ch[0].children[0];

                    switch( p.dlgType ) {
                        case EnumPasswordDlgType.OLD_PASSWORD:
                            loginInfo.pwd = pe.value;
                            break;
                        case EnumPasswordDlgType.NEW_PASSWORD:
                            loginInfo.npwd = pe.value;
                            break;
                    }
                    callback(p);
                };
            }(params,cb);

        btnOk = mstrmojo.getInstance( $BTN($DESC(1442, 'OK'), fnOK, { enabled: params.enableOK } ) );

            
        items.push({
            scriptClass: 'mstrmojo.Box',
            cssDisplay: 'table',
            children: [ {
            				scriptClass: "mstrmojo.TextBoxWithLabel",
            				label: $DESC(18) + ":",
            				value: "",
            				type: "password",
            				cssDisplay: 'table-row',
            				onvalueChange: function() {
            					if ( params.dlgType == EnumPasswordDlgType.CONFIRM_NEW_PASSWORD ) {
            						btnOk.set("enabled", this.value == loginInfo.npwd );
                               }
                           }
                       }
                   ]
        });

        dialogConfig.children = items;

        
        dialogConfig.buttons = [
            $BTN($DESC(221, 'Cancel'), function() {
                mstrApp.cancelPending();
            }  ),
            btnOk
        ];

        dialog = mstrApp.showDialog(dialogConfig);
    }


    

    function handleExpiredPassword(request) {

        var cfg = this._mobileCfg,
            projectId = request.pid,
            project = cfg.getProject(projectId),
		    params = {
                cfg: cfg,
                projectId: projectId,
                project: project,
                transport: this.transport,
                loginInfo: cfg.getLoginInfo(projectId)
             },
             me = this;

        
        mstrApp.hideMessage();

        
        
        params.loginInfo.uid = request.params.userid;

        
        notifyUserNewPasswordRequired( params, function(params) {

            
            doPasswordDialog( $H.copy({ title: "Enter your old password",
                                        dlgType: EnumPasswordDlgType.OLD_PASSWORD,
                                        enableOK: true }, params ), function(params) {

                
                doPasswordDialog( $H.copy({ title: "Enter your new password",
                                            dlgType: EnumPasswordDlgType.NEW_PASSWORD,
                                            enableOK: true }, params ), function(params) {

                    
                    doPasswordDialog( $H.copy( { title: "Confirm your new password",
                                                dlgType: EnumPasswordDlgType.CONFIRM_NEW_PASSWORD,
                                                enableOK: (params.loginInfo.npwd == "") }, params ), function(params) {

                        
                        var fnSuccess = function(p) {
                            return function(res) {
                                var liInfo = p.loginInfo,
                                	npwd = liInfo.npwd,
                                	nuid = liInfo.uid;

                                
                                if ( project.udc ) {
                                    var server = cfg.getServerByProjectId(projectId);
                                    server.pdc.ps = npwd;
                                    server.pdc.lo = nuid;
                                } else {
                                    project.pc.ps = npwd;
                                    project.pc.lo = nuid;
                                }
                                cfg.saveConfiguration();

                                
                                request.params.password = npwd;

                                login.call(me,request);
                            };
                        }(params),

                        
                        fnFailure = function(res) {
                            var callback = request.callback;

                            
                            if (callback.failure !== undefined) {
                                callback.failure(res);
                            }

                            
                            
                            callback.complete(request.id);
                        };

                        
                        me.request( {
                            success: fnSuccess,
                            failure: fnFailure
                        }, {
                            taskId: $chgPassword,
                            server: params.project.sn,
                            userid: params.loginInfo.uid,
                            oldPassword: params.loginInfo.pwd,
                            newPassword: params.loginInfo.npwd
                        },
                        false, {
                            projectId: projectId,
                            mobileConfig: cfg,
                            
                            doNotHold : true
                        });
                    });

                });

            });

        });
    }

    
    function promptForCredentials(loginInfo, isServer, callback) {

        var dialog,
            btnOk,
            getInstance = mstrmojo.getInstance,
            fnNewInput = function (descId, valueNode, type, props) {
                
                return getInstance($H.copy(props, {
                    scriptClass: 'mstrmojo.TextBoxWithLabel',
                    cssDisplay: 'table-row',
                    label: $DESC(descId) + ":",
                    value: loginInfo[valueNode],
                    type: type || 'text',
                    onEnter: function () {
                        
                        if (btnOk.enabled) {
                            
                            btnOk.onclick({
                                e: {
                                    stopPropagation: mstrmojo.emptyFn
                                }
                            });
                        }
                    }
                }));
            },
            userId = fnNewInput(17, 'uid', null, {
                onRender: function () {
                    
                    this.focus();
                },
                onvalueChange: function() {
                    
                    btnOk.set('enabled', !!this.value.length);
                }
            }),
            userPwd = fnNewInput(18, 'pwd', 'password');

        btnOk = getInstance($BTN($DESC(9935, 'Log In'), function () {
            
            var name = loginInfo.uid = userId.value;
            loginInfo.pwd = userPwd.value;

            
            if (name.length) {
                
                window.setTimeout(function() {
                    callback();
                }, 100);                             
            }
        }, {
            enabled: false
        }));

        
        dialog = mstrApp.showDialog({
            id: 'user_creds_prompt',
            title: (isServer ? $DESC(7904) : $DESC(11) ) + ' ' + $DESC(26),
            cssClass: 'mstrmojo-CredentialsDialog',
            loginInfo: loginInfo,
            children: [{
                scriptClass: 'mstrmojo.Box',
                cssDisplay: 'table',
                children: [ userId, userPwd ]
            }],
            buttons: [ $BTN($DESC(221, 'Cancel'), function() {
                
                
                dialog.manualClose = true;
                mstrApp.cancelPending();
            }), btnOk ]
        });
    }

    

    function needServerCreds( loginInfo ) {
    	return ( ( loginInfo.wsam > 1 ) && !loginInfo.wsuid );
    }

    function needProjectCreds( loginInfo ) {
    	return ( !loginInfo.uid && loginInfo.am != 2  );
    }

    function getCredentials( li, callback ) {
        var loginInfo = li,
            needUpdateCfg = false;

        
        var promptForServerCreds = function(cb) {
            var serverCreds = { uid: loginInfo.wsuid, pwd: loginInfo.wspwd },
                callback = function() {
                    loginInfo.wsuid = serverCreds.uid;
                    loginInfo.wspwd = serverCreds.pwd;

                    
                    loginInfo.updateCfgAfterLogin |= 0x01;

                    cb();
                };

            promptForCredentials.call(this, serverCreds, true, callback );
        };

        
        var promptForProjectCreds = function(cb) {
            var projCreds = { uid: loginInfo.uid, pwd: loginInfo.pwd },
                callback = function() {
                    loginInfo.uid = projCreds.uid;
                    loginInfo.pwd = projCreds.pwd;

                    
                    loginInfo.updateCfgAfterLogin |= 0x02;

                    cb();
                };
            promptForCredentials.call(this, projCreds, false, callback);
        };

        
        if ( needServerCreds(loginInfo) && needProjectCreds( loginInfo )  ) {
            
            var ths = this;
            promptForServerCreds.call(this, function() {
                promptForProjectCreds.call(ths,callback);
            } );

        
        } else if ( needServerCreds( loginInfo ) ) {

            promptForServerCreds.call(this,callback);

        
        } else if ( needProjectCreds( loginInfo ) ) {

            promptForProjectCreds.call(this, callback);

        } else {

            
            callback();
        }
    }

    
    function canUseCache(request) {
        var cfg = this._mobileCfg,
            pid = request.pid,
            project = cfg.getProject(pid),
            realPid = project.realPid,
            loginInfo = cfg.getLoginInfo(pid);

        
        if ( mstrApp.useBinaryFormat && realPid && loginInfo.uid) {
            request.params.projectID = realPid;
            return true;
        }
        return false;
    }

    
    function postLogin(request) {
        var me = this,
            cfg = me._mobileCfg,
            projectId = request.pid,
            realPid = request.params.projectID,
            transport = me.transport,
            id = me.id,
            callback = {
                success: function(res){
                    
                    var l = localeInfoMap[projectId] = mstrmojo.hash.obj2array(res);
                    mstrmojo.hash.copy(l, mstrmojo.locales);

                    if ( mstrApp.useBinaryFormat ) {
                        
                        getProjectSettings.call(me, request);
                    } else {
                        postLoginFlag[projectId] = true;
                        
                        transport.serverRequest(id, request.id, request);
                    }
                },
                failure: function(response){
                    var cb = request.callback;

                    if (cb.failure !== undefined) {
                        cb.failure(response);
                    }

                    cb.complete(request.id);
                }
            },
            params = {
                taskId: 'getLocaleInfo'
            },
            config = {
                projectId: projectId,
                mobileConfig: cfg,
                
                
                skipLogin : true,
                
                doNotHold : true
            };
        if ( realPid) {
            params.projectID = realPid;
        }

        
        me.request(callback, params, false, config);
    }
    
    function login(request) {
        var me = this,
            cfg = me._mobileCfg,
            projectId = request.pid,
            project = cfg.getProject(projectId),
            transport = me.transport,
            id = me.id,
            loginInfo = cfg.getLoginInfo(projectId),
            repromptForCreds = false,
            repromptTimer,
            doLogin = function( f ){
                project.posLoginFlag = false;
                var loginCallback = {
                        success: function(res) {

                        	
                        	clearInterval(repromptTimer);

                            
                            
                            
                            
                            

                        	
                        	
                        	project.es = res.hasEmailScreenPriv;

                            
                            if ( loginInfo.updateCfgAfterLogin ) {
                                cfg.updateLoginInfo(projectId,loginInfo);
                            }

                            
                            cfg.setRealPid(project, res.projectID);
                            
                            var sessionState = sessions[projectId] = res.sessionState;
                            mstrMobileApp.putSession(projectId, sessionState);

                            
                            request.params.sessionState = sessionState;

                            
                            if ( res.isCompatible === false ) {
                                mstrApp.handleCompatibilityError(request);
                            }

                            postLogin.call(me, request);

                        },
                        failure: function( res ) {
                            var callback = request.callback,
                            	canUseCacheFlag = canUseCache.call(me, request),
                            	isHttpAuthFail = (res.status==401),
                            	isAuthFail = ( res.code == $ERRS.AUTHEN_E_LOGIN_FAIL ) || (res.status==401),
                            	errorCallback = mstrmojo.emptyFn,
                            	li = cfg.getLoginInfo(projectId),
                            	needToReprompt = isHttpAuthFail ||  isAuthFail || ( needServerCreds(li) || needProjectCreds( li ) );

	                        
	                        if ((callback.failure !== undefined) && !isHttpAuthFail) {
	                            
	                            res.noErrorMessage = canUseCacheFlag || needToReprompt || res.requireDeviceCertificate;

	                            
	                            res.handledError = needToReprompt || res.requireDeviceCertificate;

	                            callback.failure(res);
	                        }


	                        
	                        
	                        

	                        if ( !needToReprompt ) {
		                        callback.complete(request.id);
	                        }

	                        
	                        
	                        
	                        if ( canUseCacheFlag && !mstrMobileApp.isOnline()) {
	                            postLogin.call(me, request);
	                        } else {
	                            res.method = "login";

	                            
	                            if ( needToReprompt ) {

                                    if ( isAuthFail ) {
                                        cfg.clearLoginInfoForProject(projectId);
                                    }

	                            	
		                            if ( isHttpAuthFail ) {
		                            	var	server = cfg.getServerByProjectId(projectId),
		                            		creds;

		                            	
		                            	if ( server.udc ) {
		                            		
		                                    creds = cfg.getDefaultServerCreds();
		                            	} else {
		                            		
		                            		creds = server.wsc;
		                            	}
		                            	
	                                    delete creds.lo;
	                                    delete creds.ps;

	                                    
	                                    
		                                cfg.saveConfiguration();

		                                
	                                    res.message = $DESC( 10672, "The username or password you entered is incorrect." );
		                            }

	                            	
	                            	res.handledError = false;

	                            	
	                            	errorCallback = function() {
			                            repromptForCreds = true;
		                            };
	                            }

	                            
	                            mstrApp.onerror(res, errorCallback );
	                        }
	                	}
                    },
                    devTypes = EnumDeviceType,
                    loginParams = setLocaleInfo({
                        taskId: $mobileLogin,
                        server: project.sn,
                        project: project.pn,
                        userid: loginInfo.uid,
                        password: loginInfo.pwd,
                        
                        wsSize: 10,
                        
                        authMode: loginInfo.am,

                        
                        wsuid: loginInfo.wsuid,
                        wspwd: loginInfo.wspwd,
                        wsam: loginInfo.wsam,

                        
                        clientVersion: mstrMobileApp.getAppVersion(),
                        clientType: mstrMobileApp.isTablet() ? devTypes.ANDROID_TAB : devTypes.ANDROID_PHONE

                    }),
                    loginConfig = {
                        projectId: projectId,
                        mobileConfig: cfg,
                        
                        doNotHold : true
                    };
                me.request(loginCallback, loginParams, false, loginConfig); 
            },
            foo = doLogin;

        getCredentials.call( this, loginInfo, doLogin );

        repromptTimer = setInterval( function () {

            if ( repromptForCreds ) {
            	
            	repromptForCreds = false;

            	
            	loginInfo = cfg.getLoginInfo(projectId);

            	
            	getCredentials.call( me, loginInfo, doLogin );
            }

        }, 500 );

    }

    
    mstrmojo.MobileServerProxy = mstrmojo.declare(
        mstrmojo.ServerProxy,

        null,

        
        {
            scriptClass: "mstrmojo.MobileServerProxy",

            getSessions: function() {
                return sessions;
            },

            
            request: function request(callback, params, override, config) {
                
                this._projectId = config.projectId;

                
                this._mobileCfg = config.mobileConfig;

                this._super(callback, params, override, config);
            },

            
            createRequest: function createRequest(requestId, callback, params, config) {
                var request;
                try {
                    
                    request = this._super(requestId, callback, params, config);

                    
                    var projectId = this._projectId;
                    request.pid = projectId;
                    if ( ! config.noTaskURL ) {
                    request.taskURL = this._mobileCfg.getTaskUrlByProject(projectId);
                    }
                    request.isLogin = (params.taskId === $mobileLogin);
                    request.isPwdChange = (params.taskId == $chgPassword);
                } catch(ex) {
                    
                    this.deleteRequest(requestId);
                    throw ex;
                }

                
                return request;
            },

            
            userInteractionRequired: function userInteractionRequired(request) {
                var result = false;

                
                if ( request.pid && !sessions[request.pid]) {

                    var loginInfo = request.config.mobileConfig.getLoginInfo(request.pid),
                        needServerCreds = ( ( loginInfo.wsam > 1 ) && !loginInfo.wsuid ),
                        needProjectCreds = ( !loginInfo.uid && loginInfo.am != 2  );

                    
                    return needServerCreds || needProjectCreds;
                }

                return result;
            },

            
            submitRequest: function submitRequest(request) {
                
                if (request.isLogin || request.isPwdChange  ) {
                    
                    this._super(request);

                    
                    return;
                }

                
                var state = sessions[request.pid],
                    localeInfo = localeInfoMap[request.pid];

                
                if (state) {
                    
                    request.params.sessionState = state;

                    if (localeInfo){
                        mstrmojo.hash.copy(localeInfo, mstrmojo.locales);
                    }

                      
                    this._super(request);

                } else {
                    if ( request.config.skipLogin ) {
                        this._super(request);
                        return;
                    }
                    if ( mstrMobileApp.isOnline() ) {
                        
                        
                        login.call(this, request);
                    } else {
                        
                        
                        if ( canUseCache.call(this, request)) {
                            
                            
                            if ( ! postLoginFlag[request.pid] ) {
                                postLogin.call(this, request);
                            } else {
                                this._super(request);
                            }
                        } else {
                            
                            login.call(this, request);
                        }
                    }
                }
            },

            
            response: function response(requestId, status, res) {
                var request = this.getRequest(requestId);

                
                if (!request) {
                    
                    return;
                }

                
                if (!status && mstrMobileApp.isOnline()) {
                    switch (parseInt(res.code,10)) {
                        case $ERRS.AUTHEN_E_LOGIN_FAIL_EXPIRED_PWD:
                        case $ERRS.AUTHEN_E_LOGIN_FAILED_NEW_PASSWORD_REQD:
                            handleExpiredPassword.call(this,request);
                            return;
                            break;

                        case $ERRS.MSI_INBOX_MSG_NOT_FOUND:
                            
                            break;

                        case $ERRS.E_MSI_USERMGR_USER_NOTFOUND:
                            if (!request.isLogin) {
                                
                                delete request.params.sessionState;

                                
                                login.call(this, request);

                                
                                return;
                            }
                            break;
                    }
                }

                
                this._super(requestId, status, res);
            },

            getSession: function getSession(projectId) {
                return sessions[projectId];
            },

            closeSession: function closeSession(projectId) {
                
            },

            closeAllSessions: function closeAllSessions() {
                
                sessions = {};
            },

            getLocaleInfo: function getLocaleInfo(projectId) {
                return localeInfoMap[projectId];
            },

            hasEmailScreenPrivilege : function hasEmailScreenPrivilege(projectId) {
            	return false;
            }
        });

}());
(function() {
    mstrmojo.requiresCls("mstrmojo.ValidationTextBox", "mstrmojo._IsInputControl", "mstrmojo.dom", "mstrmojo.num");
    
    var _VAL = mstrmojo.validation,
        SC = _VAL.STATUSCODE,
        _VALIDATOR = _VAL.VALIDATOR,
        _DTP = mstrmojo.expr.DTP,
        NO_VALIDATION = 0,
        PHONE_NO = 1,
        EMAIL_ADDRESS = 2,
        ZIP_CODE = 3,
        SOCIAL_SECURITY_NO = 4,
        REG_EXP = 5;
    
    
    mstrmojo.TextFieldDIC = mstrmojo.declare(
            
        mstrmojo.ValidationTextBox,
        
        [mstrmojo._IsInputControl],
        
        {
            scriptClass: 'mstrmojo.TextFieldDIC',
            
            cssClass: 'mstrmojo-TextFieldDIC',
            
            dtp: _DTP.VARCHAR,
            
            validationDelay: 0, 
            
            getInputNode: function(){
                return this.inputNode;
            },
            
            focus: function() {
                this.validate();
                mstrmojo.dom.setCaret(this.domNode, (this.value && this.value.length || 0));
            },
            
            init: function(props) {
                if (this._super){
                    this._super(props);
                }
                
                this.constraints = mstrmojo.hash.copy()
                
                var di = props.dic, 
                    c = this.constraints = {trigger: mstrmojo.validation.TRIGGER.ONKEYUP}, 
                    dt = di.dt;
                
                if(di.ml) {
                    this.maxLength = di.ml;
                }
                
                
                if(di.psw) {
                    this.type = 'password';
                    
                    this.value = this.lv = '';
                    this.owner.applyPasswordMask && this.owner.applyPasswordMask();
                }
                
                
                if (_VAL.isNumeric(dt) || _VAL.isInt(dt) || _VAL.isString(dt)){
                    this.dtp = dt;
                }
                
                switch (di.vm){
                case PHONE_NO: 
                        c.validator = _VALIDATOR.VALIDATE_PHONENO;
                        break;
                case EMAIL_ADDRESS: 
                        c.validator = _VALIDATOR.VALIDATE_EMAIL;
                        break;
                case ZIP_CODE:
                        c.validator = _VALIDATOR.VALIDATE_ZIPCODE;
                        break;
                case SOCIAL_SECURITY_NO: 
                        c.validator = _VALIDATOR.VALIDATE_SSN;
                        break;
                case REG_EXP: 
                        c.regExp = new RegExp('^'+di.rgx+'$');
                        break;
                }
                
                c.min = di.emin ? di.min : null;
                c.max = di.emax ? di.max : null;
                
                c.maxLen = (di.ml !== undefined) ? di.ml : null;
                c.minLen = (di.mnl !== undefined) ? di.mnl : null;
                
                if (di.req || di.emin){
                    this.required = true;
                }
            },
            
            
            onInvalid: function(){
                if(this.popup) {
                    this.popup.set('hasInvalidData', true);
                }
            },
            
            onValid: function(){
                if(this.popup) {
                    this.popup.set('hasInvalidData', false);
                }
            },
            
            
            applyChanges: function(){
                this.validate();
                
                if(this.isValid()){
                    this._super();
                }else{
                    this.handleInvalid();
                    return false;
                }
                
                return true;
            },
            
            handleInvalid: function(){
                if (mstrmojo.all.mojoConfirmx9){
                    
                    return;
                }
                
                var me = this;
                mstrmojo.confirm(this.validationStatus.msg + '<br>(' + mstrmojo.desc(9199) + ')',  
                                
                                [{
                                    scriptClass: 'mstrmojo.Button',
                                    text: mstrmojo.desc(1442), 
                                    onclick: function(){
                                        me.focus();
                                    }
                                },{
                                    scriptClass: 'mstrmojo.Button',
                                    text: mstrmojo.desc(221), 
                                    onclick: function(){
                                        me.popup.onCancel();
                                    }
                                }], mstrmojo.desc(7548)); 
            },
            
            cancelChanges: function(){
                this.inputNode.blur();
                this.value = this.lv;
                this.clearValidation();
            }
        });
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.Slider",
                         "mstrmojo.MetricQualification",
                         "mstrmojo.expr",
                         "mstrmojo.ValidationTextBox",
                         "mstrmojo.array",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(8153, 8154, 8155, 8156, 8157, 8158, 8159, 8160, 8161, 8162, 8163, 8164, 8165, 8166, 8167, 8168, 8169, 8170, 7839, 587, 2204, 2202, 2203, 7576, 7575, 7622);

    var $D = mstrmojo.dom,
        $HASH = mstrmojo.hash,
        $M = mstrmojo.MCSUtil,
        $DESC = mstrmojo.desc,
        $C = mstrmojo.css,
        $NM = mstrmojo.num,
        $MATH = Math,
        $MATH_MAX = $MATH.max,
        $MATH_MIN = $MATH.min,
        $MATH_FLOOR = $MATH.floor,
        $MATH_ROUND = $MATH.round;

    
    function positionSliderElements(slider, ui, handle1, handle2) {
        var px = 'px',
            effectiveLength = slider._length,                   
            handleSize = slider.handleSize,
            orCfg = slider.orCfg,
            position = orCfg.posCssP,
            length = orCfg.lenCssP;

        
        handle1 = $MATH_MAX(handle1, -1);
        handle2 = $MATH_MIN(handle2, effectiveLength);

        
        var min = $MATH_MIN(handle1, handle2),
            max = $MATH_MAX(handle1, handle2),
            thumbLength = max - min,
            upperLength = $MATH_MAX(parseInt(slider[length], 10) - (2 * slider.cssBkBW) - (max + handleSize), 0);   

        
        if (slider.hasRendered) {

            
            ui.handle1Node.style[position] = handle1 + px;
            ui.handle2Node.style[position] = handle2 + px;

            var lowerStyle = ui.lowerRange.style,
                thumbStyle = ui.thumbNode.style,
                upperStyle = ui.upperRange.style;

            
            lowerStyle[position] = 0;
            thumbStyle[position] = (min + handleSize) + px;
            upperStyle[position] = (max + handleSize) + px;

            
            lowerStyle[length] = $MATH_MAX(min, 0) + px;
            thumbStyle[length] = thumbLength + px;
            upperStyle[length] = upperLength + px;

        } else {
            
            px += ';';
            position += ':';
            length += ':';

            
            slider.handle1CssText = position + handle1 + px;
            slider.handel2CssText = position + handle2 + px;

            
            slider.lowerRangeCssText = length + $MATH_MAX(min, 0) + px;
            slider.thumbCssText = position + (min + handleSize) + px + length + thumbLength + px;
            slider.upperRangeCssText =  position + (max + handleSize) + px + length + upperLength + px;
        }

        
        return {
            handle1: handle1,
            handle2: handle2
        };
    }

    
    function MetricSlider(sl) {
        
        this.getUnit = function () {
            return sl._length / $MATH_MAX((sl.items.length - 1), 1);
        };

        this.calcMinMax = function (pxMin, pxMax) {
            var unit = sl.unit;
            return {
                min: $MATH_FLOOR(pxMin / unit + 0.5),
                max: $MATH_FLOOR(pxMax / unit + 0.5)
            };
        };

        this.calcPxIdx = function (px) {
            return $MATH_FLOOR(px / sl.unit + 0.5);
        };

        
        this.getStep = function () {
            var rng = sl.high - sl.low,
                cat = parseInt(sl.numFmts.cat, 10),
                adjust = (cat === 4) ? 2 : (cat === 5) ? 4 : 0;

            rng = (rng === 0) ? 1 : rng;
            if (rng > 1) {
                return (rng > (sl._length - 2)) ? Number(Number(rng / (sl._length - 2)).toFixed(sl.numFmts.dp + adjust)) : 1;
            }

            return rng / (sl._length - 2);
        };

        
        this.getIdx = function (vl) {
            return $MATH_MIN($MATH_MAX($MATH_ROUND((vl - sl.low) / sl.step), 0), sl.items.length - 1);
        };

        
        this.initialMetricSlider = function initialMetricSlider() {
            var notNull = function (v) {
                    return v !== undefined && v !== null;
                },
                validateData = function (sl) {
                    return (notNull(sl.da) && notNull(sl.da.low) && notNull(sl.da.high) &&
                            notNull(sl.da.cnt) && notNull(sl.f) && notNull(sl.ft) && notNull(sl.qua));
                },
                displayInvalid = function (sl) {
                    var gen = true,
                        rp = true;

                    
                    if (sl.ft == $M._GENERIC) {
                        gen = sl.f != $M.FN.ISNULL && sl.f != $M.FN.ISNOTNULL && sl.f != $M.FN.NOTIN && sl.f != $M.FN.IN;
                    } else if(sl.ft == $M._PERCENT || sl.ft == $M._RANK) {
                        rp = sl.f != $M.MRPFN.INASCENDING && sl.f != $M.MRPFN.INDESCENDING && sl.f != $M.MRPFN.NOTINDESCENDING && sl.f != $M.MRPFN.NOTINASCENDING;
                    }

                    return !gen || !rp;
                },
                adjust = 0;

            sl.include = sl.parent.include;
            sl.clsType = 'scm ';

            sl.staticStatus = !(notNull(sl.da) && notNull(sl.da.low) && notNull(sl.da.high)&& notNull(sl.da.cnt)&& notNull(sl.qua));
            if (sl.staticStatus) { 
               sl.da.low = 1;
               sl.da.high = 7;
               sl.ft = $M._GENERIC;
               sl.f = $M.FN.BETWEEN;
               sl.qua = $M.Q._G;
               sl.cs = [{n: '', v: 1}, {n: '', v: 7}];
               sl.numFmts = {cat: 9, dp: 0, fm: ''};
            }

            
            switch (sl.qua) {
            case 0:
                var cat = sl.numFmts.cat;
                adjust = cat == 4 ? 2 : cat == 5 ? 4 : 0;
                sl.low = Number(Number(sl.da.low ).toFixed(sl.numFmts.dp + adjust));
                sl.high = Number(Number(sl.da.high).toFixed(sl.numFmts.dp + adjust));
                break;
            case 1:
            case 2:
                sl.low = 1;
                sl.high = sl.da.cnt;
                break;
            case 3:
            case 4:
                sl.low = 0;
                sl.high  = 100;
                break;
            }

            var ept = !sl.staticStatus && !sl.da.nov && sl.dt != 30;
            sl.set('lowText', ept? $M.formatNumber(sl.qua, sl.low, sl.numFmts) : "");
            sl.set('highText', ept? $M.formatNumber(sl.qua, sl.high, sl.numFmts) : "");

            
            sl.step = (sl.qua == 1 || sl.qua == 2)? 1 : this.getStep();

            sl.low -= sl.step;
            sl.high += sl.step;

            
            sl.cs1Vl = sl.low;
            sl.cs2Vl = sl.high;

            
            var l = sl.low,
                h = sl.high,
                itms = [],
                len = 0;

            if ( notNull(l) && notNull(h) && sl.dt != 30) {
                for (var i = 0, j = l; j <= h; i ++, j += sl.step) {
                    itms[i] = {n : $M.formatNumber(sl.qua, j, sl.numFmts), v: Number(Number(j).toFixed(sl.numFmts.dp + adjust))};
                }
                len = itms.length;
                if (len > 0 && itms[len -1].v != h){  itms[len-1] = {n: $M.formatNumber(sl.qua, h, sl.numFmts), v: h}; }
            }

            len = itms.length;
            if(len >= 2 ) {
                itms[0].n = itms[len -1].n = $DESC(7622);
            }

            sl.items = itms;

            
            var $O = $M.OP,
            cs = sl.cs,
            c1 = (cs && cs.length > 0)? $NM.parseNumeric(String(cs[0].v).replace('%', '')) : l,
            c2 = (cs && cs.length >1)? $NM.parseNumeric(String(cs[1].v).replace('%', '')) : h;

            if(c1 < sl.low) { sl.frtUst = true;}
            if(c2 > sl.high) {sl.ndUst = true;}

            sl.opId = (sl.f != null && sl.ft != null)? $M.getOpIdxByfunc(sl.f, sl.ft) : $O._BETWEEN;

            switch (sl.opId){
            case  $O._EQUALS :
            case $O._NOT_EQUALS:
                sl.cs1Vl = sl.cs2Vl = c1;
                break;
            case $O._LESS_EQUAL:
            case $O._GREATER:
                sl.cs1Vl = l;
                sl.cs2Vl = c1;
                break;
            case $O._GREATER_EQUAL:
            case $O._LESS:
                sl.cs1Vl = c1;
                sl.cs2Vl = h;
                break;
            case $O._IN:
            case $O._NOT_IN:
            case $O._IS_NULL:
            case $O._IS_NOT_NULL:
                break;
            default:
                sl.cs1Vl = c1;
                sl.cs2Vl = c2;
                break;
            }

            sl.cs1Idx = this.getIdx(sl.cs1Vl);
            sl.cs2Idx = this.getIdx(sl.cs2Vl);

            if (sl.dt != 30) {
               
               
               sl.cs1Nm = notNull(sl.cs1Vl) ? $M.formatNumber(sl.qua, sl.cs1Vl, sl.numFmts) : sl.items[sl.cs1Idx].n;
               sl.cs2Nm = notNull(sl.cs2Vl) ? $M.formatNumber(sl.qua, sl.cs2Vl, sl.numFmts) : sl.items[sl.cs2Idx].n;
            }

            sl.unit = this.getUnit();

            sl.set('unSet', (sl.dt == 30 || !validateData(sl) || displayInvalid(sl) || (!sl.cs || sl.cs.length == 0)) && !sl.staticStatus);
        };

        
        this.updateOpCs = function () {
            
            var i = (sl.cs1Vl > sl.cs2Vl)? sl.cs2Vl : sl.cs1Vl,
                a = (sl.cs1Vl > sl.cs2Vl)? sl.cs1Vl : sl.cs2Vl,
                l = sl.low,
                h = sl.high,
                il = sl.include,
                $O = $M.OP,
                isPercent = (sl.qua == $M.Q._PT || sl.qua == $M.Q._PB),
                unset,
                cs = [];

            if ((i >= l && a <= h) || i < l || a > h) { sl.opId = (il)? $O._BETWEEN : $O._NOT_BETWEEN;}
            if (i == a) { sl.opId = (il)? $O._EQUALS : $O._NOT_EQUALS;}
            if (i == l && a < h ) { sl.opId = (il)? $O._LESS_EQUAL : $O._GREATER;}
            if (i > l && a == h) {sl.opId = (il)? $O._GREATER_EQUAL : $O._LESS;}

            unset = l == i && a == h;
            if(!unset){
                
                switch (sl.opId){
                case $O._BETWEEN:
                case $O._NOT_BETWEEN:
                    cs.push({dtp:5, v: $NM.toLocaleString(i) + (isPercent? '%' : '')});

                case $O._EQUALS:
                case $O._NOT_EQUALS:
                    cs.push({dtp:5, v: $NM.toLocaleString(a) + (isPercent? '%' : '')});
                    break;
                 default:
                     if (i > l) { cs.push({dtp:5, v: $NM.toLocaleString(i) + (isPercent? '%' : '')});}
                     if (a < h) { cs.push({dtp:5, v: $NM.toLocaleString(a) + (isPercent? '%' : '')});}
                }
            }
            sl.cs = cs;

            
            sl.parent.node.data.cs = cs;
            sl.set('unSet', unset);
        };

        
        this.updateThumb = function () {
            var cs1Idx = sl.cs1Idx,
                cs2Idx = sl.cs2Idx;

            
            if (cs1Idx !== undefined && cs2Idx !== undefined) {
                var unit = sl.unit,
                    gap = sl.gap;

                
                $HASH.copy(positionSliderElements(sl, sl, $MATH_ROUND(cs1Idx * unit - gap), $MATH_ROUND(cs2Idx * unit - gap)), sl);
            }
        };

        this.joinConst = function () {
            var cs = sl.cs;
            if (cs) {
                var constValues = [],
                    i;

                for (i in cs){
                    constValues.push(cs[i].v);
                }

                return constValues.join(',');
            }
        };
    }

    var tooltipMarkup = '<span {@ttpCssText}>{@content}</span>';

    
    function initGhost() {
        
        if (this.staticStatus) {
            
            return null;
        }

        
        var ghost = this.ghost;
        if (!ghost) {
            
            var cn = this.containerNode.cloneNode(true),
                cnc = cn.childNodes;

            
            $C.addClass(cn, [ 'gh' ]);

            
            ghost = this.ghost = {
                containerNode: cn,
                lowerRange: cnc[0],
                handle1Node: cnc[1],
                thumbNode: cnc[2],
                handle2Node: cnc[3],
                upperRange: cnc[4]
            };

            
            this.sdcNode.appendChild(cn);
        }

        var orCfg = this.orCfg,
            position = orCfg.posCssP,
            length = orCfg.lenCssP,
            id = this.id;

        
        mstrmojo.array.forEach([ 'lowerRange', 'containerNode', 'thumbNode', 'upperRange' ], function (nodeName, idx) {
            
            var slider = mstrmojo.all[id],
                widgetNodeStyle = slider[nodeName].style,
                ghostNodeStyle = ghost[nodeName].style;

            
            if (idx) {
                
                ghostNodeStyle[position] = widgetNodeStyle[position];
            }

            
            ghostNodeStyle[length] = widgetNodeStyle[length];
        });

        
        ghost.containerNode.style.display = 'block';

        return ghost;
    }

    
    mstrmojo.MetricSlider = mstrmojo.declare(
        
        mstrmojo.Slider,

        
        [ mstrmojo._HasPopup ],

        
        {
            scriptClass: "mstrmojo.MetricSlider",

            markupString: '<div>' +
                            '<div class="mstrmojo-Slider-summary"></div>'+
                            '<div class="mstrmojo-Slider {@cssClass} {@clsType} {@clsOrientation}" style="{@cssText}" >' +
                                '<div class="cont" style="position:absolute;">' +
                                    '<div class="bk" style="margin-top: 2px;{@bkCssText}"></div>' +
                                    '<div class="sdc" style="position:absolute;{@sdcCssText}">' +
                                        '<div class="sd" style="{@sdCssText}">' +
                                            '<div class="bk" style="{@lowerRangeCssText}"></div>' +
                                            '<div class="t1" style="{@handle1CssText}" mstrAttach:mouseover,mouseout,click></div>' +
                                            '<div class="t2 bk" style="{@thumbCssText}"></div>' +
                                            '<div class="t3" style="{@handel2CssText}" mstrAttach:mouseover,mouseout,click></div>' +
                                            '<div class="bk" style="{@upperRangeCssText}"></div>' +
                                        '</div>' +
                                    '</div>' +
                                    '<div class="mstrmojo-Label" style="margin-top:5px;float:left;"></div>' +
                                    '<div class="mstrmojo-Label" style="margin-top:5px;float:right;"></div>' +
                                '</div>' +
                            '</div>'+
                        '</div>',

            markupSlots: {
                summaryNode: function() {return this.domNode.childNodes[0];},
                dndNode: function() {return this.domNode.childNodes[1].childNodes[0];},
                bgNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[0];},
                sdcNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1];},
                containerNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0];},
                lowerRange: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[0];},
                handle1Node: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[1];},
                thumbNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[2];},
                handle2Node: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[3];},
                upperRange: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[4];},
                tooltipNode: function(){return this.domNode.childNodes[1].childNodes[0].childNodes[1];},
                lowNode: function(){return this.domNode.childNodes[1].childNodes[0].childNodes[2];},
                highNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[3];},
                editValueNode: function(){return this.domNode;}
            },

            markupMethods: {
                onlowTextChange: function (){ this.lowNode.innerHTML = this.lowText || ''; },
                onhighTextChange: function (){ this.highNode.innerHTML = this.highText || ''; },
                onfontChange: function () { this.lowNode.style.font = this.highNode.style.font = String(this.font); },
                onunSetChange: function () { $C.toggleClass(this.domNode.childNodes[1], 'invalid', this.unSet); }
            },

            init: function init(p) {
                this._super(p);

                this.handleSize = mstrmojo.MetricSlider.METRICSLIDERTHUMBWIDTH;

                this.clsType = 'scm';
                this.typeHelper = new MetricSlider(this);
                this.useRichTooltip = false;
            },

            

            unSet : false, 

            preBuildRendering: function preBuildRendering() {
                
                var orCfg = this.orCfg,
                    isHoriz = this.isHoriz;

                orCfg.cPosCssP = (isHoriz) ? 'right' : 'bottom';
                orCfg.cLenCssP = (isHoriz) ? 'height' : 'width';

                var dimension = orCfg.lenCssP,
                    rawLength = this[dimension],
                    length = parseInt(rawLength, 10),
                    handleSize = this.handleSize;

                var effectiveLength = this._length = (isNaN(length)) ? 0 : (length - handleSize);
                if (effectiveLength <= 0) {
                    effectiveLength = this._length = mstrmojo.MetricSlider.METRICSLIDERDEFAULTWIDTH - handleSize;   
                }

                if (rawLength) {
                    this.bkCssText = dimension + ':' + $MATH_MAX(length - (2 * this.cssBkBW), 0) + 'px;';
                    this.sdcCssText =  orCfg.posCssP + ':0px;' + dimension + ':' + effectiveLength + 'px;' + orCfg.opPosCssP + ':0px;';
                }

                this.typeHelper.initialMetricSlider();
                this.typeHelper.updateThumb();
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                if (!this.staticStatus && !this.da.nov) {
                    var ln = this.lowNode,
                        fos = parseInt(ln.style.fontSize, 10);

                    ln.style.fontSize = this.highNode.style.fontSize = $MATH_ROUND((isNaN(fos) ? 8 : fos) * this.parent.model.zf) + 'pt';

                    this.updateSummary();
                }
            },

            onmouseover: function onmouseover(evt) {
                this.showTooltip(evt.e, self);
            },

            onmouseout: function onmouseout(evt) {
                this.hideTooltip(evt.e, self);
            },

            summaryLabels: {
                db : $DESC(8153, "Between ## and ###"),
                dnb: $DESC(8154,"Not between ## and ###"),
                din: $DESC(587,"In"),
                dnin: $DESC(2204,"Not in"),
                dnull: $DESC(2202,"Is Null"),
                dnnull: $DESC(2203,"Is not Null"),

                req: $DESC(8155,"Rank ="),
                rneq: $DESC(8156,"Rank <>").replace("<>", String.fromCharCode(0x2260)),
                rexb: $DESC(8157,"Rank exclude bottom"),
                rext: $DESC(8158,"Rank exclude top"),
                rb: $DESC(8159,"Rank bottom"),
                rt: $DESC(8160,"Rank top"),
                rbt: $DESC(8161,"Rank between ## and ###"),
                rnbt: $DESC(8162,"Rank not between ## and ###"),
                rin: $DESC(8163,"Rank in"),
                rnin: $DESC(8164,"Rank not in"),

                peq: $DESC(8165,"Percent ="),
                pneq: $DESC(8166,"Percent <>").replace("<>", String.fromCharCode(0x2260)),
                pexb: $DESC(8167,"Exclude bottom"),
                pext: $DESC(8168,"Exclude top"),
                pb: $DESC(7576,"Bottom"),
                pt: $DESC(7575,"Top"),
                pbt: $DESC(8153,"Between ## and ###"),
                pnbt: $DESC(8154,"Not between ## and ###"),
                pin: $DESC(8169,"Percent in"),
                pnin: $DESC(8170,"Percent not in")
            },

            updateSummary: function updateSummary() {
                

                if (this.summaryNode && !this.staticStatus) {
                    var f  = this.f,  
                        ft = this.ft, 
                        fte = $M,
                        fe = $M.FN,
                        fmrpe = $M.MRPFN,
                        txt = "",
                        fl = (this.cs1Vl < this.cs2Vl)? this.cs1Nm : this.cs2Nm,
                        fr = (this.cs1Vl > this.cs2Vl)? this.cs1Nm : this.cs2Nm,
                        th = this.typeHelper,
                        s = this.summaryLabels,
                        specialCase = (ft == fte._GENERIC && (f == fe.ISNULL || f == fe.ISNOTNULL || f == fe.NOTIN || f == fe.IN)) ||
                                        ((ft == fte._PERCENT || ft == fte._RANK) && (f == fmrpe.INASCENDING || f == fmrpe.INDESCENDING || f == fmrpe.NOTINDESCENDING || f == fmrpe.NOTINASCENDING));

                    
                    if(!this.unSet || specialCase){
                        switch(ft){
                            case  fte._GENERIC:
                                switch(f){
                                case fe.EQUALS:
                                    txt = "= " + fl;
                                    break;
                                case fe.NOTEQUALS:
                                    txt = String.fromCharCode(0x2260) + " " + fl;
                                    break;
                                case fe.GREATERTHAN:
                                    txt = "> " + fr;
                                    break;
                                case fe.GREATERTHANEQUALS:
                                    txt = String.fromCharCode(0x2265) + " " + fl;
                                    break;
                                case fe.LESSTHAN:
                                    txt = "< " + fl;
                                    break;
                                case fe.LESSTHANEQUALS:
                                    txt = String.fromCharCode(0x2264) + " " + fr;
                                    break;
                                case fe.BETWEEN:
                                    txt = s.db.replace("##",fl).replace("###",fr);
                                    break;
                                case fe.NOTBETWEEN:
                                    txt = s.dnb.replace("##",fl).replace("###",fr);
                                    break;
                                case fe.ISNULL:
                                    txt = s.dnull;
                                    break;
                                case fe.ISNOTNULL:
                                    txt = s.dnnull;
                                    break;
                                case fe.IN:
                                    txt = s.din + " " + th.joinConst();
                                    break;
                                case fe.NOTIN:
                                    txt = s.dnin + " " +th.joinConst();
                                    break;
                                }
                                break;
                            case fte._PERCENT:
                            case fte._RANK:

                                var pr = "r";
                                if(ft == fte._PERCENT) pr = "p";

                                switch(f){
                                case fmrpe.EQUALSDESCENDING:
                                case fmrpe.EQUALSASCENDING:
                                    txt = s[pr + "eq"] + " " + fl;
                                    break;
                                case fmrpe.NOTEQUALSDESCENDING:
                                case fmrpe.NOTEQUALSASCENDING:
                                    txt = s[pr + "neq"] + " " + fl;
                                    break;
                                case fmrpe.GREATERTHANEQUALSASCENDING:
                                    txt = s[pr + "exb"] + " " + fl;
                                    break;
                                case fmrpe.GREATERTHANASCENDING:
                                    txt = s[pr + "exb"] + " " + fr;
                                    break;
                                case fmrpe.GREATERTHANEQUALSDESCENDING:
                                    txt = s[pr + "ext"] + " " + fl;
                                    break;
                                case fmrpe.GREATERTHANDESCENDING:
                                    txt = s[pr + "ext"] + " " + fr;
                                    break;
                                case fmrpe.LESSTHANASCENDING:
                                    txt = s[pr + "b"] + " " + fl;
                                    break;
                                case fmrpe.LESSTHANEQUALSASCENDING:
                                    txt = s[pr + "b"] + " " + fr;
                                    break;
                                case fmrpe.LESSTHANDESCENDING:
                                    txt = s[pr + "t"] + " " + fl;
                                    break;
                                case fmrpe.LESSTHANEQUALSDESCENDING:
                                    txt = s[pr + "t"] + " " + fr;
                                    break;
                                case fmrpe.BETWEENDESCENDING:
                                case fmrpe.BETWEENASCENDING:
                                    txt = s[pr + "bt"].replace("##",fl).replace("###",fr);
                                    break;
                                case fmrpe.NOTBETWEENASCENDING:
                                case fmrpe.NOTBETWEENDESCENDING:
                                    txt = s[pr + "nbt"].replace("##",fl).replace("###",fr);
                                    break;
                                case fmrpe.INASCENDING:
                                case fmrpe.INDESCENDING:
                                    txt = s[pr + "in"] + " " + th.joinConst();
                                    break;
                                case fmrpe.NOTINDESCENDING:
                                case fmrpe.NOTINASCENDING:
                                    txt = "";
                                    txt = s[pr + "nin"] + " " + th.joinConst();
                                    break;
                                }
                                break;
                        }
                    }

                    var summaryNode = this.summaryNode,
                        margin = (txt !== '') ? '' : 0;     

                    
                    summaryNode.innerHTML = txt;
                    summaryNode.style.margin = margin;

                    if (this.hasRendered && this.height == null){
                        this.parent.updateHeight();
                     }

                }
            },

            getClientHeight: function getClientHeight(){
                return this.dndNode.clientHeight + this.summaryNode.clientHeight + 15;
            },

            
            initDrag: function initDrag(e, hWin) {
                if (!this.staticStatus && !this.da.nov) {
                    hWin = hWin || window;

                    
                    var td = $D.eventTarget(hWin, this.dnd.startE);
                    if (td === this.handle1Node || td === this.handle2Node) {

                        var ghost = initGhost.call(this),
                            oc = this.orCfg,
                            dnd = this.dnd;

                        dnd.initD = {
                            handle1: parseFloat(this.handle1, 10),
                            handle2: parseFloat(this.handle2, 10),
                            length: this._length,
                            contL: ghost.containerNode[oc.lenP],
                            offset: $D.getMousePosition(this.dnd.startE, hWin)[oc.offsetP]
                        };

                        dnd.initD.td = td;

                        $C.removeClass(this.domNode.childNodes[1], ['invalid']);
                    }
                }
            },

            ondrag: function ondrag(e, hWin){
                if (!this.staticStatus) {
                    hWin = hWin || window;

                    var initD = this.dnd.initD;
                    if (initD) {
                        var ghost = this.ghost,
                            cs1Px = initD.handle1,
                            cs2Px = initD.handle2,
                            cs1Idx = this.cs1Idx,
                            cs2Idx = this.cs2Idx,
                            unit = this.unit,
                            gap = this.gap,
                            length = initD.length;

                        
                        var diff = $D.getMousePosition(e, hWin)[this.orCfg.offsetP] - initD.offset;
                        switch (initD.td) {
                            case this.handle1Node:
                                cs1Px = $MATH_MAX($MATH_MIN($MATH_MAX(initD.handle1 + diff, 0), length) - gap, -1);
                                cs1Idx = $MATH_MAX($MATH_FLOOR(cs1Px / unit + 0.5), 0);
                                break;

                            case this.handle2Node:
                                cs2Px = $MATH_MAX($MATH_MIN($MATH_MAX(initD.handle2 + diff, 0), length) - gap, -1);
                                cs2Idx = $MATH_MAX($MATH.ceil(cs2Px / unit + 0.5), 0);  
                                break;

                            default:
                                return;
                        }

                        
                        positionSliderElements(this, ghost, cs1Px, cs2Px);

                        var items = this.items,
                            itemCount = (items && items.length) || 0;

                        if (itemCount && cs1Idx >= 0 && cs1Idx < itemCount && cs2Idx >= 0 && cs2Idx < itemCount) {
                            var _changed = false;
                            if (cs1Idx !== this.cs1Idx) {
                                this.cs1Idx = cs1Idx;
                                var itm = this.items[cs1Idx];
                                this.cs1Vl = itm.v;
                                this.cs1Nm = itm.n;
                                _changed = true;
                            }
                            if (cs2Idx !== this.cs2Idx) {
                                this.cs2Idx = cs2Idx;
                                var itm = this.items[cs2Idx];
                                this.cs2Vl = itm.v;
                                this.cs2Nm = itm.n;
                                _changed = true;
                            }

                            if (_changed) {
                                
                                this.typeHelper.updateThumb();
                                this._updateTooltip(initD.td);
                            }
                        }
                    }
                }
            },

            ondrop: function ondrop( e){
                if (!this.staticStatus && !this.da.nov) {
                    this.typeHelper.updateThumb();

                    var ghost = this.ghost;
                    if (ghost) {
                        ghost.containerNode.style.display = "none";
                    }

                    this.hideTooltip(e, self);

                    if (this.items && this.items.length){
                        this[($D.eventTarget(self, e) === this.ghost.handle1Node)? 'frtUst' : 'ndUst'] = false;
                        this.selectRange();
                    }

                    this.dnd.initD = null;
                }
            },

            
            selectRange : function slctrng(onlyInclude, changeQual, updateUnset) {
                var T = this.typeHelper,
                    c1 = this.cs1Vl,
                    c2 = this.cs2Vl,
                    q = this.qua,
                    nf = this.numFmts;

                this.cs1Idx = T.getIdx(c1);
                this.cs2Idx = T.getIdx(c2);

                var isEdge = function(idx, itms) {
                        var its = itms || [];
                        return idx == 0 || idx == its.length -1;
                    },
                    unsetStr = $DESC(7622);

                this.cs1Nm = isEdge(this.cs1Idx, this.items) && !this.frtUst ? unsetStr : $M.formatNumber(q, c1, nf);
                this.cs2Nm = isEdge(this.cs2Idx, this.items) && !this.ndUst ? unsetStr : $M.formatNumber(q, c2, nf);

                T.updateOpCs();

                
                this.onlyInclude = !!onlyInclude;
                this.changeQual = !!changeQual;
                this.unSet = !!updateUnset || this.unSet;

                this.updateSummary();
                this.onselectionChange();
             },

             onincludeChange : function incChange(){
                 if (!this.staticStatus) {
                     this.selectRange(true);
                 }
             },

            
            showTooltip: function showTooltip(e, win) {
                 var tgt = $D.eventTarget(win, e);
                 this._updateTooltip(tgt);
                 mstrmojo.tooltip.open(this, e, win);
            },

            
            _updateTooltip: function _updateTooltip(tgt) {
                var oc = this.orCfg,
                    ps = oc.posCssP,
                    txt,
                    tt = {
                        contentNodeCssClass: 'scm-tooltip',
                        refNode: this.domNode.childNodes[1],
                        posType: this._tooltip_pos
                    };

                tt[oc.opPosCssP] = - parseInt(this.font)/2;
                tt[ps] = tgt.style[ps];

                if (this.unSet) {
                    txt = $DESC(7622);
                } else {
                    txt = String((tgt === this.handle1Node) ? this.cs1Nm: this.cs2Nm);
                }

                tt.content = tooltipMarkup.replace(/\{@content\}/g, txt);

                this.set('richTooltip', tt);
            },

            
            onclick: function onclick(evt) {
                if (!this.staticStatus && !this.da.nov) {
                    var tgt = $D.eventTarget(evt.hWin || window, evt.e);
                    
                    this.dnd.initD = {
                    		makeMetricSilderSelectionByClick: true,
                    		td: ((tgt===this.handle1Node) ? this.handle1Node : ((tgt=== this.handle2Node) ? this.handle2Node : null))
                    };
                    
                    this.openEditValue({
                        isfrt: (tgt === this.handle1Node),
                        tgt: tgt
                    });

                    if (this._onThumb) {
                        
                        this._onThumb(evt);
                    }
                }
            },
            
            onselectionChange: function onselChg(evt) {
            	this._super(evt);
            	
            	
        		if (this.dnd.initD && this.dnd.initD.makeMetricSilderSelectionByClick){
        			this.dnd.initD = null;
        		}
            },

            onquaChange: function onqChg(evt){
                var oldf = mstrmojo.MCSUtil.getFuncInfo(this.opId, evt.valueWas),
                    newf = mstrmojo.MCSUtil.getFuncInfo(this.opId, evt.value),
                    u;

                if (oldf.ft != newf.ft) {
                    if (!this.staticStatus) {
                        this.items = [];
                        this.cs = [];
                        this.f = this.ft = null;
                        this.refresh();
                        u = true;
                    }
                } else {
                    this.f = mstrmojo.MCSUtil.getFuncInfo(this.opId, evt.value).f;
                    u = false;
                }

                this.selectRange(false, true, u);
            },

            updateData: function udtDt(da, props){
                this.da = da;

                
                
                this.updateExpr(props);

            },

            updateExpr: function udtEp(props) {
                if (props) {
                    this.cs = props.cs;
                    this.f = props.f;
                    this.ft = props.ft;
                    this.qua = props.qua;
                }
                this.refresh();
            },

            editValueRef:{
                cssClass: "edvl",
                slot: "editValueNode",
                scriptClass: "mstrmojo.Popup",
                locksHover: true,
                onOpen: function() {
                    if (this.tgt) {
                        this.set("left", $MATH_MIN($MATH_MAX(parseInt(this.tgt.style.left, 10), 0), parseInt(this.opener.width, 10) - 90) + 'px');
                        this.set("top", this.tgt.style.top);
                    }
                    var op = this.opener,
                    cld = this.children[0];
                    if (op) {
                        var v = this.isfrt ? op.cs1Vl : op.cs2Vl;
                        if (this.isfrt){
                            if ((op.cs1Vl <= op.low || op.cs1Vl >= op.high) && !op.frtUst){
                                v = '';
                            }
                        } else {
                            if((op.cs2Vl <= op.low || op.cs2Vl >= op.high) && !op.ndUst){
                                v = '';
                            }
                        }
                        cld.edt.set('value', $NM.toLocaleString(v));
                    }
                },
                children:[{
                  scriptClass : "mstrmojo.Table",
                  rows:1,
                  cols: 2,
                  layout: [{
                      cells: [{
                          cssText: "width: 40px; padding: 3px;"
                      }, {
                          cssText: "width: 16px;padding: 3px;"
                      }]
                  }],
                  children : [{
                        slot: "0,0",
                        scriptClass : "mstrmojo.ValidationTextBox",
                        alias: "edt",
                        cssText: "color:black",
                        dtp: mstrmojo.expr.DTP.NUMERIC,
                        constraints: {
                            trigger: mstrmojo.validation.TRIGGER.ALL
                        },
                        onValid: function() {
                            if (this.parent.apply) {
                                this.parent.apply.set("enabled", String(this.value).length != 0);
                            }
                        },
                        onInvalid: function() {
                            if (this.parent.apply) {
                                this.parent.apply.set("enabled", false);
                            }
                        },
                        onkeyup: function(evt) {
                            if (this.parent.apply.enabled) {
                                var hWin = evt.hWin,
                                    e = evt.e || hWin.event;
                                if (e.keyCode === 13){
                                    this.parent.apply.onclick();
                                }
                            }
                        }
                    }, {
                        slot: "0,1",
                        scriptClass : "mstrmojo.Button",
                        cssClass : 'icn apply',
                        alias: "apply",
                        onclick : function() {
                            var p = this.parent.parent,
                                op = p.opener,
                                v = this.parent.edt.value;

                            if (p && op && String(v).length > 0) {
                                op[p.isfrt ? 'cs1Nm' : 'cs2Nm'] = v;
                                v = $NM.parseNumeric(v);
                                op[p.isfrt ? 'cs1Vl' : 'cs2Vl'] = v;
                            }

                            op[p.isfrt? 'frtUst' : 'ndUst'] = true;
                            op.selectRange();

                            op.typeHelper.updateThumb();
                            p.close();
                        }
                    }]
                }]
            },

            openEditValue: function( config) {
                this.openPopup("editValueRef", config);
            }
        }
    );

    mstrmojo.MetricSlider.METRICSLIDERTHUMBWIDTH = 14;
    mstrmojo.MetricSlider.METRICSLIDERDEFAULTWIDTH = 95;

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.TextInput",
                         "mstrmojo.ValidationTextBox",
                         "mstrmojo.hash");

    
    mstrmojo.android.ui.ValidationTextInput = mstrmojo.declare(

        mstrmojo.android.ui.TextInput,

        null,

        
        {
            scriptClass: "mstrmojo.android.ui.ValidationTextInput",

            
            valProps: null,

            
            getTextCfg: function getTextCfg() {
                return mstrmojo.hash.copy(this.valProps, {
                    scriptClass: 'mstrmojo.ValidationTextBox',
                    onEnter: function () {
                        
                        var parent = this.parent,
                            fnEnter = parent.onEnter;

                        
                        if (fnEnter) {
                            
                            if (this.isValid()) {
                                
                                fnEnter.call(parent, this.value);
                            }
                        }
                    },
                    onvalidationStatusChange: function () {
                        
                        var status = this.validationStatus,
                            code = status && status.code,
                            errorLabel = this.parent.lblErr,
                            msg = code ? status.msg : '';

                        
                        errorLabel.set('text', msg);
                        errorLabel.set('visible', !!msg);
                    }
                });
            },

            
            validate: function validate() {
                return this.txt.validate();
            },

            
            isValid: function isValid() {
                return this.txt.isValid();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.TextArea",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $DOM = mstrmojo.dom,
        $C = mstrmojo.css,
        BASEFORM_URL = 5,
        BASEFORM_EMAIL = 6,
        INTEGER = 1,
        FLOAT = 7, 
        BIGDECIMAL = 30; 

    function reApplyWebkitTransform(dom) {
        if (dom.style) {
            var trans = mstrmojo.css.getStyleValue(dom, $DOM.CSS3_TRANSFORM);
            if (trans !== 'none') {
                dom.style[$DOM.CSS3_TRANSFORM] =  trans;
            }
        }
    }

    function convert3dTransform(dom) {
        var i,
            len = dom.childNodes.length;
        for (i = 0; i < len; i++) {
            var c = dom.childNodes[i];
            convert3dTransform(c);
            reApplyWebkitTransform(c);
        }
    }

    mstrmojo.android.inputControls.TextAreaDIC = mstrmojo.declare(

        mstrmojo.TextArea,

        [mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton],

        {
            scriptClass: "mstrmojo.android.inputControls.TextAreaDIC",

            cssDisplay: 'block',

            init: function init(props) {
                this._super(props);

                this.maxLength = this.dic.ml;

                if (!this.showByDefault) {
                    this.cssClass = 'mstrmojo-TextAreaDIC-Popup';
                    this.rows = 7;
                }
            },

            focus: function focus() {
                $DOM.setCaret(this.domNode, (this.value != null && String(this.value).length) || 0);
            },

            onfocus: function onfocus() {
                
                window.setTimeout(function () {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },

            onvalueChange: function onvalueChange() {
                if (!this.showByDefault) {
                    this._super();
                }
            },

            onblur: function onblur() {
                if (this.showByDefault) {
                    this.applyChanges();
                }
            },

            applyChanges: function applyChanges() {
                
                
                
                this.domNode.blur();
                var dt = parseInt(this.dic.dt, 10);
                if ((dt >= INTEGER && dt <= FLOAT) || dt === BIGDECIMAL) {
                    this.value = parseFloat(this.value);
                }
                this._super();
            },

            cancelChanges: function cancelChanges() {
                this.domNode.blur();
                this._super();
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                if (this.showByDefault) {
                    
                    
                    this.domNode.style.width = '100%';
                    this.domNode.style.height = '100%';

                    
                    
                    
                    
                    
                    
                    if (!mstrApp.isTablet()) {
                        
                        
                        
                        $DOM.attachEvent(this.domNode, 'click', function () {
                            convert3dTransform(document.body);
                        }, false);
                    }

                    
                    
                    
                    
                    
                    var me = this;
                    $DOM.attachEvent(this.domNode, 'blur', function () {
                        var d = me.domNode;
                        while (d != null) {
                            if (d.scrollTop > 0) {
                                d.scrollTop = 0;
                                break;
                            }
                            d = d.parentNode;
                        }
                    }, false);
                }
            },

            renderPreview: function renderPreview() {
                var dic = this.dic,
                    v = this.value,
                    dv = (this.dv == null) ? '' : String(this.dv),
                    prefix = '',
                    reg4URL = /(.*href=['"])(.*)(['"].*>)(.*)(<.*)/i;

                if (!dv || !dic.sp) { 
                    this.dv = dic.siwc ? '&nbsp;' : (dv || '&nbsp;');
                } else {
                    
                    v = (v.length > dic.pl) ? (v.substring(0, dic.pl) + '&hellip;') : v;

                    
                    switch (this.ts) {
                    case BASEFORM_EMAIL:
                        prefix = 'mailto:';
                        
                    case BASEFORM_URL:
                        if (!dv) {
                            dv = '<a href="mailto:"></a>';
                        }
                        dv = dv.replace(reg4URL, '$1' + prefix + this.value.replace(/\$/g, '$$$$') + '$3' + v.replace(/\$/g, '$$$$') + '$5');
                        break;
                   default:
                        dv = (dv.length > dic.pl) ? (dv.substring(0, dic.pl) + '&hellip;') : dv;
                    }
                    this.dv = dv;
                }

                this.renderPreviewButton(this.openerNode, this.dv);

                $C.toggleClass(this.openerNode.firstChild, 'filled', !this.dicChanged && this.value != null && String(this.value).length > 0);

            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.android.ui.Label",
                         "mstrmojo.android.ui.Menu",
                         "mstrmojo.android.ui.SearchBox",
                         "mstrmojo.android.ui.Image",
                         "mstrmojo.mstr.WebElements",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    mstrmojo.requiresDescs(10, 9462, 9463);

    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css,
        $TRANSITION_END = $DOM.CSS3_TRANSITION_END;

    var menuItems = [{
        n: mstrmojo.desc(9462, 'View All'),
        idx: 1,
        v: true
    }, {
        n: mstrmojo.desc(9463, 'View Selected'),
        idx: 0,
        v: false
    }];

    
    function canSearchClose() {
        
        if (this.searchRequired) {
            
            if (!this.target.getSelectedItems().length) {
                
                return false;
            }

            
            
        }

        return true;
    }

    
    function toggleSearch() {
        var switchLbl = this.lbl,
            switchLblNode = switchLbl.domNode,
            switchLblNodeStyle = switchLblNode.style,
            searchNodeStyle = this.searchNode.style,
            txt = this.search.box,
            txtNode = txt.inputNode,
            txtNodeStyle = txtNode.style,
            target = this.target,
            viz = 'visible';

        
        var isSearch = this._isSearch = !!switchLbl.visible;

        
        if (isSearch) {
            
            target.enterSearchMode();

            
            var textStyle = $CSS.getComputedStyle(txt.inputNode),
                width = this.domNode.offsetWidth - (2 * parseInt(textStyle.marginRight, 10)) - parseInt(textStyle.paddingLeft, 10) - parseInt(textStyle.paddingRight, 10) - this.search.slot0.offsetWidth,
                browseElements = this.browseElements;

            
            $DOM.attachOneTimeEvent(switchLblNode, $TRANSITION_END, function () {
                
                switchLbl.set(viz, false);

                
                searchNodeStyle.width = '100%';

                
                txt.set('hint', (browseElements && browseElements.source.n) || mstrmojo.desc(10, 'Search'));

                
                txt.set(viz, true);

                window.setTimeout(function () {
                    
                    txtNodeStyle.width = width + 'px';
                }, 0);
            });

            
            switchLblNodeStyle.opacity = 0;

        } else {
            
            if (!canSearchClose.call(this)) {
                return;
            }

            
            target.exitSearchMode(!this.searchRequired);

            
            $DOM.attachOneTimeEvent(txtNode, $TRANSITION_END, function () {
                
                txt.set(viz, false);

                
                txt.set('value', '');

                
                searchNodeStyle.width = '';

                
                switchLbl.set(viz, true);

                
                window.setTimeout(function () {
                    switchLblNodeStyle.opacity = 1;
                }, 0);
            });

            
            txt.inputNode.style.width = 0;
        }
    }


    
    mstrmojo.android.ui.ElementsSearchBar = mstrmojo.declare(
        mstrmojo.Container,

        null,

        
        {
            scriptClass: 'mstrmojo.android.ui.ElementsSearchBar',

            markupString: '<div id="{@id}" class="mstrmojo-ElementSearchBar {@cssClass}" style="{@cssText}" >' +
                              '<div>' +
                                  '<div class="mstrmojo-ElementSearchBar-switch"></div>' +
                                  '<div class="mstrmojo-ElementSearchBar-search"></div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                switchNode: function () { return this.domNode.firstChild.firstChild; },
                searchNode: function () { return this.domNode.firstChild.lastChild; }
            },

            markupMethods: {
                oncanSearchChange: function () { this.search.btn.set('visible', !!this.canSearch); }
            },

            
            target: null,

            
            browseElements: null,

            
            searchRequired: false,

            children: [{
                scriptClass: 'mstrmojo.android.ui.Menu',
                slot: 'switchNode',
                alias: 'menu',
                visible: false,
                items: [ menuItems[1] ],
                postselectionChange: function (evt) {
                    var added = evt.added,
                        item = added && this.items[added[0]];

                    
                    if (item) {
                        
                        var parent = this.parent;
                        parent.lbl.set('text', item.n);

                        
                        this.set('visible', false);
                        this.set('items', [ menuItems[item.idx] ]);

                        
                        parent.target.set('viewAll', item.v);
                    }
                }
            }, {
                scriptClass: 'mstrmojo.HBox',
                alias: 'search',
                slot: 'searchNode',
                children: [{
                    scriptClass: 'mstrmojo.android.ui.Image',
                    alias: 'btn',
                    touchTap: function () {
                        
                        toggleSearch.call(this.parent.parent);
                    }
                }, {
                    scriptClass: 'mstrmojo.android.ui.SearchBox',
                    alias: 'box',
                    hint: mstrmojo.desc(10, 'Search'),
                    cssDisplay: 'block',
                    cssText: 'width:0;',
                    visible: false,

                    searchFunc: function (searchPattern) {
                        
                        if (searchPattern) {
                            
                            var searchBar = this.parent.parent,
                                elements = searchBar.browseElements,
                                searchElements = (elements && elements.duplicate()) || new mstrmojo.mstr.WebElements(),
                                cfg = searchElements.browseConfig || {},
                                id = this.id;

                            
                            cfg.searchPattern = searchPattern;
                            cfg.blockBegin = 1;
                            cfg.searchForms = this.searchForms;
                        	
                            if (searchBar.searchTarget) {
                            	cfg.searchTarget = searchBar.searchTarget;
                            	delete searchBar.searchTarget;
                            }

                            
                            searchElements.browseConfig = cfg;

                            
                            searchElements.getItems(0, {
                                success: function () {
                                    
                                    mstrmojo.all[id].set('searchResult', searchElements);
                                }
                            });

                        } else {
                            
                            this.clearSearch();

                        }
                    },

                    clearFunc: function () {
                        
                        this.parent.parent.target.clearSearch();
                    },

                    onsearchResultChange: function () {
                        
                        this.parent.parent.target.search(this.searchResult);
                    }
                }]
            }],
            
            
            init: function init(props) {
                this._super(props);
                var lbl = {
                        scriptClass: 'mstrmojo.android.ui.Label',
                        slot: 'switchNode',
                        alias: 'lbl'
                    };
                if ( props.searchRequired) {
                    lbl.text = props.title;
                    lbl.cssClass = 'mstrmojo-no-Image';
                } else {
                    lbl.text = mstrmojo.desc(9462, 'View All');
                    lbl.touchTap = function () {
                        var menu = this.parent.menu,
                            show = !menu.visible;

                        
                        if (show) {
                            
                            menu.set('width', this.domNode.offsetWidth + 'px');
                        }

                        
                        menu.set('visible', show);
                    };
                }
                this.addChildren(lbl);
            },
            
            onRender: function onRender() {
                var initialSearch = this.initSearchValue,
                    id = this.id;

                
                if (initialSearch || this.searchRequired) {
                    
                    delete this.initSearchValue;

                    
                    window.setTimeout(function () {
                        
                        var bar = mstrmojo.all[id];
                        
                        toggleSearch.call(bar);

                        
                        var box = bar.search.box;
                        box.set('value', initialSearch || '');

                        
                        if (initialSearch) {
                            
                            box.onEnter();
                        }
                    }, 0);
                }

                return this._super();
            },

            goBack: function goBack() {
                
                if (this._isSearch) {
                    
                    if (canSearchClose.call(this)) {
                        
                        toggleSearch.call(this);

                        
                        return true;
                    }
                }

                
                return false;
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.ToolBar",
                         "mstrmojo.boxmodel",
                         "mstrmojo.array",
                         "mstrmojo.EnumRWUnitType",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var MOVE_FMTS = ['background-color',
                  'border',
                  'border-color',
                  'border-left',
                  'border-style',
                  'border-top',
                  'border-width',
                  'filter',
                  'top',
                  'left',
                  'z-index',
                  'fx',
                  'normWidth',
                  'normHeight',
                  'normZIndex',
                  'normTop',
                  'normLeft',
                  'tbborder',
                  'lrborder',
                  'ttl'],
        COPY_FMTS = ['width', 'height'],
        P_FMTS = 'p_fmts';

    var $PX = 'px';

    
    var ETS = {
        
        getContentHeight: function (h, f) {
            var th = f.ttl && f.ttl.height;
            if (h && th && !this.floatingToolbar) {
                
                return Math.max(parseInt(h, 10) - parseInt(th, 10), 0) + $PX;
            }

            return '';
        },

        getPortletMinHeight: function (f) {
            return f.ttl.height;
        },

        adjustTitleCss: function (ptlt) {
            return;
        }
    };

    
    var FTS = {
        getContentHeight: function (h, f) {
            return h;
        },
        getPortletMinHeight: function () {
            return 0;
        },
        adjustTitleCss: function (ptlt) {



            ptlt.titlebarNodeClass += ' floating';
            return;
        }
    };

    
    function passDirtyKey(method, key) {
        var parent = this.parent,
            methodName = method + 'DirtyKey';

        if (parent[methodName]) {
            parent[methodName](key);
        }
    }


    function updateTitle() {
        
        var title = this.title;

        
        if (this.count) {
            
            title += ' ' + this.count;
        }

        
        this.toolbarTitleTextNode.innerHTML = title;
    }

    function retrieveFilterPanel() {
        
        var parent = this.parent,
            parentDefn = parent && parent.defn;

        
        if (parentDefn && parseInt(parentDefn.t, 10) === mstrmojo.EnumRWUnitType.PANEL) {
            
            var panelStack = parent.parent,
                panelStackDefn = panelStack.defn;

            
            if (panelStackDefn && panelStackDefn.ifp) {
                
                return panelStack;
            }
        }

        return null;
    }

    var $HASH = mstrmojo.hash,
        ITEM_SPA = 2;

    mstrmojo.DocPortlet = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [mstrmojo._Formattable],

        
        {
            scriptClass: 'mstrmojo.DocPortlet',
            
            floatingTitle: false,
            
            floatingTitleHeight: 30,
            
            buttonWidth: 17,

            markupString:
                '<div class="mstrmojo-portlet {@borderCss}" style="{@portletNodeCssText}">' +
                    '<div class="mstrmojo-portlet-slot-shadow" style="{@shadowNodeCssText}"></div>' +
                    '<div class="mstrmojo-portlet-container" style="{@portletContainerNodeCssText}">' +
                        '<div class="mstrmojo-portlet-titlebar {@titlebarNodeClass}" style="{@titlebarNodeCssText}">' +
                            '<table style="height:100%;width:100%" class="mstrmojo-portlet-titlebar-table" cellspacing="0" cellpadding="0">' +
                            '<tr>' +
                                '<td class="mstrmojo-portlet-slot-toolbar-left {@leftToolbarNodeClass}" style="{@leftToolbarNodeCssText}"></td>' +
                                    '<td class="mstrmojo-portlet-title" style="{@titleNodeCssText}"><div style="overflow: hidden;">{@title} {@count}</div></td>' +
                                '<td class="mstrmojo-portlet-slot-toolbar {@toolbarNodeClass}" style="{@rightToolbarNodeCssText}"></td>' +
                                '</tr>' +
                            '</table>' +
                        '</div>' +
                        '<div class="mstrmojo-portlet-buttonbar {@buttonbarNodeClass}" style="{@buttonbarNodeCssText}"></div>' +
                        '<div class="mstrmojo-portlet-slot-content" style="{@contentNodeCssText}"></div>' + 
                    '</div>' +
                '</div>',

            rightToolbarNodeCssText: '',
            leftToolbarNodeCssText: '',
            titleNodeCssText: '',
            titlebarNodeClass: '',
            titlebarNodeCssText: '',
            contentNodeCssText: '',
            borderCss: 'no-border',
            buttonbarNodeClass: '',
            buttonbarNodeCssText: '',
            markupSlots: {
                containerNode: function () {return this.domNode.lastChild; }, 
                portletNode: function () {return this.domNode; },
                portletContainerNode: function () {return this.domNode.lastChild; },
                dimNode: function () {return this.domNode.lastChild; }, 
                shadowNode: function () { return this.domNode.firstChild; },
                titleNode: function () {return this.domNode.lastChild.childNodes[0]; },
                buttonbarNode: function() {return this.domNode.lastChild.childNodes[1];},
                toolbarNode: function () { return this.domNode.lastChild.firstChild.childNodes[0].rows[0].cells[2]; }, 
                toolbarTitleTextNode: function () { return this.domNode.lastChild.firstChild.childNodes[0].rows[0].cells[1].firstChild; },
                leftToolbarNode: function () { return this.domNode.lastChild.firstChild.childNodes[0].rows[0].cells[0]; },
                contentNode: function () { return this.domNode.lastChild.lastChild; }
            },

            markupMethods: {
                ontitleChange: function(){
                    updateTitle.call(this);
                },
                oncountChange: function () {
                    updateTitle.call(this);
                },
                onfcChange: function () {
                    if (this.fc && this.content) {
                        this.updateContentHeight();
                    }
                }
            },

            formatHandlers: {
                
                portletContainerNode: [ 'RW', 'B'], 
                shadowNode: [ 'RW', 'B', 'fx', 'background-color' ], 
                titlebarNode: {
                        src: 'ttl',
                        props: ['F', 'B', 'background-color', 'height', 'fx', 'text-align', 'vertical-align']
                    },
                titleNode : {
                    src: 'ttl',
                    props: ['vertical-align', 'P', 'text-decoration']
                },
                buttonbarNode: {
                     src: 'ttl',
                     props: ['background-color']
                }
            },

            
            fc: false, 

            
            content: null,
            
            rightToolbar: null,
            
            leftToolbar: null,
            
            floatingToolbar: false,
            
            _ts: ETS,
            
            getCacheKey: function getCacheKey(w){
                return this._super(w) + '-portlet';
            },
            
            getFormats: function getFormats() {
                var c = this.content,
                f = c && c.getFormats();

                return f && f[P_FMTS];
            },

            updateContentHeight: function updateContentHeight(bHide) {
                var pf = this.getFormats(),
                    cnt = this.content,
                    node = cnt.dimNode  || cnt.domNode,
                    h = ((pf.ttl && parseInt(pf.ttl.height, 10)) || 0);

                if (node){
                    if (!bHide) {
                        h += ((this.fc || this.isInFilterPanel()) ? node.offsetHeight : (pf.height ? parseInt(pf.height, 10) : 0));
                    }

                    this.containerNode.style.height = h + $PX;
                    this.shadowNode.style.height = h + $PX;
                }
            },


            
            init: function init(props) {
                
                this._super(props);

                var content = this.content;

                
                
                if (content && content.getFormats() && !this.getFormats()) {
                    
                    this._createFormats();
                }
            },

            
            preBuildRendering: function preBuildRendering() {
                
                var ts = this._ts = (this.floatingTitle) ? FTS : ETS;

                
                this._super();

                
                ts.adjustTitleCss(this);

                var displayNone = "display:none;";

                if (this.isInFilterPanel()) {
                    var f = $HASH.clone(this.formatHandlers);
                    f.portletContainerNode = ['z-index', 'height', 'B', 'backgroud-color'];
                    f.shadowNode = ['z-index', 'height', 'B', 'fx', 'background-color'];
                    this.formatHandlers = f;
                }

                if (!this.leftToolbar){
                    this.leftToolbarNodeCssText += displayNone;
                }

                if (!this.toolbar){
                    this.toolbarNodeCssText += displayNone;
                }

                
                var borderWidths = mstrmojo._Formattable.getBorderWidths(this);
                if (borderWidths.l || borderWidths.t || borderWidths.r) {
                    
                    this.borderCss = 'has-border';
                }
             },

            
            postBuildRendering: function postBuildRendering() {
                    
                    var dom = mstrmojo.dom,
                        css = mstrmojo.css,
                        d = this.contentNode,
                        t = this.titleNode,
                        me = this;

                if (this.titleNode) {
                    if (this.floatingTitle) {
                        
                        document.body.appendChild(this.titleNode);


                    if (!this._onhover){
                        
                        this._onhovertt = function() {
                            
                            css.addClass(me.titleNode, ['visible']);
                            me._onflt = true;
                            return true;
                        };
                        
                        this._onhoverofftt = function() {
                            css.removeClass(me.titleNode, ['visible']);
                            me._onflt = false;
                            return true;
                        };
                        
                        this._onhover = function () {
                            var t = me.titleNode;
                            
                            css.addClass(t, ['visible']);
                            
                            var p = dom.position(me.contentNode, true);
                            t.style.top = (p.y - t.clientHeight + 2) + $PX; 
                            t.style.left = p.x + $PX;
                            return true;
                        };
                        
                        this._onhoveroff = function () {
                            css.removeClass(me.titleNode, ['visible']);
                            return true;
                        };
                    }
                    dom.attachEvent(d, 'mouseover', this._onhover);
                    dom.attachEvent(d, 'mouseout', this._onhoveroff);
                    
                    dom.attachEvent(t, 'mouseover', this._onhovertt);
                    dom.attachEvent(t, 'mouseout', this._onhoverofftt);
                }

                    
                    if (this.attachContextMenuEvent) {
                        
                        this._oncontextmenu = function ( e,  hWin) {
                            var btn = me.rightToolbar && me.rightToolbar.btnMenu;

                            if (btn) {
                                btn.cmPos = dom.getMousePosition(e, hWin);
                                btn.openPopupMenu();
                                btn.cmPos = null;

                                dom.preventDefault(hWin, e);
                            }
                        };
                        dom.attachEvent(t, 'contextmenu', this._oncontextmenu);
                    }
                }

                if (this._super) {
                    this._super();
                }

                
                var pf = this.getFormats();
                this.set('fc', pf && !pf.height);

                if (this.isInFilterPanel() && !this.isHorizFP()) {
                    var portletContainerNodeStyle = this.portletContainerNode.style,
                        shadowNodeStyle = this.shadowNode.style,
                        parent = this.parent;
                    portletContainerNodeStyle.width = shadowNodeStyle.width = '99%';
                    portletContainerNodeStyle.top = shadowNodeStyle.top = parent.topStart + $PX;
                    portletContainerNodeStyle.left = shadowNodeStyle.left = ITEM_SPA + $PX;
                }
                
                else if (this.isInFilterPanel() && this.isHorizFP()) {
                    ITEM_SPA = 8;

                    this.portletContainerNode.style.left = this.shadowNode.style.left = parseInt(pf.left) + ITEM_SPA * this.orgPos + $PX;
                }
                
                else if (this.defn.ifp){
                	this.adjustFPHeight2Fit();
                }
            },
            adjustFPHeight2Fit: function(){
            	var dom = mstrmojo.dom,
            		ttl = dom.position(this.titleNode),
        			btn_h = dom.position(this.contentNode).y - ttl.y - ttl.h;
            	this.content.domNode.style.height = parseInt(this.defn.fmts.height) - btn_h + 'px';
            },
            
            unrender: function unrender(ignoreDom) {

                if (this.floatingTitle && this.titleNode) {
                    var d = this.domNode,
                        t = this.titleNode,
                    dom = mstrmojo.dom;

                    if (d && this._onhover){
                        dom.detachEvent(d, 'mouseover', this._onhover);
                    }
                    if (d && this._onhoveroff) {
                        dom.detachEvent(d, 'mouseout', this._onhoveroff);
                    }
                    
                    if (t && this._onhovertt) {
                        dom.detachEvent(t, 'mouseover', this._onhovertt);
                    }
                    if (t && this._onhoverofftt) {
                        dom.detachEvent(t, 'mouseout', this._onhoverofftt);
                    }
                    if (t && this._oncontextmenu) {
                        dom.detachEvent(t, 'contextmenu', this._oncontextmenu);
                    }

                    if(t) {
                        document.body.removeChild(t);
                    }
                }
                if (this._super) {
                    this._super(ignoreDom);
                }
            },

            updateStyle: function (h, w) {
                var snStyle = this.shadowNode.style,
                    cnStyle = this.containerNode.style;
                snStyle.height = cnStyle.height = h;
                snStyle.width = cnStyle.width = w;
            },

            
            _createFormats: function _createFormats() {
                var c_f = this.content && this.content.getFormats(),
                    f;
                
                f = c_f.p_fmts = {};
                var i, p;
                
                for (i in MOVE_FMTS) {
                    p = MOVE_FMTS[i];
                    if (p in c_f) {
                        f[p] = c_f[p];
                        delete c_f[p];
                    }
                }
                
                for (i in COPY_FMTS) {
                    p = COPY_FMTS[i];
                    if (p in c_f) {
                        f[p] = c_f[p];
                    }
                }
                

                
                c_f.height = this._ts.getContentHeight(c_f.height, f);

                
                
                if (mstrmojo.dom.isIE&&f.fx && f.fx.ds && !f['background-color']){
                    f['background-color'] = '#ffffff';
                }
            },

            
            refresh: function refresh() {
                if (!this.hasRendered) {
                    return;
                }

                
                var c = this.children,
                    i;
                for (i = c.length - 1; i >= 0; i--) {
                    c[i].refresh();
                }
                
                
                
            },

            isInFilterPanel: function isInFilterPanel() {
                return (retrieveFilterPanel.call(this) !== null);
            },

            isHorizFP: function(){
                if(this.isInFilterPanel()){
                    var fp = this.getFilterPanel();
                    return fp && fp.defn && fp.defn.fds == 2;
                }else{
                    return false;
                }
            },

            getFilterPanel: function getFilterPanel() {
                return retrieveFilterPanel.call(this);
            },

            getContainerHeight: function getContainerHeight() {
                return this.containerNode.clientHeight;
            },

            relocate: function relocate(top, width) {
                if (this.isInFilterPanel() && !this.isHorizFP()) {
                    this.portletContainerNode.style.top = this.shadowNode.style.top = top + $PX;
                }
            },

            
            setInfoWindowDimensions: function setInfoWindowDimensions(d) {
                var domNodeStyle = this.domNode.style,
                    shadowStyle = this.shadowNode.style,
                    containerStyle = this.portletContainerNode.style,
                    borderWidths = mstrmojo._Formattable.getBorderWidths(this);

                
                d.h -= borderWidths.h;
                d.w -= borderWidths.w;

                
                shadowStyle.height = containerStyle.height = domNodeStyle.height = d.h + $PX;
                shadowStyle.width = containerStyle.width = domNodeStyle.width = d.w + $PX;

                
                d.h -= this.titleNode.offsetHeight;

                
                this.toolbarNode.style.display = 'none';
            },

            
            addDirtyKey: function addDirtyKey(key) {
                passDirtyKey.call(this, 'add', key);
            },

            
            removeDirtyKey: function removeDirtyKey(key) {
                passDirtyKey.call(this, 'remove', key);
            },

            
            setDirtyChildren: function setDirtyChildren() {
                
                var contentChild = this.content;
                if (contentChild && contentChild.setDirtyChildren) {
                    
                    contentChild.setDirtyChildren.apply(contentChild, arguments);
                }
            }
        }
    );

    
    var ST_RESTORE = 0,
        ST_MIN = 1,
        ST_MAX = 2;

    
    function updateWindowState(v, oh, ow, evt) {

        
        var w = this.content,
            key = w.k,
            px = mstrmojo.boxmodel.px2Inches,
            m = w.model.docModel || w.model,
            f = this.getFormats(),
            callback = {},
            me = this,
            fnUpdateDS = function () {
                var defn = me.content && me.content.defn;
                if (defn) {
                    defn.set('ds', v);      
                }
            },
            propValues = {                  
                ZIndex: f['z-index'],
                WindowState: v
            },
            props = {};

        props[key] = propValues;

        
        if (oh !== undefined && ow !== undefined) {
            
            $HASH.copy({
                OldHeight: px(m, oh),
                OldWidth: px(m, ow),

                
                Height: px(m, parseInt(f.height, 10)),      
                Width: px(m, parseInt(f.width, 10))         
            }, propValues);

            
            callback.success = function (res) {
                
                var data = res && res.data;
                if (data) {
                    
                    w.model.loadPartialData(data, key);
                }

                
                fnUpdateDS();

                
                var p = me.parent;
                if ('adjustSectionSize' in p) {
                    
                    p.adjustSectionSize();
                }
            };

            
            m.saveRWProps(key, props, 1, this.loadDataOnResize, callback, true);

        } else {
            
            fnUpdateDS();
            if (!(evt && evt.all)) {
                m.saveRWProps(key, props, 1, this.loadDataOnResize, callback, true);
            }
        }

        return props;
    }

    
    function onWindowStateChange() {
        
        

        
        
        var content = this.content;
        if (!content) {
            
            
            return;
        }

        var fnUpdateBtnState = function (children) {
                
                mstrmojo.array.forEach(children, function (child) {
                    
                    if ('ds' in child) {
                        
                        child.set('visible', (child.ds !== content.defn.ds));
                    }
                });
            },
            toolbar;

        
        if (this.isInFilterPanel()) {

            
            var isRestore = (parseInt(this.defn.ds, 10) === ST_RESTORE);
            content.set('visible', isRestore);
            this.updateContentHeight(!isRestore);

            
            toolbar = this.leftToolbar;
            fnUpdateBtnState(toolbar && toolbar.children);

            
            var p = this.parent;
            if (p.refreshFP) {
                p.refreshFP();
            }

        } else {
            
            var c_f = content.getFormats(),                     
                p_f = this.getFormats(),                        
                ps = this.portletContainerNode.style,
                ss = this.shadowNode.style,
                cs = this.contentNode.firstChild.style;

            
            cs.height = c_f.height;
            cs.width = c_f.width;

            
            ss.height = ps.height = p_f.height;
            ss.width = ps.width = p_f.width;
            ss.top = ps.top = p_f.top;
            ss.left = ps.left = p_f.left;

            
            if ('z-index' in p_f) {
                
                ss.zIndex = ps.zIndex = p_f['z-index'];
            }

            
            toolbar = this.rightToolbar;
            fnUpdateBtnState(toolbar && toolbar.children);

            
            if (content.resize) {
                
                content.resize();
            }
        }
    }

    mstrmojo.DocResizablePortlet = mstrmojo.declare(
            
            mstrmojo.DocPortlet,

            
            null,

            
            {
                scriptClass : 'mstrmojo.DocResizablePortlet',

                
                loadDataOnResize: false,

                
            _createFormats: function _createFormats() {
                    
                    this._super();

                    var f = this.getFormats();

                    
                var ds = parseInt(this.defn.ds, 10);    

                    
                    
                    if (ds === ST_RESTORE) {
                        
                        f.normHeight = f.height;
                        f.normWidth = f.width;
                        if (f['z-index'] !== null && f['z-index'] !== undefined) {
                            f.normZIndex = f['z-index'];
                        }
                    }

                    
                    if (ds !== ST_MAX) {
                        f.normTop = f.top;
                        f.normLeft = f.left;
                    }
                },

                
            onmaximize: function onmaximize() {

                    var p = this.parent,
                        c = this.content,
                        c_f = c && c.getFormats(),
                        f = this.getFormats(),
                        oh = f.height,
                        ow = f.width,
                        bw = mstrmojo._Formattable.getBorderWidths(this);

                    this.clearCache();
                    c.clearCache();

                    
                f.height = (parseInt(p.height(), 10) - bw.h) + $PX;
                    
                    c_f.height = this._ts.getContentHeight(f.height, f);
                    
                f.width = c_f.width = (p.width() - bw.w) + $PX;
                    f.top = f.left = 0;
                    f['z-index'] = p.getMaxZIndex() + 1;

                    
                updateWindowState.call(this, ST_MAX, oh, ow);
                },
                
            onminimize: function onminimize() {

                    var c = this.content,
                    node = c.dimNode  || c.domNode,
                        c_f = c && c.getFormats(),
                        f = this.getFormats(),
                    oh = f.height || node.offsetHeight,
                        ow = f.width;

                    this.clearCache();
                    c.clearCache();

                    
                    f.width = c_f.width = f.normWidth;
                    
                    f.top = f.normTop;
                    
                    f.left = f.normLeft;
                    
                    if (f.normZIndex !== null && f.normZIndex !== undefined) {
                        f['z-index'] = f.normZIndex;
                    }

                    
                    c_f.height = 0;
                    
                    f.height = this._ts.getPortletMinHeight(f);

                    
                updateWindowState.call(this, ST_MIN, oh, ow);
                },
                
            onrestore: function onrestore() {

                    var c = this.content,
                        c_f = c && c.getFormats(),
                        f = this.getFormats(),
                        oh = f.height,
                        ow = f.width;

                    this.clearCache();
                    c.clearCache();

                    
                    f.height = f.normHeight;
                    
                    c_f.height = this._ts.getContentHeight(f.height, f);
                    
                    f.width = c_f.width = f.normWidth;
                    
                    f.top = f.normTop;
                    
                    f.left = f.normLeft;
                    
                    if (f.normZIndex !== null && f.normZIndex !== undefined) {
                        f['z-index'] = f.normZIndex;
                    }

                    
                updateWindowState.call(this, ST_RESTORE, oh, ow);
                },
                
            oncollapse: function oncollapse(evt) {
                return updateWindowState.call(this, ST_MIN, undefined, undefined, evt);
            },
            
            onexpand: function onexpand(evt) {
                
                return updateWindowState.call(this, ST_RESTORE, undefined, undefined, evt);
            },

                
                postBuildRendering: function postBuildRendering() {
                    
                    if (!this._sub_dsChange) {
                    this._sub_dsChange = this.defn.attachEventListener('dsChange', this.id, onWindowStateChange);
                    }

                    this._super();

                    
                    
                    if (this.isInFilterPanel()) {
                    
                    var isRestore = (parseInt(this.defn.ds, 10) === ST_RESTORE);
                	this.updateContentHeight(!isRestore);
                    }
                }
            }
        );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.SliderBox",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.ui.MobileSlider",
                         "mstrmojo.num");

    var INPUT_VALUES_MANUAL = 1,
        $NUM = mstrmojo.num;

    mstrmojo.android.inputControls.SliderDIC = mstrmojo.declare(
        mstrmojo.SliderBox,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: "mstrmojo.android.inputControls.SliderDIC",

            popupStyle: 1,

            init: function init(props) {
                
                
                var sbMin, sbMax, sbItv, sb;

                this._super(props);
                this.items = this.getItems();

                this.cssClass = this.showByDefault ? 'mstrmojo-SliderGroup' : 'mstrmojo-PopupSlider';

                if (this.dic.ipt !== INPUT_VALUES_MANUAL) {
                    this.isSequential = true;
                    sbMax = this.max = this.dic.max;
                    sbMin = this.min = this.dic.min;
                    sbItv = this.interval = this.dic.itv;
                } else {
                    sbMin = 1;
                    sbMax = this.items.length;
                    sbItv = 1;
                }

                sb = this.sliderBar;
                if (sb) {
                    sb.min = sbMin;
                    sb.max = sbMax;
                    sb.interval = sbItv;
                }
            },

            preBuildRendering: function preBuildRendering() {
                
                var dic = this.dic,
                    ldw = (dic.ldw != null) ? dic.ldw / 100 : 0.4,
                    os;

                this.valueText = this.dv;
                this._super();

                
                if (this.showByDefault) {
                    
                    
                    os = this.openerStyle;
                    
                    this.valueCssText = 'left:-' + os.iw * ldw + 'px;width:' + os.iw * ldw + 'px';
                    this.cssText = 'width:' + os.iw * (1 - ldw) + 'px';

                    this.alignSlider(this.openerNode, os.ih);
                }
            },

            onpopupResized: function onpopupResized() {
                var sb = this.sliderBar;
                if (sb) {
                    sb.refresh();
                }
            },

            
            sliderRef: {
                scriptClass: "mstrmojo.ui.MobileSlider",
                onslidingValueChange: function () {
                    if (this.hasRendered) {
                        this.selectedIdx = parseInt((this.slidingValue - this.min) / this.interval, 10) || 0;
                        this.parent.selectedIdxChanged(this.selectedIdx);
                    }
                },
                
                selectedIdx: 0,
                
                select: function (v) {
                    this.selectedIdx = v || 0;
                    this.slidingValue = this.value = this.min + v * this.interval;
                }
            },

            
            selectedIdxChanged: function selectedIdxChanged(v) {
                var item = this.items[v],
                    sv = item && item.n;
                
                this.set('value', $NUM.toLocaleString(sv));
                this.set('valueText', $NUM.toLocaleString(sv));
            }
        }
    );
}());

(function () {
    mstrmojo.requiresCls("mstrmojo.graph._MobileGraphAreaHelper",
                         "mstrmojo.GraphBase",
                         "mstrmojo.dom");

    
    var ANIMATION_DURATION = 0,
        INITIAL_TIME = 0,
        
        InsUndefined = 0,
        InsSaveState = 1,
        InsRestoreState = 2,
        InsClip = 11,
        InsScale = 12,
        InsRotate = 13,
        InsNewPath = 101,
        InsClosePath = 102,
        InsMoveTo = 111,
        InsLineTo = 112,
        InsBezierCurveTo = 113,
        InsAddRect = 121,
        InsAddArc = 122,
        InsAddNeedle = 131,
        InsAddGaugeMarker = 132,
        InsAddString = 201,
        InsSetLineDash = 301,
        InsSetLineWidth = 302,
        InsSetLineJoin = 303,
        InsSetFontSize = 311,
        InsSetRGBAFillColor = 321,
        InsSetRGBAStrokeColor = 322,
        InsFillPath = 401,
        InsStrokePath = 402,
        InsFillSimple = 501,
        InsFillPattern = 502,
        InsFillGradient = 503,
        InsFillEdgeType = 511,
        InsFillDonutOrSphere= 512,
        InsFillRadientGradient = 513,
        InsFillDonut2Rect= 514,
        InsFillBorderMetallic = 515,
        InsMakeDarker = 521,
        InsRestoreColor = 522,
        InsApplyLineFormat = 601,
        InsAddFormatedText = 701,
        InsApplyBeveledFrameToRectangle = 801;
    var GradientReserved = 0,
        GradientCircular = 9,
        GradientRectangular = 10,
        GradientLinear = 14;
    var FillBevelNone = 0,
        FillBevelSmoothEdge = 1,
        FillBevelChiselEdge = 2,
        FillBevelDonut = 3,
        FillBevelSphere = 4;
    var RGPieSlice = 0,
        RGRing = 1,
        RG_BORDERRING = 2;
    var BSS_METALLIC_OUTER_RING = 2,
        BSS_METALLIC_MIDDLE_RING = 3;
    var FillSimple = 0,
        FillWash = 3,
        FillPicture = 4,
        FillUserPicture = 6,
        FillBrush = 13,
        FillAdvancedWash = 14,
        FillPattern = 101;
    var LineJoinMiter = 0,
        LineJoinBevel = 1,
        LineJoinRound = 2;
    var PI = 3.14159265;
    var startPoint,endPoint;
    var MS_Rectangle = 0,
        MS_XShape = 1,
        MS_PlusSymbolthin = 2,
        MS_PlusSymbolthick = 3,
        MS_Circle = 4,
        MS_Diamond = 5,
        MS_Triangle = 6,
        MS_Square = 7,
        MS_Star = 8,
        MS_Area = 9;
    var gLocalMarkerSize = 100;
    var gMarkerShapes = [
        [-100, -100, 100, -100, 100, 100, -100, 100],
        [-80, -100, 0, -20, 80, -100, 100, -80, 20, 0, 100, 80, 80, 100, 0, 20, -80, 100, -100, 80, -20, 0, -100, -80],
        [-33, -100, 33, -100, 33, -33, 100, -33, 100, 33, 33, 33, 33, 100, -33, 100, -33, 33, -100, 33, -100, -33, -33, -33],
        [-50, -100, 50, -100, 50, -50, 100, -50, 100, 50, 50, 50, 50, 100, -50, 100, -50, 50, -100, 50, -100, -50, -50, -50],
        [],
        [0, -100, 100, 0, 0, 100, -100, 0],
        [0, -100, 100, 100, -100, 100],
        [-100, -100, 100, -100, 100, 100, -100, 100],
        [0, -100, 23, -31, 95, -31, 36, 12, 59, 81, 0, 38, -59, 81, -36, 12, -95, -31, -23, -31],
        [0, -60, 100, -100, 100, 100, -100, 100, -100, -100, 0, -60, 0, 100]
    ];

    function drawWithContext(context, progress, unit, formatList){
        var insList = unit.InstructionList,
            insCount = insList.length,
            ins, j, x, y, h, w, format, color, formatIndex,
            gradient, startColor, endColor,
            rect, finalGradient, bevel, isCircularShape, darker;

        for (j = 0; j < insCount; j++)
        {
            
            ins = insList[j];

            
            if (typeof(ins) === 'undefined') {
                
                continue;
            }

            
            switch (ins.Ins) {
                case InsUndefined:
                    
                    break;
                case InsSaveState:
                    context.save();
                    break;
                case InsRestoreState:
                    context.restore();
                    break;
                case InsClip:
                    context.clip();
                    break;
                case InsScale:
                    context.scale(ins.X, ins.Y);
                    break;
                case InsRotate:
                    if (ins.Radian !== 0) {
                        context.translate(ins.Anchor.X, ins.Anchor.Y);
                        context.rotate(ins.Radian);
                        context.translate(-ins.Anchor.X, -ins.Anchor.Y);
                    }
                    break;
                case InsNewPath:
                    context.beginPath();
                    break;
                case InsClosePath:
                    context.closePath();
                    break;
                case InsMoveTo:
                    if (unit.IsAnimated === 0) {
                        context.moveTo(ins.X, ins.Y);
                    } else {
                        if (ins.CA[0] == 0) {
                            x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                            y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                            context.moveTo(x, y);
                        } else {
                            var r1 = Math.sqrt((ins.X[0]-ins.BPX[0])*(ins.X[0]-ins.BPX[0]) + (ins.Y[0]-ins.BPY[0])*(ins.Y[0]-ins.BPY[0]));
                            var r2 = Math.sqrt((ins.X[1]-ins.BPX[0])*(ins.X[1]-ins.BPX[0]) + (ins.Y[1]-ins.BPY[0])*(ins.Y[1]-ins.BPY[0]));
                            var d = Math.sqrt((ins.X[0]-ins.X[1])*(ins.X[0]-ins.X[1]) + (ins.Y[0]-ins.Y[1])*(ins.Y[0]-ins.Y[1]));
                            var de = Math.acos((r1*r1+r2*r2-d*d)/(2*r1*r2));

                            
                            var lDest = (ins.X[0]-ins.BPX[0]) * Math.cos(de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(de) + ins.BPX[0] - ins.X[1];
                            if (lDest < -0.01 || lDest > 0.01)
                                de = 2*PI - de;

                            x = (ins.X[0]-ins.BPX[0]) * Math.cos(progress*de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(progress*de) + ins.BPX[0];
                            y = (ins.Y[0]-ins.BPY[0]) * Math.cos(progress*de) + (ins.X[0]-ins.BPX[0]) * Math.sin(progress*de) + ins.BPY[0];
                            context.moveTo(x, y);
                        }
                    }
                    break;
                case InsLineTo:
                    if (unit.IsAnimated === 0) {
                        context.lineTo(ins.X, ins.Y);
                    } else {
                        if (ins.CA[0] == 0) {
                            x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                            y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                            context.lineTo(x, y);
                        } else {
                            var r1 = Math.sqrt((ins.X[0]-ins.BPX[0])*(ins.X[0]-ins.BPX[0]) + (ins.Y[0]-ins.BPY[0])*(ins.Y[0]-ins.BPY[0]));
                            var r2 = Math.sqrt((ins.X[1]-ins.BPX[0])*(ins.X[1]-ins.BPX[0]) + (ins.Y[1]-ins.BPY[0])*(ins.Y[1]-ins.BPY[0]));
                            var d = Math.sqrt((ins.X[0]-ins.X[1])*(ins.X[0]-ins.X[1]) + (ins.Y[0]-ins.Y[1])*(ins.Y[0]-ins.Y[1]));
                            var de = Math.acos((r1*r1+r2*r2-d*d)/(2*r1*r2));
                            
                            
                            var lDest = (ins.X[0]-ins.BPX[0]) * Math.cos(de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(de) + ins.BPX[0] - ins.X[1];
                            if (lDest < -0.02 || lDest > 0.02)
                                de = 2*PI - de;
                                
                            x = (ins.X[0]-ins.BPX[0]) * Math.cos(progress*de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(progress*de) + ins.BPX[0];
                            y = (ins.Y[0]-ins.BPY[0]) * Math.cos(progress*de) + (ins.X[0]-ins.BPX[0]) * Math.sin(progress*de) + ins.BPY[0];
                            context.lineTo(x, y);
                        }
                    }
                    break;
                case InsBezierCurveTo:
                    if (unit.IsAnimated === 0) {
                        context.bezierCurveTo(ins.CP1X, ins.CP1Y, ins.CP2X, ins.CP2Y, ins.X, ins.Y);
                    } else {
                        cp1x = ins.CP1X[0] * (1 - progress) + ins.CP1X[1] * progress;
                        cp1y = ins.CP1Y[0] * (1 - progress) + ins.CP1Y[1] * progress;
                        cp2x = ins.CP2X[0] * (1 - progress) + ins.CP2X[1] * progress;
                        cp2y = ins.CP2Y[0] * (1 - progress) + ins.CP2Y[1] * progress;
                        x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                        y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                        context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                    }
                    break;
                case InsAddRect:
                    if (unit.IsAnimated === 0) {
                        context.rect(ins.X, ins.Y, ins.W, ins.H);
                    } else {
                        x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                        y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                        w = ins.W[0] * (1 - progress) + ins.W[1] * progress;
                        h = ins.H[0] * (1 - progress) + ins.H[1] * progress;
                        context.rect(x, y, w, h);
                    }
                    break;
                case InsAddArc:
                    if (unit.IsAnimated === 0) {
                        if (ins.EndAngle == 6.283) 
                         ins.EndAngle = 2*PI;
                        context.arc(ins.X, ins.Y, ins.Radius, ins.StartAngle, ins.EndAngle, ins.AntiClockwise);
                    } else {
                        if (ins.EndAngle[0] == 6.283) 
                         ins.EndAngle[0] = 2*PI;
                        if (ins.EndAngle[1] == 6.283) 
                         ins.EndAngle[1] = 2*PI;

                        context.arc(ins.X[0] * (1 - progress) + ins.X[1] * progress,
                                    ins.Y[0] * (1 - progress) + ins.Y[1] * progress,
                                    ins.Radius[0] * (1 - progress) + ins.Radius[1] * progress,
                                    ins.StartAngle[0] * (1 - progress) + ins.StartAngle[1] * progress,
                                    ins.EndAngle[0] * (1 - progress) + ins.EndAngle[1] * progress,
                                    ins.AntiClockwise[0]);
                    }
                    break;
                case InsAddGaugeMarker:
                    if (unit.IsAnimated == 1)
                    {
                        var angle = ins.Angle[0] * (1 - progress) + ins.Angle[1] * progress;
                        var lSize = ins.NeedleSize[0];
                        var bPX = ins.BPX[0];
                        var bPY = ins.BPY[0];
                        var markerSize = ins.MarkSize[0];
                        var markerShape = ins.MarkShape[0];

                        var lMarkerPostion = {X:lSize*Math.cos(angle)+bPX, Y:lSize*Math.sin(angle)*-1+bPY};
                        var lPolygon = hGetClockwisePolygon(markerShape, lMarkerPostion, markerSize);
                        hDrawPolygon(context, lPolygon, false, false);
                        
                    }
                    break;
                case InsAddString:
                case InsSetLineDash:
                    
                    break;

                case InsSetLineWidth:
                    context.lineWidth = ins.LineWidth;
                    break;

                case InsSetLineJoin:
                    switch(ins.Type)
                    {
                    case LineJoinMiter:
                        context.lineJoin = 'miter';
                        break;
                    case LineJoinBevel:
                        context.lineJoin = 'bevel';
                        break;
                    case LineJoinRound:
                        context.lineJoin = 'round';
                        break;
                    }
                    break;
                case InsSetFontSize:
                case InsSetRGBAFillColor:
                case InsSetRGBAStrokeColor:
                    
                    break;

                case InsFillPath:
                    context.fill();
                    break;

                case InsStrokePath:
                    context.stroke();
                    break;

                case InsFillSimple:
                    formatIndex = ins.Format;
                    format = formatList[formatIndex];
                    if(ins.HEP == 1)
                      color = ins.FC;
                    else
                        color = format.SimpleColor;
                    context.fillStyle = "RGBA(" + Math.round(color.R * ins.DarkerFactor) + ", " + Math.round(color.G * ins.DarkerFactor) + ", " + Math.round(color.B * ins.DarkerFactor) + ", " + format.Alpha / 255.0 + ");";
                    context.fill();
                    break;

                case InsFillPattern:
                    break;
                case InsFillGradient:
                    if (unit.IsAnimated === 0) {
                        rect = ins.BoundingRect;
                        darker = ins.DarkerFactor;
                    }
                    else {
                        rect = ins.BoundingRect[0];
                        darker = ins.DarkerFactor[0];
                        var rect2 = ins.BoundingRect[1];
                        rect.X = rect.X * (1-progress) + rect2.X * progress;
                        rect.Y = rect.Y * (1-progress) + rect2.Y * progress;
                        rect.Width = rect.Width * (1-progress) + rect2.Width * progress;
                        rect.Height = rect.Height * (1-progress) + rect2.Height * progress;
                    }
                    if (rect.Width < 1 || rect.Height < 1)
                        continue;

                    rect.Width = Math.floor(rect.Width);
                    rect.Height = Math.floor(rect.Height);

                    var format = formatList[ins.Format];
                    
                    
                    if (format.Bevel.FillBevelType != FillBevelSphere || progress < 1)
                    {
                        fillGradient(context, format, rect, darker);
                    }
                    else
                    {
                        
                        addCompensativeLayer(context, format);
                        
                        
                        
                        fillGradient(context, format, rect, darker);
                        
                    }

                    break;
                case InsFillEdgeType:
                    
                    format = formatList[ins.Format];
                    bevel = format.Bevel;

                    lPolygon = hRemoveZeroEdgeInPolygon(ins.Polygon);

                    var lInitialPolygonSize = lPolygon.length;
                    var lInitialPolygon = [];
                    for (var i = 0; i < lInitialPolygonSize; i++)
                        lInitialPolygon.push(lPolygon[i]);

                    while(true)
                    {
                        lInitialPolygonSize = lInitialPolygon.length;
                        if (lInitialPolygonSize < 3)
                            break;

                        var lFirstPolygon = [];
                        var lSecondPolygon = [];
                        var lDivided = false;
                        if(lInitialPolygonSize > 3)
                        {
                            var lIntersectionPoint = { X:0, Y:0 };

                            for(var i = 0; ((i < (lInitialPolygonSize - 2)) && (!lDivided)); ++i)
                            {
                                for(var k = i + 2; k < (lInitialPolygonSize - 1); ++k)
                                {
                                    var rt = hLineInterSection(lInitialPolygon[i], lInitialPolygon[i+1], lInitialPolygon[k], lInitialPolygon[k+1], lIntersectionPoint, false);
                                    lIntersectionPoint = rt.interSection;
                                    if(rt.val == 1)
                                    {
                                        lDivided = true;
                                        
                                        for(m = 0; m <= i; ++m)
                                        {
                                            if (!hIsFPointsEqual(lInitialPolygon[m], lIntersectionPoint))
                                                lFirstPolygon.push(lInitialPolygon[m]);
                                        }
                                        lFirstPolygon.push(lIntersectionPoint);
                                        for(m = k + 1; m < lInitialPolygonSize; ++m)
                                        {
                                            if (!hIsFPointsEqual(lInitialPolygon[m], lIntersectionPoint))
                                                lFirstPolygon.push(lInitialPolygon[m]);
                                        }
                                        
                                        lSecondPolygon.push(lIntersectionPoint);
                                        for(m = k; m > i; --m)
                                        {
                                            if (!hIsFPointsEqual(lInitialPolygon[m], lIntersectionPoint))
                                                lSecondPolygon.push(lInitialPolygon[m]);
                                        }
                                        break;
                                    }
                                }

                                
                                if((i != 0) && (!lDivided))
                                {
                                    var rt = hLineInterSection(lInitialPolygon[i], lInitialPolygon[i+1], lInitialPolygon[0], lInitialPolygon[lInitialPolygonSize-1], lIntersectionPoint, false);
                                    lIntersectionPoint = rt.interSection;
                                    if(rt.val == 1)
                                    {
                                        for(m = 0; m <= i; ++m)
                                            lFirstPolygon.push(lInitialPolygon[m]);
                                        lFirstPolygon.push(lIntersectionPoint);
                                        
                                        lSecondPolygon.push(lIntersectionPoint);
                                        for(m = lInitialPolygonSize - 1; m > i; --m)
                                            lSecondPolygon.push(lInitialPolygon[m]);
                                        lDivided = true;
                                    }
                                }
                            }
                        }

                        if(!lDivided)
                            lFirstPolygon = lInitialPolygon;

                        
                        var lDepth = 0.0;
                        var lRt = hGetAreaDepth(lFirstPolygon, lDepth);
                        lDepth = lRt.depth;
                        if (!lRt.mark)
                            break;
                        lDepth *= bevel.Depth * 0.01;
                        
                        var lNormalStart = [];
                        var lNormalEnd = [];
                        var lFirstPolygonSize = lFirstPolygon.length;
                        for(var i = 0; i < lFirstPolygonSize; ++i)
                        {
                            var lPointStart;
                            var lPointEnd;
                            var lRt = hGetAngularBisectorIntersectionPoint(lFirstPolygon[(i+lFirstPolygonSize-1) % lFirstPolygonSize], lFirstPolygon[i],
                                        lFirstPolygon[(i+1) % lFirstPolygonSize], lDepth);
                            lPointStart = lRt.start;
                            lPointEnd = lRt.end;

                            lNormalStart.push(lPointStart);
                            lNormalEnd.push(lPointEnd);
                        }

                        
                        
                        for(var i = 0; i < lFirstPolygonSize; ++i)
                        {
                            var lVectorNormalLine = {X:lNormalEnd[i].X - lNormalStart[i].X, Y:lNormalEnd[i].Y - lNormalStart[i].Y};
                            var lLengthNormalLine = Math.sqrt(hLengthSquared(lVectorNormalLine));
                            var lVectorUnitNormalLine = {X:lVectorNormalLine.X / lLengthNormalLine, Y:lVectorNormalLine.Y / lLengthNormalLine};
                            
                            var lAngleReflectedLight = degreeToRadian((540 - bevel.LightAngle) % 360);
                            var lVectorUnitLight = {X:Math.cos(lAngleReflectedLight), Y:Math.sin(lAngleReflectedLight)};
                            var lTemp = hInnerProduct(lVectorUnitNormalLine, lVectorUnitLight);

                            var lColorRGB = 0.0;
                            var lTransparency = 0.0;
                            
                            var lFactor = 0.1;
                            var lTransparencyFactor = 0.2;
                            if(lTemp < -0.01)
                            {
                                lColorRGB = (1.0 + lTemp) * lFactor;
                                lTransparency = (1.0 + Math.abs(lTemp)) * lTransparencyFactor * bevel.Intensity * 0.01;
                            }
                            else
                            {
                                lColorRGB = (1.0 - lFactor) + lTemp * lFactor;
                                lTransparency = ((1.0 - lTransparencyFactor) + lTemp * lTransparencyFactor) * bevel.Intensity * 0.01;
                            }
                            var lNext = i + 1;
                            if(lNext == lFirstPolygonSize)
                                lNext -= lFirstPolygonSize;

                            context.beginPath();
                            context.moveTo(lFirstPolygon[i].X, lFirstPolygon[i].Y);
                            context.lineTo(lFirstPolygon[lNext].X, lFirstPolygon[lNext].Y);
                            context.lineTo(lNormalStart[lNext].X, lNormalStart[lNext].Y);
                            context.lineTo(lNormalStart[i].X, lNormalStart[i].Y);
                            context.closePath();

                            var R = Math.round(lColorRGB*255);
                            if (isNaN(R))  
                                continue;

                            if(bevel.FillBevelType == FillBevelSmoothEdge)
                            {
                                context.save();
                                context.clip();
                                var lLinearGrad = context.createLinearGradient(lNormalEnd[i].X, lNormalEnd[i].Y, lNormalStart[i].X, lNormalStart[i].Y);


                                lLinearGrad.addColorStop(0, 'rgba(' + R + ',' + R +',' + R +',' + lTransparency + ')');
                                lLinearGrad.addColorStop(1, 'rgba(' + R + ',' + R +',' + R +',' + 0 + ')');

                                 context.fillStyle = lLinearGrad;
                                 context.fill();
                                 context.restore();
                            }
                            else
                            {
                                context.fillStyle = "RGBA(" + R + ", " + R + ", " + R + ", " + lTransparency + ");";
                                context.fill();
                            }


                        }
                        if(lDivided)
                        {
                            lInitialPolygon = lSecondPolygon;
                        }
                        else
                            break;
                    }

                    
                    if (lPolygon.length != 0)
                    {
                        context.beginPath();
                        context.moveTo(lPolygon[0].X, lPolygon[0].Y);
                        for (var i = 1; i < lPolygon.length; ++i)
                        {
                            context.lineTo(lPolygon[i].X, lPolygon[i].Y);
                        }
                        context.closePath();
                    }
                    break;
                case InsFillDonutOrSphere:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;
                    if (unit.IsAnimated === 0) {
                        rect = ins.BoundingRect;
                        isCircularShape = ins.IsCircularShape;
                    }
                    else {
                        var rect1 = ins.BoundingRect[0];
                        var rect2 = ins.BoundingRect[1];
                        rect = {X : 0, Y : 0, Width:0, Height:0};
                        rect.X = rect1.X * (1-progress) + rect2.X * progress;
                        rect.Y = rect1.Y * (1-progress) + rect2.Y * progress;
                        rect.Width = rect1.Width * (1-progress) + rect2.Width * progress;
                        rect.Height = rect1.Height * (1-progress) + rect2.Height * progress;

                    }

                    if (bevel.FillBevelType === FillBevelDonut)
                    {
                        var factor = 0.2;
                        var lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                        var lStop = 1.0 - bevel.Depth * 0.01;

                        finalGradient = context.createLinearGradient(rect.X, rect.Y, rect.X + rect.Width, rect.Y);

                        startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                        endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                        finalGradient.addColorStop(0, startColor);
                        finalGradient.addColorStop(lStop * factor, startColor);
                        finalGradient.addColorStop(lStop, endColor);
                        finalGradient.addColorStop(1, startColor);
                    }
                    else
                    {
                        startColor = format.SimpleColor;
                        var lCenterPoint = {x: rect.X + rect.Width / 2, y : rect.Y + rect.Height / 2};

                        startPoint = {x : 0, y : 0};
                        endPoint = {x : 0, y : 0};
                        hRatioInRectangle(rect, bevel.LightAngle, lCenterPoint); 

                        var lFillAlpha = format.Alpha / 255.0;
                        var lNewAlpha = lFillAlpha;
                        if (format.FillType != FillSimple)
                        {
                            lFillAlpha *= 0.8;
                            lNewAlpha *= 0.5;
                            startColor = {R : 128, G : 128, B : 128};
                        }

                        var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                        lLinearGrad.addColorStop(0, 'rgba(255,255,255,' + lFillAlpha + ')');
                        lLinearGrad.addColorStop(0.05 + bevel.Intensity * 0.001, 'rgba(255,255,255,' + 9 * lFillAlpha / (10 - lFillAlpha) + ')');
                        lLinearGrad.addColorStop(0.5, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lNewAlpha + ')');
                        lLinearGrad.addColorStop(0.85 + (1.0 - bevel.Intensity * 0.01) * 0.05, 'rgba(0,0,0,' + 9 * lFillAlpha / (10 - lFillAlpha) + ')');
                        lLinearGrad.addColorStop(1, 'rgba(0,0,0,' + lFillAlpha + ')');

                        context.fillStyle = lLinearGrad;
                        context.fill();

                        if (format.FillType != FillSimple)
                            continue;

                        var lRadius = Math.max(rect.Width, rect.Height) * 0.5 * (2.0 - bevel.Intensity * 0.01);
                        lRadius *= isCircularShape ? 0.75 : 2;

                        
                        finalGradient = context.createRadialGradient(lCenterPoint.x, lCenterPoint.y, 0, lCenterPoint.x, lCenterPoint.y, lRadius);

                        finalGradient.addColorStop(0, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lFillAlpha + ')');
                        finalGradient.addColorStop(0.5, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lFillAlpha / 2 + ')');
                        finalGradient.addColorStop(0.8, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lFillAlpha / 10 + ')');
                        finalGradient.addColorStop(1, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',0)');
                    }
                    context.fillStyle = finalGradient;
                    context.fill();

                    break;
                case InsFillBorderMetallic:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;

                    var CX = ins.CX;
                    var CY = ins.CY;
                    var mRadius = ins.Radius;
                    var lRadius;
                    var lAlpha;

                    switch(ins.BorderUse)
                    {
                        case BSS_METALLIC_OUTER_RING:
                            lAlpha = 0.4;
                            startPoint = {x : CX + mRadius * Math.cos(PI * 1.25), y : CY + mRadius * Math.sin(PI * 1.25)};
                            endPoint = {x : CX + mRadius * Math.cos(PI * 0.25), y : CY + mRadius * Math.sin(PI * 0.25)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(0,0,0,' + lAlpha + ')');
                            lLinearGrad.addColorStop(1, 'rgba(255,255,255,' + lAlpha + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();

                            lAlpha = 0.4;
                            lRadius = mRadius * 0.3;
                            color = format.SimpleColor;
                            startPoint = {x : CX + lRadius * Math.cos(PI * 0.75), y : CY + lRadius * Math.sin(PI * 0.75)};
                            endPoint = {x : CX + lRadius * Math.cos(PI * 1.75), y : CY + lRadius * Math.sin(PI * 1.75)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 0.0 + ')');
                            lLinearGrad.addColorStop(0.2, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 1.0 + ')');
                            lLinearGrad.addColorStop(0.8, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 1.0 + ')');
                            lLinearGrad.addColorStop(1, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 0.0 + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();
                            break;
                        case BSS_METALLIC_MIDDLE_RING:
                            lAlpha = 0.6;
                            lRadius = mRadius* 0.2;
                            var lStop = 0.3;
                            startPoint = {x : CX + lRadius * Math.cos(PI * 1.25), y : CY + lRadius * Math.sin(PI * 1.25)};
                            endPoint = {x : CX + mRadius * Math.cos(PI * 0.25), y : CY + mRadius * Math.sin(PI * 0.25)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(255,255,255,' + lAlpha + ')');
                            lLinearGrad.addColorStop(lStop, 'rgba(0,0,0,' + lAlpha + ')');
                            lLinearGrad.addColorStop(1, 'rgba(255,255,255,' + lAlpha + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();
                            break;
                        default:
                            lAlpha = 0.4;
                            lRadius = mRadius- ins.Thickness;
                            startPoint = {x : CX + lRadius * Math.cos(PI * 1.25), y : CY + lRadius * Math.sin(PI * 1.25)};
                            endPoint = {x : CX + lRadius * Math.cos(PI * 0.25), y : CY + lRadius * Math.sin(PI * 0.25)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(0,0,0,' + lAlpha + ')');
                            lLinearGrad.addColorStop(1, 'rgba(255,255,255,' + lAlpha + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();
                            break;
                    }
                    break;
                case InsFillRadientGradient:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;

                    var lAlpha;
                    var lStop;
                    var CX;
                    var CY;
                    var innerRadius;
                    var outerRadius;
                    var lUsage;
                    var lExtraPara;
                    var lExtraDepth;
                    var lExtraIntensity;

                    if (unit.IsAnimated === 0) {
                        CX = ins.CX;
                        CY = ins.CY;
                        innerRadius = ins.InnerRadius;
                        outerRadius = ins.OuterRadius;
                        lUsage = ins.RGUsage;
                        lExtraPara = ins.HEP;
                        if (lExtraPara == 1)
                        {
                            lExtraDepth = ins.ExtraDepth;
                            lExtraIntensity = ins.ExtraIntensity;
                        }
                    } else {
                        CX = ins.CX[0] * (1 - progress) + ins.CX[1] * progress;
                        CY = ins.CY[0] * (1 - progress) + ins.CY[1] * progress;
                        innerRadius = ins.InnerRadius[0];
                        outerRadius = ins.OuterRadius[0];
                        lUsage = ins.RGUsage[0];
                        lExtraPara = ins.HEP[0];
                        if (lExtraPara == 1)
                        {
                            lExtraDepth = ins.ExtraDepth[0];
                            lExtraIntensity = ins.ExtraIntensity[0];
                        }
                    }

                    switch(lUsage)
                    {
                        case RGPieSlice:
                            lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                            lStop = 1.0 - bevel.Depth * 0.01;
                            finalGradient = context.createRadialGradient(CX, CY, innerRadius, CX, CY, outerRadius);
                            startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                            endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                            finalGradient.addColorStop(0, startColor);
                            finalGradient.addColorStop(lStop, endColor);
                            finalGradient.addColorStop(1, startColor);

                            context.fillStyle = finalGradient;
                            context.fill();
                            break;
                        case RGRing:
                            lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                            finalGradient = context.createRadialGradient(CX, CY, innerRadius, CX, CY, outerRadius);
                            startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                            endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                            finalGradient.addColorStop(0, startColor);
                            finalGradient.addColorStop(1, endColor);

                            context.fillStyle = finalGradient;
                            context.fill();
                            break;
                        case RG_BORDERRING:
                            if (lExtraPara == 0)
                            {
                                lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                                lStop = bevel.Depth * 0.01;
                            }
                            else
                            {
                                lAlpha = lExtraIntensity * 0.01 * format.Alpha / 255.0;
                                lStop = lExtraDepth * 0.01;
                            }
                            finalGradient = context.createRadialGradient(CX, CY, innerRadius, CX, CY, outerRadius);
                            startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                            endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                            finalGradient.addColorStop(0, startColor);
                            finalGradient.addColorStop(lStop, endColor);
                            finalGradient.addColorStop(1, startColor);

                            context.fillStyle = finalGradient;
                            context.fill();
                            break;
                    }
                    break;
                case InsFillDonut2Rect:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;
                    lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                    lStop = 1.0 - bevel.Depth * 0.01;

                    startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                    endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                    finalGradient = context.createLinearGradient(ins.StartPoint.X, ins.StartPoint.Y, ins.EndPoint.X, ins.EndPoint.Y);
                    finalGradient.addColorStop(0, startColor);
                    finalGradient.addColorStop(lStop, endColor);
                    finalGradient.addColorStop(1, startColor);

                    context.save();
                    context.clip();
                    context.fillStyle = finalGradient;
                    context.fill();
                    context.restore();
                    break;
                case InsMakeDarker:
                case InsRestoreColor:
                    
                    break;

                case InsApplyLineFormat:
                    formatIndex = ins.Format;
                    format = formatList[formatIndex];
                    color = format.Color;
                    context.strokeStyle = "RGBA(" + color.R + ", " + color.G + ", " + color.B + ", " + format.Alpha / 255.0 + ");";
                    context.stroke();
                    break;
                case InsAddFormatedText:
                    formatIndex = ins.Format;
                    format = formatList[formatIndex];
                    color = format.Color;
                    
                    context.font = format.Size + "px " + format.Name;
                    if (format.Style & 0x02)    
                    {
                        context.font = "italic " + context.font;
                    }
                    if (format.Style & 0x01)    
                    {
                        context.font = "bold " + context.font;
                    }
                    context.fillStyle = "RGBA(" + color.R + ", " + color.G + ", " + color.B + ", " + format.Alpha / 255.0 + ");";
                    context.fillText(ins.Text, ins.StartPoint.X, ins.StartPoint.Y);
                    if (format.Style & 0x0C) 
                    {
                        context.beginPath();
                        var textSize = context.measureText(ins.Text);
                        if(format.Style & 0x04) 
                        {
                            context.moveTo(Math.round(ins.StartPoint.X), Math.round(ins.StartPoint.Y));
                            context.lineTo(Math.round(ins.StartPoint.X + textSize.width), Math.round(ins.StartPoint.Y));
                        }
                        if(format.Style & 0x08) 
                        {
                            context.moveTo(Math.round(ins.StartPoint.X), Math.round(ins.StartPoint.Y - format.Size * 0.5));
                            context.lineTo(Math.round(ins.StartPoint.X + textSize.width), Math.round(ins.StartPoint.Y - format.Size * 0.5));
                        }
                        context.strokeStyle = "RGBA(" + color.R + ", " + color.G + ", " + color.B + ", " + format.Alpha / 255.0 + ");";
                        context.lineWidth = Math.round(Math.max(1, format.Size * 3 / 40));
                        context.stroke();
                    }
                    break;

                case InsApplyBeveledFrameToRectangle: 

                    var lRect;
                    if (unit.IsAnimated === 0) {
                        lRect = ins.Rect;
                    }
                    else {
                        lRect = ins.Rect[0];
                        var rect2 = ins.Rect[1];
                        lRect.X = lRect.X * (1-progress) + rect2.X * progress;
                        lRect.Y = lRect.Y * (1-progress) + rect2.Y * progress;
                        lRect.Width = lRect.Width * (1-progress) + rect2.Width * progress;
                        lRect.Height = lRect.Height * (1-progress) + rect2.Height * progress;
                    }

                    var lRotationAngle = ins.RotationAngle;
                    var llBevelDepth = ins.BevelDepth;
                    var lrLTColor = ins.LTColor;
                    var lLTAlpha = ins.LTAlpha;
                    var lrRBColor = ins.RBColor;
                    var lRBAlpha = ins.RBAlpha;
                    var lDeviceAnchor ={X:lRect.X + lRect.Width / 2, Y:lRect.Y + lRect.Height / 2};
                    var lInnerRect = {X:0, Y:0, Width:0, Height:0};
                    lInnerRect.X =  lRect.X;
                    lInnerRect.Y = lRect.Y;
                    lInnerRect.Width = lRect.Width;
                    lInnerRect.Height = lRect.Height;
                    hImplode(lInnerRect, llBevelDepth, llBevelDepth);

                    var lOutterPolygon = [];

                    lOutterPolygon.push(hRotateAndClone({X:lRect.X, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lOutterPolygon.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lOutterPolygon.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    lOutterPolygon.push(hRotateAndClone({X:lRect.X, Y:lRect.Y + lRect.Height},lDeviceAnchor, lRotationAngle));

                    var lInnterPolygon = [];
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));

                    
                    var lLeftTop = [];
                    lLeftTop.push(hRotateAndClone({X:lRect.X, Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lRect.X, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    hDrawPolygon(context, lLeftTop, false, false);
                    context.fillStyle = "RGBA(" + lrLTColor.R + ", " + lrLTColor.G + ", " + lrLTColor.B + ", " + lLTAlpha / 255.0 + ");";
                    context.fill();

                    
                    var lRightBottom = [];
                    lRightBottom.push(hRotateAndClone({X:lRect.X, Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lRect.X + lRect.Width,Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    hDrawPolygon(context, lRightBottom, false, false);
                    context.fillStyle = "RGBA(" + lrRBColor.R + ", " + lrRBColor.G + ", " + lrRBColor.B + ", " + lRBAlpha / 255.0 + ");";
                    context.fill();

                    context.strokeStyle = "RGBA(230, 230, 230, " + lLTAlpha*0.5 / 255.0 + ");";
                    context.lineWidth = 1;
                    hDrawPolygon(context, lOutterPolygon, true, true);
                    context.stroke();
                    hDrawPolygon(context, lInnterPolygon, true, true);
                    context.stroke();
                    break;
            }
        }
    }

    function hGetRadialAlpha(rr, cc)
    {
        return 1 - ( Math.sqrt((cc - 256) * (cc -  256) + (rr -  256) * (rr -  256)) / (1.5 * 256) );
    }

    function hMoveTo(context, iX, iY, iIsLinePath, iIsLineWidthOdd)
    {
        var lOffset = (iIsLinePath && iIsLineWidthOdd) ? 0.5 : 0.0;
        context.moveTo(iX + lOffset, iY + lOffset);
    }

    function hLineTo(context, iX, iY, iIsLinePath, iIsLineWidthOdd)
    {
        var lOffset = (iIsLinePath && iIsLineWidthOdd) ? 0.5 : 0.0;
        context.lineTo(iX + lOffset, iY + lOffset);
    }

    function hDrawPolyLine(context, irPoints, iIsLinePath, iIsLineWidthOdd)
    {
        var lNumberOfPoints = irPoints.length;
        if(lNumberOfPoints<=0)
            return;
        context.beginPath();
        hMoveTo(context, irPoints[0].X, irPoints[0].Y, iIsLinePath, iIsLineWidthOdd);
        var lPreviousIndex = 0;
        for(i = 1; i < lNumberOfPoints; ++i)
        {
            
            
            
            
                hLineTo(context, irPoints[i].X, irPoints[i].Y, iIsLinePath, iIsLineWidthOdd);
                lPreviousIndex = i;
            
        }
    }

    function hGetMarkerShape(iMarkerShape)
    {
        var opPoints = gMarkerShapes[iMarkerShape];
        var opPointNumber = opPoints.length/2;

        return {number:opPointNumber, points:opPoints};
    }


    function hGetClockwisePolygon(iMarkerShape, mpos, iMarkerSize)
    {
        var mPolygon = [];

        if (iMarkerShape == MS_Circle)
        {
            mPolygon.push({X:mpos.X - iMarkerSize, Y:mpos.Y - iMarkerSize});
            mPolygon.push({X:mpos.X + iMarkerSize, Y:mpos.Y - iMarkerSize});
            mPolygon.push({X:mpos.X + iMarkerSize, Y:mpos.Y + iMarkerSize});
            mPolygon.push({X:mpos.X - iMarkerSize, Y:mpos.Y + iMarkerSize});
            return mPolygon;
        }

        var lPointNumber;
        var lPoints;

        var rt = hGetMarkerShape(iMarkerShape);
        lPointNumber = rt.number;
        lPoints = rt.points;

        for (var i = 0; i < lPointNumber; i++)
        {
            var lx = (lPoints[2 * i]) * iMarkerSize / gLocalMarkerSize + mpos.X;
            var ly = (lPoints[2 * i + 1]) * iMarkerSize / gLocalMarkerSize + mpos.Y;
            mPolygon.push({X:lx, Y:ly});
        }

        return mPolygon;
    }

    function hDrawPolygon(context, irPoints, iIsLinePath, iIsLineWidthOdd)
    {
        var lNumberOfPoints = irPoints.length;
        if(lNumberOfPoints < 3)
            return;

        context.beginPath();
        if (iIsLinePath && iIsLineWidthOdd)
        {
            var lAdjustedPoints = [];
            for(var i = 0; i < lNumberOfPoints; ++i)
            {
                lAdjustedPoints.push(irPoints[i]);
            }

            var lPreviousIndex = lNumberOfPoints - 1;
            for(var i = 0; i < lNumberOfPoints; ++i)
            {
                lNextIndex = (i + 1 == lNumberOfPoints) ? 0 : i + 1;
                if (irPoints[i].X == irPoints[lPreviousIndex].X || irPoints[i].X == irPoints[lNextIndex].X)
                {
                    lAdjustedPoints[i].X += 0.5;
                }
                if (irPoints[i].Y == irPoints[lPreviousIndex].Y || irPoints[i].Y == irPoints[lNextIndex].Y)
                {
                    lAdjustedPoints[i].Y += 0.5;
                }
                lPreviousIndex = i;
            }
            hDrawPolyLine(context, lAdjustedPoints, false, iIsLineWidthOdd);
        }
        else
        {
            hDrawPolyLine(context, irPoints, false, iIsLineWidthOdd);
        }
        context.closePath();
    }

    function hRotate(point, irAnchor, iRadian)
    {
        var lXDist = point.X - irAnchor.X;
        var lYDist = point.Y - irAnchor.Y;

        point.X = irAnchor.X + Math.cos(iRadian) * lXDist - Math.sin(iRadian) * lYDist;
        point.Y = irAnchor.Y + Math.sin(iRadian) * lXDist + Math.cos(iRadian) * lYDist;
        return point;
    }

    function hRotateAndClone(point, irAnchor, iRadian)
    {
        return hRotate(point, irAnchor, iRadian);
    }

    function hImplode(rect, iXOffset, iYOffset)
    {
        if (iXOffset * 2 > rect.Width)
        {
            iXOffset = rect.Width / 2;
        }
        if (iYOffset * 2 > rect.Height)
        {
            iYOffset = rect.Height / 2;
        }

        return hExplode(rect, -iXOffset, -iYOffset);
    }

    function hExplode(rect, iXOffset, iYOffset)
    {
        rect.X -= iXOffset;
        rect.Y -= iYOffset;
        rect.Width += (iXOffset*2);
        rect.Height += (iYOffset*2);
        return rect;
    }

    function hGetTriangleAreaDouble(vectorA, vectorB, vectorC)
    {
        return hCrossProduct(vectorA,vectorB) + hCrossProduct(vectorB, vectorC) + hCrossProduct(vectorC, vectorA);
    }

    function hDistance(vectorA, vectorB)
    {
        return Math.sqrt((vectorA.X - vectorB.X) * (vectorA.X - vectorB.X)
            + (vectorA.Y - vectorB.Y) * (vectorA.Y - vectorB.Y));
    }

    
    function hGetNewPolygon(polygon, iCurrent, oPolygon)
    {
        var rtPolygon = oPolygon;

        var lSize = polygon.length;
        var i = iCurrent;
        var lPointA = polygon[(i + lSize - 1) % lSize];
        var lPointC = polygon[(i + 1) % lSize];
        
        var lIndexAB = 0;
        var lIntersectionAB = {X:0, Y:0};
        var lVectorAB = {X: polygon[iCurrent].X - polygon[(iCurrent + lSize - 1) % lSize].X,
            Y:polygon[iCurrent].Y - polygon[(iCurrent + lSize - 1) % lSize].Y};

        for(var k = (i+2) % lSize; k != i; k = (k + 1) % lSize)
        {
            var j = k - 1;
            if(j < 0)
                j += lSize;
            var lVectorBJ = {X:polygon[j].X - polygon[i].X, Y:polygon[j].Y - polygon[i].Y};
            var lVectorBK = {X:polygon[k].X - polygon[i].X, Y:polygon[k].Y - polygon[i].Y};
            if(hCrossProduct(lVectorAB, lVectorBJ) < 0.01 && hCrossProduct(lVectorAB, lVectorBK) > 0.01)
            {
                
                var rt = hLineInterSection(lPointA, polygon[i], polygon[j], polygon[k], lIntersectionAB, false);
                lIntersectionAB = rt.interSection;
                lIndexAB = k;
                break;
            }
        }

        
        var lIndexCB = 0;
        var lIntersectionCB = {X:0, Y:0};
        var lVectorCB = { X:polygon[iCurrent].X - polygon[(iCurrent + 1) % lSize].X, Y:polygon[iCurrent].Y - polygon[(iCurrent+1) % lSize].Y };
        for(var k = (i + lSize - 2) % lSize; k != i; k = (k - 1 + lSize) % lSize)
        {
            var j = k + 1;
            if(j >= lSize)
                j -= lSize;
            var lVectorBJ = {X:polygon[j].X - polygon[i].X, Y:polygon[j].Y - polygon[i].Y};
            var lVectorBK = {X:polygon[k].X - polygon[i].X, Y:polygon[k].Y - polygon[i].Y};
            if(hCrossProduct(lVectorCB, lVectorBJ) > -0.01 && hCrossProduct(lVectorCB, lVectorBK) < -0.01)
            {
                
                var rt = hLineInterSection(lPointC, polygon[i], polygon[j], polygon[k], lIntersectionCB, false);
                lIntersectionCB = rt.interSection;
                lIndexCB = k;
                break;
            }
        }
        rtPolygon.push(polygon[i]);
        rtPolygon.push(lIntersectionAB);
        for(m = lIndexAB; ; m = (m + 1) % lSize)
        {
            rtPolygon.push(polygon[m]);
            if (m == lIndexCB)
                break;
        }
        rtPolygon.push(lIntersectionCB);

        return rtPolygon;
    }

    
    function hGetNewAreaDepth(polygon, orMaxDepth)
    {
        var lSize = polygon.length;
        if(lSize == 3)
        {
            var lRt = hGetAreaDepth(polygon, orMaxDepth);
            return lRt;
        }
        else
        {
            
            
            
            var lPointA = polygon[lSize - 1];
            var lVectorBC = {X:polygon[1].X - polygon[0].X, Y:polygon[1].Y - polygon[0].Y};
            var lVectorCB = {X:-lVectorBC.X, Y:-lVectorBC.Y};
            var lVectorBA = {X:lPointA.X - polygon[0].X, Y:lPointA.Y - polygon[0].Y};
            var lVectorAB = {X:-lVectorBA.X, Y:-lVectorBA.Y};

            var lIsValid = false;
            var lDepth = 1e10; 
            
            for(var i = 2; i < lSize; ++i)
            {
                var j = i - 1;
                var lVectorJI = {X:polygon[i].X - polygon[j].X, Y:polygon[i].Y - polygon[j].Y};
                if (hCrossProduct(lVectorCB, lVectorJI) < -0.01)
                {
                    
                    var lPoint = {X:0, Y:0};
                    
                    var rt = hLineInterSection(polygon[0], polygon[1], polygon[j], polygon[i], lPoint, false);
                    lPoint = rt.interSection;
                    if(rt.val > 0)
                    {
                        var lVectorBIntersection = {X:lPoint.X - polygon[0].X, Y:lPoint.Y - polygon[0].Y};
                        
                        if(hInnerProduct(lVectorBC, lVectorBIntersection) > 0.01)
                        {
                            
                            var lTempPoint = {X:lPoint.X + lVectorJI.X, Y:lPoint.Y + lVectorJI.Y};
                            var lBisectorPoint = {X:0, Y:0};
                            var lTemp;

                            var lRt = hGetBisectorPointAndDepth(lPointA, polygon[0], lPoint, lTempPoint, lBisectorPoint, lTemp);
                            lBisectorPoint = lRt.point;
                            lTemp = lRt.val;
                            if (lRt.mark)
                            {
                                lIsValid = true;
                                if((lTemp < lDepth) && hPointInRange(lBisectorPoint, polygon[j-1], polygon[j], polygon[i], polygon[(i+1)%lSize]))
                                {
                                    lDepth = lTemp;
                                }
                            }
                        }
                    }
                }
                else if(hCrossProduct(lVectorAB, lVectorJI) < -0.01)
                {
                    
                    var lPoint = {X:0, Y:0};
                    
                    var rt = hLineInterSection(polygon[0], lPointA, polygon[j], polygon[i], lPoint, false);
                    lPoint = rt.interSection;
                    if(rt.val > 0)
                    {
                        var lVectorBIntersection = {X:lPoint.X - polygon[0].X, Y:lPoint.Y - polygon[0].Y};
                        
                        if(hInnerProduct(lVectorBA, lVectorBIntersection) > 0.01)
                        {
                            
                            var lTempPoint = {X:lPoint.x - lVectorJI.x, Y:lPoint.y - lVectorJI.y};
                            var lBisectorPoint = {X:0, Y:0};
                            var lTemp;

                            var lRt = hGetBisectorPointAndDepth(lTempPoint, lPoint, polygon[0], polygon[1], lBisectorPoint, lTemp);
                            lBisectorPoint = lRt.point;
                            lTemp = lRt.val;
                            if (lRt.mark)
                            {
                                lIsValid = true;
                                if((lTemp < lDepth) && hPointInRange(lBisectorPoint, polygon[j-1], polygon[j], polygon[i], polygon[(i+1)%lSize]))
                                {
                                    lDepth = lTemp;
                                } 
                            }
                        } 
                    } 
                } 
            } 
            return {mark:lIsValid, depth:lDepth};
        } 
    }

    function hLengthSquared(vectorA)
    {
        return vectorA.X * vectorA.X + vectorA.Y * vectorA.Y;
    }

    function hGetAngularBisectorIntersectionPoint(vectorA, vectorB, vectorC, depth)
    {
        var lVectorBA = {X:vectorA.X - vectorB.X, Y:vectorA.Y - vectorB.Y};
        var lVectorBC = {X:vectorC.X - vectorB.X, Y:vectorC.Y - vectorB.Y};
        var lLengthBA = Math.sqrt(hLengthSquared(lVectorBA));
        var lLengthBC = Math.sqrt(hLengthSquared(lVectorBC));
        var lVectorUnitBA = {X: lVectorBA.X / lLengthBA, Y:lVectorBA.Y / lLengthBA};
        var lVectorUnitBC = {X:lVectorBC.X / lLengthBC, Y:lVectorBC.Y / lLengthBC};
        var lLength = 0.0;
        if(Math.abs(lVectorUnitBA.X - lVectorUnitBC.X) < 0.01)
        {
            lLength = depth * (lVectorUnitBC.X + lVectorUnitBA.X) / (lVectorUnitBA.Y - lVectorUnitBC.Y);
        }
        else
        {
            lLength = depth * (lVectorUnitBC.Y + lVectorUnitBA.Y) / (lVectorUnitBC.X - lVectorUnitBA.X);
        }
        var oPointEnd = { X:0, Y:0 };
        var oPointStart = { X:0, Y:0 };
        oPointEnd.X = vectorB.X + lLength * lVectorUnitBC.X;
        oPointEnd.Y = vectorB.Y + lLength * lVectorUnitBC.Y;
        oPointStart.X = oPointEnd.X + depth * (-lVectorUnitBC.Y);
        oPointStart.Y = oPointEnd.Y + depth * lVectorUnitBC.X;

        return {start:oPointStart, end:oPointEnd};
    }

    function hIncludedAngle(vectorA, vectorB)
    {
        var lTemp = hInnerProduct(vectorA, vectorB) / (Math.sqrt(hLengthSquared(vectorA) * hLengthSquared(vectorB)));
        lTemp = (lTemp > 1.0) ? 1.0 : lTemp;
        lTemp = (lTemp < -1.0) ? -1.0 : lTemp;
        return Math.acos(lTemp);
    }

    function hPointInRange(irPoint, vectorA, vectorB, vectorC, vectorD)
    {
        
        var lVectorBA = {X:vectorA.X - vectorB.X, Y:vectorA.Y - vectorB.Y};
        var lVectorBC = {X:vectorC.X - vectorB.X, Y:vectorC.Y - vectorB.Y};
        var lAngleABC = radianToDegree(hIncludedAngle(lVectorBA, lVectorBC));
        if(hCrossProduct(lVectorBC, lVectorBA) < -0.01)
            lAngleABC = 360 - lAngleABC;
        var lVectorBPoint = {X:irPoint.X - vectorB.X, Y:irPoint.Y - vectorB.Y};
        var lAnglePointBC = radianToDegree(hIncludedAngle(lVectorBPoint,lVectorBC));
        if(hCrossProduct(lVectorBC, lVectorBPoint) < -0.01)
            lAnglePointBC = 360 - lAnglePointBC;
        if(2 * lAnglePointBC > lAngleABC)
            return false;

        
        var lVectorCB = {X:-lVectorBC.X, Y:-lVectorBC.Y};
        var lVectorCD = {X:vectorD.X - vectorC.X, Y:vectorD.Y - vectorC.Y};
        var lAngleBCD = radianToDegree(hIncludedAngle(lVectorCB, lVectorCD));
        if(hCrossProduct(lVectorCD, lVectorCB) < -0.01)
            lAngleBCD = 360 - lAngleBCD;
        var lVectorCPoint = {X:irPoint.X - vectorC.X, Y:irPoint.Y - vectorC.Y};
        var lAngleBCPoint = radianToDegree(hIncludedAngle(lVectorCB, lVectorCPoint));
        if(hCrossProduct(lVectorCPoint, lVectorCB) < -0.01)
            lAngleBCPoint = 360 - lAngleBCPoint;
        if(2 * lAngleBCPoint > lAngleBCD)
            return false;
        
        return true;
    }

    function hLength(vectorA)
    {
        return Math.sqrt(hLengthSquared(vectorA));
    }

    function hGetBisectorPointAndDepth(vectorA, vectorB, vectorC, vectorD, orBisectorPoint, orDistance)
    {
        var val;
        var mark;

        var lVectorAB = {X:vectorB.X - vectorA.X, Y:vectorB.Y - vectorA.Y};
        var lVectorCD = {X:vectorD.X - vectorC.X, Y:vectorD.Y - vectorC.Y};
        var lVectorBC = {X:vectorC.X - vectorB.X, Y:vectorC.Y - vectorB.Y};
        var lLengthBC = Math.sqrt(hLengthSquared(lVectorBC));
        var lABCrossCD =  hCrossProduct(lVectorAB, lVectorCD);
        if (lABCrossCD > 0.01 || lABCrossCD < -0.01)
        {
            
            
            var lE = {X:0, Y:0};
            var rt = hLineInterSection(vectorA, vectorB, vectorC, vectorD, lE, false);
            lE = rt.interSection;
            var lLengthBE = hDistance(vectorB, lE);
            var lLengthCE = hDistance(vectorC, lE);
            if (lABCrossCD < -0.01)
            {
                
                var lP = lLengthBC + lLengthBE + lLengthCE;
                orBisectorPoint.X = (lLengthCE * vectorB.X + lLengthBE * vectorC.X + lLengthBC * lE.X) / lP;
                orBisectorPoint.Y = (lLengthCE * vectorB.Y + lLengthBE * vectorC.Y + lLengthBC * lE.Y) / lP;
                val = hGetTriangleAreaDouble(vectorB, vectorC, lE) / lP;
                mark = true;
            }
            else 
            {
                
                var lP = lLengthBE + lLengthCE - lLengthBC;
                if(lP < 0.01)
                {
                    var lDepth = 0.0;
                    if(Math.abs(hCrossProduct(lVectorAB, lVectorBC)) < 0.01)
                    {
                        var lVectorCBUnit = {X:-lVectorBC.X / lLengthBC, Y:-lVectorBC.Y / lLengthBC};
                        var lLengthCD = Math.sqrt(hLengthSquared(lVectorCD));
                        var lVectorCDUnit = {X:lVectorCD.X / lLengthCD, Y:lVectorCD.Y / lLengthCD};
                        lDepth = (lVectorCBUnit.Y - lVectorCDUnit.Y) * lLengthBC / (lVectorCBUnit.X + lVectorCDUnit.X);
                        orBisectorPoint.X = vectorB.X + lDepth * lVectorCBUnit.Y;
                        orBisectorPoint.Y = vectorB.Y + lDepth * (-lVectorCBUnit.X);
                    }
                    else
                    {
                        var lVectorBCUnit = {X:lVectorBC.X / lLengthBC, Y:lVectorBC.Y / lLengthBC};
                        var lLengthAB = hLength(lVectorAB);
                        var lVectorBAUnit = {X:-lVectorAB.X / lLengthAB, Y:-lVectorAB.Y / lLengthAB};
                        lDepth = (lVectorBAUnit.Y - lVectorBCUnit.Y) * lLengthBC / (lVectorBAUnit.X + lVectorBCUnit.X);
                        orBisectorPoint.X = vectorC.X + lDepth * (-lVectorBCUnit.Y);
                        orBisectorPoint.Y = vectorC.Y + lDepth * lVectorBCUnit.X;
                    }
                    val = lDepth;
                    mark = true;
                    return {val:val, mark:mark, point:orBisectorPoint};
                }
                orBisectorPoint.X = (lLengthCE * vectorB.X + lLengthBE * vectorC.X - lLengthBC * lE.X) / lP;
                orBisectorPoint.Y = (lLengthCE * vectorB.Y + lLengthBE * vectorC.Y - lLengthBC * lE.Y) / lP;
                val = hGetTriangleAreaDouble(vectorB, lE, vectorC) / lP;
                mark = true;
            }
        }
        else
        {
            

            
            if(Math.abs(hCrossProduct(lVectorAB, lVectorBC)) < 0.01)
            {
                mark = false;
                return {val:val, mark:mark, point:orBisectorPoint};
            }
            var lLengthAB = Math.sqrt(hLengthSquared(lVectorAB));
            var lUnitVectorBA = {X:-lVectorAB.X / lLengthAB, Y:-lVectorAB.Y / lLengthAB };
            orBisectorPoint.X = (vectorB.X + vectorC.X + lLengthBC * lUnitVectorBA.X) / 2;
            orBisectorPoint.Y = (vectorB.Y + vectorC.Y + lLengthBC * lUnitVectorBA.Y) / 2;
            val = hCrossProduct(lVectorBC, lUnitVectorBA) / 2;
            mark = true;
        }

        return {val:val, mark:mark, point:orBisectorPoint};
    }


    function hGetAreaDepth(polygon, orMaxDepth)
    {
        var val = false;

        var lPolygonSize = polygon.length;
        if(lPolygonSize == 3)
        {
            
            var lLengthA = hDistance(polygon[0], polygon[1]);
            var lLengthB = hDistance(polygon[1], polygon[2]);
            var lLengthC = hDistance(polygon[2], polygon[0]);
            var lP = lLengthA + lLengthB + lLengthC;
            orMaxDepth = hGetTriangleAreaDouble(polygon[0], polygon[1], polygon[2]) / lP;
            val = true;
        }
        else
        {
            var lIsValid = false;
            var lDepth = 1e10; 
            for(var i = 0; i < lPolygonSize; ++i)
            {
                var lPointB = polygon[i];
                
                var lPointA = polygon[(i + lPolygonSize - 1) % lPolygonSize];
                var lPointC = polygon[(i + 1) % lPolygonSize];
                var lPointD = polygon[(i + 2) % lPolygonSize];


                var lVectorBA = {X:lPointA.X - lPointB.X, Y:lPointA.Y - lPointB.Y};
                var lVectorBC = {X:lPointC.X - lPointB.X, Y:lPointC.Y - lPointB.Y};
                var lVectorCB = {X:-lVectorBC.X, Y:-lVectorBC.Y};
                var lVectorCD = {X: lPointD.X - lPointC.X, Y:lPointD.Y - lPointC.Y};
                var lBACrossBC = hCrossProduct(lVectorBA, lVectorBC);
                if(lBACrossBC < 0.01) 
                {
                    if(hCrossProduct(lVectorCB, lVectorCD) < 0.01)
                    {
                        var lTempPoint = {X:0, Y:0};
                        var lTemp = 0.0;

                        var lRt = hGetBisectorPointAndDepth(lPointA, lPointB, lPointC, lPointD, lTempPoint, lTemp);
                        lTempPoint = lRt.point;
                        lTemp = lRt.val;
                        if (lRt.mark)
                        {
                            lIsValid = true;
                            lDepth = (lDepth > lTemp) ? lTemp : lDepth;
                        }
                    }
                    
                }
                else if(lBACrossBC > 0.01)
                {
                    var lPolygon = [];
                    lPolygon = hGetNewPolygon(polygon, i, lPolygon);

                    var lRt = hGetNewAreaDepth(lPolygon, lTemp);
                    var lTemp = lRt.depth;
                    if (lRt.mark)
                    {
                        lIsValid = true;
                        lDepth = (lDepth > lTemp) ? lTemp : lDepth;
                    }
                }
                
            }
            orMaxDepth = lDepth;
            val = lIsValid;
        }

        return {mark:val, depth:orMaxDepth};
    }

    function hIsFPointsEqual(vectorA, vectorB)
    {
        return (Math.abs(vectorA.X - vectorB.X) < 0.01 && Math.abs(vectorA.Y - vectorB.Y) < 0.01);
    }

    function hRemoveZeroEdgeInPolygon(polygon)
    {
        var lPolygon = [];
        lPolygon.push(polygon[0]);

        pcount = polygon.length;
        for(var i = 1; i < pcount; i++)
        {
            if (polygon[i-1].X == polygon[i].X && polygon[i-1].Y == polygon[i].Y)
                continue;
            lPolygon.push(polygon[i]);
        }

        var lFinalPolygon = new Array();
        pcount = lPolygon.length;
        for(var i = 0; i < pcount; i++)
        {
            if (i === pcount - 1)
            {
                if (lPolygon[i].X == lPolygon[0].X && lPolygon[i].Y == lPolygon[0].Y)
                    continue;
            }
            lFinalPolygon.push(lPolygon[i]);
        }

        return lFinalPolygon;
    }

    function hIsOnSegment(vectorA, vectorB, vectorC, bExclude)
    {
        var lTolerance = 0.01;
        if (bExclude === false)
            lTolerance = -0.01;

        if (Math.abs(vectorB.X - vectorC.X) < 0.01)
        {
            if (vectorA.Y - vectorB.Y > lTolerance && vectorC.Y - vectorA.Y > lTolerance)
                return true;
            if (vectorA.Y - vectorC.Y > lTolerance && vectorB.Y - vectorA.Y > lTolerance)
                return true;
        }
        else
        {
            if (vectorA.X - vectorB.X > lTolerance && vectorC.X - vectorA.X > lTolerance)
                return true;
            if (vectorA.X - vectorC.X > lTolerance && vectorB.X - vectorA.X > lTolerance)
                return true;
        }

        return false;
    }


    function hLineInterSection(vectorA, vectorB, vectorC, vectorD, vectorSection, bExclude)
    {
        var vectorAB = {X : vectorB.X - vectorA.X, Y : vectorB.Y - vectorA.Y};
        var vectorCD = {X : vectorD.X - vectorC.X, Y : vectorD.Y - vectorC.Y};

        if (Math.abs(hCrossProduct(vectorAB, vectorCD)) < 0.01)
        {
            var vectorAC = {X : vectorC.X - vectorA.X, Y : vectorC.Y - vectorA.Y};
            if (Math.abs(hCrossProduct(vectorAB, vectorAC)) < 0.01)
               return { val:-1, interSection:vectorSection };
            else
               return { val:0, interSection:vectorSection };
        }
        else
        {
            var vectorCA = {X : vectorA.X - vectorC.X, Y : vectorA.Y - vectorC.Y};
            var lS = hCrossProduct(vectorCD, vectorCA)/hCrossProduct(vectorAB, vectorCD);
            vectorSection.X = vectorA.X + lS*vectorAB.X;
            vectorSection.Y = vectorA.Y + lS*vectorAB.Y;
            if (hIsOnSegment(vectorSection, vectorA, vectorB, bExclude)
                    && hIsOnSegment(vectorSection, vectorC, vectorD, bExclude))
                return { val:1, interSection:vectorSection };
            else
                return { val:2, interSection:vectorSection };
        }
    }

    function hRatioInRectangle(rect, angle, anchor)
    {
        var lAngle = angle;
        while (lAngle < 0)
        {
            lAngle += 360;
        }
        while (lAngle >= 360)
        {
            lAngle -= 360;
        }

        var lEdgeRight = rect.X + rect.Width - anchor.x;
        var lEdgeUp = anchor.y - rect.Y;
        var lEdgeLeft = anchor.x - rect.X;
        var lEdgeDown = rect.Y + rect.Height - anchor.y;
        var lRadianAngle = degreeToRadian(lAngle);

        
        var lUnitVectorAngle = {x : Math.cos(lRadianAngle), y : -Math.sin(lRadianAngle)};

        
        
        
        
        
        
        
        var lLengthOF;
        var lNegLengthOE;
        if (lAngle >= 0 && lAngle < 90)
        {
            var lVectorOB = {x : lEdgeRight, y : -lEdgeUp};
            var lVectorOD = {x : -lEdgeLeft, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOB, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOD, lUnitVectorAngle);
        }
        else if (lAngle >= 90 && lAngle < 180)
        {
            var lVectorOA = {x : -lEdgeLeft, y : -lEdgeUp};
            var lVectorOC = {x : lEdgeRight, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOA, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOC, lUnitVectorAngle);
        }
        else if (lAngle >= 180 && lAngle < 270)
        {
            var lVectorOB = {x : lEdgeRight, y : -lEdgeUp};
            var lVectorOD = {x : -lEdgeLeft, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOD, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOB, lUnitVectorAngle);
        }
        else 
        {
            var lVectorOA = {x : -lEdgeLeft, y : -lEdgeUp};
            var lVectorOC = {x : lEdgeRight, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOC, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOA, lUnitVectorAngle);
        }

        endPoint.x = anchor.x + lLengthOF * lUnitVectorAngle.x;
        endPoint.y = anchor.y + lLengthOF * lUnitVectorAngle.y;
        startPoint.x = anchor.x + lNegLengthOE * lUnitVectorAngle.x;
        startPoint.y = anchor.y + lNegLengthOE * lUnitVectorAngle.y;
        var lAnchorPercent = -lNegLengthOE / (lLengthOF - lNegLengthOE);
        if (lAnchorPercent < 0)
        {
            lAnchorPercent = 0;
        }
        else if (lAnchorPercent > 1)
        {
            lAnchorPercent = 1;
        }
        return lAnchorPercent;
    }

    function degreeToRadian(degree)
    {
        return degree * PI / 180;
    }

    function radianToDegree(radian)
    {
        return radian * 180 / PI;
    }

    function innerProduct(vector1, vector2)
    {
        return (vector1.x * vector2.x + vector1.y * vector2.y);
    }

    function hInnerProduct(vector1, vector2)
    {
        return (vector1.X * vector2.X + vector1.Y * vector2.Y);
    }

    function hCrossProduct(vector1, vector2)
    {
        return (vector1.X * vector2.Y - vector1.Y * vector2.X);
    }

    function fillGradient(context, format, rect, darkerFactor)
    {
        var gradient = format.Gradient;

        var startColor = "RGBA(" + Math.round(darkerFactor * gradient.StartGraphColor.R) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.G) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.B) + ", " + format.Alpha / 255.0 + ");";
        var endColor = "RGBA(" + Math.round(darkerFactor * gradient.EndGraphColor.R) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.G) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.B) + ", " + gradient.EndAlpha / 255.0 + ");";
        var finalGradient;

        switch (gradient.GradientType)
        {
        case GradientLinear:
            {
                var lHOffset = gradient.HorizontalOffset;
                if ((gradient.Angle > 90 && gradient.Angle < 180) || gradient.Angle > 270)
                {
                    
                    lHOffset = 100 - lHOffset;
                }

                var lAnchorPoint = {x : rect.X + rect.Width * lHOffset / 100,
                        y : rect.Y + rect.Height * gradient.VerticalOffset / 100};
                startPoint = {x : 0, y : 0};
                endPoint = {x : 0, y : 0};
                var lAnchorPercent = hRatioInRectangle(rect, gradient.Angle, lAnchorPoint);

                finalGradient = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                finalGradient.addColorStop(0, endColor);
                finalGradient.addColorStop(lAnchorPercent, startColor);
                finalGradient.addColorStop(1, endColor);

                context.fillStyle = finalGradient;
                context.fill();
            }
            break;

        case GradientCircular:
            {
                var lAnchorPoint = {x : rect.X + rect.Width * gradient.HorizontalOffset / 100,
                        y : rect.Y + rect.Height * gradient.VerticalOffset / 100};
                var lScale = rect.Width * 1.0 / rect.Height;
                lAnchorPoint.y *= lScale;

                finalGradient = context.createRadialGradient(lAnchorPoint.x, lAnchorPoint.y, 0, lAnchorPoint.x, lAnchorPoint.y, rect.Width * 2);
                finalGradient.addColorStop(0, startColor);
                finalGradient.addColorStop(0.5, endColor);
                finalGradient.addColorStop(1, endColor);
                context.fillStyle = finalGradient;

                context.save();
                context.scale(1.0, 1 / lScale);
                context.fill();
                context.restore();
            }
            break;

        case GradientRectangular:
            {
                var lAnchorPoint = {x : rect.X + rect.Width * gradient.HorizontalOffset / 100,
                        y : rect.Y + rect.Height * gradient.VerticalOffset / 100};
                var lAngle = gradient.Angle % 90;
                var lRectAngle = radianToDegree(Math.atan(rect.Height / rect.Width));
                var lTempAngle = 2 * lAngle - lRectAngle * lAngle / 45 + 90 + lRectAngle;

                startPoint = {x : 0, y : 0};
                endPoint = {x : 0, y : 0};
                var lAnchorPercent = hRatioInRectangle(rect, lTempAngle, lAnchorPoint);

                var lGradient = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                startColor = "RGBA(" + Math.round(darkerFactor * gradient.StartGraphColor.R) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.G) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.B) + ", " + format.Alpha / (255.0 * 2 - format.Alpha) + ");";
                endColor = "RGBA(" + Math.round(darkerFactor * gradient.EndGraphColor.R) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.G) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.B) + ", " + gradient.EndAlpha / (255.0 * 2 - gradient.EndAlpha) + ");";
                lGradient.addColorStop(0, endColor);
                lGradient.addColorStop(lAnchorPercent, startColor);
                lGradient.addColorStop(1, endColor);
                context.fillStyle = lGradient;
                context.fill();

                lTempAngle = lRectAngle * lAngle / 45 + 90 - lRectAngle;
                lAnchorPercent = hRatioInRectangle(rect, lTempAngle, lAnchorPoint);

                finalGradient = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                startColor = "RGBA(" + Math.round(darkerFactor * gradient.StartGraphColor.R) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.G) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.B) + ", " + format.Alpha / (255.0 * 2) + ");";
                endColor = "RGBA(" + Math.round(darkerFactor * gradient.EndGraphColor.R) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.G) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.B) + ", " + gradient.EndAlpha / (255.0 * 2) + ");";
                finalGradient.addColorStop(0, endColor);
                finalGradient.addColorStop(lAnchorPercent, startColor);
                finalGradient.addColorStop(1, endColor);
                context.fillStyle = finalGradient;
                context.fill();
            }
            break;
        }
    }

    function addCompensativeLayer(context, format)
    {
        
        
        
        var lFillAlpha = format.Alpha / 255.0;
        context.fillStyle = 'rgba(255,255,255,' + format.Alpha / 255.0 + ')';
        context.fill();
    }


    
    function clearCanvas(context) {
        
        var canvas = context.canvas;

        
        context.clearRect(0, 0, canvas.width, canvas.height);
    }

    function draw(widget) {
        INITIAL_TIME = (new Date()).getTime();
        drawEx(widget);
    }

    function drawEx(widget) {
        var data = widget.graphData,
            unitList = data.UnitList,
            unitCount = unitList.length,
            formatList = data.FormatList,
            cn = widget.graphNode,
            hcn = widget.highlightNode,
            hcontext = hcn.getContext('2d'),
            scn = widget.selectionNode,
            scontext = scn.getContext('2d'),
            context = cn.getContext('2d');

        
        clearCanvas(context);
        clearCanvas(hcontext);
        clearCanvas(scontext);

        
        var t = Math.min(((new Date()).getTime() - INITIAL_TIME) / ANIMATION_DURATION, 1),
            x = (1 - t),
            i;

        
        var progress = 0.3 * t * x * x + 2.7 * x * t * t + t * t * t;

        var isAnimated = 0;
        for (i = 0; i < unitCount; i++) {
            drawWithContext(context, progress, unitList[i], formatList);
            if (unitList[i].IsAnimated !== 0)
            {
                isAnimated = 1;
            }
        }

        
        if (t < 1.0 && isAnimated === 1) {
            
            setTimeout(function() {
                drawEx(widget);
            }, 20);
        }
    }

    
    mstrmojo.graph._CanvasGraph = mstrmojo.provide(
        "mstrmojo.graph._CanvasGraph",

        
        {
            markupString: '<div class="{@cssClassPrefix} {@cssClass}" title="{@tooltip}" style="{@domNodeCssText};">' +
                              '<div class="{@cssClassPrefix}-txt"></div>' +
                              '<canvas id="{@id}" height="{@height}" width="{@width}">' +
                                  '{@unsupportedError}' +
                              '</canvas>' +
                              '{@map}' +
                              '<canvas id="{@id}-highlight" class="mobile-graph-selection-canvas" height="{@height}" width="{@width}" style="position:absolute;top:0;left:0">' +
                              '</canvas>' +
                              '<canvas id="{@id}-highlight" class="' + mstrmojo.GraphBase.canvasCLS + '" height="{@height}" width="{@width}" style="position:relative;top:0;left:0">' +
                              '</canvas>' +
                          '</div>',

            unsupportedError: "This text is displayed if your browser does not support HTML5 Canvas element.",

            markupSlots: {
                graphNode: function () { return this.domNode.childNodes[1]; },
                imgNode: function () { return this.domNode.childNodes[1]; },        
                mapNode: function () { return null; },                              
                textNode: function () { return this.domNode.firstChild; },
                selectionNode: function () { return this.domNode.lastChild.previousSibling;},
                highlightNode: function () { return this.domNode.lastChild; }
            },

            
            graphData: null,

            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                var graphNode = this.graphNode,
                    highlightNode = this.highlightNode,
                    selectionNode = this.selectionNode,
                    graphData = this.graphData,
                    data = (graphData && graphData.data);

                if(data && data.eg) {
                    var tn = this.textNode,
                        img = this.imgNode;

                    
                    img.style.display = 'none';
                    highlightNode.style.display = 'none';
                    selectionNode.style.display = 'none';

                    
                    tn.innerHTML = data.eg || '';

                    
                    tn.style.display = 'block';
                    
                    tn.className = 'mstrmojo-message';
                } else {
                    
                    var height = graphData.GH ||  parseInt(h, 10),
                        width = graphData.GW || parseInt(w, 10);

                    graphNode.setAttribute('height', height);
                    graphNode.setAttribute('width', width);

                    highlightNode.style.display = 'block';
                    highlightNode.setAttribute('height', height);
                    highlightNode.setAttribute('width', width);

                    highlightNode.style.top = -height + 'px';

                    selectionNode.style.display = 'block';
                    selectionNode.setAttribute('height', height);
                    selectionNode.setAttribute('width', width);

                    
                    this.displayTooltips([], 0, 0);
                    
                    
                    draw(this);

                    if (graphData.Selected) {
                        this.highlightAreaInInit(selectionNode, graphData.Selected);
                    }
                }
            },
            
            unrender: function unrender(ignoreDom) {

                
                this._super(false);
                
            },
          
            invalidate: function invalidate() {
                
                var graphNode = this.graphNode;
                if(graphNode) { 
                    clearCanvas(graphNode.getContext('2d'));
                }
            },
            
            getCaptureDimensions: function getCaptureDimensions() {
            	var graphNode = this.graphNode,
            	    position = mstrmojo.dom.position(this.domNode, true);
            	
            	position.w = graphNode.width;
            	position.h = graphNode.height;
            	
            	return position;
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.GraphBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.graph._MobileGraphAreaHelper");

    
    mstrmojo.MobileGraph = mstrmojo.declare(

        mstrmojo.GraphBase,

        [ mstrmojo._TouchGestures, mstrmojo.graph._MobileGraphAreaHelper ],

        
        {
            scriptClass: "mstrmojo.MobileGraph",

            
            areaMarkup: '<area shape="{@shape}" coords="{@coords}" ttl="{@tooltip}" aid="{@aid}" {@extra}/>',

            cssImageClass: "mstrmojo-ReportGraph",

            setDimensions: function setDimensions(h, w) {
            	if(this.height === h && this.width === w) {
            		return; 
            	}
                
            	this.height = h;
                this.width = w;

                
                if (this.hasRendered) {
                    
                    this.controller.refresh(this);
                }
            },

            preBuildRendering: function preBuildRendering() {
                
                var graphData = this.graphData.gd.g;
                this.as = graphData && graphData.as;

                
                return this._super ? this._super() : true;
            },

            refresh: function refresh() {
                
                this.graphData = this.model.data;

                
                this._super();
            },

            
            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                var src = "data:image/png;base64," + this.graphData.ib.eb,
                    imgNode = this.imgNode;

                if (imgNode.src !== src) {
                    imgNode.src = src;
                }
            },

            
            getFormats: function getFormats() {
                return {
                    height: this.height,
                    width: this.width,
                    top: 0,
                    left: 0
                };
            },

            touchTap: function touchTap() {
                
                this.displayTooltips([], 0, 0);

                
                var ctrl = this.controller;
                if (ctrl && ctrl.viewTap) {
                    
                    ctrl.viewTap();
                }
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                this.syncTooltips(touch.pageX, touch.pageY);
            },

            touchSelectMove: function touchSelectMove(touch) {
                this.syncTooltips(touch.pageX, touch.pageY);
            },

            setModel: function setModel(model) {
                this._super(model);

                this.setGraphData(model.data);
            },
            
            
            syncTooltips: function syncTooltips(x, y) {
                
                var me = this,
                    pos = mstrmojo.dom.position(me.domNode, true);

                
                x -= pos.x;
                y -= pos.y;

                me.model.getDataService().handleUserSingleTap(-1, "", x, y, false, {
                    success: function (res) {
                        me.displayTooltips(res.Areas, pos.x, pos.y);
                    }
                }); 
            },
            
            setGraphData: function setGraphData(graphData) {
                
                this.graphData = graphData;

                
                this.controller.getPageByTree(false);
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.GraphBase",
                         "mstrmojo._Formattable",
                         "mstrmojo._HasWaitIcon",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo.tooltip");

    var $D = mstrmojo.dom;

    
    function adjustGraphHeight(w) {
        var f = w.getFormats();
        if (!f.width && 'gp' in f) {
            f = f.gp;
        }
        w.resizeForDisplayState(parseInt(f.height, 10), parseInt(f.width, 10), false);
    }

    function _getEventPos(e) {
        




        
        var domNodePosition = $D.position(this.domNode),        
            mousePosition = $D.getMousePosition(e);             
        return {
            x: parseInt(mousePosition.x - domNodePosition.x, 10),
            y: parseInt(mousePosition.y - domNodePosition.y, 10)
        };
    }
    
    
    function getOverlappedItems(e, win) {
    	var t = $D.eventTarget(win, e),
			p = t && t.parentNode,
			c = p && p.children,
			as = [],
			coords = t.getAttribute("coords");
		if (c && !!coords) {
			for (var i = 0; i < c.length; ++i) {
				if (c[i] && c[i].getAttribute && c[i].getAttribute("coords") == coords) {
					as.push(c[i]);
				}
			}
		}
		return as;
    }

    
    mstrmojo.DocXtabGraph = mstrmojo.declare(
        
        mstrmojo.GraphBase,

        
        [ mstrmojo._Formattable, mstrmojo._HasWaitIcon, mstrmojo._IsSelectorTarget ],

        
        {
            scriptClass: "mstrmojo.DocXtabGraph",

            cssClassPrefix: "mstrmojo-DocXtabGraph",

            areaMarkup: '<area shape="{@shape}" coords="{@coords}" ttl="{@tooltip}" aid="{@aid}" onclick="mstrmojo.all[\'{@id}\'].onClickArea(this, event);" onmousemove="mstrmojo.all[\'{@id}\']._updateTooltip(event, self);" {@extra}/>',

            _att: '',

            markupSlots: {
                imgNode: function () { return this.domNode.childNodes[1]; },
                mapNode: function () { return this.domNode.childNodes.length > 2 ? this.domNode.childNodes[2] : null; },
                textNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode: [ 'RW', 'B', 'background-color', 'fx' ]
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? 'block' : 'none'; }
            },

            onClickArea: function onClickArea(elem, e) {
                e = e || window.event;

                var ep = _getEventPos.apply(this, [e]),                               
                    defn = this.defn,
                    domNodePosition = $D.position(this.domNode),        
                    area = this.as[elem.getAttribute('aid')],
                    key = this.k,
                    x = ep.x,
                    y = ep.y,
                    anchor = {                                            
                       getBoundingClientRect: function () {
                        var left = domNodePosition.x + x,
                            top = domNodePosition.y + y;

                        return {
                            left: left,
                            top: top,
                            right: left + 1,
                            bottom: top + 1
                        };
                       }, 
                       
                       w: this 
                	};
                
                this.showInfoWin(area.tks, anchor);

                
                this.model.slice({
                    type: parseInt(defn.t, 10) || mstrmojo.EnumRWUnitType.GRAPH,
                    src: key,
                    ck: defn.ck,
                    gk: key,
                    tks: area.tks,
                    cks: area.cks,
                    sid: this.node.data.sid,
                    x: x,
                    y: y,
                    anchor: anchor,
                    tty: area.tty
                });
            },
            
            showInfoWin: function showInfoWin(tks, anchor) {
            	var m = this.model,
            		ifws = tks && m.getTargetInfoWin(tks);
            	if (ifws && ifws.length) {
            		for (var i = 0;i < ifws.length; i++) {
            			m.showInfoWin(ifws[i], anchor, 'h');
            		}
            	}
            },

            showTooltip: function showTooltip(e, win) {
                this._updateTooltip(e, win);
                var items = getOverlappedItems(e, win);
                if (items && items.length > 1) {
                	
                	mstrmojo.DocXtabGraph.multiTooltip.open(this, e, win, items);
                } else {
                	this._super(e, win);
                }
            },

            
            _updateTooltip: function _updateTooltip(evt, win) {
                this.updatingTooltipHelper($D.eventTarget(win, evt), _getEventPos.apply(this, [evt]));
            },

            hideTooltip: function hideTooltip(e, win) {
                var elem = $D.eventTarget(win, e);
                if (elem.getAttribute('aid') === this.cAreaIdx) {
                    
                    this.cAreaIdx = -1;

                    
                    var items = getOverlappedItems(e, win);
                    if (items && items.length > 1) {
                    	
                    	mstrmojo.DocXtabGraph.multiTooltip.close(this, e, win, items);
                    } else {
                    	this._super(e, win);
                    }
                }
            },

            
            update: function update(node) {
                this.node.data = node.data;
                
                this.as = node.data.as;

                
                var sep = '\u001E',
                    m = this.model,
                    cgbm = m.getCGBMap && m.getCGBMap(),
                    as = this.as || [],
                    i,
                    j;

                for (i = 0; i < as.length; i++) {
                    var a = as[i],
                        cgb = a && a.tgbs;

                    if (cgb) {
                        var cgbs = cgb.split(sep);
                        var keys = {};
                        for (j = 0; j < cgbs.length; j++) {
                            var k = cgbm && cgbm[cgbs[j]];
                            if (k) {    
                                keys[k] = true;
                            } else {    
                                keys[cgbs[j]] = true;
                            }
                        }
                        a.tks = mstrmojo.hash.keyarray(keys).join(sep);
                    }
                }

                
                this.eg = node.data.eg;
            },

            
            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                
                var src = mstrConfig.taskURL + '?taskId=getRWGraphImage&taskEnv=xhr&__ts__=' + (new Date().getTime()) + '&messageID=' + this.model.mid + '&nodeKey=' + this.k + '&sliceID=' + parseInt(this.node.data.sid, 10) + '&imgType=4' + '&width=' + parseInt(w, 10) + '&height=' + parseInt(h, 10) + '&sessionState=' + mstrApp.sessionState,
                    imgNode = this.imgNode;

                
                if (imgNode.src !== src) {
                    
                    imgNode.src = src;
                }
            },

            resize: function () {
                adjustGraphHeight(this);
            },

            
            resizeForDisplayState: function resizeForDisplayState(h, w, doDom) {
                var f = this.getFormats(),
                    imgNode = this.imgNode;

                
                if (doDom) {
                    var dns = this.domNode.style;

                    
                    dns.top = f.top;
                    dns.left = f.left;
                    dns.height = f.height;
                    dns.width = f.width;
                }

                
                if (imgNode) {
                    imgNode.style.height = h + 'px';
                }

                
                if (!this.eg) {
                    
                    this.retrieveGraphSrc(h, w);
                    if (h) {
                        this.refreshMap();
                    }
                }
            }
        }
    );

    
    
    function getTargetWidth(a) {
    	if (a && a.getAttribute) {
    		var c = a.getAttribute("coords");
    		c = c && c.split(",");
    		if (c && c.length >= 3) {
    			return c[2] - c[0];
    		}
    	}
    	return 0;
    }
    
    
    function getMultiPosition(targetWid) {
    	var p = [],
    		docw = document.body.offsetWidth,
    		doch = document.body.offsetHeight,
    		maxw = 0,
    		maxh = 0,
    		x = ttpList[0] && ttpList[0].domNode ? ttpList[0].domNode.offsetLeft : 0,
    		y = ttpList[0] && ttpList[0].domNode ? ttpList[0].domNode.offsetTop : 0,
    		line = Math.ceil(ttpList.length / 2),
    		margin = 5,
    		originalX = function(x, tpWid) {
				if (x + targetWid + tpWid + margin > docw) {
		    		
		    		return docw - targetWid - tpWid - margin;
		    	} else if (ttpList.length > 1 && x - tpWid - margin < 0) {
		    		
		    		return tpWid + margin;
		    	}
				return x;
			},
			originalY = function(y, tpHeight, line) {
				
				y += tpHeight;
		    	
				var toph = line == 1 ? tpHeight : (line * tpHeight + (line - 1) * margin) / 2;
		    	if (toph > y) {
		    		
		    		return 0;
		    	} else if (toph + y > doch) {
		    		
		    		return doch - toph * 2;
		    	} else {
		    		return y - toph;
		    	}
			};
		
    	for (var i = 0; i < ttpList.length; ++i) {
    		maxw = Math.max(maxw, ttpList[i].containerNode.offsetWidth);
    		maxh = Math.max(maxh, ttpList[i].containerNode.offsetHeight);
    	}
    	x = originalX(x, maxw);
    	y = originalY(y, maxh, line);
    	for (var i = 0; i < ttpList.length; ++i) {
    		if (i % 2 == 0) {
        		p.push({l: x + targetWid + margin, t: y});
    		} else {
    			p.push({l: x - ttpList[i].containerNode.offsetWidth - margin, t: y});
    			y += maxh + margin;
    		}
    	}
    	return p;
    }

    var ttpList = [];
    mstrmojo.DocXtabGraph.multiTooltip = {
    		_posMultiTp: function(multiPos) {
        		for (var i = 0; i < ttpList.length; ++i) {
        			ttpList[i].domNode.style.left = multiPos[i].l + 'px';
        			ttpList[i].domNode.style.top = multiPos[i].t + 'px';
        		}
    		},
    		
            open: function(opener, e, win, as, config) {                
                if (!config) {
                    config = {};
                }
                config.e = e;
                config.win = win;
                var tw = 0;
                if (as && as.length) {
                	tw = getTargetWidth(as[0]);
                }

                for (var i = 0; i < as.length; ++i) {
                	var tp = ttpList[i];
                	if (!tp || !mstrmojo.all[tp.id]) {
                		tp = new mstrmojo.Tooltip();
                		var count = 0,
                			me = this;
                		
                		tp.optimizePos = function() {
                        	count++;
                        	if (count >= ttpList.length) {
                        		count = 0;
                        		me._posMultiTp(getMultiPosition(tw));
                        	}	
                		}; 
                		ttpList.push(tp);
                	}
                	opener.richTooltip.content = as[i] && as[i].getAttribute('ttl');
                	tp.open(opener, config);
                }
            },
            
            close: function() {
            	for (var j = ttpList.length - 1; j >= 0; --j) {
            		ttpList[j].close();
            	}
            	ttpList = [];
            }
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ViewSlider",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._IsRwDocument",
                         "mstrmojo.android.ui.LayoutSelector",
                         "mstrmojo.Label",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.func",
                         "mstrmojo.android.EnumOrientationTypes");

    mstrmojo.requiresDescs(4174);

    var $ARR = mstrmojo.array,
        $AFE = $ARR.forEach,
        $HASH = mstrmojo.hash,
        EnumOrientationTypes = mstrmojo.android.EnumOrientationTypes,
        OR_PORTRAIT = EnumOrientationTypes.PORTRAIT,
        OR_LANDSCAPE = EnumOrientationTypes.LANDSCAPE;

    
    function isInfoWindowLayout(l) {
        return (l.defn.iw !== undefined && l.defn.iw);
    }

    
    function getLoadingPlaceholder(view) {
        return new mstrmojo.Label({
            cssClass: 'pre-loader',
            n: view.n,
            k: view.k,
            isPreloader: true
        });
    }

    
    function updateLayoutSelector(currentLayout, noItems) {
        
        var layoutSelector = this.layoutSelector,
            supportedLayouts = this.getSupportedLayouts();

        
        if (!noItems) {
            
            layoutSelector.set('items', supportedLayouts);
        }

        
        layoutSelector.setCurrentTab($ARR.find(supportedLayouts, 'k', currentLayout.k));

        
        layoutSelector.set('visible', !!noItems);

        
        if (noItems) {
            
            layoutSelector.initiateFade();
        }
    }

    
    function findNextLayout(index, direction) {
        var allLayouts = this._layouts,
            orientation = mstrMobileApp.getOrientation(),
            wrapIdx = allLayouts.length - 1 - index,        
            hasWrapped = false,
            layout;

        
        var layouts = allLayouts.slice(index + 1);

        
        if (index) {
            
            layouts = layouts.concat(allLayouts.slice(0, index));
        }

        
        if (!direction) {
            
            layouts.reverse();

            
            wrapIdx = index;
        }

        
        $AFE(layouts, function (l, idx) {

            
            
            hasWrapped = (idx >= wrapIdx);

            
            if (((l.defn.or & orientation) > 0) && !isInfoWindowLayout(l)) {
                
                layout = l;

                
                return false;
            }
        });

        
        if (!layout) {
            
            return null;
        }

        
        return {
            wrap: hasWrapped,
            layout: layout
        };
    }


    function hasDifferentViewsOrientation() {
        
        
        var views = this.model.defn.views,
            len = (views && views.length) || 0,
            i;

        if (len) {
            var orientation = views[0].orientation;
            for (i = 1; i < len; i++) {
                if (orientation !== views[i].orientation) {
                    
                    return true;
                }
            }
        }

        return false;
    }

    
    function checkLayoutOrientation(key) {
        
        var layouts = this._layouts,
            orientationInfo = this._orientationInfo;

        
        if (!orientationInfo) {
            
            orientationInfo = this._orientationInfo = {};
            var portraitInfo = orientationInfo[OR_PORTRAIT] = {
                lyts: []
            };
            var landscapeInfo = orientationInfo[OR_LANDSCAPE] = {
                lyts: []
            };

            
            $ARR.forEach(layouts, function (layout) {
                
                var or = layout.defn.or,
                    info = orientationInfo[or];

                
                if (!isInfoWindowLayout(layout) && info !== undefined) {
                    
                    info.lyts.push(layout.k);
                }
            });

            
            if (portraitInfo.lyts.length || landscapeInfo.lyts.length) {
                
                orientationInfo.specific = true;
            }
        }

        var selectedLayout = layouts[$ARR.find(layouts, 'k', key)], 
            selectedOrientation = selectedLayout.defn.or,           
            selectedOrInfo = orientationInfo[selectedOrientation],  
            deviceOrientation = mstrMobileApp.getOrientation(),     
            rtn = {
                isSupported: true,                                  
                currentLayout: selectedLayout,
                specific: !!orientationInfo.specific
            };

        
        if (isInfoWindowLayout(selectedLayout) || ((selectedOrientation & deviceOrientation) === 0)) {
            
            rtn.isSupported = false;

            
            var deviceOrInfo = orientationInfo[deviceOrientation];

            
            if (selectedOrInfo === undefined || deviceOrInfo === undefined) {
                return rtn;
            }

            
            var targetLayoutKey = deviceOrInfo.lyts[$ARR.indexOf(selectedOrInfo.lyts, key)];
            if (targetLayoutKey) {
                
                rtn.newLayout = layouts[$ARR.find(layouts, 'k', targetLayoutKey)];

            } else {
                
                var lastLayout = deviceOrInfo.last;
                if (lastLayout) {
                    
                    rtn.newLayout = lastLayout;

                } else {
                    
                    $ARR.forEach(layouts, function (layout) {
                        
                        if (!isInfoWindowLayout(layout) && (layout.defn.or & deviceOrientation) > 0) {
                            
                            rtn.newLayout = layout;

                            
                            return false;
                        }
                    });
                }
            }

            
            selectedOrInfo.last = selectedLayout;

            
            if (!rtn.newLayout) {
                
                rtn.isStale = true;
            }
        } else {
            
            
            rtn.needNewLayout = hasDifferentViewsOrientation.call(this);
        }

        return rtn;
    }

    
    function getScrollLayoutInfo(touch) {
        
        var nextLayoutInfo = findNextLayout.call(this, $ARR.find(this._layouts, 'k', this.model.getCurrentLayoutKey()), (touch.delta.x < 0));

        
        return (nextLayoutInfo && !nextLayoutInfo.wrap) ? nextLayoutInfo : null;
    }

    
    function getImageWatermark() {
        var model = this.model,
            watermark = model && model.wm;

        
        if (watermark && watermark.tp === 3 && watermark.imgSrc) {
            return watermark;
        }

        
        return null;
    }

    
    function insertWatermark(wm) {
        
        var img = document.createElement('img'),
            style = img.style;

        
        this.watermarkNode = img;

        
        style.position = "absolute";
        style.top = 0;
        style.left = 0;
        
        style.visibility = 'hidden';

        
        var me = this;
        img.onload = function () {
            var iw = img.width,
                ih = img.height;
            
            if (wm.imgScale <= 0) { 
                var dn = me.domNode;

                if(dn) { 
                    img.width = dn.clientWidth;
                    img.height = dn.clientHeight;
                }

            } else { 
                var r = wm.imgScale / 100;
                
                img.width = iw * r;
                img.height = ih * r;

            }

            
            img.style.visibility = 'visible';
        };

        
        this.domNode.insertBefore(img, this.domNode.firstChild);
        var ds = this.model.getDataService();
        
        var imgSrcUrl = wm && wm.imgSrc;
        img.src = (imgSrcUrl && ds && ds.getDocImage && ds.getDocImage(imgSrcUrl)) || imgSrcUrl;
    }
    
    mstrmojo.android.ui.DocumentView = mstrmojo.declare(
        mstrmojo.android.ui.ViewSlider,

        [ mstrmojo._HasBuilder, mstrmojo._IsRwDocument ],

        
        {
            scriptClass: "mstrmojo.android.ui.DocumentView",

            postBuildRendering: function postBuildRendering() {
                var rtn = this._super(),
                    watermark = getImageWatermark.call(this);

                
                if (watermark) {
                    
                    insertWatermark.call(this, watermark);
                }

                return rtn;
            },

            buildChildren: function buildChildren(noAddChildren) {
                
                
                this._layouts = this._super(true);
            },

            beforeViewHidden: function beforeViewHidden(isBack) {
                
                this._stale = true;
                var lyt = this.getCurrentLayout();
                if (lyt && lyt.beforeViewHidden) {
                    lyt.beforeViewHidden(isBack);
                }
            },

            getViewController: function getViewController(view) {
                
                return null;
            },

            unrender: function unrender(ignoreDom) {
                
                delete this._stale;

                this._super(ignoreDom);
            },

            reloadLayout: function reloadLayout() {

            	var view = this.getCurrentView(),
            		id = this.id,
                    params = {
                        layoutKey: view.k,
                        reload: true,
                        executionOrientation: mstrMobileApp.getOrientation()
                    };

                this.getNewLayout(params, this._layouts, true, {
                    success: function (newLayout) {
	                    
            			var doc = mstrmojo.all[id];
            			doc.replaceView(newLayout, view,true);
	                    doc.resetSliderNodes();
	                }
                });
            },

            rootOrientationChange: function rootOrientationChange() {
                
                if (this._stale) {
                    
                    return;
                }

                
                var watermark = getImageWatermark.call(this);
                if (watermark && watermark.imgScale <= 0) {
                    
                    var watermarkNode = this.watermarkNode;
                    watermarkNode.width = parseInt(this.width, 10);
                    watermarkNode.height = parseInt(this.height, 10);
                }

                
                var view = this.getCurrentView();
                if (view.isPreloader) {
                    
                    return;
                }

                
                var layoutsCollection = this._layouts,
                    viewKey = view.k,
                    layoutInfo = checkLayoutOrientation.call(this, viewKey),
                    layout = layoutInfo.newLayout;

                
                if (layoutInfo.isStale) {
                    
                    return;
                }

                
                if (layoutInfo.specific) {
                    
                    updateLayoutSelector.call(this, view);
                }

                var needNewDocumentView = !!layoutInfo.needNewLayout,                                               
                    needNewOrientationLayout = !needNewDocumentView && (!layoutInfo.isSupported && layout),         
                    needNewFitLayout = !needNewOrientationLayout && (this.model.zt && !view.isFullScreenWidget);    

                
                if (needNewDocumentView || needNewOrientationLayout || needNewFitLayout) {
                    
                    mstrApp.closeAllDialogs();

                    var id = this.id,
                    	me = this,
                    	params = {
                            layoutKey: viewKey,
                            reload: true,
                            executionOrientation: mstrMobileApp.getOrientation()
                        },
                        fnSuccess = function (newLayout) {
                            
                            mstrmojo.all[id].replaceView(newLayout, me.getCurrentView());  
                            
                            me.resetSliderNodes();
                        };

                    
                    if (needNewOrientationLayout) {
                    
                        view = this.replaceView(getLoadingPlaceholder(layout), view, true);

                        
                        params.layoutKey = layout.k;

                        
                        delete params.reload;

                        
                        fnSuccess = mstrmojo.func.composite([ function (newLayout) {
                            
                            updateLayoutSelector.call(mstrmojo.all[id], newLayout);
                        }, fnSuccess ]);
                    }

                    
                    this.getNewLayout(params, layoutsCollection, true, {
                        success: fnSuccess
                    });
                }

                
                this.controller.generateActionToolbar();
            },

            onRender: function onRender() {
                
                if (!this.layoutSelector) {
                    
                    this.addChildren([{
                        scriptClass: 'mstrmojo.android.ui.LayoutSelector',
                        slot: 'overlayNode',
                        alias: 'layoutSelector',
                        visible: false,
                        tabSelected: function (item) {
                            this.parent.showLayout(item);
                        }
                    }]);
                }

                
                var lyt = this.getCurrentLayout();

                
                var layoutInfo = checkLayoutOrientation.call(this, this.model.getCurrentLayoutKey()),
                    currentLayout = layoutInfo.currentLayout,
                    me = this,
                    fnShow = function (lyt) {
                        
                        if (lyt && !lyt.domNode) {
                            
                            me.switchView(lyt);
                        } else {
                            
                            me.stackViews(lyt.slot);
                        }

                        return lyt;
                    };

                if (layoutInfo.needNewLayout && this.controller.isBack) {

                    fnShow(currentLayout);
                    var params = {
                        layoutKey: currentLayout.k,
                        reload: true,
                        executionOrientation: mstrMobileApp.getOrientation()
                    };

                    this.getNewLayout(params, this._layouts, true, {
                        success: function (newLayout) {
                            me.replaceView(newLayout, currentLayout);
                        }
                    });

                } else if (layoutInfo.isSupported) {  
                    
                    fnShow(currentLayout);

                    
                    updateLayoutSelector.call(this, currentLayout);

                } else {
                    
                    var layout = layoutInfo.newLayout;
                    if (layout) {
                        
                        currentLayout.defn.loaded = false;

                        
                        layout = fnShow(this.selectLayout(getLoadingPlaceholder(layout), false));

                        
                        this.getNewLayout({ layoutKey: layout.k }, this._layouts, true, {
                            success: function (newLayout) {
                                
                                updateLayoutSelector.call(me, newLayout);

                                
                                me.replaceView(newLayout, layout);

                            }
                        });

                    } else {
                        
                        this._ignoreOrientation = true;

                        
                        fnShow(currentLayout);
                    }
                }

            },

            
            showLayout: function showLayout(layout) {
                
                var key = layout.k,
                    doc = this;

                if (key !== this.model.getCurrentLayoutKey()) {
                    var params = {
                        layoutKey: key
                    };

                    if (hasDifferentViewsOrientation.call(this)) {
                        params.executionOrientation = mstrMobileApp.getOrientation();
                        params.reload = true;
                    }

                    
                    this.getNewLayout(params, this._layouts, true, {
                        success: function (newLayout) {
                            
                            doc.switchView(newLayout);
                        }
                    });

                    
                    return true;
                }

                
                return false;
            },

            afterSwitch: function afterSwitch(layout) {
                this._super(layout);

                
                this.selectLayout(layout, (layout.k !== this.model.getCurrentLayoutKey()));
            },

            
            selectLayout: function selectLayout(layout, updateServer, callback) {
                var _layout = this._super(layout, updateServer, callback);

                
                this.controller.getPageByTree(true);

                
                if (!layout.defn || !layout.defn.iw) {
                    
                    updateLayoutSelector.call(this, _layout, true);
                }

                return _layout;
            },

            replaceLayout: function replaceLayout(oldLayout, newLayoutNode) {
                
                var layouts = this._layouts || [],
                    idx = $ARR.find(layouts, 'k', oldLayout.k);

                
                if (idx >= 0) {
                    oldLayout.unrender();
                    oldLayout.destroy();
                }

                
                var c = this.builder.build([ newLayoutNode ], this.model)[0];

                
                
                if (idx >= 0) {
                    layouts[idx] = c;
                } else {
                    layouts.push(c);
                }

                
                this._layouts = layouts;

                
                return c;
            },

            onLayoutRebuilt: function onLayoutRebuilt(layout) {
                
                this.replaceView(layout, this.getCurrentView());
            },

            
            canScroll: function canScroll(touch) {
                return !!getScrollLayoutInfo.call(this, touch);
            },

            
            beginScroll: function beginScroll(touch, view) {
                
                if (this.isAnimating()) {
                    
                    return false;
                }

                
                delete this._scrollInfo;

                
                if (!view) {
                    
                    var layouts = this._layouts,
                        nextLayoutInfo = getScrollLayoutInfo.call(this, touch),
                        id = this.id;

                    
                    if (!nextLayoutInfo) {
                        
                        return;
                    }

                    
                    view = nextLayoutInfo.layout;

                    var orientation = mstrMobileApp.getOrientation(),
                    	docLayout = view.docLayout,
                    	
                    	
                        needNewLayout = hasDifferentViewsOrientation.call(this) || (this.model.zt && docLayout && orientation !== docLayout.defn.lastOrientation);

                    
                    if (!view.defn.loaded || needNewLayout) {
                        
                        view = getLoadingPlaceholder(view);
                        var params = {
                            layoutKey: view.k
                        };

                        if (needNewLayout) {
                            params.executionOrientation = orientation;
                            params.reload = true;
                        }

                        
                        this.getNewLayout(params, layouts, false, {
                            success: function (newLayout) {

                                
                                var me = mstrmojo.all[id],
                                    scrollInfo = me._scrollInfo;

                                if (scrollInfo) {
                                    
                                    scrollInfo.view = newLayout;
                                }

                                
                                me.replaceView(newLayout, view);
                            }
                        });
                    }
                }

                
                if (view) {
                    
                    this._super(touch, view);
                }
            },

            scrollStarted: function scrollStarted() {
                var layoutSelector = this.layoutSelector;

                
                layoutSelector.set('visible', true);

                
                layoutSelector.enterScroll();
            },

            scrollProgress: function scrollProgress(info, delta) {
                
                this.layoutSelector.scroll(delta);
            },

            scrollStopped: function scrollStopped(info, isComplete) {
                
                var layoutSelector = this.layoutSelector,
                    idx = layoutSelector.selectedIndex;

                
                if (isComplete) {
                    
                    idx += (info.isForward ? 1 : -1);
                }

                
                layoutSelector.exitScroll(idx);
            },

            
            scrollCanceled: function scrollCanceled(info) {
                this._super(info);

                
                var layout = info.oldView;

                this.model.getDataService().setCurrentDocLayout(layout.k);
                this.selectLayout(layout, false);

                
                this.layoutSelector.initiateFade();
            },

            
            scrollComplete: function scrollComplete(info) {
                this._super(info);

                
                var layout = info.newView;
                this.selectLayout(layout, (layout.k !== this.model.getCurrentLayoutKey()));

                
                this.controller.generateActionToolbar();
            },

            
            renderInfoWindow: function renderInfoWindow(infoWindow) {
                
                
                infoWindow.autoCloses = infoWindow.locksHover = false;

                
                if (mstrApp.isTablet()) {
                    
                    this._super(infoWindow);
                    return;
                }

                var controller = this.controller,
                    rootCtrl = controller.rootCtrl,
                    oldTitle = rootCtrl.getTitle(),
                    fnUpdateTitle = function (title) {
                        rootCtrl.updateContent(null, title);
                    },
                    shouldReleaseOrientation = false;

                
                this.fullScreenInfoWindow = true;

                
                controller.generateActionToolbar();

                
                var id = this.id;
                mstrApp.showDialog({
                    cssClass: 'FSInfoWindow',

                    children: infoWindow,

                    
                    resizeDialog: function resizeDialog() {
                        var rootView = mstrApp.rootView,
                            availableSpace = rootView.getContentDimensions(),
                            ens = this.editorNode && this.editorNode.style,
                            infoWindow = this.children[0],
                            iwn = infoWindow && infoWindow.infoNode;

                        
                        if (ens) {
                            
                            ens.top = (parseInt(rootView.getBrowserDimensions().h, 10) - availableSpace.h + 3) + 'px';
                            ens.left = '5px';
                        }


                        
                        if (iwn) {
                            var iwns = iwn.style;

                            iwns.height = availableSpace.h + 'px';
                            iwns.width = availableSpace.w + 'px';

                            
                            mstrmojo.all[infoWindow.psId].setInfoWindowDimensions(availableSpace);
                        }
                    },

                    onClose: function onClose() {
                        fnUpdateTitle(oldTitle);

                        
                        delete mstrmojo.all[id].fullScreenInfoWindow;

                        
                        controller.generateActionToolbar();
                        
                        if (shouldReleaseOrientation) {
                            
                            mstrMobileApp.releaseOrientation();
                        }

                        
                        var infoWindow = this.children[0];
                        if (infoWindow && infoWindow.clearAnchorHilites) {
                            infoWindow.clearAnchorHilites();
                        }
                    },

                    
                    positionDialog: mstrmojo.emptyFn
                });

                
                var panelStack = infoWindow.children[0];
                fnUpdateTitle(panelStack.getTitle());

                
                if (mstrMobileApp.getLockedOrientation() === 0) {
                    
                    mstrMobileApp.lockOrientation(mstrMobileApp.getOrientation());

                    
                    shouldReleaseOrientation = true;
                }

                
                panelStack.attachEventListener('titleChange', this.id, function (evt) {
                    
                    fnUpdateTitle(evt.value);
                });
            },

            
            updateInfoWindowPS: function updateInfoWindowPS(psID, psKey) {
                if (!mstrApp.isTablet()) {
                    
                    mstrmojo.all[psID].setInfoWindowDimensions(mstrApp.getContentDimensions());
                }
            },

            
            destroy: function destroy(ignoreDom) {
                
                $AFE(this._layouts, function (lyt) {
                    
                    lyt.destroy(ignoreDom);
                });

                
                this.builder.destroy();

                
                this._super(ignoreDom);
            },

            getLayouts: function () {
                return this._layouts;
            },

            
            getSelectedLayoutWidget: function getSelectedLayout() {
                return this.getCurrentView();
            },

            
            getNewLayout: function getNewLayout(params, layouts, isSelected, callback) {
                
                var controller = this.controller,
                    desired;

                if (controller && controller.getDesiredElements) {
                    desired = controller.getDesiredElements();
                    if (desired) {
                        params.desiredElements = desired;
                    }
                }

                
                callback.success = mstrmojo.func.composite([ callback.success, function () {
                    
                    controller.generateActionToolbar();
                }]);

                
                $HASH.forEach(this.ifwMap, function (infoWindow) {
                    
                    if (infoWindow.visible) {
                        
                        infoWindow.close();
                    }
                });

                
                return this._super(params, layouts, isSelected, callback);
            },

            
            
            
            
            unloadLayouts: function unloadLayouts(keys, gbFlag) {

                var layouts = this._layouts,
                    curKey = this.model.getCurrentLayoutKey(),
                    i,
                    cnt = (layouts && layouts.length) || 0,
                    lyt,
                    gbys,
                    defn,
                    iKey;

                for (i = 0; i < cnt; i++) {
                    lyt = layouts[i];
                    defn = lyt.defn;
                    if (lyt.k !== curKey && defn && defn.loaded) {
                        if (gbFlag) {
                            gbys = (lyt.gb && lyt.gb.groupbys);
                            if (gbys && gbys.length) {
                                defn.loaded = false;
                            }
                        } else if (keys) {
                            for (iKey = 0; iKey < keys.length; iKey++) {
                                if (lyt.k === keys[iKey]) {
                                    defn.loaded = false;
                                    break;
                                }
                            }
                        } else {
                            defn.loaded = false;
                        }
                    }
                }
            },

            
            getSupportedLayouts: function getSupportedLayouts() {
                
                var layouts = [],
                    orientation = mstrMobileApp.getOrientation();

                
                $AFE(this._layouts, function (l) {
                    
                    if (((l.defn.or & orientation) > 0) && (!isInfoWindowLayout(l))) {
                        
                        layouts.push(l);
                    }
                });

                return layouts;
            },

            
            getCurrentLayout: function getCurrentLayout() {
                var layouts = this._layouts;
                return layouts[$ARR.find(layouts, 'k', this.model.getCurrentLayoutKey())];
            },

            getCaptureDimensions: function getCaptureDimensions() {
                var layout = this.getCurrentLayout();
                return layout.getCaptureDimensions && layout.getCaptureDimensions();
            },

            closeInfoWindowsOnTablet: function closeInfoWindowsOnTablet() {
                if (mstrApp.isTablet()) {
                    
                    $HASH.forEach(this.ifwMap, function (infoWindow) {
                        
                        if (infoWindow.visible) {
                            
                            infoWindow.closeOnTablet();
                        }
                    });
                }
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.MobileDocLayoutViewer");
    
    var $CFC = mstrmojo.DynamicClassFactory.newComponent;
    
    
    
    mstrmojo.maps.MobileMapInfoWindowLayoutViewer = mstrmojo.declare(
        mstrmojo.MobileDocLayoutViewer, 
        null, 
        {
            scriptClass: 'mstrmojo.maps.MobileMapInfoWindowLayoutViewer',
            
            preBuildRendering: function preBuildRendering() {
                
                this.setDimensions(this.height, this.width);
                
                this.set('visible', true);       
            
                return this._super ? this._super() : true;
            }
        }
    );
    
    
     
    mstrmojo.maps.MapInfoWindowLayoutViewer = mstrmojo.declare(
        
        mstrmojo.MobileDocLayoutViewer,
        
        
        null,
        
        
        {
            scriptClass: "mstrmojo.maps.MapInfoWindowLayoutViewer",
            
            preBuildRendering: function preBuildRendering() {            
                
                this.set('visible', true);
                
                return this._super ? this._super() : true;
            }        
        }
    );
    
}());

(function() {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.maps.jsmap.InfoWindow"
                      );
    
    
    mstrmojo.maps.jsmap.InfoWindowController = mstrmojo.declare(
            
        mstrmojo.Obj,
        
        null,

        
        {
            scriptClass: "mstrmojo.maps.jsmap.InfoWindowController",
            
            start: function start(params) {
                params = params || {};
                
                
                var win = this.infoWindow = new mstrmojo.maps.jsmap.InfoWindow(params);
                win.start();                
            }
        });
})();
(function(){
    mstrmojo.requiresCls("mstrmojo.Dialog",
                         "mstrmojo._IsAnchorable",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller");
    
    var $D = mstrmojo.dom;
    
    function fnCloseDialog(){
        mstrApp.closeDialog();
    }
    
    
    mstrmojo.Magnifier = mstrmojo.declare(
        
        mstrmojo.Dialog,
        
        [mstrmojo._IsAnchorable, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],
        
        {
            scriptClass: "mstrmojo.Magnifier",
            
            cssClass: 'mstrmojo-magnifier anchor',

            markupString: '<div id="{@id}" class="mstrmojo-Dialog {@cssClass}">' +
                            '<div class="win mstrmojo-Editor" style="{@cssText}">' +
                                '<div class="mstrmojo-InfoViewer-Title"><div class="mstrmojo-Editor-title">{@title}</div></div>' +
                                '<div class="mstrmojo-InfoViewer-Content"></div>' + 
                                '<div class="mstrmojo-InfoViewer-Buttons"></div>' + 
                            '</div>' +
                            '<div class="mstrmojo-Editor-curtain"></div>' + 
                            '<div class="mstrmojo-Editor-tip"></div>' +
                         '</div>',
            
            anchorOrientation : 'h',
            
            anchorOffset: 0,
            
            baseTipClass: '',

            
            screenDim: null,
            
            width: 'auto',
            
            
            close: function close() {
                if (this.onClose) {
                    this.onClose();
                }
                
                $D.detachEvent(window, 'resize', fnCloseDialog);
                               
                this.destroy();
            },
            
            touchBegin: function touchBegin(touch) {
                
                this.helper.glowOnTap(touch.target);
            },
            
            touchTap: function touchTap(touch) {
                var target = touch.target;
                
                if (target === this.curtainNode) {
                    
                    mstrApp.closeDialog();
                }else {
                    
                    this.helper.handleTouchTap(target);
                }
            },
            
            touchSwipeEnd: function touchSwipeEnd(touch){
                this.helper.handleTouchSwipe(touch);
                this._super(touch);
            },
            
            preBuildRendering: function preBldRdr(){
                this._super();
                
                var dim = this.screenDim = mstrApp.getScreenDimensions(),
                    w = dim.w,
                    h = dim.h;
                
                if (mstrApp.isTablet()){
                    this.width = 'auto';
                }else{
                    
                    
                    this.width = (w > h ? (w * 0.4) : (w * 0.6)) + 'px';
                }
            },
            
            
            postBuildRendering: function(){
            	this._super();
                
                
                $D.attachEvent(window, 'resize', fnCloseDialog);                
            },
            
            
            updateContent: function () {
                var helper = this.helper;
                
                helper.createTitle(this.titleNode);
                
                helper.createContent(this.containerNode);
            },
            
            
            resizeAndPosition: function(anchorPos){
                var contentHeight = this.helper.getContentHeight(),
                    titleHeight = this.helper.titleHeight,
                    dim = this.screenDim,
                    totalHeight  = dim.h - 30, pos;

                
                this.height = Math.min(contentHeight, totalHeight - titleHeight);
                this.containerNode.style.height = this.height + 'px';
                
                this.updateScroller();
                
                if (anchorPos){
                    this.moveTo(anchorPos);
                }else{
                    pos = $D.position(this.editorNode);

                    
                    if (!(pos.x > 0 && pos.x + pos.w < dim.w && pos.y > 0 && pos.y + pos.h < dim.h)){
                        this.positionDialog();
                    }
                }
                
                window.setTimeout(function() {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },
            
            
            moveTo: function(anchorPosition) {
                this.anchorPosition = anchorPosition;
                this.positionDialog();
            },
            
            
            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    idx = this.helper.currentTabIndex,
                    scrollEl = this.containerNode.children[idx];

                cfg.bounces = false;

                if (scrollEl){
                    
                    cfg.scrollEl = scrollEl;
    
                    
                    cfg.origin = cfg.origin || {
                        x: 0,
                        y: 0
                    };
    
                    
                    cfg.noVScroll = cfg.noHScroll = true;
                    
                    
                    var offsetEnd = Math.max(this.helper.getContentHeight() - this.height, 0);
    
                    
                    var enableScroll = cfg.vScroll = (offsetEnd !== 0);
                    if (enableScroll) {
                        
                        cfg.offset = {
                            y: {
                                start: 0,
                                end: offsetEnd
                            }
                        };
                    }
                }

                return cfg;
            }
        });
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.fx",
                         "mstrmojo.Dialog",
                         "mstrmojo._IsPopup",
                         "mstrmojo._HasPopup",
                         "mstrmojo._IsMovable");

    var $D = mstrmojo.dom;

    
    mstrmojo.Editor = mstrmojo.declare(

        mstrmojo.Dialog,

        [ mstrmojo._IsPopup, mstrmojo._HasPopup, mstrmojo._IsMovable ],

        
        {
            scriptClass: "mstrmojo.Editor",

            
            title: '',

            
            help: '',

            
            autoClose: false,

            
            showTitle: true,

            
            openEffect: null,

            
            closeEffect: null,

            markupString: '<div id="{@id}" class="mstrmojo-Editor-wrapper">' +
                            '<div class="mstrmojo-Editor {@cssClass}" style="z-index:{@zIndex};{@cssText}" mstrAttach:mousedown>{@titlebarHTML}' +
                                '<div class="mstrmojo-Editor-content"></div>' +
                                '<div class="mstrmojo-Editor-buttons"></div>' +
                            '</div>' +
                            '<div class="mstrmojo-Editor-curtain"></div>' +
                          '</div>',

            titleMarkupString: '<div style="position:absolute;width:100%;"><table cellspacing="0" cellpadding="0" class="mstrmojo-Editor-titlebar"><tr>' +
                          '<td class="mstrmojo-Editor-titleCell"><div class="mstrmojo-Editor-title"></div></td>' +
                          '<td><a href="#" target="_new" class="mstrmojo-Editor-help"><img class="mstrmojo-Editor-help" src="../images/1ptrans.gif" title="' + mstrmojo.desc(1143, "help") + '"></img></a></td>' +
                          '<td><div class="mstrmojo-Editor-close" title="' + mstrmojo.desc(2102, "Close") + '"></div></td>' +
                     '</tr></table></div><div class="mstrmojo-Editor-titleSpacer"></div>',

            markupSlots: {
                editorNode: function () { return this.domNode.firstChild; },
                titlebarNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild : null; },
                titleNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild.rows[0].cells[0].firstChild : null; },
                helpNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild.rows[0].cells[1].firstChild : null; },
                closeNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild.rows[0].cells[2].firstChild : null; },
                containerNode: function () { return this.domNode.firstChild.childNodes[2]; },
                buttonNode: function () { return this.domNode.firstChild.childNodes[3]; },
                curtainNode: function () {return this.domNode.lastChild; }
            },

            markupMethods: {
                ontitleChange: function () {
                    if (this.showTitle) {
                        this.titleNode.innerHTML = this.title;
                    }
                },

                onzIndexChange: function () {
                    var zIndex = this.zIndex;
                    this.editorNode.style.zIndex = zIndex;
                    this.curtainNode.style.zIndex = zIndex - 1;
                },

                onvisibleChange: function (init) {
                    if (init) {
                        return;
                    }

                    var v = this.visible,
                        fx = 'closeEffect',
                        d = 'none';

                    if (v) {
                        fx = 'openEffect';
                        d = 'block';
                    }

                    if (this[fx]) {
                        this.playEffect(fx);

                    } else {
                        this.editorNode.style.display = d;
                        if (this.modal) {
                            this.curtainNode.style.display = d;
                        }
                    }
                },

                onhelpChange: function () {
                    if (this.showTitle) {
                        if (this.help === null) {
                            this.helpNode.style.display = 'none';
                        }

                        this.helpNode.href = (mstrApp.helpUrl || '../help/')  + 'WebUser/WebHelp/Lang_' + (mstrApp.helpLocaleId ? mstrApp.helpLocaleId : mstrApp.localeId) +
                            '/'+(mstrApp.userHelpPage || 'MicroStrategy_Web_Help.htm')+'#' + (this.help || '');
                    }
                },

                onleftChange: function () { this.editorNode.style.left = this.left || ''; },
                ontopChange: function () { this.editorNode.style.top = this.top || ''; }
            },

            
            preBuildRendering: function preBuildRendering() {
                if (!this.slot && !this.placeholder) {
                    this.placeholder = document.body.appendChild(document.createElement('div'));
                    this._curtain_to_body = true;
                }

                this.titlebarHTML = (this.showTitle) ? this.titleMarkupString : '<div></div><div></div>';

                return this._super();
            },

            getMovingHandle: function getMovingHandle() {
                return this.titlebarNode;
            },

            getMovingTarget: function getMovingTarget() {
                return this.editorNode;
            },

            
            onPreClose: function() {
                return true;
            },
            
            premousedown: function premousedown(evt) {
                var target = $D.eventTarget(evt.hWin, evt.e);
                if (target === this.closeNode) {
                 
                    if (this.onPreClose()) {
                        this.close();
                    }
                }
            },

            
            _set_visible: function _set_visible(n, v) {
                
                var bChanged = (this[n] !== v);
                if (bChanged) {
                    
                    this[n] = v;

                    var closeHandler = this._close_handler;

                    
                    if (v) {
                        if (this._curtain_to_body) {
                            this.resizeDialog();
                            this.positionDialog();
                        }

                        
                        if (this.autoClose) {
                            var me = this;

                            closeHandler = this._close_handler = closeHandler || function (evt) {
                                var t = $D.eventTarget(self, evt); 
                                if (t && t.parentNode && !$D.contains(me.editorNode, t, true, document.body)) {
                                    me.close();
                                }
                            };

                            $D.attachEvent(document.body, 'mousedown', closeHandler);
                        }
                    } else {
                        var curtainHandler = this._curtain_handler;

                        
                        if (curtainHandler) {
                            
                            $D.detachEvent(window, 'resize', curtainHandler);
                        }

                        
                        if (closeHandler) {
                            
                            $D.detachEvent(document.body, 'mousedown', closeHandler);
                        }
                    }
                }

                return bChanged;
            }
        }
    );

    mstrmojo.Editor.openEffect_fadeIn = {
        scriptClass: 'mstrmojo.fx.AnimateProp',
        slot: 'curtainNode',
        props: {
            backgroundColor: {
                start: 255,
                stop: 0,

                
                fn: function (v) {
                    v = Math.round(v);
                    return ['rgb(', v, ',', v, ',', v, ')'].join('');
                }
            }
        },

        preStart: function () {
            var target = this.target,
                widget = this.widget;

            widget.editorNode.style.display = 'block';

            if (!widget.modal) {
                return false;
            }

            target.style.display = 'block';
            mstrmojo.css.setOpacity(target, 60);

            return true;
        }
    };

    mstrmojo.Editor.closeEffect_fadeOut = {
        scriptClass: 'mstrmojo.fx.FadeOut',
        slot: 'curtainNode',
        start: 0.6,
        stop: 0,
        preStart: function () {
            var widget = this.widget;
            widget.editorNode.style.display = 'none';

            return !!widget.modal;
        }
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Dialog",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo._IsAnchorable"
    					);
    
    var $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array;
    
    
    
    
    
    
    mstrmojo.VisHeatMapPopupPanel = mstrmojo.declare(
    	mstrmojo.Container,
    	
		null,
    	
	{
		scriptClass: "mstrmojo.VisHeatMapPopupPanel",

		title: "",


		markupString: '<div id="{@id}" class="heatmap-popup-panel" style="{@cssText}">' +
					       '</div>',

			markupSlots: {
				containerNode: function () { return this.domNode;}
			},
			
			initialized: false,
			
			naviAction: null 
    	}
    );
    
	mstrmojo.VisHeatMapAnimation = (function () { 
		var animationSet = []; 
		return {
				animate: function (node, propName, orgStyle, targetStyle, duration, callback) { 
					var thisObj;
					var emptyPos = animationSet.length;
					for (var i = 0, len = animationSet.length; i < len; i++) {
						if (!animationSet[i]) { 
							emptyPos = i;
							continue;
						}
						if (animationSet[i].node === node && animationSet[i].propName === propName) {
							
							(animationSet[i].finalize(false)); 
							thisObj = animationSet[i];
							break;
						}
					}
					if (!thisObj) { 
						thisObj = {};
						thisObj.node = node;
						thisObj.index = emptyPos;
						thisObj.propName = propName;
						animationSet[emptyPos] = thisObj;
					}
					var startTime = (new Date()).getTime();
					var duration = duration || 500; 
					var interval = 20; 
					
					var timer = null;
					thisObj.finalize = function ( removeNode) {
						
						clearInterval(timer);
						timer = null;
						
						
						if (targetStyle.r !== undefined) { 
							targetStyle.a = targetStyle.a || 1;
							
							
							node.style[propName] = "";
						} else if (targetStyle.px !== undefined) { 
							node.style[propName] = targetStyle.px + "px";
						}
						
						
						if (removeNode) {
							delete animationSet[this.index];
						}
						
						
						if (callback) {
							callback();
						}
					};
					
					function setStyle () {
						
						var curStyle = {};
						var curTime = (new Date()).getTime();
						var timeDiff = curTime - startTime;
						if (timeDiff >= duration) {
							
							thisObj.finalize(true); 
							return;
						}
						
						for (var prop in orgStyle) {
							curStyle[prop] = (targetStyle[prop] - orgStyle[prop]) * timeDiff / duration + orgStyle[prop]; 
							if (prop !== "a") {
								curStyle[prop] = Math.round(curStyle[prop]);
							}
						};
						
						if (curStyle.r) { 
							curStyle.a = curStyle.a || 1;
							node.style[propName] = "rgba(" + curStyle.r + "," + curStyle.g + "," + curStyle.b + "," + curStyle.a + ")";
						} else if (curStyle.px) { 
							node.style[propName] = curStyle.px + "px";
						}
					}
					timer = setInterval(setStyle, interval);
				}
			};
	})();
    
    
    
    mstrmojo.VisHeatMapPopup = mstrmojo.declare(

    	mstrmojo.Container,

    	
		null,
        
        
        {
            scriptClass: "mstrmojo.VisHeatMapPopup",
            
            
            fadeOnClose: false,
            
            
            autoClose: true,
            
            
            markupString:'<div style="display: -webkit-box; -webkit-box-align: start; -webkit-box-pack: center;position:absolute; left:0px; top:0px; z-index:100000; width: 100%; height:100%;"  id={@id} mstrAttach:mouseup,touchend>' + 
	            			'<div id={@id} style=" position:relative; left: 0px; top: 0px; width:{@width}; background-color:#F5F5F5;z-index:100001;border:2px solid rgba(0, 0, 0, 0.1);-webkit-box-shadow:rgba(0, 0, 0, 0.45) 2px 2px 8px;">' +
	        						'<div  class="heatmap-popup-panel-title" style="display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: center;position:relative; -webkit-box-sizing: border-box; margin-bottom:6px; padding-right: 25%; height:65px; width:100%; line-height:65px;vertical-align:bottom;color:#33b5e5;">' +
	        							
	        						'</div>' +
	        						'<div style="height: 2px;width:100%;background-color:#33b5e5">' +
	        						'</div>' +
	        						'<div style="width:100%; height:auto; position:relative;overflow:hidden; display: -webkit-box; -webkit-box-orient: horizontal">' +
	        						'</div>' +
	    					'</div>' +
	    					'<div style="position:absolute;z-index:100000;top:0px;left:0px;width:100%;height:100%;background: rgba(0, 0, 0, 0.5);">' +
	    					'</div>' +
    					'</div>',

			markupSlots: {
				contentNode: function () {return this.domNode.firstChild;},
				titleNode: function () {return this.domNode.firstChild.firstChild;},
				
				containerNode: function () {return this.domNode.firstChild.lastChild;},
				curtainNode: function () {return this.domNode.lastChild;}
			},
         
			baseTipClass: "heatmap-editor-tip",
			
			
			anchorOffset: 42,
			
			
			hasCloseButton: true,

            goBack: function () {
                    
                    return this.close();
            },
			
			
            
			close: function () {
                    this.domNode.style.webkitTransform = 'translate(-100000px,0px)';
                    this.destroy();
                    
                    return true;
			},

            destroy: function() {
                    this.onClose();
                    if(this._super){
                            this._super();
                    }
            },

			postBuildRendering: function () {
				this._super();

				
				
				
				for (var i = 0, len = this.panels.length; i < len; i++) {
					
					if (i !== 0) {
						
						var div = document.createElement("div");
						div.style.cssText = "position:relative;width:1px;color:grey;height:35px;text-align:center;background-color:grey;"; 
						
						this.titleNode.appendChild(div);
					}
					var div = document.createElement("div");
					div.style.cssText = "-webkit-box-flex:1; line-height:65px;text-align:center; display: -webkit-box; -webkit-box-align: center; -webkit-box-pack: center; height:100%;";
                    if(i==0)
                            div.style.cssText += 'margin-left:16px;';
                    else
                            div.style.cssText += 'margin-right:16px;';
					div.setAttribute("panel", i);
					div.innerText = this.panels[i].title;
					this.titleNode.appendChild(div);
				}
				
				var that = this;
				document.body.appendChild(this.domNode);
				
				this.panelStack = 0;
				this.navigateTo(0);
                this.contentNode.style.marginTop = parseInt((document.body.offsetHeight - this.contentMaxHeight - this.titleNode.offsetHeight) / 2) + 'px';
			},			
			
			
			onmouseup: function (event) {
				if (event.e.target === this.curtainNode) {
					this.close();
					return;
				}
				var title = mstrmojo.dom.findAncestorByAttr(event.e.target, "panel", true, this.domNode);
				if (!title) {
					return;
				}

				
				
				
				title.node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
				var callback = function () {
					mstrmojo.VisHeatMapAnimation.animate(title.node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
				};
				var that = this;
				setTimeout(function () {
    		   		setTimeout(function () {
    		   			that.navigateTo(title.value);
    		   			callback();
    		   		}, 0);
    		   },0); 
				
			},
			
			ontouchend: function (event) {
				this.onmouseup(event);
			},

            highlightTitle: function (titleIndex) {
                    titleIndex =  2*parseInt(titleIndex);
                    if(isNaN(titleIndex))
                            return;
                    var titles = this.titleNode.childNodes,
                        len = titles.length;
                    for( var i = 0; i < len; i+=2){
                        if(i != titleIndex){
                               titles[i].style.borderBottom = '';
                        }else{
                                titles[i].style.borderBottom = 'solid 6px #33b5e5';
                        }
                    }
            },
			
            
            panelStack: 0, 
            
			
			navigateTo: function (panelIndex) {
                this.highlightTitle(panelIndex);

				var newPanel = this.panels[panelIndex];
				var curPanel = this.panelStack;
			    var oldPanel = this.panels[curPanel];
                
                if(panelIndex != curPanel){
                        if(oldPanel.hasRendered){
                                oldPanel.domNode.style.display = 'none';
                        }
                }
				if (!newPanel.hasRendered) {
					this.panels[panelIndex] = new mstrmojo.VisHeatMapPopupPanel(this.panels[panelIndex]);
					var newPanel = this.panels[panelIndex];
					this.addChildren(newPanel);
					this.renderChildren();
					
					
				}
                newPanel.domNode.style.display = 'block';
				if (newPanel.naviAction) {
					newPanel.naviAction(); 
				}

				
				
				if (curPanel === panelIndex) {
					
					
					
					delete newPanel.domNode.style["webkitTransform"];
				} else {
					
					var oldWidth = oldPanel.domNode.offsetWidth + "px";
					var newWidth = newPanel.domNode.offsetWidth + "px";

					
					
					var maxWidth = Math.max(parseInt(oldWidth), parseInt(newWidth));
					
					delete newPanel.domNode.style["webkitTransition"];
					var newStyle = "";
					var oldStyle = "";
					if (curPanel < panelIndex) { 
						newStyle = "translate(-" + maxWidth + "px,0px)";
						
						oldStyle = "translate(-" + maxWidth + "px,0px)";
					} else { 
						newStyle = "translate(" + maxWidth + "px,0px)";
						
						oldStyle = "translate(" + maxWidth + "px,0px)";
					}
					
					
					
					
                    
					this.panelStack = panelIndex;

					
				}
				
				
				
				
				
				
				
			},
			
            animation: function (newPanel, oldPanel, oldStyle) {
            	
            	
				oldPanel.domNode.style["webkitTransform"] = oldStyle;
            	
				newPanel.domNode.style["webkitTransform"] = oldStyle;
				
            },
			
			
			
			dummy: true
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Dialog",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo._IsAnchorable");

    var $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array;

    
    mstrmojo.android.Popup = mstrmojo.declare(

        mstrmojo.Dialog,

        [mstrmojo._IsAnchorable],

        
        {
            scriptClass: "mstrmojo.android.Popup",

            
            fadeOnClose: false,

            
            autoClose: true,

            
            init: function init(props) {
                
                this._super(props);

                
                if (this.anchor) {
                    mstrmojo.css.addWidgetCssClass(this, 'anchor');
                }
            },

            addChildren: function addChildren(children, idx, silent) {
                this._super(children, idx, silent);

                
                $ARR.forEach(this.children, function (child) {
                    
                    if (child.isElastic) {
                        
                        this._elasticChild = child;

                        
                        return false;
                    }
                }, this);
            },

            resizeDialog: function resizeDialog() {
                
                var editorNode = this.editorNode,
                    app = mstrApp,
                    dimensions = app.getScreenDimensions(),
                    mh = Math.round(dimensions.h * 0.9),
                    w = dimensions.w,
                    contentHeight;

                
                w = w * 0.85;

                
                if (app.isTablet()) {
                    var popDimensions = this.popDimensions || {},
                        tabletDimensions = mstrApp.getScreenDimensions();

                    
                    mh = popDimensions.h || Math.min(Math.round(tabletDimensions.h * 0.6), mh);
                    w = popDimensions.w ||  Math.min(Math.round(tabletDimensions.w * (mstrApp.isLandscape() ? 0.43 : 0.65)), w);
                }

                
                w += 'px';

                
                var elasticChild = this._elasticChild;
                if (elasticChild) {
                    
                    var elasticHeight = elasticChild.elasticHeight;
                    if (elasticHeight) {
                        
                        contentHeight = elasticHeight;

                    
                    } else if (elasticChild.getItemsContainerHeight) {
                        
                        contentHeight = elasticChild.getItemsContainerHeight();
                    }
                }

                
                if (contentHeight === undefined) {
                    
                    contentHeight = this.getAvailableContentSpace();

                    
                    
                    mh = Math.max( mh, contentHeight + (this.titleNode.offsetHeight + this.buttonNode.offsetHeight) );
                    
                } else {
                    
                    contentHeight = Math.min(contentHeight, mh - (this.titleNode.offsetHeight + this.buttonNode.offsetHeight));
                }

                
                if (editorNode) {
                    
                    editorNode.style.maxHeight = mh + 'px';

                    
                    this.set('width', w);
                } else {
                    
                    this.width = w;
                    this.cssText = (this.cssText || '') + 'max-height:' + mh + 'px;';
                }

                
                this.raiseEvent({
                    name: 'popupResized',
                    maxheight: mh,
                    height: contentHeight,
                    width: parseInt(w, 10)
                });

                
                if (elasticChild) {
                    
                    var h = elasticChild.height;
                    if (h !== undefined && h !== 'auto') {
                        
                        elasticChild.set('height', 'auto');
                    }

                    
                    elasticChild.set('height', contentHeight + 'px');

                    
                    
                    if (elasticChild.updateScroller) {
                        
                        elasticChild.updateScroller();
                    }
                }

                this._super();
            },

            getAvailableContentSpace: function getAvailableContentSpace() {
            	
            	
                return Math.max(this.containerNode.offsetHeight, this.editorNode.clientHeight - this.titleNode.offsetHeight - this.buttonNode.offsetHeight);
            },

            close: function close() {
                
                if (this.onClose) {
                    
                    this.onClose();
                }

                
                if (this.fadeOnClose) {
                    
                    var domNode = this.domNode;
                    if (domNode) {
                        var id = this.id;

                        if (!$DOM.isWinPhone) {

                            $DOM.attachOneTimeEvent(domNode, $DOM.CSS3_TRANSITION_END, function () {
                                mstrmojo.all[id].destroy();
                            });

                            
                            domNode.style.opacity = 0;

                        } else {

                            (new mstrmojo.fx.FadeOut({
                                onEnd: function () {
                                    mstrmojo.all[id].destroy();
                                },
                                target: domNode,
                                duration: 400
                            })).play();

                        }
                    }
                } else {
                    this.destroy();
                }
            },

            onclick: function onclick(evt) {
                
                if (this.autoClose && evt.e.target === this.curtainNode) {
                    
                    this.close();
                }
            },

            ontouchend: function ontouchend(evt) {
                
                this.onclick(evt);
            }
        }
    );
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.TableLayoutList");

    
    mstrmojo._IsTableLayoutListDIC = mstrmojo.provide(

        "mstrmojo._IsTableLayoutListDIC",
        
        {
            _mixinName: 'mstrmojo._IsTableLayoutListDIC',

            icnCss: 'dicContainer',
            
            tableLayoutCssStyle: 'fixed',
            
            
            setDirtyFlag: function(c, d) {
                if (c.className !== 'flag-container') {
                    var f = document.createElement('div'), w = this.itemsNode
                            && this.itemsNode.clientWidth - 8;
                    f.className = 'flag-container';
                    f.style.left = (w > 0 ? w : 0) + 'px';
                    f.innerHTML = '<div class="dirty-cell"/>';
                    d.insertBefore(f, c);
                }
            }
        });
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.CheckBoxDIC",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var MIN_HEIGHT_MDPI = 24,
        MIN_HEIGHT_HDPI = 36,
        MIN_HEIGHT_XHDPI = 48,
        MIN_HEIGHT = {160: MIN_HEIGHT_MDPI,
                      213: MIN_HEIGHT_MDPI,
                      240: MIN_HEIGHT_HDPI,
                      320: MIN_HEIGHT_XHDPI},
        SCROLLER_OFFSET_X = {160: 48,
                             213: 48,
                             240: 73,
                             320: 98},
        SWITCH_DURATION = 300,
        $C = mstrmojo.css,
        $D = mstrmojo.dom;

    function toggleBtn(isOn) {
        this.btnNode.innerHTML = isOn ? this.onText : this.offText;
        $C.toggleClass(this.btnNode, 'on', isOn);
        $C.toggleClass(this.btnNode, 'off', !isOn);
    }

    function clearAnimationTimeout() {
        if (this._animHandle) {
            window.clearTimeout(this._animHandle);
            delete this._animHandle;
        }
    }

    
    function applyTransform(duration, value) {
        this._scroller.origin.x = value;

        if (!duration) return;

        var style = this.scrollNode.style,
            me = this;

        this._isAnimating = true;
        style[$D.CSS3_TRANSITION_DURATION] = duration + 'ms';
        style[$D.CSS3_TRANSFORM] = $D.createTranslateString(-value);

        this._animHandle = window.setTimeout(function() {
            if (me._isAnimating) { me._isAnimating = false; }
            clearAnimationTimeout.call(me);
        }, duration * 3);
    }
    
    mstrmojo.android.inputControls.CheckBoxDIC = mstrmojo.declare(

        mstrmojo.CheckBoxDIC,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo.android._HasPreviewButton ],

        
        {
            scriptClass: 'mstrmojo.android.inputControls.CheckBoxDIC',
            cssText: 'cursor:pointer;',
            cssDisplay: 'inline-block',

            onText: 'ON',
            offText: 'OFF',

            isSwitchStyle: false,

            
            markupString: '<div id="{@id}" class="mstrmojo-Label mstrmojo-CheckBoxDIC {@cssClass}" style="{@cssText}" mstrAttach:click,keydown>' +
                    '<div class="checkBox-android-wrapper">' +
                        '<div class="checkBox-android-scrollable">' +
                            '<div class="checkBox-androidMobile-button off"></div>' +
                            '<div class="checkBox-label-text"></div>' +
                        '</div>' +
                    '</div>' +
                '</div>',

            markupSlots: {
                scrollNode: function () { return this.domNode.firstChild.firstChild; },
                textNode: function () { return this.domNode.firstChild.firstChild.lastChild; },
                btnNode: function () { return this.domNode.firstChild.firstChild.firstChild; }
            },

            
            markupMethods: mstrmojo.hash.copy({
                ontextChange: function () { this.textNode.innerHTML = (this.text != null) ? this.text : ''; }
            }, mstrmojo.hash.copy(mstrmojo.CheckBoxDIC.prototype.markupMethods)),

            init: function init(props) {
                this._super && this._super(props);
                if (this.dic.stl == 0) {
                    this.isSwitchStyle = true;
                    var dpi = mstrMobileApp.getDeviceDPI();

                    this.maxOffsetX = SCROLLER_OFFSET_X[dpi];
                    this.scrollerConfig = {
                        showScrollbars: false,
                        showIndicators: false,
                        vScroll: false,
                        hScroll: true,
                        bounces: false,
                        useTranslate3d: false,
                        offset: { x: {end: this.maxOffsetX, start: 0},
                                 scrollPast: false
                        }
                    };
                    this.minHeight = MIN_HEIGHT[dpi] || MIN_HEIGHT_MDPI;
                }
            },

            updateScrollerConfig: function updateScrollerConfig() {
                if (!this.isSwitchStyle) return;
                var cfg = this._super(),
                    originX = this.checked ? 0 : (this.maxOffsetX || 0);
                mstrmojo.hash.copy({
                    scrollEl: this.scrollNode,
                    origin: {
                        x: originX,
                        y: 0
                    }
                }, cfg);
                return cfg;
            },

            updateScroller: function updateScroller(noScrollToOrigin, duration) {
                if (!this.isSwitchStyle) return;
                this._super(noScrollToOrigin, duration);
            },

            initScroller: function initScroller(scroller) {
                if (!this.isSwitchStyle) return;
                this._super(scroller);

                var me = this;
                
                scroller.attachEventListener('scrollMoved', this.id, function (evt) {
                    this._translateX = evt.x; 
                    toggleBtn.call(me, (evt.x < me.maxOffsetX / 2));
                });
            },

            oncheckedChange: function oncheckedChange(e) {
                if (this.isSwitchStyle) {
                    if (this.checked && this._scroller.origin.x !== 0) {
                        applyTransform.call(this, SWITCH_DURATION, 0);
                    } else if (!this.checked && this._scroller.origin.x !== this.maxOffsetX) {
                        applyTransform.call(this, SWITCH_DURATION, this.maxOffsetX);
                    }
                    toggleBtn.call(this, this.checked);
                }
                this._super && this._super(e);
            },

            preBuildRendering: function preBuildRendering() {
                this.cssClass = this.isSwitchStyle ? 'Android-tristate-mobile' : 'Android-tristate';
                
                var alignment;

                
                switch (this.owner.getFormats()['text-align']) {
                case 'center':
                    
                    alignment = '50%';
                    break;

                case 'right':
                    
                    alignment = '100%';
                    break;
                }

                
                if (alignment) {
                    
                    this.cssText += 'background-position:' + alignment + ' 50%;';
                }

                return this._super();
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                if (this.isSwitchStyle) {
                    toggleBtn.call(this, this.checked);
                    
                    
                    this.domNode.style.height = (this.openerStyle.ih > this.minHeight ? this.openerStyle.ih : this.minHeight) + 'px';
                 }
            },

            touchTap: function touchTap(touch) {
                this.onclick();
            },

            touchBegin: function touchBegin(touch) {
                if (!this.isSwitchStyle) return;
                if (this._isAnimating) {
                    touch.stop();
                    return false;
                }
                return this._super(touch);
            },

            touchSwipeEnd: function(touch) {
                if (!this.isSwitchStyle) return;
                
                touch.evt.handle = true;
                var posX = this._translateX,
                    isOn = (posX < this.maxOffsetX / 2),
                    value = isOn ? posX : (this.maxOffsetX - posX),
                    duration = value * SWITCH_DURATION / this.maxOffsetX;
                applyTransform.call(this, duration, isOn ? 0 : this.maxOffsetX);
                this.set('checked', isOn);
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                if (this.isSwitchStyle) {
                    mstrmojo.css.addClass(this.domNode.firstChild || d, 'tx-active');
                } else {
                    this._super(c, d);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ResultSetView",
                         "mstrmojo.dom");

    var $100 = '100%';

    
    mstrmojo.android.medium.ui.ResultSetView = mstrmojo.declare(

        mstrmojo.android.ui.ResultSetView,

        null,

        {
            scriptClass: "mstrmojo.android.medium.ui.ResultSetView",

            markupString: '<div id="{@id}" class="{@cssClass}" style="{@cssText}">' +
                              '<div class="mstrmojo-ResultSetView-content"></div>' +
                              '<div class="mstrmojo-ResultSetView-toolbar"></div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; },
                toolbarNode: function () { return this.domNode.lastChild; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },

            layoutConfig: {
                h: {
                    containerNode: $100,
                    toolbarNode: 'auto'
                },
                w: {
                    containerNode: $100,
                    toolbarNode: $100
                }
            },

            children: [{
                scriptClass: 'mstrmojo.android.ui.ActionToolbar',
                slot: 'toolbarNode',
                alias: 'toolbar',
                fullscreenDirection: 'down'
            }],

            rootOrientationChange: function rootOrientationChange() {
                
                this.controller.generateActionToolbar();
            },
 
            delegateToolbar: function delegateToolbar(tbCfg) {
                
                var actions = mstrmojo.android.ui.ActionToolbar.newToolbarConfig(),
                    minBtnCnt = 1,                                                      
                    maxBtnCnt = Math.round(mstrMobileApp.getDeviceDPI() / 63) + 1,      
                    rtn = false,
                    controller = this.controller;

                
                
                
                if (!mstrApp.isLandscape() && this.controller.canDelegateToolBar()) {
                    
                    tbCfg.minBtnCount = minBtnCnt;
                    tbCfg.maxBtnCount = maxBtnCnt;

                    
                    actions = tbCfg;

                    
                    controller.toolBarDelegated = true;
                    
                    
                    rtn = true;                    
                }else{
                	controller.toolBarDelegated = false;
                }

                
                this.toolbar.setActions(this.controller.id, actions);

                
                this.doLayout();

                return rtn;
            },

            setActionToolbarStatus: function setActionToolbarStatus(isActive) {
                this.toolbar.set('active', isActive);
            },

            enterFullScreen: function enterFullScreen() {
                this.toolbar.enterFullScreen();

                this._super();
            },

            exitFullScreen: function exitFullScreen(animation) {
                if (this.domNode) {
                    this.toolbar.exitFullScreen(animation);

                    this._super(animation);
                }
            },

            flashFullScreen: function flashFullScreen() {
                this.toolbar.flashFullScreen();
            },

            cancelFlashFullScreen: function cancelFlashFullScreen() {
                this.toolbar.cancelFlashFullScreen();
            },

            getPosition: function getPosition() {
                var position;
                if (this.containerNode) {
                    position = mstrmojo.dom.position(this.containerNode);
                }

                return position;
            }
        }
    );
}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.WidgetList", "mstrmojo.dom", "mstrmojo.TreeNodeSelector");
    
    var _D = mstrmojo.dom,
        NODE_STATE_CSS_MAP = {
            0: 'closed',
            1: 'opened',
            2: 'leaf'
        };
    
    
    mstrmojo.TreeNode = mstrmojo.declare(
        
        mstrmojo.WidgetList,
        
        null,
        {   
            scriptClass: "mstrmojo.TreeNode",
            
            markupString: '<li id="{@id}" class="mstrmojo-TreeNode {@cssClass}" style="{@cssText}" mstrAttach:mousedown>'
                                + '<div class="mstrmojo-TreeNode-div">'
                                    + '<img class="mstrmojo-TreeNode-state" src="../images/1ptrans.gif" />'
                                    + '<span class="mstrmojo-TreeNode-text {@textCssClass}"></span>'
                                + '</div>'
                                + '<ul class="mstrmojo-TreeNode-itemsContainer">{@itemsHtml}</ul></li>',

            markupSlots: {
                stateNode: function(){ return this.domNode.firstChild.firstChild;},
                textNode: function(){return this.domNode.firstChild.lastChild;},
                itemsContainerNode: function(){return this.domNode.lastChild;}
            },
            
            markupMethods: {
                
                ontextChange: function(){ this.textNode.innerHTML = mstrmojo.string.encodeHtmlString(this.text);},
                onstateChange: function(){ 
                    this.stateNode.className = "mstrmojo-TreeNode-state " + (NODE_STATE_CSS_MAP[this.state] || 'closed');
                    this.itemsContainerNode.style.display = (this.state === 1) ? 'block' : 'none';
                },
                onselectedChange: function(){
                    var fn = this.selected ? 'addClass' : 'removeClass';
                    mstrmojo.css[fn](this.domNode.firstChild, ['selected']);
                },
                ondropCuePosChange: mstrmojo.WidgetList.prototype.markupMethods.ondropCuePosChange
            },
            
            renderOnScroll: false,

            listSelector: mstrmojo.TreeNodeSelector,
            
            
            premousedown: function pmd(evt) {
                var ret = this._super(evt),
                    t = _D.eventTarget(evt.hWin, evt.e);
                if (t == this.stateNode) {
                    if (this.state !== 2) {
                        this.set("state", this.state === 1 ? 0 : 1);
                    }
                }
                return ret;
            },
            
            
            preclick: function(evt) {
                
                mstrmojo.dom.stopPropogation(evt.hWin, evt.e);
            },
            
            
            prechange: function(evt){
                var ret = this._super(evt);
                if (ret !== false) {
                    var t = this.tree;
                    if (t && t.onnodechange) {
                        t.onnodechange(evt);
                    }
                }
                return ret;
            }
        });

})();

(function () {
   
    mstrmojo.requiresCls(   
            "mstrmojo.dnd"
            );
    
    
    function _createAvatar(w){
        var d = document.createElement('div'),
            s = d.style,
            dn = w.domNode;
        d.className = "mstrmojo-DataGrid-avatar";
        s.height = dn.clientHeight + "px";
        dn.appendChild(d);
        w.avatar = d;
        return d;
    }
    
    
    function _getMyX(w){
        var p = mstrmojo.dom.position(w.domNode, true);
        return p.x;
    }
    
    
    function _RHString(i){
        return '<div class="mstrmojo-DataGrid-resizeHandle" unselectable="on" onselectstart="return false" rh="' + i + '"></div>';
    }
    
    
    function _getRHIndex(t){
        var rs = t.getAttribute("rh"),
            result = rs && parseInt(rs, 10);
        return result;
    }
    
    function _doNothing4Resizing(w, _super, ctxt){
        var s = ctxt.src,
            d = s && s.data,
            rsIdx = d && d.resizingIdx;
        if(!(rsIdx && rsIdx>0)){
            return _super && _super.apply(w,[ctxt]);
        }
    }
    
    
    mstrmojo.RESIZE_NEXT_COLUMN_MODE = {
    		getRange: function _getRange(me, rsIdx){
    			var sa = me.colSizeArray;
    			var range = [-sa[rsIdx - 1] + me.minColWidth,
                      (rsIdx == sa.length - 1) ? sa[rsIdx] - me.resizeHandleWidth - me.minColWidth : sa[rsIdx] - me.minColWidth];
    			return range;
    		},
    		updateSize: function _updateSize(me, rsIdx, deltaX){
    			var sa = me.colSizeArray;
    			sa[rsIdx - 1] = sa[rsIdx - 1] + deltaX;
    			sa[rsIdx] = sa[rsIdx] - deltaX;
    		},
    		updateColumnWidth: function _updateColumnWidth(me, cls, dcls, rsIdx){
                var sa = me.colSizeArray;
    	        cls[rsIdx - 1].style.width = sa[rsIdx - 1] + 'px';
    	        dcls[rsIdx - 1].style.width = sa[rsIdx - 1] + 'px';     
    	        cls[rsIdx].style.width = sa[rsIdx] + 'px';
    	        dcls[rsIdx].style.width = sa[rsIdx] + 'px';
    		}
    };
    
    
    mstrmojo.RESIZE_ALL_COLUMN_MODE = {
    		getRange: function _getRange(me, rsIdx){
    			var mw = me.minColWidth + me.resizeHandleWidth,
    				sa = me.colSizeArray,
    	            rr = 0; 
    	        for(var i = rsIdx; i < sa.length; ++i){
    	        	rr += sa[i] - mw;
    	        }
    	        var range = [-sa[rsIdx-1] + mw, rr];
    	        return range;
    		},
    		updateSize: function _updateSize(me, rsIdx, deltaX){
    			var mw = me.minColWidth + me.resizeHandleWidth,
					sa = me.colSizeArray;
    	        sa[rsIdx - 1] = sa[rsIdx - 1] + deltaX;
    	        var ia = []; 
    	        for (var i = 0; i < sa.length - rsIdx; ++i){
    	        	ia[i] = rsIdx + i;
    	        }
    	        ia.sort(function(x,y){return sa[x] - sa[y];}); 
    	        for (var i = 0; i < ia.length; ++i){
    	        	var sdx = deltaX / (ia.length - i); 
    	        	var ccw = sa[ia[i]]; 
    	        	
    	        	deltaX -= (ccw >= sdx + mw) ? sdx : ccw - mw;
    	        	sa[ia[i]] = (ccw >= sdx + mw) ? ccw - sdx : mw;
    	        }
    		},
    		updateColumnWidth: function _updateColumnWidth(me, cls, dcls, rsIdx){
                var sa = me.colSizeArray;
    	    	for(var i = rsIdx - 1; i < sa.length; ++i){
    	    		cls[i].style.width = sa[i] + 'px';
    	    		dcls[i].style.width = sa[i] + 'px';
    	    	}
    		}
    }
    
    
    mstrmojo._CanResizeColumn = mstrmojo.provide(
        "mstrmojo._CanResizeColumn",
        
        {
            draggable: true,
            dropZone: false,  
            
            
            avatar: null,
            colSizeArray: null,
            
            resizableColumns: true, 
            resizeHandleWidth: 10,
            minColWidth: 5,            
            
            resizeColumnBehavior: mstrmojo.RESIZE_NEXT_COLUMN_MODE,
            
            
            
            postBuildRendering: function postBuildRendering(){
                if(this._super){
                    this._super();
                }
                if(this.avatar){
                    this.domNode.appendChild(this.avatar);
                }
                this.colSizeArray = null;
            },
            
            
            getDragData: function getDragData(ctxt){ 
                var s = ctxt.src,
                    n = s.node,
                    rsIdx = _getRHIndex(n);
                if(rsIdx && rsIdx > 0){
                    return {resizingIdx: rsIdx, startingX: s.pos.x, baseX:_getMyX(this)};
                } else {
                    if(this._super){
                        return this.dropZone && this._super(ctxt);
                    }
                }
                return null;
            },
            
            allowDrop: function allowDrop(ctxt){
                var s = ctxt.src,
                d = s && s.data,
                rsIdx = d && d.resizingIdx;
                if(rsIdx && rsIdx>0){
                    return true;
                } else {
                    return this.dropZone; 
                }
            },
            
            ondragenter: function ondragenter(ctxt) {
                _doNothing4Resizing(this, this._super, ctxt);
            },
            
            ondragover: function ondragover(ctxt) {
                _doNothing4Resizing(this, this._super, ctxt);
            },
            
            ondragleave: function ondragleave(ctxt) {
                _doNothing4Resizing(this, this._super, ctxt);
            },
            
            ondrop: function ondrop(ctxt) {
                _doNothing4Resizing(this, this._super, ctxt);
            },
            
            
            
            ondragstart: function ondragstart(ctxt){
                var s = ctxt.src,
                    d = s && s.data,
                    rsIdx = d && d.resizingIdx;
                if(rsIdx && rsIdx>0){
                    var a = this.avatar || _createAvatar(this); 
                    
                    this.ownAvatar = true;
                    a.style.left = (d.startingX - d.baseX) + "px";
                    a.style.display = "block";
                    document.body.style.cursor = "col-resize";
                    
                    
                    var sa = this.colSizeArray; 
                    if(!sa){
                        var hc = this.headerContainerNode,
                        ht = hc && hc.getElementsByTagName('table')[0],
                        cls = ht.rows[0].cells;
                        
                        sa = [];
                        for(var i =0, len=cls.length;i<len;i++){
                            sa.push(cls[i].offsetWidth);
                        }
                        this.colSizeArray = sa;
                        this._firstTimeResize = true;
                    }
                    
                    d.resizingRange = this.resizeColumnBehavior.getRange(this, rsIdx);  
                    return true;
                } else {
                    if(this._super){
                        return this._super(ctxt);
                    }
                }
            }, 
            
            

            
            ondragmove: function ondragmove(ctxt){
                var s = ctxt.src,
                    d = s && s.data,
                    rsIdx = d && d.resizingIdx;                
                if(rsIdx && rsIdx>0){
                    var t = ctxt.tgt,
                        a = this.avatar,
                        rg = d.resizingRange,
                        mx = t.pos.x - d.startingX,
                        deltaX = Math.min(rg[1],Math.max(mx,rg[0]));
                    
                    d.deltaX = deltaX;
                    
                    if(a){
                        a.style.left = (d.startingX - d.baseX + deltaX) + "px";
                    }
                } else {
                    if(this._super){
                        this._super(ctxt);
                    }
                }
            },
            
            
            ondragend: function ondragend(ctxt){
                var s = ctxt.src,
                    d = s && s.data,
                    rsIdx = d && d.resizingIdx;  
                if(rsIdx && rsIdx>0){
                    
                    var cg = this.titleColGroup,
                        cls = cg && cg.childNodes,
                        dcg = this.dataColGroup,
                        dcls = dcg && dcg.childNodes,
                        len = cls.length,
                        sa = this.colSizeArray,
                        deltaX = d.deltaX;
                    
                    
                    this.resizeColumnBehavior.updateSize(this, rsIdx, deltaX);
                    
                    
                    if(this._firstTimeResize){
                        for(var i=0;i<len;i++){
                            cls[i].style.width = sa[i] + 'px';
                            dcls[i].style.width = sa[i] + 'px';                        
                        }
                        this._firstTimeResize = false;
                    }else{
                    	this.resizeColumnBehavior.updateColumnWidth(this, cls, dcls, rsIdx);
                    }               
                    
                    
                    this.avatar.style.display = "none";
                    document.body.style.cursor = "";   
                    this.ownAvatar = false;
                } else {
                    if(this._super){
                        this._super(ctxt);
                    }
                }
            }
        });
    
    mstrmojo.requiresCls(   
            "mstrmojo._CanResizeColumn",
            "mstrmojo.ListMapperTable",         
            "mstrmojo.WidgetList");
    
    function _buildColGroup(cls){
        var cg = document.createElement('colgroup'),
            len = cls.length,
            cl;
        for (var i=0; i < len; i++) {
            var col = document.createElement('col');
            cl = cls[i];
            if(cl.colWidth){
                col.style.width = cl.colWidth + 'px';
            }
            col.className = cl.colCss || ('col' + i);
            cg.appendChild(col);                    
        }
        return cg;
    }
    
    function _destroyHeaderWidgets(w){
        var hws = w._headerWidgets_,
            len = hws && hws.length;
        if(len>0){
            for(var i=0;i<len;i++){
                hws[i].destroy(true);
            }
        }  
    }
    
    
    mstrmojo.DataGrid = mstrmojo.declare(
        
        mstrmojo.WidgetList,
        
        [mstrmojo._CanResizeColumn],
        
        {
            scriptClass: "mstrmojo.DataGrid",
            
            banding: true,
            
            
            resizableColumns: true,
            
            columns: null,
            
            items: null,
            
            listMapper: mstrmojo.WidgetListMapperTable,
            
            markupString: '<div id="{@id}" class="mstrmojo-DataGrid {@cssClass}" style="{@cssText}" mstrAttach:mousedown,mouseup>'
                    + '<div class="mstrmojo-DataGrid-headerContainer">{@headerHtml}</div>'
                    + '<div class="mstrmojo-DataGrid-itemsScrollBox" style="position:relative;">'
                        + '<div class="mstrmojo-DataGrid-itemsContainer" style="{@itemsContainerCssText}">{@itemsHtml}</div>'
                        + '<div class="mstrmojo-ListBase2-dropCue"><div class="mstrmojo-ListBase2-dropCue-inner"></div></div>'                        
                    + '</div>'
                + '</div>',
                
            markupSlots: {
                scrollboxNode: function(){return this.domNode.lastChild;},
                itemsContainerNode: function(){return this.domNode.lastChild.firstChild;},
                dropCueNode: function(){return this.domNode.lastChild.lastChild;},
                headerContainerNode: function(){return this.domNode.firstChild;}
            },
            
            itemFunction: function(item, idx, w){
                var c = new mstrmojo.DataRow({
                    columns: w.columns,
                    data: item,
                    idx: idx,
                    dataGrid: w
                });
                return c;
            },
            
            
            preBuildRendering: function preBuildRendering(){
                var cls = this.columns,
                    len = cls.length,
                    out = ['<table class="mstrmojo-DataGrid-headerTable" cellspacing="0" cellpadding="0"><tr>'],
                    cl, w;
                this._headerWidgets = [];
                for(var i =0;i<len;i++){
                    cl = cls[i];
                    w = cl.headerWidget;
                    out.push('<td>');
                    if(i>0 && this.resizableColumns){
                        out.push(_RHString(i));
                    }
                    out.push('<div class="mstrmojo-DataGrid-headerText');
                    out.push(cl.headerCss ? ' ' + cl.headerCss : '');
                    if(w){
                        this._headerWidgets.push(mstrmojo.hash.copy(w));
                        out.push('" w="1">');
                    } else {
                        out.push('">');
                    }
                    out.push(cl.headerText ? cl.headerText : '&nbsp');
                    out.push('</div>');                  
                    out.push('</td>'); 
                }
                out.push('</tr></table>');
                this.headerHtml = out.join('');
                if(this._super){
                    this._super();
                }
            },
                  
            
            postBuildRendering: function postBuildRendering(){
                if(this._super){
                    this._super();
                }
                
                
                var hws = this._headerWidgets,
                    len = hws.length;
                if(len > 0){
                    this._headerWidgets_ = [];
                    var divs = this.headerContainerNode.getElementsByTagName('div'),
                        phs = mstrmojo.array.filter(divs,function(div){
                            return div.getAttribute('w') == '1';
                        }),
                        w;
                    for(var i=0;i<len;i++){
                        hws[i].placeholder = phs[i].firstChild;
                        hws[i].dataGrid = this;
                        w = mstrmojo.registry.ref(hws[i]);
                        w.render();
                        this._headerWidgets_.push(w);
                    }
                }
                
                
                
                var cg = _buildColGroup(this.columns),
                    dcg = cg.cloneNode(true),
                    hc = this.headerContainerNode,
                    ht = hc && hc.getElementsByTagName('table')[0],
                    dc = this.itemsContainerNode,
                    dt = dc && dc.getElementsByTagName('table')[0];
                this.titleColGroup = cg;
                this.dataColGroup = dcg;
                if(ht && dt){
                    ht.insertBefore(cg,ht.firstChild);
                    dt.insertBefore(dcg,dt.firstChild);
                }
                
            },
            
            refresh: function refresh(postUnrender){
                _destroyHeaderWidgets(this);
                if(this._super){
                    this._super(postUnrender);
                }
            },
                
            destroy: function dst(skipCleanup) {
                _destroyHeaderWidgets(this);
                this._super();
            },
            
            unrender: function unrn(ignoreDom) {
                var hws = this._headerWidgets_,
                    len = hws && hws.length,
                    hw;
                if(len>0){
                    for(var i=0;i<len;i++){
                        hw = hws[i];
                        if(hw && hw.hasRendered){
                            hw.unrender(true);
                        }
                    }
                }
                this._super(ignoreDom);
            }
            
        });
    
    mstrmojo.requiresCls(
            "mstrmojo.css",
            "mstrmojo.hash",
            "mstrmojo.Container");
    
    mstrmojo.DataRow = mstrmojo.declare(
            
            mstrmojo.Container,
            
            null,
            
            {
                scriptClass: "mstrmojo.DataRow",
                
                cssClass: "mstrmojo-DataRow",
                
                columns: null,
                
                markupMethods: {
                    onselectedChange: function(){ 
                        mstrmojo.css.toggleClass(this.domNode, "selected", this.selected);
                    }
                },
                
                buildDom: function(){
                    this.children = [];
                    var ph = document.createElement('tr'),
                        d = this.data,
                        idx = this.idx,
                        dataGrid = this.dataGrid,
                        css = this.cssClass,
                        cls = this.columns,
                        ch = this.children,
                        td,
                        cn = -1,
                        cl,
                        w;
                    
                    ph.setAttribute('id', this.id);
                    if(dataGrid.banding){
                        css += (idx%2 == 1) ? ' odd' : ' even';
                    }
                    ph.className = css + (mstrmojo.string.isEmpty(d[dataGrid.itemDisplayField || 'n']) ? ' empty-row' : '');
                    
                    
                    for(var i = 0, len = cls.length; i<len; i++){
                        cl = cls[i];
                        w = (cl.dataWidgetBuilder && cl.dataWidgetBuilder(d)) || cl.dataWidget;
                        td = document.createElement('td');
                        ph.appendChild(td);                  
                        if(w) {
                            td.setAttribute('w', '1');
                            cn++;
                            ch.push(mstrmojo.hash.copy(w,{
                                slot:'slot'+cn,
                                data:d,
                                idx:idx,
                                dataGrid:dataGrid
                            }));
                        } else {
                            if (cl.dataFunction) {
                                td.innerHTML = cl.dataFunction(d, idx, dataGrid);
                            } else {
                                var txt = mstrmojo.string.htmlAngles(d[cl.dataField || 'n']) || '&nbsp',
                                    atts = cl.tooltip ? ' title="' + txt + '"' : '';
                                
                                td.innerHTML = '<div class="mstrmojo-DataRow-text" ' + atts + '>' + txt + '</div>';
                            }
                        }
                    }
                    this.initChildren();
                    return ph;
                },
            
                buildRendering: function bldRn() {            
                    
                    this._super();  
                    
                    
                    var tds = this.domNode.childNodes,
                        len = tds.length,
                        slots = {},
                        ct = 0,
                        td;
                    for(var i=0;i<len;i++){
                        td = tds[i];
                        if(td.getAttribute('w') == '1'){
                            slots['slot' + ct] = td;
                            ct++;
                        }
                    }
                    this.addSlots(slots);      
                }
            });    
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo.android.ui._CanBeFullScreen",
                         "mstrmojo.android.ui.ActionToolbar",
                         "mstrmojo.android.ui.TitleLabel",
                         "mstrmojo.android.ui.Image",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.css");

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        $CSS = mstrmojo.css;

    
    var $AB = mstrmojo.android.ui.ActionBar = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._HasLayout, mstrmojo.android.ui._CanBeFullScreen ],

        
        {
            scriptClass: 'mstrmojo.android.ui.ActionBar',

            markupString: '<div id="{@id}" class="mstrmojo-ActionBar {@cssClass}" style="{@cssText}" >' +
                              '<div>' +
                                  '<div class="mstrmojo-ActionBar-logo"></div>' +
                                  '<div>' +
                                  	'<div class="mstrmojo-ActionBar-contents"></div>' +
                                  '</div>' + 	
                                  '<div class="mstrmojo-ActionBar-toolbar"></div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                logoNode: function () { return this.domNode.firstChild.firstChild; },
                containerNodeWrapper: function () { return this.domNode.firstChild.childNodes[1]; },
                containerNode: function () { return this.domNode.firstChild.childNodes[1].firstChild; },
                toolbarNode: function () { return this.domNode.firstChild.lastChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },

            layoutConfig: {
                h: {
                    logoNode: '56px',
                    containerNodeWrapper: '56px',
                    containerNode: '56px',
                    toolbarNode: '56px'
                },
                w: {
                    logoNode: '66px',
                    containerNodeWrapper: '100%',
                    containerNode: '100%',
                    toolbarNode: 'auto'
                }
            },

            children: [{
                scriptClass: 'mstrmojo.android.ui.Image',
                slot: 'logoNode',
                alias: 'logo',
                onactiveChange: function () {
                    
                    $CSS.toggleClass(this.domNode, 'active', this.active);
                },
                touchTap: function () {
                    
                    mstrApp.closeAllDialogs();

                    
                    if (this.active) {
                        var domNode = this.domNode,
                            cls = 'selected';

                        $CSS.addClass(domNode, cls);

                        
                        this.parent.controller.goUp();

                        window.setTimeout(function () {
                            $CSS.removeClass(domNode, cls);
                        }, 500);
                    }
                }
            }, {
                scriptClass: 'mstrmojo.android.ui.TitleLabel',
                slot: 'containerNode',
                alias: 'title',
                onlistSelectionMade: function (evt) {
                    
                    this.parent.controller.jumpTo(evt.item);
                }
            }, {
                scriptClass: 'mstrmojo.android.ui.ActionToolbar',
                slot: 'toolbarNode',
                alias: 'toolbar'
            }],

            
            reset: function reset() {
                
                this.title.reset();
                this.toolbar.reset();
            },

            setUpStatus: function setUpStatus(isActive) {
                this.logo.set('active', isActive);
            },

            
            setNavigation: mstrmojo.emptyFn,

            
            clearNavigation: mstrmojo.emptyFn,

            
            restoreNavigation: mstrmojo.emptyFn,

            
            selectNavigationItem: function selectNavigationItem(item) {
                var list = this.getNavList(),
                    res = false;
                $ARR.forEach(list && list.items, function (btn, idx) {
                    if (item.act === btn.act) {
                        list.singleSelect(idx);
                        res = true;
                        return false;
                    }
                });
                return res;
            },

            
            getNavList: mstrmojo.emptyFn,

            
            setLastOpened: function setLastOpened(items) {
                this.title.setListItems(items);
            },

            
            updateTitle: function updateTitle(text) {
                
                this.title.setText(text);
            },

            
            updateToolbar: function updateToolbar(id, tbCfg) {
                
                this.toolbar.setActions(id, tbCfg);

                
                this.title.checkTextFit();
            },

            
            setActionToolbarStatus: function setActionToolbarStatus(isActive) {
                this.toolbar.set('active', isActive);
            },

            onEnterFullScreen: function onEnterFullScreen() {
                this.reset();
            }
        }
    );

    
    $AB.adjustLayoutConfig = function (dpi, isTablet) {
        
        var $DPI_MANAGER = mstrmojo.DPIManager;

        
        $HASH.forEach($AB.prototype.layoutConfig.h, function (value, slot) {
            
            $DPI_MANAGER.registerClass($AB, 'h', slot, dpi);
        });

        
        var widthDpi = $HASH.copy(dpi);

        
        if (isTablet) {
            
            $HASH.forEach(widthDpi, function (value, key) {
                widthDpi[key] = Math.ceil(value * 1.333);
            });
        }

        
        $DPI_MANAGER.registerClass($AB, 'w', 'logoNode', widthDpi);
    };
}());


(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.android.ui.ActionToolbar");

    mstrmojo.requiresDescs(1, 1143, 7831);

    var MENUS = mstrmojo.android.EnumMenuOptions,
        $HASH = mstrmojo.hash,
        $AFE = mstrmojo.array.forEach,
        GOTO_SETTINGS = MENUS.SETTINGS,
        GOTO_HELP = MENUS.HELP,
        GOTO_LEARN = MENUS.LEARN,
        DEFAULT_ALL = -1;

    
    var linkDrillParams = {
        currentViewMedia : 0,
        documentID : 'objectID',
        elementsPromptAnswers : 0,
        link : 0,
        linkAnswers : 0,
        objectID : 0,
        objectsPromptAnswers : 0,
        promptsAnswerXML : 0,
        reportID : 0,
        reportViewMode : 0,
        valuePromptAnswers : 0,
        visMode : 0,
        desiredElements : 0,
        desiredUnits : 0,           
        projectID : 0,              
        Project : 'projectID',      
        groupByElements : 0,        
        pageByElements : 0,         
        layoutIndex : 0,
        originMessageID: "originMessageID",
        promptAnswerMode: 0,
        selectorMode: "selectorMode"
    };

    
    mstrmojo.android.controllers.ViewController = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        
        {
            scriptClass: "mstrmojo.android.controllers.ViewController",

            
            supportsFullScreen: false,

            
            start: function start(params) {
                
                this.set('orientation', mstrApp.isLandscape() ? 0 : 1);

                
                this.pid = mstrApp.getCurrentProjectId();
            },

            
            detach: function detach() {
                var me = this,
                    nextController = me.nextController,
                    prevController = me.prevController;

                
                if (prevController) {
                    
                    delete prevController.nextController;
                }

                
                if (nextController) {
                    
                    nextController.destroy();
                }

                
                this.nextController = this.prevController = null;

                
                var view = this.view;
                if (view) {
                    
                    view.destroy();
                }
            },

            
            destroy: function destroy() {
                
                this.detach();

                
                this._super();
            },

            
            canDetach: function canDetach(controller) {
                
                return controller.hsc || !this.hsc;
            },

            
            getUpStatus: function getUpStatus() {
                return !this.hsc;
            },

            
            spawn: function spawn(controller, startParams) {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    if (!nextController.canDetach(controller)) {
                        
                        nextController.spawn(controller, startParams);
                        return;
                    }

                    
                    nextController.destroy();
                }

                
                this.nextController = controller;
                controller.prevController = this;

                
                controller.rootCtrl = this.rootCtrl || this;

                
                controller.start(startParams || {});
            },

            
            spawnFailed: function spawnFailed(details) {
                
                this.makeCurrent();

                
                mstrApp.onerror(details);
            },

            
            viewFailed: function viewFailed(details) {
                
                if (details) {
                    mstrmojo.dbg('details: ' + JSON.stringify(details));
                }

                
                mstrApp.hideMessage();

                
                if (this.view) {
                    
                    if (this.rootCtrl.getCurrent() !== this) {
                        
                        this.makeCurrent(true);
                    }

                } else {
                    
                    var previousController = this.prevController;
                    if (previousController) {
                        
                        previousController.spawnFailed(details);
                    }
                }

                
                mstrApp.onerror(details);
            },

            
            makeCurrent: function makeCurrent(isBack) {
                
                var nextController = this.nextController,
                	
                    needRefresh = true;
                if (nextController) {
                	needRefresh = ! nextController.doNotRefresh;
                    
                    nextController.destroy();
                }

                
                if (!this.supportsFullScreen) {
                    
                    this.rootCtrl.exitFullScreen();
                }

                
                var projectId = this.pid;
                if (projectId) {
                    
                    mstrApp.setCurrentProjectId(projectId);
                }

                
                if (isBack) {
                    
                    if (mstrApp.useBinaryFormat && mstrApp.getCurrentProjectId()) {
                        
                        
                        var ctrlType = this.ctrlType;
                        if (ctrlType) {
                            var model = this.model,
                                emptyFn = mstrmojo.emptyFn,
                                successFn = emptyFn,
                                me = this;

                            
                        	
                            if (this.checkCache && needRefresh) {
                                successFn = function () {
                                    
                                    setTimeout(function () {
                                        me.checkCache(null, null, null, 1);
                                    }, 100);
                                };
                            }

                            var params = {
                                    taskId: 'setCurrentView',
                                    st: ctrlType,
                                    did: this.did || '',
                                    mid: (model && model.dataService && model.dataService.msgId) || ''
                                },
                                curLayoutKey = model && model.currlaykey;

                            
                            if (curLayoutKey) {
                                params.layoutKey = curLayoutKey;
                            }

                            
                            mstrApp.serverRequest(params, {
                                success: successFn,
                                failure: emptyFn
                            }, {
                                silent: true
                            });
                        }
                    }
                }
            },

            
            makeHome: function makeHome() {
                this.makeCurrent(true);
            },

            
            jumpTo: function jumpTo(item) {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    nextController.jumpTo(item);
                    return;
                }

                
                this.spawn(mstrApp.controllerFactory.newController(this.getViewKey(item.st), item), item);
            },

            
            getPath: function getPath() {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    return nextController.getPath();
                }

                
                return [];
            },

            
            updateItemProperties: function updateItemProperties(defaultMsg, item, ctrlId, isAvail) {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    nextController.updateItemProperties(defaultMsg, item, ctrlId, isAvail);
                }
            },

            
            onorientationChange: function onorientationChange() {
                var orientation = this.orientation,
                    view = this.view;

                
                if (view && view.hasRendered && view.rootOrientationChange) {
                    
                    view.rootOrientationChange({
                        isLandscape: !orientation
                    });
                }

                
                var nextController = this.nextController;
                if (nextController) {
                    
                    nextController.set('orientation', orientation);
                }
            },

            
            getCurrent: function getCurrent() {
                var nextController = this.nextController;
                if (nextController) {
                    return nextController.getCurrent();
                }

                return this;
            },

            
            goBack: function goBack() {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    if (!nextController.goBack()) {
                        
                        if (!this.rootCtrl) {
                            
                            return false;
                        }

                        
                        this.makeCurrent(true);
                    }

                    return true;
                }

                return false;
            },

            
            goUp: function goUp() {
                
                var nextController = this.nextController;
                if (nextController) {
                    return nextController.goUp();
                }

                return false;
            },

            
            getController: function getController(propName, propValue, isForward) {
                
                var ctrl = this[(isForward ? 'next' : 'prev') + 'Controller'];
                if (ctrl) {
                    
                    if (ctrl[propName] === propValue) {
                        
                        return ctrl;
                    }

                    
                    return ctrl.getController(propName, propValue, isForward);
                }

                
                return null;
            },

            
            newView: function newView(viewKey, params) {
                return mstrApp.viewFactory.newView(viewKey, mstrmojo.hash.copy(params, {
                    controller: this
                }));
            },

            
            getViewKey: function getViewKey(subtype) {
                return {
                    1: 'Projects',
                    2: 'Home',
                    3: 'Subscriptions',
                    4: 'Settings',
                    5: 'Projects',
                    6: 'Help',
                    8: 'Subscriptions',
                    768: 'Xtab',
                    769: 'Graph',
                    774: 'Xtab',
                    2048: 'Folder',
                    14081: 'Document'
                }[subtype];
            },

            
            getDefaultMenus: function getDefaultMenus() {
                return DEFAULT_ALL;
            },

            
            generateActionToolbar: function generateActionToolbar() {
                
                var rootCtrl = this.rootCtrl || this,
                    currentCtrl = rootCtrl.getCurrent();

                
                rootCtrl.setActionToolbar(currentCtrl.id, currentCtrl.updateActionToolbar(mstrmojo.android.ui.ActionToolbar.newToolbarConfig()));
            },

            
            updateActionToolbar: function updateActionToolbar(tbCfg) {
                var menus = this.getDefaultMenus(),
                    config = mstrApp.getConfiguration();

                
                if (config.isMenuAllowed(GOTO_LEARN, menus)) {
                    tbCfg.addMenuItem(GOTO_LEARN, mstrmojo.desc(9849, 'Learn More'), GOTO_LEARN, true, 6);
                }

                
                if (config.isMenuAllowed(GOTO_SETTINGS, menus)) {
                    tbCfg.addMenuItem(GOTO_SETTINGS, mstrmojo.desc(7831, 'Settings'), GOTO_SETTINGS, true, 6);
                }

                
                if (config.isMenuAllowed(GOTO_HELP, menus)) {
                    tbCfg.addMenuItem(GOTO_HELP, mstrmojo.desc(1143, 'Help'), GOTO_HELP, false, 9);
                }

                
                if (!mstrApp.isTablet()) {
                    
                    tbCfg.maxBtnCount = (mstrApp.isLandscape()) ? Math.round(mstrMobileApp.getDeviceDPI() / 105) + 1 : 2;
                }

                return tbCfg;
            },

            
            handleMenuItem: function handleMenuItem(group, cmdId) {
                switch (group) {
                case GOTO_SETTINGS:
                    
                    this.spawn(mstrApp.controllerFactory.newController('Settings'));
                    break;

                case GOTO_LEARN:
                    mstrMobileApp.displayLearnMore();
                    break;

                case GOTO_HELP:
                    
                    mstrApp.displayHelp();
                    break;
                }

                return false;
            },

            
            beforeViewVisible: mstrmojo.emptyFn,

            
            afterViewVisible: function afterViewVisible() {
                
                
                var me = this;
                window.setTimeout(function () {
                    me.generateActionToolbar();
                }, 100);
            },

            
            beforeViewHidden: mstrmojo.emptyFn,

            
            afterViewHidden: mstrmojo.emptyFn,

            
            handleSpecialLink: function handleSpecialLink(uri) {
                var eventId = uri.queryKey.evt,
                    forceRepaint;

                
                if (eventId === '3999') {
                    this.spawn(mstrApp.controllerFactory.newController('Settings', {}), {});

                } else if (eventId === '3124') { 
                    mstrApp.goBack();

                    
                    forceRepaint = true;

                } else if (eventId === '3994') { 
                    mstrApp.displayHelp();

                } else if (eventId === '3997') { 
                    mstrApp.rootController.jumpTo({
                        act: 8
                    });

                } else if (eventId === "3995") { 
                    
                    mstrApp.rootController.goHome();

                    
                    forceRepaint = true;

                } else if (eventId === "3996") { 
                    
                    mstrApp.rootController.jumpTo({
                        act: 5
                    });

                    
                    forceRepaint = true;
                }

                
                if (forceRepaint) {
                    window.setTimeout(function () {
                        mstrMobileApp.forceRepaint();
                    }, 0);
                }
            },

            
            getDepth: function getDepth() {
            	var prev = this.prevController;
            	return (prev && (prev.getDepth() + 1)) || 1;
            },

            onLink: function onLink(view, action) {
                var params = this.buildLinkParams(action);
                params.action = 'linkToObject';

                
                var isHTMLDoc = false,
                    subtype = 768;

                
                switch (parseInt(action.evt, 10)) {
                    case 4001:
                        
                        if (parseInt(action.reportViewMode, 10) === 2) {
                            
                            subtype = 769;
                        }

                        
                        params.styleName = 'AndroidMessageResultStyle';
                        break;

                    case 32001:
                        
                        isHTMLDoc = true;
                        break;

                    case 2048001:
                        
                        subtype = 14081;
                        break;
                }

                
                params.st = subtype;

                
                this.spawn(mstrApp.controllerFactory.newController(isHTMLDoc ? 'HTMLDoc' : this.getViewKey(subtype), {
                    st : subtype
                }), params);

            },

            
            buildLinkParams: function buildLinkParams(action) {
                var params =  {};

                
                $HASH.forEach(action, function (v, p) {
                    var pV = linkDrillParams[p];

                    
                    if (p === "Project") {
                        
                        var mobileCfg = mstrApp.getConfiguration(),
                            sn = action.Server,
                            port = action.port || action.Port,
                            project;

                        
                        
                        if (sn === undefined) {
                            var server = mobileCfg.getServerByProjectId(mstrApp.getCurrentProjectId());
                            if (server !== undefined) {
                                $AFE(server.pl, function (p) {
                                    if (v === p.pn) {
                                        if ((port === undefined) || (!!port && parseInt(port, 10) === p.sp)) {
                                            project = p;
                                            return false;
                                        }
                                    }
                                });
                            }
                        } else {
                            project = mobileCfg.getProjectByServerAndProjectName(sn, port, v);
                        }

                        
                        if (project !== undefined) {
                            
                            params[pV] = project.pid;
                        }

                        
                    } else if (pV !== undefined) {
                        
                        
                        
                        params[pV || p] = v;
                    }
                });

                
                if (mstrApp.useBinaryFormat) {
                    
                    params.srcMsgId = action.srcMsgId;
                }


                var linkInfo = action.linkInfo;  

                if (linkInfo && linkInfo.so > 0) {
                    params.selectorMode = linkInfo.so;
                    params.originMessageID = action.srcMsgId;
                    if (!action.linkAnswers) {
                        params.promptAnswerMode = '0'; 
                    }
                }

                return params;
            },

            
            exitFullScreen: mstrmojo.emptyFn
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DateTimePicker",
                         "mstrmojo.ui.MobileStepper",
                         "mstrmojo._TouchGestures");
    
    var dateTimeScriptClass = 'mstrmojo.ui.MobileStepper';
        
    
    mstrmojo.ui.MobileDateTimePicker = mstrmojo.declare(
        
        mstrmojo.DateTimePicker,
            
        
        [mstrmojo._TouchGestures],
            
        {

            scriptClass: "mstrmojo.ui.MobileDateTimePicker",
            
            stepperClass: 'mstrmojo.ui.MobileStepper',
            
            
            onclick: function(evt) {
                this.touchTap(evt.e);
            },
            
            
            touchTap: function(touch) {
                if (touch.target === this.meridiemNode) {
                    
                    this.set('meridiem', !this.meridiem);
                    this.updateTime();
                }
            },
            
            touchBegin: function(touch){
                if (touch.target == this.meridiemNode){
                    mstrmojo.css.addClass(touch.target, 'glow');
                }
            },
            
            touchEnd: function(touch){
                if (touch.target == this.meridiemNode){
                    mstrmojo.css.removeClass(touch.target, 'glow');
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo.array",
        "mstrmojo.hash",
        "mstrmojo.StickySections",
        "mstrmojo.VisTextTooltip"
    );

    var $D = mstrmojo.dom,
        $H = mstrmojo.hash,
        $A = mstrmojo.array,
        $THEMES = [ 'white', 'black', 'transparent', 'gray'],
        $SELECTED_ROW = "ig-selected-row";

    
    function isIGFullscreen() {
        return (this.isFullScreenWidget || !this.isDocXtab);
    }


    
    function cleanUpMXVP() {
        var gd = this.gridData,
            chs = gd.ghs.chs;

        
        if (chs.items && chs.items.length) {
            var mx = gd.ghs.chs.items[0].items,
                vp = gd.vp,
                cols = vp.cols,
                cg = cols.cg,
                cws = cols.cws,
                cgc = cg.cgc,
                i, j,
                hasMx = false,
                remove = [];

            for (i = 0; i < cgc; i++) {
                var col = cg[i],
                    mxCount = -1;

                $H.forEach(col, function (v, k) {
                    if (/[mMiIxX]([0-9])+$/.test(k)) {
                        for (j = 0; j < mx.length; j++) {
                            if (mx[j].mix == v) {
                                col[k] = j;
                                mxCount++;
                                break;
                            }
                        }
                        if (mx[col[k]] === undefined || j === mx.length) {
                            delete col[k];
                            return;
                        }
                        hasMx = true;
                    }
                });

                if (hasMx) {
                    var lastEmpty = [];
                    for (j = 0; j < col.cl; j++) {
                        if (col['mix' + j] === undefined) {
                            lastEmpty.push(j);
                        } else if (lastEmpty.length > 0) {
                            col['mix' + lastEmpty.splice(0, 1)] = col['mix' + j];
                            delete col['mix' + j];
                        }
                    }
                    col.cl = ++mxCount;

                    
                    if (col.cl === 0) {
                        remove.push(i);
                    }
                } else if (!col.attForms) {
                    
                    remove.push(i);
                }

                hasMx = false;
            }

            for (i = remove.length - 1; i >= 0; i--) {
                
                delete cg[remove[i]];

                
                for (j = remove[i]; j < cgc; j++) {
                    cg[j] = cg[j + 1];
                }

                
                delete cg[j-1];

                
                cws.splice(remove[i], 1);
                cg.cgc--;
            }
        }
    }


    
    function setupDefaultProps() {
        var DAF_DELIMITER = ":",
            gd = this.gridData,
            gts = gd.gts,
            chs = gd.ghs.chs,
            row = gts.row,
            firstTitle = row[0],
            hasMetrics = gts.col && gts.col.length > 0,
            vp = {
                
                bn: "0",

                
                gr: "0",

                
                ar: "1",

                
                ct: "1",

                
                daf: firstTitle.id + DAF_DELIMITER + firstTitle.fid,

                
                cols: {
                    
                    cws: [ { w: "100"} ],
                    cg: { cgc: 1 }
                }
            },
            gdAxis = ['row'],
            gdES = [gts.row],
            idx,
            len;

        
        if(hasMetrics) {
            
            gdAxis = ['row', 'col'];
            gdES = [gts.row, chs.items[0].items];

            
            vp.cols = {
                cws: [ { w: "50" }, { w: "50" } ],
                cg: { cgc: 2 }
            }
        }
        cg = vp.cols.cg;

        
        for(idx = 0, len = cg.cgc; idx < len; idx++) {
            var axis = gdAxis[idx],
                i;

            
            cg[idx] = {
                
                tg: true,

                
                cl: gdES[idx].length,

                
                cc: 0,

                
                sh: true
            };

            
            if (axis === 'col') {
                for (i = 0; i < gdES[idx].length; i++) {
                    cg[idx]['mix' + i] = gdES[idx][i].mix;
                }
            } else {
                cg[idx].attForms = [];
                for (i = 0; i < gdES[idx].length; i++) {
                    cg[idx].attForms[i] = {idx: i, n: ''};
                }
            }
        }

        
        this.gridData.vp = vp;
    }

    
    function findStackedCells(tr, trs) {
        var c, i, iLen, cn,
            
            findTR = function (direction, row, collection) {
                var j, jLen, r = row[direction + 'Sibling'], cell;
                if (r) {
                    for (j = 0, jLen = r.cells.length; j < jLen; j++) {
                        cell = r.cells[j];
                        if ((direction === 'next' && /stack-bottom/.test(cell.className)) || (direction === 'previous' && /stack-top/.test(cell.className))) {
                            collection.push(r);
                            return;
                        }
                    }

                    collection.push(r);
                    findTR(direction, r, collection);
                }
            };

        
        trs.push(tr);
        for (i = 0, iLen = tr.cells.length; i < iLen; i++) {
            c = tr.cells[i];
            cn = c.className;
            
            if (/stack/.test(cn)) {
                
                if (/stack-top/.test(cn)) {
                    findTR('next', tr, trs);
                    break;
                
                } else if (/stack-bottom/.test(cn)) {
                    findTR('previous', tr, trs);
                    break;
                
                } else if (/stack-middle/.test(cn)) {
                    findTR('next', tr, trs);
                    findTR('previous', tr, trs);
                    break;
                }
            }
        }

        return trs;
    }

    function addSelection(rows) {
        $A.forEach(rows, function (row) {
            
            mstrmojo.css.addClass(row, $SELECTED_ROW);
        });
    }

    function removeSelection() {
        
        var rows = $H.copy(document.getElementsByClassName($SELECTED_ROW));

        $A.forEach(rows, function (row) {
            mstrmojo.css.removeClass(row, $SELECTED_ROW);
        });
    }



    
    function handleAction(target) {
        
        var td = $D.findAncestorByAttr(target, 'ei', true, this.domNode),
            node = td && td.node,
            cell = this.getCellForNode(node);

        
        if (node && node.className.indexOf('iggroup') > 0) {
            return true;
        }

        
        if (this.isInteractiveGrid() && this.igToggle(cell)) {
            
            return true;
            
        }

        
        
        
        if (!cell) {
        	return true;
        }

        
        if ($D.contains(this._BR, target)) {
            
            removeSelection();

            var row = $D.findAncestorByName(target, 'tr', true);
            
            if ($D.contains(this._BR, row)) {
                
                addSelection(findStackedCells(row, []));
            }
        }

        return false;
    }

    
    mstrmojo._IsInteractiveGrid = mstrmojo.provide(
        "mstrmojo._IsInteractiveGrid",
        
        {
            _mixinName: 'mstrmojo._IsInteractiveGrid',

            
            cssClass: 'mstrmojo-InteractiveGrid',

            
            enableMagnifier: false,

            
            scrollerConfig: {
                scrollPast: false
            },

            
            isInteractiveGrid: function () {
                return (this.gridData.vp && this.gridData.vp.cols) ? true : false; 
            },

            preBuildRendering: function preBuildRendering() {
                
                if (this.gridData.eg) {
                    return this._super();
                }

                
                if (!this.isInteractiveGrid()) {
                    setupDefaultProps.call(this);
                }

                
                cleanUpMXVP.call(this);

                var me = this,
                    parent = this.parent,
                    setProp = function (propName) {
                        me[propName] = me[propName] || ((parent && parent[propName]) ? parent[propName] : 480);
                    };

                
                setProp('height');
                setProp('width');

                
                var theme = isNaN(this.gridData.vp.ct) ? 1 : parseInt(this.gridData.vp.ct, 10);

                
                this.cssClass = "mstrmojo-InteractiveGrid " + $THEMES[theme];

                
                this.scrollboxNodeOverflow = 'overflow:hidden;';

                var returnVal = (this._super ? this._super() : true);

                this.cssDefault = (this.cssDefault === "") ? "r-cssDefault" : "";

                return returnVal;
            },

            
            getKey: function getKey() {
                return this.gridData.k;
            },

            
            renderChildren: function renderChildren() {
                
                this.prepareCWSCalculation();

                
                if (this._super) {
                    this._super();
                }

                
                this.createStickySections();

                
                var BR = this.zones._BR,
                    hilitedCells = BR.hiliteCellsMap,
                    rows = {}, trs = [];
                
                $H.forEach(hilitedCells, function(cell, key){
                    $A.forEach(cell.pos, function(ro) {
                        BR.clearHilites(key);
                        rows[ro.row] = ro.row;
                    });
                });
                
                if(!$H.isEmpty(rows)) {
                    
                    $H.forEach(rows, function(v){
                        trs.push(BR.domNode.firstChild.rows[v]);
                    });
                    
                    addSelection(findStackedCells(trs[0], []));
                }
            },

            
            useDomToCalculateOffsets: function useDomToCalculateOffsets() {
                var cp = this.zones._BR.cp;
                if (cp && (cp.groupEnabled || cp.stackLevels > 1)) {
                    return true;
                } else {
                    return (this._super || this._super()) || false;
                }
            },

            
            prepareCWSCalculation: function prepareCWSCalculation() {
                var fmts = this.getFormats && this.getFormats(),
                    
                    width = (!isIGFullscreen.call(this)) ? parseInt(fmts.width, 10) : parseInt(this.width, 10);

                
                this.zones._BR.cp.gridWidth = width;
                this.zones._TR.cp.gridWidth = width;
            },

            
            createStickySections: function createStickySections() {
                var gd = this.gridData,
                    fmts = this.getFormats && this.getFormats();

                
                if (this.isInteractiveGrid() && (gd.vp.gr === '1' && gd.gts.cws.length > 1)) {
                    
                    mstrmojo.requiresCls("mstrmojo.StickySections");

                    
                    var node = this._TR,
                        slotName = 'stickySections';

                    
                    this.addSlots({ stickySections: node });

                    
                    if (!this.ss) {
                        var cell = this.zones._BR.cp.getResolvedGroupHeader(0, 0),
                            cssClass = "iggroup xtab-td",
                            DPICONVERSION = {
                                    320: -52
                                },
                            marginBottom = DPICONVERSION[mstrMobileApp.getDeviceDPI()] || -33,
                            
                            
                            width = (!isIGFullscreen.call(this)) ? (parseInt(fmts.width, 10) + 'px') : '100%',
                            cssText = "width: " + width + ";z-index: 2; position: relative;margin-bottom:" + marginBottom + "px;";

                        
                        this.ss = new mstrmojo.StickySections({
                            currentSectionTitle: cell.n || cell.v,
                            cssClass: cssClass,
                            slot: slotName,
                            cssText: cssText
                        });

                        this.addChildren(this.ss);
                    }
                }
            },

            
            performAction: function performAction(touch) {
                
                return handleAction.call(this, touch && touch.target) || (this._super && this._super(touch));
            },

            
            igToggle: function igToggle(cell) {
                
                if (!this.isInteractiveGrid() || !cell) {
                    return false;
                }

                var e = cell && cell._e,
                    otp = (cell && cell.otp) || (e && e.otp);

                if (otp) {
                    var i,
                        j,
                        cols = this.gridData.vp.cols,
                        cg = cols.cg,
                        mix = cell.mix,
                        OBJECT_TYPE_METRIC = 4,
                        OBJECT_TYPE_ATTR = 12,

                        
                        adjCol = function (currentCol, colPos) {
                            var _return = false;

                            
                            if (currentCol.tg && currentCol.cl > 1) {
                                var cc = currentCol.cc,
                                    cur = currentCol.cc,
                                    start = 0,
                                    end = currentCol.cl,
                                    diff = currentCol.cc = (++cur >= (end + start)) ? start : cur,
                                    colgroup = [this._TR.getElementsByTagName('COLGROUP')[0], this._BR.getElementsByTagName('COLGROUP')[0]];

                                
                                $A.forEach(colgroup, function (c) {
                                    var wPx = c.childNodes[colPos + cc].style.width;

                                    c.childNodes[colPos + cc].style.width = '0';
                                    c.childNodes[colPos + diff].style.width = wPx;
                                });

                                _return = true;
                            }

                            return _return;
                        },
                        currentCol,
                        attFm,
                        count = 0,
                        returnVal = false;

                    if (cell && cell.otp === OBJECT_TYPE_ATTR) {
                        for (i = 0; i < cg.cgc; i++) {
                            currentCol = cg[i];
                            attFm = currentCol.attForms;

                            
                            if (attFm) {
                                for (j = 0; j < currentCol.cl; j++) {
                                    if (attFm[j] && (attFm[j].idx === (cell.ci || cell.ui))) {
                                        
                                        returnVal = adjCol.call(this, currentCol, count);
                                    }
                                }
                            }

                            
                            count += currentCol.tg ? currentCol.cl : 1;
                        }

                    
                    } else if (e && e.otp === OBJECT_TYPE_METRIC) {
                        for (i = 0; i < cg.cgc; i++) {
                            currentCol = cg[i];

                            
                            if (currentCol['mix' + currentCol.cc] === mix) {
                                
                                returnVal = adjCol.call(this, currentCol, count);
                            }

                            
                            count += currentCol.tg ? currentCol.cl : 1;
                        }
                    }

                    return returnVal;
                }

                
                return false;
            },

            
            getHACP: function getHACP() {
                
                var hacp = (this.isInteractiveGrid()) ? new mstrmojo.InteractiveGridHACP() : this._super();

                
                hacp.onDemandIF = !!(this.onDemandIF && this.gridData.rw);

                return hacp;
            },

            
            onheightChange: function onheightChange() {
                if (isIGFullscreen.call(this) && this.scrollboxNode) {
                    
                    this.scrollboxNode.style.height = (parseInt(this.height, 10) - this._TR.clientHeight) + 'px';
                }

                
                if (this._super) {
                    this._super();
                }
            },

            
            onwidthChange: function onwidthChange() {
                if (isIGFullscreen.call(this)) {
                    
                    var w = this.width;

                    
                    if (this.hasRendered) {
                        
                        this.unrender();

                        
                        this.width = w;

                        
                        this.render();
                    }

                } else if (this._super) {
                    this._super();
                }
            },

            
            defaultAction: function defaultAction(td, tCell) {
                var _returnVal = false;

                if (this._super) {
                    _returnVal = this._super(td, tCell);
                }

                
                this.model.sti = null;

                return _returnVal;
            },

            
            onclick: function onclick(evt) {
                
                if (!mstrApp.isTouchApp()) {
                    var e = evt.e;

                    
                    return handleAction.call(this, $D.findAncestorByName(e.target, 'td', true)) || (this._super && this._super(evt));
                }
            },



            touchSelectBegin: function touchSelectBegin(touch) {
                var tch = touch;

                var touchTd = mstrmojo.dom.findAncestorByName(touch.target, 'td', true, this.domNode);
                var hasImg = this.hasImgTag(touchTd);
                var touchArea = mstrmojo.dom.findAncestorByAttr(touch.target, 'trType', true, this.domNode);
                if (touchTd && touchArea && !hasImg) {
                	var textWidth = this.getTextWidth(touchTd, touchTd.className);
                    if (textWidth > touchTd.offsetWidth - 30) {
                    	
                   	 
                    	if (!this.visTextTooltip) {
                    		var ph = document.createElement('div');
                    		this.domNode.appendChild(ph);
                        	this.visTextTooltip = new mstrmojo.VisTextTooltip({placeholder: ph, targetDiv: touchTd, boundary: this.domNode, touchAreaType: touchArea.value});
                            this.visTextTooltip.render();
                            this.visTextTooltip.updateContent(touchTd, touchArea.value, touchTd.innerText);
                        } else {
                        	this.visTextTooltip.targetDiv = touchTd;
                        	this.visTextTooltip.touchAreaType = touchArea.value;
                        	this.visTextTooltip.updateContent(touchTd, touchArea.value, touchTd.innerText);
                        }
                    }
                }

            },

            touchSelectEnd: function touchSelectEnd(touch) {
            	var tch = touch;

            	if (this.visTextTooltip && this.visTextTooltip.domNode) {
            		this.visTextTooltip.toggle(false);
            	}

            },

            
            
            hasImgTag: function hIT(touchTd) {
            	var child = touchTd && touchTd.childNodes.length>0 && touchTd.childNodes[0];
            	if (child && child.nodeName.toLowerCase() === 'div') {
            		var grandChild = child.childNodes.length>0 && child.childNodes[0];
            		if (grandChild && grandChild.nodeName.toLowerCase() === 'div') {
            			var img = grandChild.childNodes.length>1 && grandChild.childNodes[1];
            			if (img && img.nodeName.toLowerCase() === 'img') {
            				return true;
            			}
            		}
            	}

            	return false;

            },

            getTextWidth : function gtw(dom, className, fontName, fontSize, fontSizeUnit, bold) {
            	var childNodes = dom.childNodes;
            	var table = null,
            		selfTextDom = null;
            	if (childNodes.length>0 && childNodes[0].nodeName.toLowerCase() === '#text') {
            		table = document.createElement('table');
            		selfTextDom = document.createElement('td');
            		table.appendChild(selfTextDom);
            	} else if (childNodes.length>0 && childNodes[0].nodeName.toLowerCase() === 'span') {
            		selfTextDom = document.createElement('span');
    				selfTextDom.style = "z-index:-10;visibility:hidden;-webkit-text-size-adjust: none;";
            	} else {
            		return -1;
            	}

				if(selfTextDom.className !== className || "")
					selfTextDom.className = className || "";
				if(selfTextDom.style.fontFamily !== fontName || "")
					selfTextDom.style.fontFamily = fontName || "" ;

				var fsUnit = fontSizeUnit || "pt"

				if(fontSize){
					selfTextDom.style.fontSize = fontSize + fsUnit;
				}else{
					selfTextDom.style.fontSize = '';
				}

				if(bold){
					if(selfTextDom.style.fontWeight !== 'bold')
						selfTextDom.style.fontWeight = 'bold';
				}else{
					if(selfTextDom.style.fontWeight!=='')
						selfTextDom.style.fontWeight = '';
				}

				selfTextDom.innerHTML = dom.innerText;

				var ret = -1;
				if (table) {
					this.domNode.appendChild(table);
					ret = selfTextDom.offsetWidth - 30; 
					this.domNode.removeChild(table);
				} else {
					this.domNode.appendChild(selfTextDom);
					
					ret = selfTextDom.offsetWidth;
					this.domNode.removeChild(selfTextDom);
				}


				return ret;
			},

            
            unrender: function unrender(ignoreDom) {
            	
            	if (this.visTextTooltip && this.visTextTooltip.destroy) {
               		this.visTextTooltip.destroy();
               		delete this.visTextTooltip;
               	}

                var stickySection = this.ss;

                
                if (stickySection) {
                    
                    this.removeChildren(stickySection, true);

                    
                    stickySection.destroy();
                    delete this.ss;
                }

                
                this._super(ignoreDom);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Button",
                         "mstrmojo.XtabZone",
                         "mstrmojo.DICFactory",
                         "mstrmojo.DynamicClassFactory");

    
    var MARKROW = 102,

        ROW_HEADER_MERGED = 1,

        TX_MARK = 2, 

        $C = mstrmojo.css,
        $D = mstrmojo.dom,
        $H = mstrmojo.hash,
        $CFC = mstrmojo.DynamicClassFactory.newComponent,
        CP_TITLE = 1,
        CP_COL_HEADERS = 2,
        CP_ROW_HEADERS = 4,
        COL_AXIS = 2,
        TX_ELEM_ATT_FORM = 1,
        TX_ELEM_METRIC = 2,
        MARK_ROW = 1, 
        CHANGE_DATA = 2, 
        MR_MANIPULATION_UNSET = 1,
        MR_MANIPULATION_SELECT = 2,
        DATA_DRIVEN_CONTROL = 2,
        XTAB = 1,
        getGroupIdx = function (cell) {
            if (cell) {
                return cell.tui >= 0 ? ('h_' + cell.tui + '_' + cell.fi + '_' + cell.axis) : ('m_' + cell.mix);
            }
            return '';
        };



















    
    function applyChange(c, k, vo) {
        var t = this.nm[k],
            v = vo.v,
            dv = vo.dv;

        c.rv = v;
        c.v = dv;
        c.mdf = 1;
        
        
        if (c._src) {
            c._src.rv = v;
            c._src.v = dv;
            c._src.mdf = 1;
        }

        
        var dicWidget = this.dicGroupMap[getGroupIdx(c)].widgetsMap[c._ei];

        
        if (!dicWidget.showByDefault) {
            if (dicWidget.hasPreview) {
                dicWidget.renderPreview();
            } else {
                
                if ($D.isIE7 && mstrmojo.string.isEmpty(v)) {
                    v = ' ';
                }
                t[t.innerText !== undefined ? 'innerText' : 'textContent'] = v;
            }
        }
        return t;
    }

    
    function onTotalRow(cp, o, rs) {
        if (rs[o] === 0) {
            return true;
        }

        if (cp && rs[o] === undefined) {
            try {
                var cells = cp.getRowCells(o),
                    c = cells && cells[0];
                if (c && c.o === o) {
                    if (c.sst) {
                        rs[o] = 0;
                    }
                    return !!c.stt;
                }

                if (c && c.o) {
                    return onTotalRow(cp, o + o - c.o, rs);
                }

                return false;
            } catch (ex) {
                return false;
            }
        } else {
            return false;
        }
    }

    
    function updateSelectedRows(marked, rs) {
        mstrmojo.array.forEach(marked, function (m) {
            rs[m.o] = 1;
        });
    }

    
    function clearMergedHeaderMarks(gd) {
        if (gd.mgh && (gd.mgh & ROW_HEADER_MERGED)) {
            this.mghMarks = {};
        }
    }
    
    
    function clearSelectedRowsForBlock(selections, block) {
          var begin = block.bb - 1, 
              end = Math.min(begin + block.bc, block.tc),
              row;
          $H.forEach(selections, function(v, idx) {
              row = Number(idx);
              if (row !== NaN && row >= begin && row < end) {
                  delete selections[idx];
              }
          });
    }

    
    function markDirtyRows(c, rowIdx) {
        var rs = this.editing ? 1 : (c.rs || 1),
            i;

        for (i = 0; i < rs; i++) {
            this.dirtyRows[rowIdx + i] = 1;
        }
    }

    
    function isDataDrivenDIC(di) {
    	return di && parseInt(di.ipt, 10) === DATA_DRIVEN_CONTROL; 
    }

    
    
    function getRowIndex(cell) {
        var _BR = this.zones._BR,
            _BL = this.zones._BL;
        
        
        if(!_BL) {
            return _BR.getRowIdxByCell(cell);
        } else {
            
            if(_BR.posMap && _BR.posMap[cell._ei]) {
                return _BR.getRowIdxByCell(cell);
            
            } else {
                return _BL.getRowIdxByCell(cell);
            }
        }
    }    
    
    mstrmojo._IsEditableGridCP = {

        _mixinName: "mstrmojo._IsEditableGridCP",

        
        initContent: function initContent(startIndexInContainer) {
            this._super(startIndexInContainer);

            
            
            
            
            
            var gd = this.gridData,
                vp = gd && gd.vp,
                i,
                j,
                fm,
                size,
                cg,
                cl,
                cws,
                rt;
            if (((this.type === CP_TITLE) || (this.type === CP_ROW_HEADERS)) && vp && vp.cols && !vp._adjusted) {
                cg = vp.cols.cg;
                cws = vp.cols.cws;
                
                if (cg && cg.cgc > 0) {
                    for (i = cg.cgc; i > 0; i--) {

                        cg[i] = $H.copy(cg[i - 1], {});
                        cl = cg[i];
                        var fms = cl.attForms;
                        if (fms) {
                            for (j = 0, size = fms.length; j < size; j++) {
                                fm = fms[j];
                                
                                fm.idx += 1;
                            }
                        }
                    }
                    
                    cg[0] = {tg: false, cc: 0, cl: 1, attForms: [{n: '', idx: 0}]};
                    
                    cg.cgc += 1;
                }
                
                if (cws) {
                    cws.splice(0, 0, {w: '60px', xc: true});
                }
                
                if (vp.dafIdx !== undefined) {
                    vp.dafIdx += 1;
                }

                rt = gd.gts.row;
                for (i = 0, size = rt.length; i < size; i++) {
                    rt[i].ci = i + 1; 
                }

                
                vp._adjusted = true;
            }

            
            this.colWidths = [{w: ''}].concat(this.colWidths);
            this.unmergedCells = [];
        },

        getUnmergedCells: function getUnmergedCells() {
            return null;
        },

        
        getRowCells: function getRowCells(ri) {
            var cells = this._super(ri),
                cell = cells[0], 
                o = (cell && cell.o) || 0,
                isTtl = (this.tp === CP_TITLE),
                ics = this.interactiveCellsArray,
                fc = {
                    css: '',
                    v: ''
                },
                umc = [],
                ncs = [],
                i,
                len;

            if (!isTtl) {
                var rows = this.base.items,
                    lb = this.lookupBase,
                    cssBase = this.gridData.css,
                    pi = cell && cell.pi, 
                    r = pi && pi.ri, 
                    c = pi && pi.ci, 
                    otr = cell.stt > 0;
                while (pi && r > -1 && c > -1) { 
                    cell = cell._p || rows[r].items[c];
                    
                    var _c = $H.copy(cell, {});
                    
                    _c._src = cell;
                    if (!_c.css) {
                        _c.css = cssBase[_c.cni].n;
                    }

                    var unit = lb[cell.tui],
                        e = unit && unit.es[cell.idx];
                    if (e) {
                        _c.v = cell.v || e.n; 
                        
                        _c._e = e;
                    }
                    _c.rs = 1;
                    if (otr) {
                        _c.at &= ~32;
                    }
                    if (o > -1) {
                        _c.o = o;
                    }
                    if (!_c.axis && this.axis) {
                        _c.axis = this.axis;
                    }
                    _c._ei = ics.push(_c) - 1;
                    umc.splice(0, 0, _c);

                    
                    pi = cell && cell.pi;
                    r = pi && pi.ri;
                    c = pi && pi.ci;
                }

                for (i = 0, len = cells.length; i < len; i++) {
                    var nc = cells[i];
                    if (nc.rs > 1) {
                        var tc = $H.copy(nc, {});
                        tc.rs = 1;
                        nc = tc;
                    }
                    ncs.push(nc);
                }

            } else {
                ncs = cells;
                if (ri > 0) {
                    return cells;
                }
            }

            if (ncs[0]) {
                fc = $H.copy(ncs[0], {});
                fc.rv = fc.v = '';
                if (this.tp === CP_TITLE) {
                    fc.n = fc.v = '';
                    fc.markAll = true;

                } else {
                    fc.n = '';
                }
                fc._ei = ics.push(fc) - 1;
                fc.at = 32;
                fc.cs = 1;
                fc.mark = true; 
                fc.mix = 'x';
                
                
                fc.css = (umc[0] && umc[0].css) || fc.css;
                delete fc.ui;
                delete fc.tui;
                delete fc.fs;
                delete fc.mdf;
            }

            return [fc].concat(umc.concat(ncs));
        }
    };    

    
    mstrmojo._IsEditableXtab =
        {
            _mixinName: "mstrmojo._IsEditableXtab",

            
            update: function update(node) {
                var marks,
                    gd = node.data;

                if (this._super) {
                    this._super(node);
                }

                this.kc = {};
                this.rs = {};
                this.rsDelta = {};

                clearMergedHeaderMarks.call(this, gd);

                
                if (gd.eg !== undefined) {
                    return;
                }

                
                marks = node.data.marked;
                if (marks) {
                    updateSelectedRows(marks, this.rs);
                }

                if (!gd.rw) {
                    var rc = gd.gvs.items.length;
                    gd.rw = {
                        row: {
                            bb: 1,
                            bc: rc,
                            tc: rc
                        },
                        col: {
                            bb: -1,
                            bc: -1,
                            tc: 0
                        }
                    };
                }
            },

            
            initCP: function initCP(gd, interactiveCellsArray, tp, base, lkpBase, ax, cp) {
                var props = {
                    gridData: gd,
                    type: tp,
                    interactiveCellsArray: interactiveCellsArray
                };

                props.base = base || props.base;
                props.lookupBase = lkpBase || props.lookupBase;
                props.axis = ax || props.axis;
                props.dataSource = this;

                if (!cp) {
                    
                    if (this.tca === TX_MARK && this.editing) {
                        if (tp === CP_TITLE) {
                            mstrmojo.EditableXtabTitlesCP = $CFC(mstrmojo.XtabTitlesCP, [mstrmojo._IsEditableGridCP], {scriptClass: "mstrmojo.EditableXtabTitlesCP", tp: CP_TITLE});
                            cp = new mstrmojo.EditableXtabTitlesCP(props);
                        } else if (tp === CP_ROW_HEADERS) {
                            mstrmojo.EditableXtabCP = $CFC(mstrmojo.XtabCP, [mstrmojo._IsEditableGridCP], {scriptClass: "mstrmojo.EditableXtabCP"});
                            cp = new mstrmojo.EditableXtabCP(props);
                        } else {
                            cp = new mstrmojo.XtabCP(props);
                        }
                    } else {
                        if (tp === CP_TITLE) {
                            cp = new mstrmojo.XtabTitlesCP(props);
                        } else {
                            cp = new mstrmojo.XtabCP(props);
                        }
                    }
                } else {
                    $H.copy(props, cp);
                }

                return cp;
            },

            
            createOnDemandCP: function createOnDemandCP(blockNum, rc, zone) {
                var cp;

                
                if (this.tca === TX_MARK && this.editing && zone === CP_ROW_HEADERS) {
                    mstrmojo.EditableXtabOnDemandCP = $CFC(mstrmojo.XtabOnDemandCP, [mstrmojo._IsEditableGridCP], {scriptClass: "mstrmojo.EditableXtabOnDemandCP"});
                    cp = new mstrmojo.EditableXtabOnDemandCP();
                } else {
                    cp =  new mstrmojo.XtabOnDemandCP();
                }

                cp.dataSource = this;
                cp.blockNum = blockNum;
                cp.rc = rc;
                return cp;
            },

            preBuildRendering: function preBuildRendering() {
                var txi = this.defn.txi;

                if (this._super) {
                    this._super();
                }

                this.txar = txi.txar;
                
                this.sci = txi.sci;
                this.tca = txi.tca;

                
                if (this.tca !== TX_MARK) {
                    this.editing = false;
                } else {
                    if (mstrApp.isMobile) {
                    
                        this.editing = this.alwaysEditing = true;
                    }
                }
                
                this.nm = {};
                this.ko = {};

                this.dirtyRows = {}; 
                this.requiredCellsMap = {}; 

                this.dicGroupMap = {};
                this.lastIndex = 0;
                this.lastHeaderIndex = 0;
                this.columnNames = {};
            },

            postBuildRendering: function postBuildRendering() {
                if (this._super) {
                    this._super();
                }

                
                if (this.tca === TX_MARK && this.gridData.eg === undefined) {
                    var t = Math.max(-16, -this.domNode.offsetTop), 
                        me = this;

                    if (!this.alwaysEditing) {
                        var dn = mstrmojo.Button.newIconButton(mstrmojo.desc(8324, 'Mark rows'), 'mstrmojo-EditButton', function () {
                                if (!me.recalculating) {
                                    me.editing = !me.editing;
                                    me.refresh();
                                }
                            }),
                            btn = new mstrmojo.Button(mstrmojo.hash.copy({
                                cssText: 'top:' + t + 'px;'
                            }, dn));

                        btn.render();
                        this.domNode.appendChild(btn.domNode);


                        if (this.editing) {
                            this.domNode.style.zIndex = 1000;
                            
                            $C.addClass(btn.domNode, 'close');
                        } else {
                            $C.removeClass(btn.domNode, 'close');
                        }
                    }
                }
            },

            dataDownloadErr: function dataDownloadErr() {
                if (this.txar && this.recalculating) {
                    var z = this.zones;
                    if (z._BL) {
                        z._BL.isDownloading = false;
                    }
                    z._BR.isDownloading = false;

                    this.rhsCP.initContent();
                    this.valuesCP.initContent();

                    
                    $C.removeClass(this.maskNode, 'wait');
                    this.recalculating = false;
                }
            },

            
            dataDownloaded: function dataDownloaded(node, memo) {
                var gd = node.data;
                if (this.txar) {
                    var idx = memo.blockNum, zn = this.zones, ica;

                    if (this.recalculating) {
                        memo.recalculating = true;
                        this.interactiveCellsArray = [];
                        this.requiredCellsMap = {};
                        this.dirtyRows = {};
                        this.lastIndex = 0;
                        this.lastHeaderIndex = 0;
                        this.kc = {};
                        this.nm = {};
                        this.updatedCellsMap = {};
                        this.recalculating = false;
                        this.destroyDICs();
                    } else {
                        memo.recalculating = false;
                    }

                    
                    if (idx === 0) {
                        this.gridData = gd;
                    }

                    
                    
                    if (gd.eg) {
                        this.refresh();
                        return;
                    }

                    ica = this.interactiveCellsArray;
                    this.initCP(gd, ica, CP_TITLE, null, null, null, this.titlesCP);
                    this.initCP(gd, ica, CP_COL_HEADERS, gd.ghs.chs, gd.gts.col, COL_AXIS, this.chsCP);
                    this.titlesCP.initContent();
                    this.chsCP.initContent();

                    
                    
                    
                    if (ica && ica.length === 0) {
                        if (zn._TR) {
                            zn._TR.refresh();
                        }
                        if (zn._TL) {
                            zn._TL.refresh();
                        }
                    }
                }

                if (this._super) {
                    this._super(node, memo);
                }

                
                clearMergedHeaderMarks.call(this, gd);

                
                clearSelectedRowsForBlock(this.rs, gd.rw.row); 
                
                if (gd.marked) {
                    updateSelectedRows(gd.marked, this.rs);
                    this.rsDelta = {};
                }
            },

            closeDownloadStatus: function closeDownloadStatus() {
                if (this._super) {
                    this._super();
                }
                mstrmojo.css.removeClass(this._STATUS, 'recalculate');
            },


            
            kc: null,

            
            ko: null,

            
            nm: null,

            
            rs: null,

            
            dicGroupMap: null,

            
            lastIndex: 0,

            
            lastHeaderIndex: 0,

            
            columnNames: null,

            
            getDataInputInfo: function getDataInputInfo(cell, widx) {
                var k = cell._ei, o,
                    defn = this.node.defn,
                    data = this.gridData;

                if (cell.mark) {
                    o = cell.o;
                    if (cell.stt) {
                        this.rs[o] = 0; 
                        return;
                    }
                    this.ko[o] = k;
                    cell.rv = cell.v = this.rs[o] || -1;
                    this.kc[k] = {rowop: true};
                    return {
                        key: k,
                        t: MARKROW,
                        vls: [{
                            'v': -1
                        }, {
                            'v': 1
                        }],
                        wm: 1,
                        w: 22,
                        hm: 1,
                        h: 16,
                        dm: 1
                    };
                }

                var titleInfo = this.model.getCellTitleInfo(cell, this.dataBlocks[cell._gd]),
                    title = titleInfo && titleInfo.title,
                    es = title && title.es,
                    mti = (cell.mti !== undefined) ? cell.mti : cell.mix,
                    isMtx = (cell.mix !== undefined),
                    dic = defn.txi.dic,
                    di;

                di = !isMtx ? dic.att && title && dic.att[title.id] && dic.att[title.id][title.fs[cell.fi].id] : dic.mtx && dic.mtx[es[mti].oid];

                if (!di) {
                    return null;
                }

                
                if (this.columnNames[widx] === undefined) {
                	this.columnNames[widx] = !isMtx ? title.n : es[mti].n;
                }

                
                if (isDataDrivenDIC(di)) {
                	di.vls = (data.dcv && data.dcv[di.k]) || [];
                }

                
                if (k >= 0 && !this.kc[k]) {
                    var isMv = !cell.axis,
                        t = {
                            isMv: isMv
                        };

                    if (isMv) {
                        var pi = cell.pi,
                            tp = pi && pi.top;
                        t.co = (tp && tp.ci) || 0;
                        t.metric_id = es[mti].oid;
                        cell.o = t.o = (cell._lp && cell._lp.o) || 0;
                        t.tp = TX_ELEM_METRIC;
                    } else {
                        t.ax = cell.axis;
                        t.atid = title.id;
                        t.form_id = title.fs[cell.fi].id;
                        t.o = cell.o;
                        t.tp = TX_ELEM_ATT_FORM;
                        t.fi = cell.fi;
                        t.ui = cell.ui;
                        t.tui = cell.tui;
                        t.rs = cell.rs;
                    }

                    t.dt = di.dt;
                    if (isDataDrivenDIC(di)) {
                    	t.vls = di.vls;
                    	t.k = di.k;
                    }

                    this.kc[k] = t;
                }

                di.key = k;

                if (di.dm) {
                    di.dm = parseInt(di.dm, 10);
                }

                return di;

            },

            isEditableHeader: function isEditableHeader(cell) {
                var defn = this.node.defn,
                    dic = defn.txi.dic;

                if (cell.sst || !dic) {
                    return false;
                }

                if (cell.id !== undefined && dic.att) { 
                    return !!(dic.att[cell.id] && (cell.fix ? dic.att[cell.id][cell.fid] : dic.att[cell.id]));
                }

                if (cell.tui !== undefined && cell.mix !== undefined && dic.mtx) { 
                    return !!(dic.mtx[cell._e.oid]);
                }

                return false;
            },

            
            dataChanged: function dataChanged(k, r, v, d) {
                if (!this.recalculating) {
                    if (d) {
                        this.nm[k] = d;
                    }

                    if (this._super) {
                        this._super(k, r, v, d);
                    }
                }
            },

            
            updateValue: function updateValue(k, vo) {
                if (this._super) {
                    this._super(k, vo);
                }

                var c = this.interactiveCellsArray[k],
                    v = vo.v,
                    t,
                    rowIdx = getRowIndex.call(this, c);

                this.lmr = null; 

                
                
                
                





                t = applyChange.call(this, c, k, vo);
                if (c.r !== v) {
                    if (!c.mark) {
                        
                        c.mdf = 1;

                        
                        mstrmojo.css.removeClass(t, 'required');

                        markDirtyRows.apply(this, [c, rowIdx]);

                        
                        this.flagDirtyUnit(t);
                    }
                } else {
                    this.clearDirtyUnit(t);
                }

                
                if (this.tca === TX_MARK) {
                    
                    if (c.mark) { 
                        var ordinal = c.markAll ? -1 : c.o,
                            rsDelta = this.rsDelta;

                        this.rs[ordinal] = v;

                        
                        
                        this.lmr = {r: ordinal, v: v}; 

                        if (c.markAll) {
                            
                            rsDelta = this.rsDelta = {};
                            rsDelta[ordinal] = v;
                            this.mghMarks = {};
                        } else if (rsDelta[ordinal] && rsDelta[ordinal] !== v) {
                            
                            
                            delete rsDelta[ordinal];
                        } else if (rsDelta[-1] !== v) {
                            
                            rsDelta[ordinal] = v;
                        }
                    } else { 
                        if (this.rs[c.o] !== 0) {
                            this.rs[c.o] = 1;
                        }

                        
                        if (!this.editing && this.mghMarks && (c.mix === undefined)) {
                            
                            
                            if(!this.mghMarks[c.o] || this.mghMarks[c.o].rs < c.rs) {
                                
                                this.mghMarks[c.o] = {o: c.o, rs: c.rs, k: k};
                            }
                            
                            
                            var sro,
                                sco,
                                me = this;
                            $H.forEach(this.rsDelta, function (mv, ro) {
                                sro = parseInt(ro, 10);
                                sco = parseInt(c.o, 10);
                                if (sro >= sco && sro <= (sco + c.rs)) {
                                    delete me.rsDelta[ro];
                                }
                            });
                        } else {
                            
                            this.rsDelta[c.o] = 1;
                        }

                        
                        
                        if (!this.editing && c.rs > 1) {
                            var o = c.o + 1;
                            while (o - c.o < c.rs) {
                                if (!onTotalRow(this.rhsCP, o, this.rs)) {
                                    this.rs[o] = 1;
                                }
                                o += 1;
                            }
                        }
                        
                        if (this.editing) {
                            var w = this.dicGroupMap.m_x.widgetsMap[this.ko[c.o]];
                            if (w) {
                                w.set('checked', true);
                            }
                        }
                    }
                }

                
                
                if (this.txar && !c.mark) {
                    return true;
                }

                return false;
            },

            autoRefresh: function autoRefresh() {
                
                var z = this.zones;
                if (z._BL) {
                    z._BL.invalidAllPages();
                }
                z._BR.invalidAllPages();
                
                this.rhsCP.invalid();
                this.valuesCP.invalid();

                
                $C.addClass(this._STATUS, 'recalculate');

                
                z._BR.onscroll(true); 
                this.recalculating = true;
            },

            
            getKeyContext: function getKeyContext(key) {
                return this.kc[key];
            },

            
            getUpdateObject: function getUpdateObject() {
                var cs = [], j, udvs, udv, lmr = this.lmr, v, ddicObj = {};

                if (lmr) { 
                    
                    this.lmr = null;
                    return {
                        manipulation: MARK_ROW,
                        actionType: (lmr.v === -1) ? MR_MANIPULATION_UNSET : MR_MANIPULATION_SELECT,
                        rowOrdinal: lmr.r, 
                        nodeKey: this.k,
                        sliceId: this.sid
                    };
                }

                
                udvs = this.getUpdatedValues();

                
                for (j = 0; j < (udvs && udvs.length); j++) {
                    if (!udvs[j].rowop) {
                        udv = udvs[j];
                        break;
                    }
                }

                if (udv) {
                    
                    v = mstrmojo.string.encodeXMLAttribute(String(udv.v));

                    if (udv.k !== undefined && udv.vls) {
                        ddicObj = {
                            controlKey: udv.k,
                            elementId: udv.vls[mstrmojo.array.find(udv.vls, 'v', udv.v)].eid
                        };
                    }

                    if (!!udv.isMv) {
                        cs.push($H.copy(ddicObj, {
                            rowOrdinal: udv.o,
                            colOrdinal: udv.co,
                            newValue: v,
                            dataType: udv.dt
                        }));
                    } else {
                        cs.push($H.copy(ddicObj, {
                            rowOrdinal: udv.o,
                            attId: udv.atid,
                            formId: udv.form_id,
                            unitIndex: udv.tui || udv.ui, 
                            newValue: v,
                            dataType: udv.dt
                        }));
                    }
                }

                return {
                    manipulation: CHANGE_DATA,
                    nodeKey: this.k,
                    sliceId: this.sid,
                    cells: cs,
                    
                    autoRefresh: this.txar
                };
            },

            
            getUpdates: function getUpdates() {
                var w = this, j, udv,
                    udvs = w.getUpdatedValues(),
                    srs = this.rsDelta,
                    eg = [], gd = [], udt = false, k = '';


                eg.push('<gr rw_tree_type="' + w.treeType + '" rw_node_key="' + w.k + '" slice_id="' + w.sid + '">');
                for (j in udvs) {
                    if (udvs.hasOwnProperty(j)) {
                        udv = udvs[j];
                        if (!udv.rowop) {
                            
                            var v = mstrmojo.string.encodeXMLAttribute(String(udv.v));

                            
                            if (udv.k && udv.vls) {
                                var m = mstrmojo.array.find(udv.vls, 'v', udv.v);
                                k = 'rw_control_key="' + udv.k + '" element_id="' + udv.vls[m].eid + '" ';
                            }

                            if (!!udv.isMv) {
                                gd.push('<cli cordinal="' + udv.co + '" metric_id="' + udv.metric_id + '"><updt types="' + udv.tp + '" rordinal="' + udv.o + '" ' + k + 'value="' + v + '" dt="' + udv.dt + '"/></cli>');
                            } else {
                                
                                
                                
                                gd.push('<cli ax="' + udv.ax + '" attribute_id="' + udv.atid + '" form_id="' + udv.form_id + '"><updt types="' + udv.tp + '" ordinal="' + udv.o + '" ' + k + 'value="' + v + '" dt="' + udv.dt + '"' + (this.mghMarks ? ' flags="1"' : '') + '/></cli>');
                            }
                            udt = true;
                        }
                    }
                }

                
                if (!$H.isEmpty(this.mghMarks)) {
                    var me = this;
                    $H.forEach(this.mghMarks, function (v, ro) {
                        k = me.getKeyContext(v.k);
                        gd.push('<mark rordinal="' + ro + '" types="4" flags="1" attribute_id="' + k.atid + '" form_id="' + k.form_id + '"/>');
                    });
                }

                
                if (srs && !$H.isEmpty(srs)) {
                    udt = true;
                    $H.forEach(srs, function (v, o) {
                        if (v === 1) {
                            gd.push('<mark rordinal="' + o + '" types="4"/>');
                        } else {
                            gd.push('<mark rordinal="' + o + '" types="5"/>');
                        }
                    });
                }

                eg.push(gd.join(''));
                eg.push('</gr>');

                
                if (!udt) {
                    eg = [];
                }
                return eg.join('');
            },

            
            flagDirtyUnit: function flgDtUnt(t) {
                if (t && this.sci) {
                    if (this._super) {
                        this._super(t);
                        return;
                    }

                    var v = document.createElement('div'),
                        df,
                        tf = false,
                        trans3d = $C.getStyleValue(this.domNode, $D.CSS3_TRANSFORM),
                        isTDRelative;
                    v.className = "flag-container";
                    v.innerHTML = '<div class="dirty-cell"/>';
                    if (t.insertBefore) {
                        t.insertBefore(v, t.firstChild);
                        isTDRelative = (v.offsetParent === t);
                    }
                    tf = mstrmojo.string.isEmpty(trans3d) || trans3d === "none";
                    
                    df = v.firstChild;
                    df.style.top = ((!tf || isTDRelative) ? (-v.offsetTop) : (t.offsetTop - v.offsetTop)) + 'px';
                    df.style.left = (t.clientWidth + ((!tf || isTDRelative) ? (-v.offsetLeft) : (t.offsetLeft - v.offsetLeft)) - 8) + 'px';
                }
            },

            
            clearDirtyUnit: function clrDtUnt(t) {
                if (this._super) {
                    this._super(t);
                    return;
                }

                var c = t.firstChild;
                if (t) {
                    if (c && c.className && c.className === 'flag-container') {
                        t.removeChild(c);
                    }
                }
            },

            onvisibleChange: function onvisChg() {
                if (this.visible === true) {
                    var me = this;

                    
                    setTimeout(function () {
                        me.configureActions();
                    }, 10);
                }
            },

            
            configureActions: function cfgAct() {
                if (this.visible === false) {
                    return;
                }

                var zone = '_BR',
                    grid = this.zones[zone],
                    rowLocked = !!this.zones['_BL'],
                    posMap = grid.posMap,
                    thPosMap = grid.thPosMap,
                    ics = this.interactiveCellsArray,
                    dicGroupMap = this.dicGroupMap,
                    dirtyNodes = [],
                    ei,
                    len,
                    i,
                    k,
                    cell,
                    pos,
                    node,
                    widx,
                    rowIdx,
                    currentRow,
                    config,
                    dicGroup,
                    me = this,
                    flagDirtyNodes = function (dns) {
                        var jLen = dns.length,
                            j;
                        for (j = 0; j < jLen; j++) {
                            me.flagDirtyUnit(dns[j]);
                        }
                    };

                for (ei = this.lastIndex, len = ics.length; ics[ei] && ei < len; ei++) {
                    cell = ics[ei];
                    pos = posMap && posMap[ei];
                    
                    
                    if(!pos && rowLocked) {
                        zone = (zone === '_BR') ? '_BL' : '_BR'; 
                        grid = this.zones[zone]; 
                        posMap = grid && grid.posMap; 
                        thPosMap = grid && grid.thPosMap; 
                        pos = posMap && posMap[ei];
                    }

                    if (pos && ((cell.at & 32) > 0)) {
                        node = grid.getNodeByPosition(pos);
                        
                        
                        cell.at = 32;

                        if (cell.rv == null) {
                            cell.rv = isNaN(cell.mix) ? cell._e.n : cell.v;
                        }

                        widx = getGroupIdx(cell);
                        config = this.getDataInputInfo(cell, widx);
                        dicGroup = this.dicGroupMap[widx];

                        if (config) {
                            if (!dicGroup) {
                                dicGroup = dicGroupMap[widx] = mstrmojo.DICFactory.createDICGroup({
                                    gk: widx,
                                    dic: config,
                                    owner: this,
                                    openerType: XTAB
                                });
                            }

                            
                            
                            var dicProps = {
                                    value: (cell.rv === undefined) ? (cell.v || cell.n) : (typeof cell.rv === 'string' ? mstrmojo.string.decodeHtmlString(cell.rv) : cell.rv),
                                    dv: cell.v || cell.n,
                                    ts: cell.ts,
                                    markAll: cell.markAll,
                                    openerNode: node,
                                    k: cell._ei,
                                    ownerCell: cell,
                                    popupTitle: this.columnNames[widx]
                                },
                                stackedRh = grid.cp.stackedRh;

                            
                            if (stackedRh && cell.singleStack && (mstrmojo.DICConfig.showDICByDefault(config, 1) || mstrmojo.DICConfig.hasDICPreview(config, 1))) {
                                var tdHeight = node.offsetHeight;

                                
                                node.className += ' igDIC';
                                node.style.cssText = 'height:' + tdHeight + 'px;';

                                mstrmojo.hash.copy({
                                    inlineExtraCssText: 'position:absolute;' + 'top:' +  parseInt(stackedRh / 2 - tdHeight / 2 + 1, 10) + 'px;'

                                }, dicProps);
                            }

                            dicGroup.addDIC(cell._ei, dicProps);

                            rowIdx = pos.page * grid.rowsPerPage + pos.row;

                            if (config.req) {
                                
                                for (k = 0; k < (this.editing ? 1 : (cell.rs || 1)); k++) {
                                    currentRow = this.requiredCellsMap[rowIdx + k];
                                    if (!currentRow) {
                                        this.requiredCellsMap[rowIdx + k] = currentRow = [];
                                    }
                                    currentRow.push(cell);
                                }
                            }

                            
                            if (cell.mdf) {
                                dirtyNodes.push(node);

                                markDirtyRows.apply(this, [cell, rowIdx]);
                            }
                        }
                    }
                }
                this.lastIndex = ei;

                
                for (widx in dicGroupMap) {
                    dicGroupMap[widx].render();
                }

                
                
                
                setTimeout(function () {
                    flagDirtyNodes(dirtyNodes);
                }, 25);

                
                for (i = this.lastHeaderIndex, len = thPosMap.length; i < len; i++) {
                    pos = thPosMap[i];
                    node = grid.getNodeByPosition(pos);
                    cell = pos.obj;

                    if (this.isEditableHeader(cell)) {
                        node.innerHTML = '<div class="editable-column">' + node.innerHTML + '</div>';
                    }
                }
                this.lastHeaderIndex = i;

                this.registerTxWidget();

                if (this._super) {
                    this._super();
                }
            },

            showPopupDIC: function showPopupDIC(target) {
                var tn = target && $D.findAncestorByAttr(target, 'ei', true, this.viewport);

                if (tn) {
                    var td = tn.node,
                        cell = this.getCellForNode(td),
                        group = this.dicGroupMap[getGroupIdx(cell)];

                    if (group) {
                        group.showPopupDIC(cell._ei);
                        return true;
                    }
                }

                return false;
            },

            
            onclick: function onclick(e) {
                var target = mstrmojo.dom.eventTarget(window, e.e);

                if (!this.showPopupDIC(target) && this._super) {
                    this._super(e);
                }
            },

            unrender: function unrender() {
                if (this._super) {
                    this._super();
                }
                this.destroyDICs();
            },

            destroyDICs: function destroyDICs() {
                var dicGroupMap = this.dicGroupMap;
                this.dicGroupMap = {};

                
                setTimeout(function () {
                    var i;
                    for (i in dicGroupMap) {
                        dicGroupMap[i].destroy();
                    }
                }, 10);
            },

            
            checkRequiredObjects: function checkRequiredObjects() {
                if (this.hasRendered && !(this.isInteractiveGrid && this.isInteractiveGrid()) && !this.gridData.eg) {
                    var grid = this.zones._BR,
                        posMap = grid.posMap,
                        row,
                        me = this,
                        rowSelections = this.rs,
                        validFlag = true,
                        
                        
                        
                        processRow = function (r, hilite) {
                            var valid = true,
                                cells = me.requiredCellsMap[r],
                                len = (cells && cells.length) || 0,
                                i;

                            for (i = 0; i < len; i++) {
                                
                                if (!cells[i].mdf) {
                                    
                                    $C.toggleClass(grid.getNodeByPosition(posMap[cells[i]._ei]), 'required', hilite);
                                    
                                    valid = !hilite;
                                }
                            }

                            return valid;
                        };

                    
                    if (this.tca === TX_MARK) {
                        
                        for (row in rowSelections) {
                            validFlag = processRow(parseInt(row, 10) + 1, rowSelections[row] > 0) && validFlag;
                        }
                    } else {
                        
                        for (row in this.dirtyRows) {
                            validFlag = processRow(row, true) && validFlag;
                        }
                    }

                    return validFlag;
                }
                return true;
            },

            
            editNext: function editNext(k) {
                
                if (this.recalculating) {
                    return false;
                }

                var ics = this.interactiveCellsArray,
                    len = ics.length,
                    i = k + 1,
                    nextCell,
                    dicWidget;

                do {
                    
                    if (i >= len) {
                        i %= len;
                    }

                    
                    if (i === k) {
                        return false;
                    }

                    nextCell = ics[i];
                    var group = this.dicGroupMap[getGroupIdx(nextCell)];

                    
                    if (group) {
                        
                        if (mstrmojo.DICConfig.isKeyNavigable(group.dic)) {

                            
                            if (!group.showByDefault) {
                                group.showPopupDIC(i);
                            } else {
                                dicWidget = group.widgetsMap[i];

                                
                                dicWidget.focus();
                            }

                            return true;
                        }
                    }
                    i++;
                } while (true);
                
            }
        };
}());
(function () { 

    var ROW_AXIS = 1;
    var COL_AXIS = 2;   
    
    var CP_ROW_HEADERS = 4;
    var CP_VALUES = 8;  
    
    
    function _moreData(gd, isDoc) {
        var rw = gd.rw;
        
        
        if (!rw) {
            return false;
        }
        
        return isDoc ? (rw.row.bb + rw.row.bc < rw.row.tc) : (rw.wsr + rw.wmr < rw.tr);
    }    
    
    
    mstrmojo._XtabSeamlessIncrementalFetch = mstrmojo.provide(
            
        "mstrmojo._XtabSeamlessIncrementalFetch",   
        
        {
            
            _mixinName: 'mstrmojo._XtabSeamlessIncrementalFetch',
            
            
            useSeamlessIncFetch: true,
            
            preBuildRendering: function preBuildRendering() {
                var rtn = true;
                if (this._super) {
                    rtn = this._super();
                }
                
                if (this.useSeamlessIncFetch) {
                    
                    this.currentPageNum = 0;
                    this.currentPageNum = this.loadingPageNum = 0;
                    this.endFetching = !_moreData(this.gridData, this.isDocXtab);
                }
            },                
            
            
            aggregateCP: function aggregateCP(cp, rc, zone) {
                
                var scp = (rc === CP_ROW_HEADERS) ? this.rhsCP : this.valuesCP;
                
                
                if (scp.scriptClass !== "mstrmojo.XtabVACP") { 
                    scp = mstrmojo.hash.clone(scp);
                    var tcp = new mstrmojo.XtabVACP();
                    tcp.cps = [scp, cp];
                    mstrmojo.hash.copy(tcp, (rc === CP_ROW_HEADERS) ? this.rhsCP : this.valuesCP);
                } else {
                    
                    scp.cps.push(cp);
                }
                
                
                if (zone) {
                    zone.cp.initContent();
                }
            },
            
            onScrolledToLastRow: function onScrolledToLastRow() {
                if (this.useSeamlessIncFetch) {
                    var cp = this.currentPageNum,
                        lp = this.loadingPageNum;
                    
                    
                    if (lp <= cp && !this.endFetching) { 
                        this.loadingPageNum = cp + 1;
                        this.download(1 + cp);            
                    }
                }
            },
            
            
            download: function download(blockNum) {
                
                var rw = this.gridData.rw,
                    rwRow = rw.row,
                    rwCol = rw.col,
                    maxRows = rwRow.bc;
                
                
                this._isDownloading = this.rhsCP.isDownloading = this.valuesCP.isDownloading = true; 
                
                
                if (maxRows) {
                    var memo = {
                            blockNum: blockNum
                        };
                    
                    
                    this.controller.onDownloadGridData(this, this.model.getDownloadAction(blockNum * maxRows + 1, maxRows, rwCol.bb, rwCol.bc, this.id, memo));
                }
            },            
            
            
            dataDownloaded: function dataDownloaded(node, memo) {
                
                if (this._isDecelerating) {
                    
                    this._cachedDownload = {
                        node: node,
                        memo: memo
                    };
                    
                    
                    return;
                }
                
                
                var cachedDownload = this._cachedDownload;
                if (cachedDownload) {
                    
                    if (node) {
                        
                        alert('Missed download');
                    }
        
                    
                    node = cachedDownload.node;
                    memo = cachedDownload.memo;
                    
                    
                    delete this._cachedDownload;
                }
                
                var gd = node.data, 
                    z = this.zones;
                
                
                this._firstRowHeight = this._firstRowHeight || this.contentNode.rows[0].offsetHeight;
                
                var rhsCP = this.initCP(gd, this.interactiveCellsArray, CP_ROW_HEADERS, gd.ghs.rhs, gd.gts.row, ROW_AXIS),
                    valuesCP = this.initCP(gd, this.interactiveCellsArray, CP_VALUES, gd.gvs);
                
                this.aggregateCP(rhsCP, CP_ROW_HEADERS, z._BL);
                this.aggregateCP(valuesCP, CP_VALUES, z._BR);
        
                
                var start = rhsCP.startIndexInContainer,
                    end = start + rhsCP.rc - 1;
                
                var appGrid = function (zone) {
                    if (zone) {
                        
                        zone.start = start;
                        zone.end = end;
                        
                        
                        zone.renderGrid(true);                                                
                    }
                };
                
                
                var id = this.id;
                window.setTimeout(function () {
                    var w = mstrmojo.all[id];
                    
                    appGrid(z._BL);
                    appGrid(z._BR);
                    
                    
                    if (!_moreData(gd, w.isDocXtab)) {
                        
                        w.endFetching = true;                    
                    }
        
                    
                    w.setOffsets();
                    w.currentPageNum++;
        
                    
                    w._isDownloading = false;
                }, 0);
            }   
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasScrollbox",
                         "mstrmojo.XtabZone",
                         "mstrmojo._ShowsStatus",
                         "mstrmojo.boxmodel",
                         "mstrmojo.dom");


    var ROW_AXIS = 1;
    var COL_AXIS = 2;
    var LOCK_OFF = 0;
    var LOCK_ROW = 1;
    var LOCK_COL = 2;
    var LOCK_BOTH = 3;

    
    var CP_TITLE = 1;
    var CP_COL_HEADERS = 2;
    var CP_ROW_HEADERS = 4;
    var CP_VALUES = 8;

    var $D = mstrmojo.dom,
        UNSET;

    function onDemandCPAgg(cpList) {
        var vCP = null;
        if (cpList && cpList.length > 1) {
            
            vCP = new mstrmojo.XtabVACP();
            vCP.cps = cpList;
        }
        return vCP;
    }

    function repaint(node) {
        var img = document.createElement('img');
        node.appendChild(img);
        node.removeChild(img);
    }

    function convertEmtoPx(dom, v) {
        if ($D.isIE) {
            return mstrmojo.boxmodel.convert2px(dom, v);
        }
        return v;
    }

    
    function addOnDemandCPs(rw) {
        if (!rw || this._onDemandCP) {
            return;
        }

        
        var blockCount = rw.bc,
            totalRows = rw.tc,
            rowsRemaining = totalRows - blockCount,
            numCPs = Math.ceil(rowsRemaining / blockCount),
            rhsCPList = [],
            valuesCPList = [],
            i;

        
        for (i = 0; i < numCPs; ++i) {
            
            var rc = Math.min(rowsRemaining, blockCount);

            
            
            rhsCPList.push(this.createOnDemandCP(i + 1, rc, CP_ROW_HEADERS));
            valuesCPList.push(this.createOnDemandCP(i + 1, rc, CP_VALUES));

            
            rowsRemaining -= blockCount;
        }

        this._onDemandCP = {rhs: rhsCPList, vls: valuesCPList};
        return this._onDemandCP;
    }


    
    
    mstrmojo.XtabBase = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [ mstrmojo._HasScrollbox, mstrmojo._ShowsStatus ],

        
        {
            scriptClass: "mstrmojo.XtabBase",

            
            dataRenderMode: "vscroll",

            
            handleClicks: function handleClicks() {
                return true;
            },

            markupString: '<div id="{@id}" class="mstrmojo-Xtab {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                            '<div style="display: none;{@msgNodeCssText}"><div>&nbsp;</div></div>' +    
                            '<div class="mstrmojo-Xtab-overlay"></div>' +
                            '<div class="mstrmojo-Xtab-content {@cssDefault}" title="{@tooltip}" style="{@viewportCssText}" mstrAttach:click,selectstart>' +
                                '<table cellspacing="0" cellpadding="0">' +
                                    '<tr trType="title">' +
                                        '<td style="vertical-align:top;padding:0px"></td>' +    
                                        '<td class="xtab-tr" style="vertical-align:top;padding:0px;"></td>' +
                                    '</tr><tr trType="content">' +
                                        '<td class="xtab-bl" style="vertical-align:top;padding:0px;"></td>' +
                                        '<td class="xtab-br" style="vertical-align:top;padding:0px">' +
                                            '<div class="mstrmojo-progress" style="display:none">' +
                                                '<div class="mstrmojo-progress-barbg">' +
                                                    '<div class="mstrmojo-progress-bar"></div>' +
                                                '</div>' +
                                                '<div class="mstrmojo-progress-text"></div>' +
                                                '</div>' +
                                            
                                            
                                            
                                            '<div id="{@id}_scrollbox" style="position:relative;{@scrollboxNodeCssText};{@scrollboxNodeOverflow}"></div>' +
                                        '</td>' +
                                    '</tr>' +
                                '</table>' +
                            '</div>' +
                        '</div>',

            markupSlots: {
                overlayNode: function () { return this.domNode; },
                msgNode: function () { return this.domNode.firstChild; },
                maskNode: function () { return this.domNode.childNodes[1]; },
                viewport: function () { return this.domNode.lastChild; },
                contentNode: function () { return this.domNode.lastChild.firstChild; },
                scrollboxNode: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].lastChild; },

                
                _TL: function () { return this.domNode.lastChild.firstChild.rows[0].cells[0]; },                                                    
                _TR: function () { return this.domNode.lastChild.firstChild.rows[0].cells[1]; },                                     
                _BL: function () { return this.domNode.lastChild.firstChild.rows[1].cells[0]; },                                 
                _BR: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].lastChild; },                          

                
                _T_ROW: function () { return this.domNode.lastChild.firstChild.rows[0]; },                              
                _B_ROW: function () { return this.domNode.lastChild.firstChild.rows[1]; },                              
                _BR_CELL: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1]; },                

                
                
                _STATUS: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].firstChild;  },
                _STATUS_TXT: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].firstChild.lastChild; },
                _STATUS_BAR: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].firstChild.firstChild.firstChild; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? 'block' : 'none'; }
            },

            
            zones: null,

            
            lockHeadersCase: LOCK_BOTH,

            
            interactiveCellsArray: null,

            
            titlesCP: null,

            
            chsCP: null,

            
            rhsCP: null,

            
            valuesCP: null,

            
            onDemandIF: true,

            
            numRowFixed: false,

            
            heightLimit: 0,

            
            height: 0,

            
            widthLimit: 0,

            
            width: 0,

            useTouchScrolling: false,

            
            scrollInterval: 0,

            
            selections: null,

            
            dataBlocks: null,

            
            getCellUnitIndex: function getCellUnitIndex(cell) {
                return (cell.o !== undefined) ? cell.o : cell._ei;
            },

            
            getCellTitleId: function getCellTitleId(cell) {
                var rtn = '';

                if (cell.axis && cell.ui !== undefined) {
                    rtn = cell.axis + 'A' + (cell.ui + 1);

                } else if (cell.mix !== undefined) {
                    rtn = '0A' + cell.mix;
                }

                return rtn;
            },

            
            update: function update(node) {
                if (this._super) {
                    this._super(node);
                }

                this.set('gridData', node.data[0] || node.data); 

                var defn = this.defn || node.defn;
                this.sid = this.gridData.sid;
                this.treeType = (defn && defn.tt) || 1;
                this.interactiveCellsArray = [];
            },

            
            initCP: function initCP(gd, interactiveCellsArray, tp, base, lkpBase, ax, cp) {
                var props = {
                    gridData: gd,
                    type: tp,
                    interactiveCellsArray: interactiveCellsArray
                };

                props.base = base || props.base;
                props.lookupBase = lkpBase || props.lookupBase;
                props.axis = ax || props.axis;

                if (!cp) {
                    if (tp === CP_TITLE) {
                        cp = new mstrmojo.XtabTitlesCP(props);
                    } else {
                        cp = new mstrmojo.XtabCP(props);
                    }
                } else {
                    mstrmojo.hash.copy(props, cp);
                }
                return cp;
            },


            preBuildRendering: function preBuildRendering() {
                var gd = this.gridData;

                
                this.lockHeadersCase = parseInt(gd.lhv, 10);
                this.selections = {};

                this.cssDefault = (this.lockHeadersCase === LOCK_OFF || !this.k) ? "" : "r-cssDefault" + (this.k ? "_" + this.k : "");

                
                
                
                
                this.numRowFixed = !!(!this.height && gd.rw && gd.rw.row && (gd.rw.row.bc < gd.rw.row.tc));
                this.rw = gd.rw;
                this._onDemandCP = null;

                
                if (this.width) {
                    this.widthLimit = parseInt(this.width, 10);
                }
                if (this.height) {
                    this.heightLimit = parseInt(this.height, 10);
                }

                
                return (this._super) ? this._super() : true;
            },

            
            renderEmptyGrid: function renderEmptyGrid() {
                var gd = this.gridData,
                    msgNode = this.msgNode,
                    viewport = this.viewport;

                
                msgNode.firstChild.innerHTML = gd.eg;
                msgNode.style.display = "block";
                msgNode.style.overflow = "hidden";
                msgNode.className = 'mstrmojo-message';
                viewport.style.display = "none";

                return (this._super) ? this._super() : true;
            },

            
            postBuildRendering: function postBldRndr() {
                
                var gd = this.gridData,
                    bInitZones = !!this._BR && gd,
                    msgNode = this.msgNode,
                    viewport = this.viewport,
                    rtn;

                if (gd.eg === undefined) {
                    
                    if (msgNode.style.display === "block") {
                        msgNode.style.display = "none";
                        viewport.style.display = "block";
                    }
                } else {
                    return this.renderEmptyGrid();
                }

                
                if (!this.interactiveCellsArray) {
                    this.interactiveCellsArray = [];
                }

                if (bInitZones) {
                    this._setupZones(gd);
                    this._setupCPs(gd);
                    
                    
                    var zs = this.zones,
                        n;

                    for (n in zs) {
                        var z = zs[n];
                        if (z.parent !== this) {
                            this.addChildren(this.zones[n]);
                        }
                    }

                    
                    if (this.scrollboxNode) {
                        
                        
                        var h = this.heightLimit;
                        this.scrollboxHeightFixed = !isNaN(h) && (h > 0);
                        if (this.scrollboxHeightFixed) {
                            this.scrollboxHeight = h; 
                        }
                        this.scrollboxLeft = this.scrollboxTop = 0; 

                        
                        if (this.lockHeadersCase) {
                            this.connectScrollbox(this);
                        }
                    }
                }

                this.renderChildren();
                rtn = this._super();

                
                if (this.numRowFixed) {
                    
                    if (!this.height) {
                        
                        this.heightLimit = this.zones._BR.getPageHeight(0) + (this._TR ? this._TR.offsetHeight : 0);

                        
                        this.height = this.heightLimit + 'px';

                    } else {
                        
                        this.heightLimit = parseInt(this.height, 10);
                    }
                }

                
                
                
                if ((this.lockHeadersCase && bInitZones && this.scrollboxNode) || this.numRowFixed) {
                    
                    
                    
                    this.resizeScrollBox($D.isIE);
                }

                
                this.onGridWidthChanged(true);

                
                
                if ($D.isIE7 && !this.scrollboxHeightFixed && this.scrollboxNode && this.scrollboxNode.scrollWidth > this.scrollboxNode.offsetWidth) {
                    this.scrollboxNode.style.height = this.scrollboxNode.offsetHeight + 17 + 'px';
                }

                return rtn;
            },

            onclick: function onclick(e, hWin) {

				
				if (!this.interactiveCellsArray.length) {
					this.isSelectingText = false;
					return;
				}

                e = e.e || e;

                
                var $D = mstrmojo.dom,
                    target = $D.eventTarget(hWin, e),
                    clickedCell = target && $D.findAncestorByName(target, 'td', true, this.viewport);

                if (target.nodeName.toLowerCase() === 'a' && clickedCell.getAttribute('ei')) {
                    try {
                        var att = this.interactiveCellsArray[parseInt(clickedCell.getAttribute('ei'), 10)];
                        var DssXmlBaseFormHTMLTag = 7;
                        if (att && att.ts === DssXmlBaseFormHTMLTag) { 
                            target.href = mstrmojo.addCSRFTokenToURL(target.href);
                        }
                    } catch (er) {
                        
                    }
                }

                
                if (clickedCell) {
                    
                    var a = $D.findAncestorByName(target, 'span', true, clickedCell);

                    if (a && !$D.shiftKey(hWin, e) && !$D.ctrlKey(hWin, e)) {
                        
                        
                        this.defaultAction(clickedCell);

                    } else {
                        this.doSelection(e, hWin, clickedCell);
                        if (!this.isSelectingText) {
                            $D.clearBrowserHighlights();
                        }
                    }
                }

                if (this.isSelectingText) {
                    this.isSelectingText = false;
                }
            },

            ontouchend: function ontouchend(e, hWin) {
                this.onclick(e, hWin);
            },

            onselectstart: function onselectstart() {
            	this.isSelectingText = true;
                return false;
            },

            
            onscroll: function onscroll() {
                this._alignHeaders();
            },

            
            resizeScrollBox: function resizeScrollBox(bForceRepaint) {

                
                var sb = this.scrollboxNode,
                    ss = sb && sb.style,
                    br = this._B_ROW,
                    brc = this._BR_CELL;
                if (!ss || !br || !brc) {
                    return;
                }

                
                
                
                var width = this.widthLimit,
                    
                    height = this.heightLimit;
                
                if (!width || !height) {
                    
                    if (!width) {
                        ss.width = 'auto';
                    }
                    if (!height) {
                        ss.height = 'auto';
                        this.scrollboxHeightFixed = false;
                    }
                }

                if (height) {
                    
                    var top = (this.zones._TR && this.zones._TR.cp.rc) ? br.offsetTop : 0,
                        newHeight = height - top;
                    if (newHeight > 0) {
                        ss.height = newHeight + 'px';
                        this.scrollboxHeight = newHeight;
                        this.scrollboxHeightFixed = true;

                        
                        
                        
                        if ((this.lockHeadersCase !== LOCK_OFF) && this.numRowFixed) {
                            this.viewport.style.height = this.overlayNode.style.height = (newHeight + top) + 'px';
                        }
                    }
                }

                if (!this.useTouchScrolling) {
                    
                    
                    

                    
                    
                    
                    var left = (this.zones._BL && this.zones._BL.cp.rc) ? brc.offsetLeft : 0;

                    
                    
                    var adjustSum = 0;
                    if (this.lockHeadersCase !== LOCK_OFF) {
                        
                        var vp = this.viewport,
                            cs = mstrmojo.css.getComputedStyle(vp),
                            metrics = ['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'];
                        if (cs) {
                            mstrmojo.array.forEach(metrics, function (v) {
                                adjustSum += parseFloat(convertEmtoPx(vp, cs[v]));
                            });
                        }
                        
                        if (this.width) {
                            this.viewport.style.width = (parseFloat(this.width) - (adjustSum || 0)) + 'px';
                        }
                    }

                    
                    var newWidth = (this.widthLimit && (this.widthLimit - left)) || (mstrmojo.dom.isIE7 ? brc.scrollWidth + 1 : (brc.scrollWidth + (sb.offsetWidth - sb.clientWidth))); 
                    if (newWidth && (newWidth > 0)) {
                        newWidth -= adjustSum;
                        ss.width = newWidth + 'px';
                    }

                    
                    this._alignHeaders(bForceRepaint);
                }

                
                var finalHeight = ss.height,
                    finalWidth = ss.width;
                if (finalHeight || finalWidth) {
                    
                    var container = mstrmojo.findAncestor(this, 'fixedSizeCanGrowShrink', null, mstrmojo.DocSection);
                    if (container) {
                        
                        container.fixedSizeCanGrowShrink(this, finalHeight, finalWidth);
                    }
                }

            },

            _resizeScrollBoxWidth: function _resizeScrollBoxWidth() {
                
                var sb = this.scrollboxNode,
                    ss = sb && sb.style,
                    br = this._B_ROW,
                    brc = this._BR_CELL;
                if (this.useTouchScrolling || !ss || !br || !brc) {
                    return;
                }

                
                
                
                var width = this.widthLimit;
                
                if (!width) {
                    ss.width = 'auto';
                }

                var fnUpdatetWidth = function() {
                    
                    var newWidth = (mstrmojo.dom.isIE7 ? brc.scrollWidth + 1: (brc.scrollWidth + (sb.offsetWidth - sb.clientWidth))); 
                    
                    
                    if ((newWidth && (newWidth > 0)) && (!width || (width && (newWidth < width))) && (sb.firstChild.firstChild.offsetWidth >= sb.clientWidth)) {
                        ss.width = newWidth + 'px';
                    }
                };

                
                if (mstrmojo.dom.isIE7) {
                    window.setTimeout(function(){fnUpdatetWidth();}, 1);
                } else {
                    fnUpdatetWidth();
                }

            },

            
            onGridWidthChanged: function onGridWidthChange(noScrollBoxChange) {

                
                if (this.lockHeadersCase === LOCK_OFF && !noScrollBoxChange) {
                    this._resizeScrollBoxWidth();
                }

                
                var container = mstrmojo.findAncestor(this, 'fixedSizeCanGrowShrink', null, mstrmojo.DocSection),
                    widthLimit = this.widthLimit;

                
                
                if (!widthLimit) {
                    this.width = UNSET;

                    
                    if (container) {
                        
                        container.performCanGrowCanShrink([ this ], true);
                    }
                } else if (container) {
                    
                    container.fixedSizeCanGrowShrink(this, null, widthLimit);
                }
            },

            
            getGridDimension: function getGridDimension(dimension) {
                var DIM_HEIGHT = 1, 
                    dim = dimension === DIM_HEIGHT ? 'Height' : 'Width',
                    dimLC = dim.toLowerCase(),
                    limit = this[dimLC + 'Limit'];

                if (!limit && (this[dimLC] === UNSET || this[dimLC] === 0)) {
                    limit = this.viewport['offset' + dim];
                    this[dimLC] = limit + 'px';
                    return limit;
                }

                return limit || parseInt(this[dimLC], 10);
            },

            
            _alignHeaders: function syncHeaders(bForceRepaint) {
                
                
                if (this.lockHeadersCase === LOCK_OFF || this.useTouchScrolling) {
                    return;
                }

                
                var left = this.scrollboxLeft,
                    top = this.scrollboxTop,
                    zs = this.zones,
                    trz = zs._TR,
                    blz = zs._BL;

                
                function set(zone, prop, v) {
                    var el = zone && zone.domNode,
                        s = el && el.style;
                    if (!s) {
                        return;
                    }
                    s[prop] = -v + "px";
                }

                
                if (trz && trz.rc) {
                    set(trz, 'left', left);
                }
                
                if (blz && blz.rc) {
                    set(blz, 'top', top);
                }

                
                
                
                if (bForceRepaint) {
                    repaint(this._BL);
                }
            },

            
            defaultAction: function defaultAction(td, tCell) {
                
                var cell = tCell || this.getCellForNode(td),
                    
                    
                    isReselectingTD = td && td.className.indexOf('sc_') > 0,
                    action = this.model.getAction(this.getActionCells(cell), td, isReselectingTD),
                    handler = action && action.h;

                
                this._currentSelectedTD = td;

                
                if (handler && this.controller[handler]) {
                    
                    this.controller[handler](this, action.a);
                    return true;
                }

                
                return false;
            },

            createZone: function createZone(cfg) {
                return new mstrmojo.XtabZone(cfg || {});
            },

            
            _setupZones: function _setupZones(gd) {
                
                
                var oldsz = this.zones;

                
                this.zones = {};

                
                var zs = this.zones,
                    l = this.lockHeadersCase,
                    zIndex = 'z-index:';

                var me = this;
                
                function newz(rm, style, slot, oldsz) {
                    var zone = (oldsz && oldsz[slot]) || me.createZone({
                        renderMode: rm,
                        cssText: style,
                        slot: slot
                    });

                    zs[slot] = zone;
                    
                    zone.rh = gd.rh;
                }

                
                

                
                newz(this.dataRenderMode, zIndex + '1;', "_BR", oldsz);
                if (l & LOCK_ROW) {
                    newz(this.dataRenderMode, zIndex + '3;', "_BL", oldsz);
                }
                if (l & LOCK_COL) {
                    newz(null, zIndex + '3;', "_TR", oldsz);
                }
                if (l === LOCK_BOTH) {
                    newz(null, zIndex + '4;', "_TL", oldsz);
                }

                
                if (l === LOCK_OFF) {
                    this.zones._BR.autoFitWindow = !!gd.afw;
                    this.zones._BR.tableCssClass = "r-cssDefault" + (this.k ? "_" + this.k : '');
                }

                
                if (mstrmojo.dom.isIE7) {
                    if (l & LOCK_ROW || l & LOCK_COL || l === LOCK_BOTH) {
                        this._T_ROW.style.display = 'block';
                    } else if (l === LOCK_OFF) {
                        this._T_ROW.style.display = 'none';
                    }
                }

                var bz = zs._BL || zs._BR;
                if (bz) { 
                    bz.numColumnCanMerge = gd.gts.cws.length - 1;
                }
            },

            getHACP: function getHACP() {
                return (this._super && this._super()) || new mstrmojo.XtabHACP();
            },

            
            _setupCPs: function _setupCPs(gd) {
                
                var titlesCP = this.titlesCP = this.getTitleCP(gd),
                    chsCP = this.chsCP = this.getColumnHeadersCP(gd),
                    rhsCP = this.rhsCP = this.getRowHeadersCP(gd),
                    valuesCP = this.valuesCP = this.getValuesCP(gd);

                
                titlesCP.forceAutoRowHeight = chsCP.forceAutoRowHeight = gd.rh;

                
                
                var zs = this.zones;

                switch (this.lockHeadersCase) {
                case LOCK_OFF:
                    
                    var vacp = new mstrmojo.XtabVACP();

                    
                    var hacpTop = this.getHACP();
                    hacpTop.cps = [titlesCP, chsCP];
                    vacp.cps = [hacpTop];

                    var hacpBottom = this.getHACP();
                    hacpBottom.cps = [rhsCP, valuesCP];
                    vacp.cps.push(hacpBottom);

                    
                    zs._BR.cp = vacp;
                    break;

                case LOCK_ROW:
                    
                    var acpLeft = new mstrmojo.XtabVACP();
                    var acpRight = new mstrmojo.XtabVACP();

                    
                    acpLeft.cps = [titlesCP, rhsCP];

                    
                    acpRight.cps = [chsCP, valuesCP];

                    
                    zs._BL.cp = acpLeft;
                    zs._BR.cp = acpRight;
                    break;

                case LOCK_COL:
                    
                    var acpTop = this.getHACP();
                    var acpBottom = this.getHACP();

                    
                    acpTop.cps = [titlesCP, chsCP];

                    
                    acpBottom.cps = [rhsCP, valuesCP];

                    
                    zs._TR.cp = acpTop;
                    zs._BR.cp = acpBottom;
                    break;

                case LOCK_BOTH:
                    zs._TL.cp = titlesCP;
                    zs._TR.cp = chsCP;

                    zs._BL.cp = rhsCP;
                    zs._BR.cp = valuesCP;
                    break;

                }
            },

            ongridDataChange: function ongridDataChange() {
                
                var m = this.model;
                if (m) {
                    
                    m.set('data', this.gridData);

                    if (!this.dataBlocks) {
                        this.dataBlocks = [];
                    }
                    this.dataBlocks[0] = this.gridData;
                }
            },

            gridPagesRendered: mstrmojo.emptyFn,

            
            getTitleCP: function getTitleCP(gd) {
                return this.initCP(gd, this.interactiveCellsArray, CP_TITLE);
            },

            
            getColumnHeadersCP: function getColumnHeadersCP(gd) {
                return this.initCP(gd, this.interactiveCellsArray, CP_COL_HEADERS, gd.ghs.chs, gd.gts.col, COL_AXIS);
            },

            
            getRowHeadersCP: function getRowHeadersCP(gd) {
                var rhsCP = this.initCP(gd, this.interactiveCellsArray, CP_ROW_HEADERS, gd.ghs.rhs, gd.gts.row, ROW_AXIS);

                
                if (this.onDemandIF && this.rw) {
                    if (!this._onDemandCP) {
                        addOnDemandCPs.call(this, this.rw && this.rw.row); 
                    }
                    this.rhsCPList = [rhsCP].concat(this._onDemandCP.rhs);
                    return onDemandCPAgg(this.rhsCPList) || rhsCP;
                }

                return rhsCP;
            },

            
            getValuesCP: function getValuesCP(gd) {
                var valuesCP = this.initCP(gd, this.interactiveCellsArray, CP_VALUES, gd.gvs);

                
                if (this.onDemandIF && this.rw) {
                    
                    if (!this._onDemandCP) {
                        addOnDemandCPs.call(this, this.rw && this.rw.row);
                    }
                    this.valuesCPList = [valuesCP].concat(this._onDemandCP.vls);

                    return onDemandCPAgg(this.valuesCPList) || valuesCP;
                }

                return valuesCP;
            },

            
            createOnDemandCP: function createOnDemandCP(blockNum, rc, zone) {
                var cp =  new mstrmojo.XtabOnDemandCP();
                cp.dataSource = this;
                cp.blockNum = blockNum;
                cp.rc = rc;
                return cp;
            },

            
            dataDownloaded: function dataDownloaded(node, memo) {
                
                var idx = memo.blockNum,
                    rhsCP = this.rhsCPList[idx],
                    valuesCP = this.valuesCPList[idx],
                    gd = node.data;

                gd._bidx = idx;
                this.dataBlocks[idx] = gd;

                if (!rhsCP || !valuesCP) {
                    return;
                }

                
                this.initCP(gd, this.interactiveCellsArray, CP_ROW_HEADERS, gd.ghs.rhs, gd.gts.row, ROW_AXIS, rhsCP);
                this.initCP(gd, this.interactiveCellsArray, CP_VALUES, gd.gvs, null, null, valuesCP);

                
                rhsCP.initContent();
                valuesCP.initContent();

                
                this.numRowsDownloaded += parseInt(rhsCP.rc, 10);
                this.updateStatus(mstrmojo.desc(8301, "Retrieving Data ..."), this.numRowsDownloaded * 100 / this.numRowsToDownload);

                var zs = this.zones,
                    bl = zs && zs._BL,
                    br = zs && zs._BR;

                
                if (bl) {
                    bl.dataDownloaded();
                }
                if (br) {
                    br.dataDownloaded();
                }
            },

            
            
            showDownloadStatus: function shwRndrSts(numRowsToDownload) {
                
                if (!numRowsToDownload) {
                    return;
                }

                
                if (this.showingStatus) {
                    this.numRowsToDownload += numRowsToDownload;
                } else {
                    
                    this.numRowsToDownload = numRowsToDownload;

                    
                    this.numRowsDownloaded = 0;
                }

                if (this.showStatus) {
                    this.showStatus(true, mstrmojo.desc(8301, "Retrieving Data ..."), this.numRowsDownloaded * 100 / this.numRowsToDownload);
                }
            },

            closeDownloadStatus: function closeSts() {
                this.numRowsToDownload = 0;
                if (this.showStatus) {
                    this.showStatus(false);
                }
            },

            
            download: function download(blockNum) {
                
                var rw = this.gridData.rw,
                    rwRow = rw.row,
                    rwCol = rw.col,
                    maxRows = rwRow.bc;

                
                this.rhsCPList[blockNum].isDownloading = this.valuesCPList[blockNum].isDownloading = true;

                
                if (maxRows) {
                    
                    this.controller.onDownloadGridData(this, this.model.getDownloadAction(blockNum * maxRows + 1, maxRows, rwCol.bb, rwCol.bc, this.id, {
                        blockNum: blockNum
                    }));
                }
            },

            unrender: function unrender(ignoreDom) {
                
                this.width = this.widthLimit = this.height = this.heightLimit = 0;

                
                
                this.disconnectScrollbox(this);
                this._super(ignoreDom);
            },

            
            getCellForNode: function getCellForNode(td) {
                var idx = td && td.getAttribute('ei');
                if (isNaN(idx)) {
                    return null;
                }
                var t = this.interactiveCellsArray[parseInt(idx, 10)];
                return t;
            },

            
            getActionCells: function getActionCells(cell) {
                var cells = [],
                    selections = this.selections;

                var titleId = cell.axis + 'A' + (cell.ui + 1),
                    selTitle = selections[titleId],
                    i;

                if (selTitle && selTitle[cell.o]) {
                    for (i in selTitle) {
                        var sc = this.getCellForNode(selTitle[i][0]); 
                        cells.push(sc);
                    }
                } else {
                    cells.push(cell);
                }
                return cells;
            },

            setModel: function setModel(model) {
                this.model = model;
                if (model.data) {
                    this.set('gridData', model.data);
                }
            },

            destroy: function destroy() {
                var model = this.model;
                if (model && model.destroy) {
                    model.destroy();
                }
                this._super();
            }

        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ui.MobileDateTimePicker",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.date",
                         "mstrmojo.expr",
                         "mstrmojo.locales");

    mstrmojo.requiresDescs(2052, 2170, 7656);

    var $D = mstrmojo.date,
        $DESC = mstrmojo.desc,
        CALENDAR = 5,
        TIMEPICKER = 6,
        DTP = mstrmojo.expr.DTP;

    mstrmojo.android.inputControls.DateTimePickerDIC = mstrmojo.declare(
        mstrmojo.ui.MobileDateTimePicker,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: "mstrmojo.android.inputControls.DateTimePickerDIC",

            cssText: '',

            valueField: 'dtValue',

            
            popupTitle: '',

            init: function init(props) {
                var dic = props.dic;

                if (dic.min !== undefined) {
                    props.min = $D.parseDateAndOrTime(dic.min);
                }
                if (dic.max !== undefined) {
                    props.max = $D.parseDateAndOrTime(dic.max);
                }

                props[this.valueField] = $D.parseDateAndOrTime(props.value);

                
                if (dic.t === CALENDAR) {
                    props.dtp = dic.ict ? DTP.TIMESTAMP : DTP.DATE;
                    props.popupTitle = dic.ict ? $DESC(7656, 'Date and Time') : $DESC(2052, 'Date');
                } else if (dic.t === TIMEPICKER) {
                    props.dtp = DTP.TIME;
                    props.minuteInterval = props.dic.itv;
                    props.popupTitle = $DESC(2170, 'Time');
                }

                this._super(props);
            },

            
            getCurValue: function getCurValue(forDisplay) {
                var oldDateTime = this[this.valueField] || {},
                    date = this.getDate() || oldDateTime.date || {year: 1970, month: 1, day: 1},
                    time = this.getTime() || oldDateTime.time || {hour: 0, min: 0, sec: 0},
                    config = this.dic,
                    dt = parseInt(config.dt, 10),
                    LD = mstrmojo.locales.datetime,
                    timeFormat = LD.TIMEOUTPUTFORMAT,
                    dateFormat = LD.DATEOUTPUTFORMAT,
                    displayDate = $D.formatDateInfo(date, dateFormat),
                    displayTime = $D.formatTimeInfo(time, timeFormat);

                if (forDisplay) {
                    if (config.t === CALENDAR) {
                        return config.ict ? (displayDate + ' ' + displayTime) : displayDate;
                    }

                    return displayTime;
                }

                if (dt === DTP.TIMESTAMP) {
                    return displayDate + ' ' + displayTime;
                }

                if (dt === DTP.TIME) {
                    return displayTime;
                }

                return displayDate;
            },

            
            
            renderPreview: function renderPreview() {
                
                this.renderPreviewButton(this.openerNode, this.getCurValue(true));
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo._HasLayout",
                         "mstrmojo._SupportsEllipsisText",
                         "mstrmojo.date",
                         "mstrmojo.string",
                         "mstrmojo.num",
                         "mstrmojo.hash",
                         "mstrmojo.expr",
                         "mstrmojo.StringBuffer",
                         "mstrmojo.android.ui.ElementsSearchBar",
                         "mstrmojo.GeoLocation",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.android.ui.TextInput",
                         "mstrmojo.ui.MobileSlider",
                         "mstrmojo.MobileCalendar",
                         "mstrmojo.android.ui.Calendar",
                         "mstrmojo.android.ui.ElementsPicker",
                         "mstrmojo.android._HasLingeringListSelections",
                         "mstrmojo.locales.datetime",
                         "mstrmojo.prompt.WebPrompt",
                         "mstrmojo.ui.MobileDateTimePicker",
                         "mstrmojo.ui.MobileReviewList",
                         "mstrmojo.array",
                         "mstrmojo.BarcodeReader",
                         "mstrmojo.string");

    mstrmojo.requiresDescs(189, 221, 1442, 6149, 8382, 8383, 8384, 8397, 8761);

    var $D = mstrmojo.date,
        $DESC = mstrmojo.desc,
        $STYLES = mstrmojo.prompt.WebPrompt.STYLES,
        $TYPES = mstrmojo.prompt.WebPrompt.TYPES,
        $NUM = mstrmojo.num,
        $BTN = mstrmojo.android.ui.Button.newButton,
        $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        $TRANS_DURATION = mstrmojo.dom.CSS3_TRANSITION_DURATION,
        $EXPR = mstrmojo.expr,
        anchorOffset = {
            160: 10,
            213: 10,
            240: 15,
            320: 20
        };

    var requiredText = '<em>*</em>',
        iconItemCls = 'item-icon',
        choiceMainCls = 'main-btn',
        choiceItemCls = 'item-btn',
        displayStyleBarCode = 'Barcode',
        displayStyleGeo = 'GeoLocation';

    
    var itemMarkupCache = {};

    
    var stepperDown = ' onclick="mstrmojo.all.{@wid}.clickStepper({@idx}, false);"',
        stepperUp = stepperDown.replace('false', 'true');

    
    function setAnswer(item, idx, vals) {
        try {
            
            item.setAnswerValue.apply(item, vals);
        } catch (e) {
            mstrmojo.alert(e.message || e);
            return false;
        }

        
        this.updateItem(idx);
        return true;
    }

    function consolidateAnswers(original, toAdd) {
        var hashArray = [],
            tempArray = [];
        
        $ARR.forEach(original, function (item) {
            hashArray[item.v] = item;
            tempArray.push(item);
        });

        $ARR.forEach(toAdd, function (item) {
            if (hashArray[item.v]) {
                return;
            }

            tempArray.push(item);
        });

        return tempArray;
    }

    function getExistingItems(items, actualReviewItems) {
        var existingItems = [],
            len = actualReviewItems.length,
            i = 0,
            j = 0,
            lastMatchPosition = 0,
            itemsLength = items.length;

        for (i = 0; i < itemsLength; i++) {
            for (j = lastMatchPosition; j < len; j++) {
                if (items[i].v === actualReviewItems[j].dssid) {
                    existingItems.push(actualReviewItems[j]);
                    lastMatchPosition = j + 1;
                    break;
                }
            }
        }
        return existingItems;
    }

    function showReviewList(picker, items, actualReviewItems, displayKeypadView, list, idx, item, isMultiSelect) {
        var callback = this,
            dialogConfig = {
                
                title: $DESC(9755, 'Prompt Values')
            },
            dialogChildren = [],
            fnOk,
            fnCancel,
            dialog,
            reviewList,
            fnShowDialog = function () {
                
                dialogConfig.children = dialogChildren;

                fnOk = function () {
                    
                    if (dialog.deleteAction) {
                        
                        var index,
                            loopVariant = 0,
                            x;
                        
                        var newItems = [].concat(items);
                        
                        for (x in reviewList.selectedIndices) {
                            index = parseInt(x, 10) - loopVariant++;
                            actualReviewItems.splice(index, 1);
                            newItems.splice(index, 1);
                        }

                        reviewList.set('items', newItems);
                        items = newItems;

                        
                        reviewList.set('height', 'auto');
                        dialog.resizeDialog();

                        dialog.setDeleteActions("done");

                        
                        return false;
                    }

                    
                    setAnswer.call(list, item, idx, [consolidateAnswers.call(this, item.answer.items || [], reviewList.items)]);
                    dialog.close();
                };

                fnCancel = function () {
                    
                    dialog.close();

                    
                    mstrmojo.BarcodeReader.readBarcodes({   
                        'attributeID': picker.browseElements.source.did,
                        'searchForms': item.prs.LookupForm,
                        'multiSelect': isMultiSelect
                    }, callback, null, getExistingItems(reviewList.items, actualReviewItems), displayKeypadView);
                };

                
                var dBtn = $BTN($DESC(8473, 'Done'), fnOk);
                dBtn.alias = 'deleteBtn';

                dialogConfig.buttons = [$BTN($DESC(221, 'Cancel'), fnCancel), dBtn];

                
                dialog = mstrApp.showDialog(dialogConfig);

                dialog.setDeleteActions = function (actionStr) {
                    if (actionStr === "delete") {
                        this.selectionHidden = false;
                        this.deleteAction = true;
                        this.titleNode.lastChild.style.display = 'block';
                        this.btnHbox.deleteBtn.set('text', $DESC(629, 'Delete'));
                        mstrmojo.css.removeClass(reviewList.domNode, 'hidden'); 
                    } else {
                        this.selectionHidden = true;
                        this.deleteAction = false;
                        this.titleNode.lastChild.style.display = 'none';
                        this.btnHbox.deleteBtn.set('text', $DESC(8473, 'Done'));
                    }
                };

                
                dialog.updateTitleBarButtonClass = function (clsName) {
                    dialog.titleNode.lastChild.className = 'mstrmojo-Editor-titlebar-button ' + clsName;
                };

                
                dialog.createTitleBarButton('mstrmojo-Editor-titlebar-button btnCheckSemi', function () {
                    reviewList.selectAll();
                });

                dialog.setDeleteActions("done");

                
                return dialog;
            };

        
        reviewList = new mstrmojo.ui.MobileReviewList({
            controller: this.controller,
            isElastic: true,
            multiSelect: true,
            itemIdField: 'v'
        });

        dialogConfig.useMenu = false;

        
        dialogChildren.push(reviewList);

        
        reviewList.set('items', items);

        
        fnShowDialog();
    }

    
    function wasBtnClicked() {
        return (this._clkTarget.className === iconItemCls);
    }

    
    function isIconStyle(item, style, displayStyle) {
        var prs = item.prs;
        return (item.getStyle() === style || (prs && prs.DisplayStyle === displayStyle));
    }

    
    function getIconClass(item) {
        if (isIconStyle(item, $STYLES.BARCODE, displayStyleBarCode) || isIconStyle(item, $STYLES.GEO, displayStyleGeo)) {
            return (wasBtnClicked.call(this)) ? choiceItemCls : choiceMainCls;
        }

        return '';
    }

    function getAnswerCount(item) {
        if (parseInt(item.promptType, 10) === $TYPES.ELEMENTS_PROMPT && item.answer) {
            return ' (' + item.getAnswersCount() + ')';
        }

        return '';
    }

    
    function ellipsizeItem(node, idx) {
        
        var item = this.items[idx];
        if (item.isTtl) {
            
            return;
        }

        var childNodes = node.firstChild.childNodes,
            promptName = childNodes[0],
            promptAnswer = childNodes[1],
            isRequired = !!item.req,
            answerCnt = getAnswerCount(item),
            ellipsisText = this.ellipsisText,
            innerHTML;

        
        if (isRequired) {
            
            promptName.innerHTML = requiredText + promptName.innerHTML.replace(requiredText, '');
        }

        
        var h3 = this.ellipsize('h3', promptName, false);

        
        if (isRequired) {
            
            innerHTML = promptName.innerHTML.replace(requiredText, '');

            
            promptName.innerHTML = h3 ? innerHTML.replace(innerHTML.slice(-1), requiredText + ellipsisText) : innerHTML + requiredText;
        }

        
        var h4 = this.ellipsize('h4', promptAnswer, true);

        
        if (h4 && answerCnt) {
            
            promptAnswer.innerHTML = mstrmojo.string.trim(promptAnswer.innerHTML.slice(0, -(answerCnt.length + 3))) + ellipsisText + answerCnt;
        }
    }

    
    function getDialogCssClass(cls) {
        
        var css = [ 'prompts-dialog' ];

        
        if (mstrApp.isTablet() && mstrApp.isLandscape()) {
            
            css.push('prompts-landscape');
        }

        
        if (cls) {
            
            css.push(cls);
        }

        return css.join(' ');
    }

    
    function getDefaultDialogConfig(props) {
        var id = this.id;
        return $HASH.copy(props, {
            cssClass: getDialogCssClass(),
            onClose: function () {
                var list = mstrmojo.all[id];

                
                list.parent.closePrompt();

                
                list.clearSelect();
            }
        });
    }

    
    function showDialog(config, children, idx, fnOk, hideCancel, viewName) {
        
        config.children = children;
        var btns = [];

        
        if (!hideCancel) {
            
            btns.push($BTN($DESC(221, 'Cancel')));
        }

        
        if (fnOk) {

            
            btns.push($BTN($DESC(1442, 'OK'), fnOk));
        }

        
        config.buttons = btns;

        
        
        if (mstrApp.isTablet()) {
            
            config.anchor = this._getItemNode(idx);
            config.anchorOrientation = 'h';
            config.autoClose = true;
            config.anchorOffset = anchorOffset[mstrMobileApp.getDeviceDPI()];
        }

        
        this.parent.openPrompt(function () {
            mstrApp.showDialog(config, viewName);
        });
    }

    
    function selectBarCodePrompt(item, idx) {
        var id = this.id;

        
        mstrmojo.BarcodeReader.readBarcodes(null, {
            success: function (val) {
                
                if (item.promptType === $TYPES.CONSTANT_PROMPT && item.dataType === mstrmojo.mstr.EnumDataType.DataTypeBigDecimal) {
                    
                    var li = mstrApp.getLocaleInfo();
                    val = val.substr(0, 1) + ((li && li.number.DECIMALSEPARATOR) || '.') + val.substr(1);
                }

                
                if (!setAnswer.call(mstrmojo.all[id], item, idx, [ val ])) {
                    return false;
                }
            },

            failure: function (ex) {
                item.setError(ex);

                
                mstrmojo.all[id].updateItem(idx);
            }
        });
    }

    
    function selectTextPrompt(item, idx) {
        var id = this.id,
            txtId = 'plTxtInputxz';

        showDialog.call(this, getDefaultDialogConfig.call(this, {
            title: item.title
        }), [{
            scriptClass: 'mstrmojo.android.ui.TextInput',
            id: txtId,
            alias: 'textInput',
            textValue: item.getDisplayValue(false, false) || '',
            onEnter: function (value) {
                
                if (!setAnswer.call(mstrmojo.all[id], item, idx, [ value ])) {
                    return; 
                }

                
                mstrApp.closeDialog();
            }
        }], idx, function () {
            if (!setAnswer.call(mstrmojo.all[id], item, idx, [ mstrmojo.all[txtId].getValue() ])) {
                return false; 
            }
        });
    }

    
    function selectElementPrompt(item, idx) {
        var id = this.id,
            answerItems = item.answer.items || [],                 
            availableAnswers = item.getAvailable(),                
            isBarCode = isIconStyle(item, $STYLES.BARCODE, displayStyleBarCode),
            isBtn = wasBtnClicked.call(this),
            prs = item.prs,
            isMultiSelect = (item.max === "" || parseInt(item.max, 10) > 1) && prs.DisplayStyle !== 'Option button',        
            sr = prs.SearchRequired,
            searchRequired = sr && sr !== "0";

        
        availableAnswers.concat = true;

        
        var fnSetPickerAndShowDialog = function () {
            var list = mstrmojo.all[id];

            
            if (isBarCode && isBtn) {
                
                mstrmojo.BarcodeReader.readBarcodes({
                    'attributeID': availableAnswers.source.did,
                    'searchForms': item.prs.LookupForm,
                    'multiSelect': isMultiSelect
                }, {
                    success: function (val) {
                        var res = JSON.parse(val),
                            items =  availableAnswers.convertElems(res.items);

                        if (res.review) {
                            
                            var picker = new mstrmojo.android.ui.ElementsPicker({
                                isElastic: true,
                                itemIdField: 'v',
                                multiSelect: true             
                            });

                            
                            picker.set('browseElements', availableAnswers);

                            
                            picker.addSelectedItems(items);

                            
                            showReviewList.call(this, picker, items, res.items, res.displayKeypadView, list, idx, item, isMultiSelect);
                        } else {
                            
                            setAnswer.call(list, item, idx, [consolidateAnswers.call(this, answerItems, availableAnswers.convertElems(JSON.parse(val).items))]);
                        }

                    }
                });

            } else {
                
                var picker = new mstrmojo.android.ui.ElementsPicker({
                    isElastic: true,
                    itemIdField: 'v',
                    multiSelect: isMultiSelect             
                });

                
                picker.set('browseElements', availableAnswers);


                
                picker.addSelectedItems(answerItems);

                
                var searchBar = new mstrmojo.android.ui.ElementsSearchBar({
                    slot: 'titleNode',
                    target: picker,
                    browseElements: availableAnswers,
                    searchForms: isBarCode  ? item.prs.LookupForm : undefined,
                    searchRequired: searchRequired,     
                    canSearch: item.canSearch(),        
                    title: item.title                   
                });

                var fnDisplayPicker = function () {
                    var fnOk;

                    if (isMultiSelect) {
                        fnOk = function () {
                        	picker.syncSelection();
                            return setAnswer.call(list, item, idx, [ picker.getSelectedItems() ]);
                        };
                    } else {
                        
                        
                    	
                    	
                    	
                        var mySuper = picker.singleSelect;
                        picker.singleSelect = function (index, suppressEv) {
                            mySuper.call(this, index, suppressEv);
                            if (index != -1 && ! suppressEv) {
                                setAnswer.call(list, item, idx, [ picker.getSelectedItems() ]);
                                this.parent.close();
                                return true;
                            }
                        };
                    }

                    
                    showDialog.call(list, getDefaultDialogConfig.call(list, {
                        title: $DESC(6149, 'Select Elements'),
                        cssClass: getDialogCssClass('edtElementPicker'),
                        goBack: function () {
                            
                            return searchBar.goBack();
                        }
                    }), [ searchBar, picker ], idx, fnOk, false);
                };

                
                if (isIconStyle(item, $STYLES.GEO, displayStyleGeo) && isBtn) {
                    
                    item.getGeoTargetValue({
                        success: function (result) {
                        	var searchTarget = item.searchTarget,
                        	    searchBox = searchBar.search.box;
                            
                            searchBar.initSearchValue =  result;
                            searchBar.canSearch = true;
                        	
                            if ( searchTarget ) {
                                searchBar.initSearchValue = 'in "' + result + '"';
                            	searchBar.searchTarget = searchTarget;
                            	searchBox.searchValue = result;
                            }  
                            
                            fnDisplayPicker();
                        }
                    });

                } else {
                    
                    fnDisplayPicker();
                }
            }
        };

        
        if (availableAnswers.browseConfig) {
            
            availableAnswers.getItems(1, {
                success: fnSetPickerAndShowDialog
            });
        } else {
            fnSetPickerAndShowDialog();
        }
    }

    
    function selectSliderPrompt(item, idx) {
        var config = getDefaultDialogConfig.call(this, {
                title: item.title,
                cssClass: getDialogCssClass('edtSlider')
            }),
            v = item.getDisplayValue(true, false), 
            valueField = new mstrmojo.Label({
                text: v,
                cssClass: 'value'
            }),
            labelField = new mstrmojo.Label({
                text: item.mn,
                cssClass: 'title'
            }),
            id = this.id;

        
        var slider = new mstrmojo.ui.MobileSlider({
            value: $NUM.parseNumeric(v),
            max: item.max,
            min: item.min,
            interval: item.interval,
            onvalueChange: function () {
                
                valueField.set('text', $NUM.toLocaleString(this.value));
            },
            onslidingValueChange: function () {
                
                valueField.set('text', $NUM.toLocaleString(this.slidingValue));
            },
            onRender: function () {
                this.parent.attachEventListener('resizeCurtain', this.id, this.resize);
            }
        });

        
        showDialog.call(this, config, [ valueField, labelField, slider ], idx, function () {
            if (!setAnswer.call(mstrmojo.all[id], item, idx, [ String(slider.value) ])) {
                return false;
            }
        });
    }

    
    function selectDateTimePrompt(item, idx, dtp) {
        
        var config = getDefaultDialogConfig.call(this, {
                title: item.title
            }),
            dateUtil = mstrmojo.date,
            formats = mstrmojo.locales.datetime,
            answer = item.answer,
            min = item.min,
            max = item.max,
            timePicker = new mstrmojo.ui.MobileDateTimePicker({
                value: dateUtil.parseDateAndOrTime(answer || ''),    
                min: dateUtil.parseDateAndOrTime(min || ''),         
                max: dateUtil.parseDateAndOrTime(max || ''),         
                minuteInterval: item.interval,                       
                
                
                hideSwitchers: dtp == $EXPR.DTP.DATE,                
                dtp: dtp || $EXPR.DTP.TIMESTAMP                      
            }),
            id = this.id;

        
        showDialog.call(this, config, [ timePicker ], idx, function () {
            var v = timePicker.getDateTime(),
                dateInfo = v && v.date,
                timeInfo = v && v.time,
                date = (dateInfo && dateUtil.formatDateInfo(dateInfo, formats.DATEOUTPUTFORMAT)) || '',
                time = (timeInfo && dateUtil.formatTimeInfo(timeInfo, formats.TIMEOUTPUTFORMAT)) || '',
                answer = [date + ' ' + time];

            
            if (item.promptType === $TYPES.ELEMENTS_PROMPT) {
                answer = [answer];
            }

            if (!setAnswer.call(mstrmojo.all[id], item, idx, answer)) {
                return false;
            }
        });
    }

    
    function selectCalenderPrompt(item, idx) {
        
        var calendar =  {
                alias: 'calendar'
            },
            max = item.max,
            id = this.id,
            fnOk,
            calendarWidget,
            isSingleSelectPrompt = false,
            promptsFiltersNode = this.parent.domNode,
            
            config = $HASH.copy(getDefaultDialogConfig.call(this, {
                cssClass: getDialogCssClass()
            }), {
                targetListHeight: promptsFiltersNode.clientHeight, 
                targetListWidth: promptsFiltersNode.clientWidth
            });

        switch (item.promptType) {
        case $TYPES.CONSTANT_PROMPT:
            
            isSingleSelectPrompt = true;
            break;

        case $TYPES.ELEMENTS_PROMPT:
            
            if (1 === parseInt(max, 10)) {
                isSingleSelectPrompt = true;
                break;
            }

            
            config.title = $DESC(8383, 'Select Dates');

            
            calendar.min = $D.parseDate(item.prs.LocalizedMinDate || '');
            calendar.max = $D.parseDate(item.prs.LocalizedMaxDate || '');

            
            calendar.selectedDates = item.getAnswerAsDateArray();

            calendar.isMultiSelect = true;

            
            fnOk = function () {
                try {
                    
                    item.setAnswerValue(calendarWidget.getSelectedDates());
                } catch (e) {
                    mstrmojo.alert(e.message || e);
                    return false;
                }

                
                item.syncDateAnswer({
                    success: function () {
                        
                        mstrApp.closeDialog();

                        var list = mstrmojo.all[id];
                        list.updateItem(idx);

                        
                        setAnswer.call(list, item, idx, [calendarWidget.getSelectedDates()]);
                    },

                    failure: function (msg) {
                        
                        window.setTimeout(function () {
                            mstrmojo.alert(msg);
                        }, 0);
                    }
                });

                
                return false;
            };
            break;

        default:
            throw new Error($DESC(8397, 'Error: Unknown prompt type.'));
        }

        if (isSingleSelectPrompt) {
            selectDateTimePrompt.call(this, item, idx, $EXPR.DTP.DATE);
        } else {
            
            calendarWidget = new mstrmojo.android.ui.Calendar(calendar);

            
            showDialog.call(this, config, [ calendarWidget ], idx, fnOk, false, 'CalendarDialog');
        }
    }

    
    function selectGeoPrompt(item, idx) {
        var id = this.id;

        
        
        mstrmojo.confirm($DESC(8384, '"MicroStrategy" Would Like to use Your Current Location.'), [ $BTN($DESC(221, 'Cancel')), $BTN($DESC(1442, 'OK'), function () {
            mstrmojo.GeoLocation.getCurrentLocation({
                success: function (la, lo, al) {
                    setAnswer.call(mstrmojo.all[id], item, idx, [ la, lo ]);
                },

                failure: function (ex) {
                    item.setError(ex);

                    
                    mstrmojo.all[id].updateItem(idx);
                }
            });
        })]);
    }

    
    function selectSwitchPrompt(item, idx) {
        
        item.toggleSwitch();

        
        this.updateItem(idx);
    }

    
    var promptFnMap = {};
    promptFnMap[$STYLES.BARCODE] = selectBarCodePrompt;
    promptFnMap[$STYLES.TEXT] = selectTextPrompt;
    promptFnMap[$STYLES.LIST] = selectElementPrompt;
    promptFnMap[$STYLES.SLIDER] = selectSliderPrompt;
    promptFnMap[$STYLES.CALENDAR] = selectCalenderPrompt;
    promptFnMap[$STYLES.TIME] = selectDateTimePrompt;
    promptFnMap[$STYLES.GEO] = selectGeoPrompt;
    promptFnMap[$STYLES.SWITCH] = selectSwitchPrompt;

    
    mstrmojo.android.ui.PromptsList = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        [ mstrmojo._SupportsEllipsisText, mstrmojo.android._HasLingeringListSelections ],

        
        {
            scriptClass: "mstrmojo.android.ui.PromptsList",

            listHooks: {
                select: function (el, item, idx) {
                    var cls = getIconClass.call(this, item);
                    if (cls) {
                        mstrmojo.css.addClass(el, cls);
                    }

                    
                    el.style[$TRANS_DURATION] = 0;

                    
                    this.setClearHandler(200);
                },
                unselect: function (el, item, idx) {
                    var cls = getIconClass.call(this, item);
                    if (cls) {
                        mstrmojo.css.removeClass(el, cls);
                    }

                    
                    el.style[$TRANS_DURATION] = '300ms';
                }
            },

            getItemMarkup: function (item) {
                
                if (item.isTtl) {
                    
                    return '<div class="item {@cls}" idx="{@idx}">{@ttl}</div>';
                }

                
                var style = item.getStyle(),
                    showIcon = isIconStyle(item, $STYLES.GEO, displayStyleGeo) || isIconStyle(item, $STYLES.BARCODE, displayStyleBarCode),
                    cacheKey = style + String(item.req) + (showIcon ? 'ic' : ''),
                    markup = itemMarkupCache[cacheKey];

                
                if (!markup) {
                    
                    var sb = new mstrmojo.StringBuffer();

                    sb.append('<div class="item {@cls}" idx="{@idx}"><div><h3>{@ttl}' + requiredText + '</h3><h4>{@val}</h4>');

                    
                    if (style === $STYLES.STEPPER) {
                        
                        sb.append('<div class="step"><div' + stepperDown + '></div><div>{@v}</div><div' + stepperUp + '></div></div>');

                    } else if (showIcon || style === $STYLES.SWITCH) {
                        
                        sb.append('<div class="' + iconItemCls + '"><div></div></div>');

                    }

                    
                    markup = itemMarkupCache[cacheKey] = sb.toString() + '</div></div>';
                }

                
                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx);

                
                props.ttl = item.title;

                
                if (item.isTtl) {
                    
                    props.addCls('ttl');
                    return props;
                }

                
                var style = item.getStyle(),
                    isStepperOrSwitch = (style === $STYLES.STEPPER || style === $STYLES.SWITCH),
                    displayValue = item.getDisplayValue(isStepperOrSwitch, isStepperOrSwitch);          

                
                if (isIconStyle(item, $STYLES.BARCODE, displayStyleBarCode)) {
                    
                    props.addCls('bar');

                } else if (isIconStyle(item, $STYLES.GEO, displayStyleGeo)) {
                    
                    props.addCls('geo');

                }

                
                props.wid = this.id;
                props.val = displayValue || '';                 

                
                props.addCls('st' + style);

                
                if (item.req) {
                    
                    props.addCls('req');
                }

                
                switch (style) {
                case $STYLES.STEPPER:
                    
                    if (!item.canStepUp()) {
                        props.addCls('max');
                    }

                    
                    if (!item.canStepDown()) {
                        props.addCls('min');
                    }

                    
                    props.v = displayValue;

                    
                    props.val = item.mn || '';
                    break;

                case $STYLES.SWITCH:
                    
                    props.val = item.mn || '';

                    
                    if (displayValue) {
                        
                        props.addCls('on');
                    }
                    break;

                case $STYLES.GEO:
                    if (!item.displayLoc) {
                        item.getDisplayLocation(this, displayValue);
                    }
                    break;
                }

                
                if (props.val) {
                    
                    props.addCls('has-ans');
                }

                
                return props;
            },

            updateItem: function updateItem(idx) {
                
                ellipsizeItem.call(this, this._super(idx), idx);
            },

            
            allowTouchBubble: false,

            
            onRender: function onRender() {
                if (this._super) {
                    this._super();
                }

                var items = this.itemsContainerNode.childNodes,
                    cnt = items.length,
                    i;

                
                for (i = 0; i < cnt; i++) {
                    
                    ellipsizeItem.call(this, items[i], i);
                }
            },

            
            clickStepper: function clickStepper(idx, isUp) {
                
                this.items[idx]['step' + (isUp ? 'Up' : 'Down')]();

                
                this.updateItem(idx);
            },

            
            postselectionChange: function postselectionChange(evt) {
                
                var added = evt.added;
                if (!added) {
                    
                    return;
                }

                
                var idx = added[0],
                    item = this.items[idx],
                    style = item.getStyle();

                
                if (style === $STYLES.BARCODE && !wasBtnClicked.call(this)) {
                    
                    style = $STYLES.TEXT;
                }

                
                var fnPrompt = promptFnMap[style];
                if (fnPrompt) {
                    
                    fnPrompt.call(this, item, idx);
                }
            },

            rootOrientationChange: function rootOrientationChange() {
                
                this.refresh();
            },

            
            touchSelectBegin: function touchSelectBegin(touch) {
                
                var idx = this.getItemIdxTouch(touch);
                if (idx > -1) {
                    
                    var item = this.items[idx],
                        style = item.getStyle(),
                        msg = [];

                    
                    var description = item.mn || '';
                    if (description) {
                        
                        msg.push(description);
                    }

                    
                    if (!(style === $STYLES.SWITCH) && !(style === $STYLES.STEPPER)) {
                        
                        var answer = item.getDisplayValue(false, false);
                        if (answer) {
                            msg.push(answer);
                        }
                    }

                    
                    if (item.req) {
                        
                        msg.push($DESC(475, 'This prompt is required and must be answered.'));
                    }

                    
                    if (msg.length) {
                        
                        mstrmojo.alert(msg.join('<br /><br />'), null, $DESC(189, 'Details'));
                    }

                    
                    return false;
                }

                
                return true;
            },

            touchTap: function touchTap(evt) {
                
                var item = this.items[this.getItemIdxTouch(evt)];
                if (item && item.isTtl) {
                    
                    return;
                }

                
                this._clkTarget = evt.target;

                this._super(evt);
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.android.SimpleList",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.string",
                         "mstrmojo.num");

    mstrmojo.requiresDescs(11, 16, 17, 18, 37, 187, 295, 629, 702, 784, 844, 845, 874, 1088, 1142, 1563, 1900, 1905, 2411, 2461, 2822, 3157, 4253, 5191, 6560, 7227, 7559, 7561, 7778, 7779, 7831, 7840, 8027, 8360, 8361, 8362, 8363, 8364, 8365, 8366, 8367, 8368, 8369, 8370, 8371, 8372, 8373, 8374, 8375, 8376, 8377, 8378, 8379, 8390, 8441, 8447, 8455, 8456, 8457, 8458, 8459, 8489, 8633, 8634, 8635, 8760, 9446, 9447, 9448, 9449, 9450, 9451, 9452, 9456, 9457, 9458, 9459, 9460, 9464, 9465, 9466, 9467, 9468, 9469, 9470, 9471, 9481, 9790, 9791, 9792, 9793, 9794, 9795, 9796, 9797, 9807);

    var $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash,
        $BTN = mstrmojo.android.ui.Button.newButton,
        $DESC = mstrmojo.desc,
        MENUS = mstrmojo.android.EnumMenuOptions,
        MENU_DELETE = MENUS.DELETE,
        MENU_ADD_SERVER = MENUS.ADD_SERVER,
        MENU_ADD_PROJECT = MENUS.ADD_PROJECT,
        MENU_ABOUT = MENUS.ABOUT,
        legalText;

    
    var STYLE_HEADER = 1,
        STYLE_BUTTON = 2,
        STYLE_VIEW_BUTTON = 3,
        STYLE_TEXT = 4,
        STYLE_LIST = 5,
        STYLE_CHECK = 6,
        STYLE_IMAGE = 7,
        STYLE_TEXT_AREA = 8,
        STYLE_NUMBER = 9,
        STYLE_TIME = 10;

    
    var TYPE_HOME = 1,
        TYPE_SERVERS = 2,
        TYPE_EDIT_SERVER = 3,
        TYPE_SERVER_CREDS = 4,
        TYPE_EDIT_PROJECT = 5,
        TYPE_PROJECT_CREDS = 6,
        TYPE_GENERAL = 7,
        TYPE_ABOUT = 8,

        TYPE_LEGAL = 10,
        TYPE_CERT = 12,
        TYPE_CERT_AUTH = 12,
        TYPE_TRUSTED_CERTS = 13;

    
    var DELETE_TXT = {};
    DELETE_TXT[TYPE_EDIT_SERVER] = 5191; 
    DELETE_TXT[TYPE_EDIT_PROJECT] = 11;  

    
    var ADD_TXT = {};
    ADD_TXT[TYPE_SERVERS] = 5191;          
    ADD_TXT[TYPE_EDIT_SERVER] = 11;        

    
    var MEMORY_LIMIT_LIST = [{
            v: 25,
            n: '25MB'
        }, {
            v: 50,
            n: '50MB'
        }, {
            v: 100,
            n: '100MB'
        }, {
            v: 250,
            n: '250MB'
        }, {
            v: 500,
            n: '500MB'
        }, {
            v: 1024,
            n: '1GB'
        }, {
            v: 2048,
            n: '2GB'
        }, {
            v: 3072,
            n: '3GB'
        }, {
            v: 4096,
            n: '4GB'
        }];

    function getHourString(v) {
        return $DESC(9797, 'Every ## hours').replace('##', v);
    }

    var UPDATE_INTERVAL = [{
            v: 1,
            n: $DESC(9796, 'Every hour')
        }, {
            v: 2,
            n: getHourString(2)
        }, {
            v: 4,
            n: getHourString(4)
        }, {
            v: 10,
            n: getHourString(10)
        }, {
            v: 24,
            n: getHourString(24)
        }];

    
    var MODIFIED_ITEMS = {};

    
    function getNewServerNode() {
        return {
            nm: '',
            po: 80,
            pt: 'MicroStrategyMobile',
            ty: 1,
            rt: 0,
            udc: true,
            wsc: {
                am: 1,
                lo: '',
                ps: ''
            },
            pdc: {
                am: 1,
                lo: '',
                ps: ''
            },
            pl: [],
            isNew: true
        };
    }

    
    function getNewProjectNode() {
        return {
            pc: {
                am: 0,
                lo: '',
                ps: ''
            },
            pn: '',
            sn: '',
            sp: 0,
            udc: false,
            isNew: true
        };
    }

    
    function updateView(viewInfo, items) {

        
        if (items) {
            
            viewInfo.items = items;
        } else {
            
            items = viewInfo.items;
        }

        var view = this.view.getList(viewInfo.cfg.isHome),
            rootCtrl = this.rootCtrl;

        
        view.restoreListState(viewInfo.idx, viewInfo.origin);

        
        view.items = items;

        
        view.refresh();

        
        if (mstrApp.isTablet() && viewInfo.cfg.isHome) {
            
            if (!viewInfo.idx) {
                
                view.singleSelect(0);
            }
        }

        
        rootCtrl.updateContent(null, (mstrApp.isTablet()) ? $DESC(7831, 'Settings') : viewInfo.title);

        
        rootCtrl.contentUpdated('Settings');

        
        this.generateActionToolbar();
    }

    
    function generateView(fnView, item) {
        
        var viewInfo = fnView.call(this, item);

        
        this.view.getList(viewInfo.cfg.isHome).resetListState();

        
        viewInfo.cfg.fnRedraw = fnView;

        
        this._viewInfos.push(viewInfo);

        
        updateView.call(this, viewInfo);
    }

    
    function getLastViewInfo() {
        var views = this._viewInfos;
        return views[views.length - 1];
    }

    
    function getCurrentConfig() {
        var viewInfo = getLastViewInfo.call(this);
        return viewInfo && viewInfo.cfg;
    }

    
    function cacheViewState(idx) {
        
        var lastViewInfo = getLastViewInfo.call(this);
        lastViewInfo.idx = idx;
        lastViewInfo.origin = this.view.getList(lastViewInfo.cfg.isHome).getScrollPos();
    }

    
    function showCurrentView() {
        
        var current = getLastViewInfo.call(this),
            cfg = current.cfg;

        
        updateView.call(this, current, cfg.fnRedraw.call(this, cfg.item).items);

        
        this.view.getList(cfg.isHome).restoreListState(current.idx, current.origin);
    }

    
    function confirmDelete(itemName, fnOk) {
        
        mstrmojo.confirm($DESC(8390, 'Are you sure you want to delete #?').replace('#', itemName), [ $BTN($DESC(1442, 'OK'), fnOk), $BTN($DESC(221, 'Cancel')) ]);
    }

    
    function deleteItem(item) {
        
        var me = this;
        confirmDelete(item.nm, function () {

            
            var mobileConfig = me.mobileConfigObj,
                cfg = getCurrentConfig.call(me),
                servers = mobileConfig.getWebServersList(),
                collection = (cfg.type === TYPE_SERVERS) ? servers : servers[cfg.idx].pl;

            
            collection.splice(item.idx, 1);

            
            me.view.getList(cfg.isHome).set('items', cfg.fnRedraw.call(me, cfg.item).items);

            me.mobileConfigObj.reconcileHomescreen();

            
            me.mobileConfigObj.saveConfiguration();

            
            me.connectivityChanged = true;
        });
    }

    
    function showPopup(item) {
        var controller = this,
            dialog;

        
        dialog = mstrApp.showDialog({
            title: item.nm,
            cssClass: 'mstrmojo-SimpleOptions',
            children: [{
                scriptClass: 'mstrmojo.android.SimpleList',
                isElastic: true,
                items: [{
                    n: $DESC(1088, 'Edit'),
                    v: 1
                }, {
                    n: $DESC(629, 'Delete'),
                    v: 2
                }],
                postselectionChange: function (evt) {
                    
                    dialog.close();

                    
                    if (this.items[evt.added[0]].v === 1) {
                        
                        item.fn();

                    } else {
                        
                        deleteItem.call(controller, item);
                    }
                }
            }]
        });
    }

    
    function convertListToItems(list) {
        
        var rtn = [],
            x = -1;

        
        $ARR.forEach(list, function (n, idx) {
            
            if (n) {
                
                rtn[++x] = {
                    n: n,
                    v: idx
                };
            }
        });

        return rtn;
    }

    
    function editItem(item, value, node) {
        var cfg = getCurrentConfig.call(this),
            type = cfg.type,
            path = item.pt.split('.'),
            prop = path.pop(),
            mobileConfig = this.mobileConfigObj,
            servers = mobileConfig.getWebServersList();

        switch (type) {
        case TYPE_EDIT_SERVER:
            
            node = servers[cfg.idx];

            
            if (!node) {
                
                node = getNewServerNode();

                
                servers.push(node);

                
                this.connectivityChanged = true;
            }
            break;

        case TYPE_EDIT_PROJECT:
            
            var serverNode = servers[cfg.parent.idx],
                projects = serverNode.pl || [];

            
            node = projects[cfg.idx];

            
            if (!node) {
                
                node = getNewProjectNode();

                
                
                this.mobileConfigObj.setPid(node);

                
                projects.push(node);

                
                this.connectivityChanged = true;
            }
            break;

        case TYPE_GENERAL:
            
            node = mobileConfig.getGeneralSettings();

            
            if (prop === 'am' || prop === 'lo' || prop === 'ps') {
                
                node = mobileConfig.getDefaultServerCreds();
            } else if (prop === 'ebs' || prop === 'tod' || prop === 'ui' || prop === 'wo' || prop === 'co') {
                
                node = mobileConfig.getBackgroundSyncSettings();
            }
            break;

        case TYPE_CERT:
        case TYPE_CERT_AUTH:
        case TYPE_TRUSTED_CERTS:
            break;

        default:
            throw new Error('AndroidSettingsController::editItem -- Unhandled edit action.');
        }

        
        if (path.length) {
            
            node = $HASH.walk(path.join('.'), node);
        }

        
        var oldValue = node[prop];
        if (oldValue !== value) {
            
            node[prop] = value;

            
            item.v = value;

            
            var mods = MODIFIED_ITEMS[type] || {};

            
            mods[item.pt.replace('.', '@')] = item;

            
            MODIFIED_ITEMS[type] = mods;

            
            $ARR.forEach(item.dependents, function (dependentItem) {
                
                $ARR.forEach([ 'Hidden', 'Disabled' ], function (prop) {
                    
                    var fnDependent = dependentItem['fn' + prop];
                    if (fnDependent) {
                        
                        dependentItem[prop.toLowerCase()] = fnDependent(value);
                    }
                });
            });

            
            if (prop === "lo" || prop === "ps") {
                
                node.um = true;
            }
        }
    }

    
    function newImage(props) {
        return $HASH.copy(props, {
            nm: '',
            style: STYLE_IMAGE
        });
    }

    
    function newHeader(text, props) {
        return $HASH.copy(props, {
            nm: text,
            style: STYLE_HEADER
        });
    }

    
    function newItem(title, value, style, props) {
        return $HASH.copy(props, {
            nm: title,
            v: value,
            style: style
        });
    }

    
    function newBtnItem(title, value, fnClick, props) {
        var controller = this;

        return newItem(title, value, STYLE_BUTTON, $HASH.copy({
            fn: function () {
                
                fnClick.call(controller);
            }

        }, props));
    }

    
    function newViewItem(title, value, fnView, props) {
        var controller = this;

        return newItem(title, value, STYLE_VIEW_BUTTON, $HASH.copy({
            fn: function () {
                
                cacheViewState.call(controller, this._renderIdx);

                
                generateView.call(controller, fnView, this);
            }
        }, props));
    }

    
    function newEditItem(title, style, node, path, props) {
        var controller = this;

        return newItem(title, $HASH.walk(path, node), style, $HASH.copy({
            pt: path,
            fn: function (value) {
                editItem.call(controller, this, value, node);
            }
        }, props));
    }

    
    function newListItem(title, node, path, items, props) {
        return newEditItem.call(this, title, STYLE_LIST, node, path, $HASH.copy({
            items: items
        }, props));
    }

    
    function newCheckItem(title, description, node, path, on, off, props) {
        return newEditItem.call(this, title, STYLE_CHECK, node, path, $HASH.copy({
            desc: description,
            on: on,
            off: off
        }, props));
    }

    
    function ellipsizeHeaderText(text, ellipsize) {
        return ellipsize ? mstrmojo.string.ellipsize(text, 20) : text;
    }

    
    function addTabletHeader(items, title, ellipsize) {
        
        if (mstrApp.isTablet()) {
            
            var headerTitle = [];
            $ARR.forEach(this._viewInfos, function (info, idx) {
                
                if (idx && info.title !== title) {
                    
                    headerTitle.push('<div hidx="' + idx + '">' + ellipsizeHeaderText(info.title, (idx > 1 && ellipsize)) + '</div>');
                }
            });

            
            headerTitle.push('<em>' + ellipsizeHeaderText(title, ellipsize) + '</em>');

            
            items = [ newHeader(headerTitle.join(''), {
                cls: 'tablet-header'
            }) ].concat(items);
        }

        
        return items;
    }

    
    function validateServerChanges(cfg, mods) {
        var servers = this.mobileConfigObj.getWebServersList(),
            server = servers[cfg.idx],
            serverCreds = server.wsc,                           
            serverAuth = serverCreds.am,                        
            projects = server.pl,
            isNewServer = server.isNew;

        
        if (isNewServer && !mods.nm) {
            
            servers.splice(cfg.idx, 1);

            
            return false;
        }

        
        delete server.isNew;

        
        if (mods.nm || mods.po || mods.pt || mods.ty) {
            
            $ARR.forEach(projects, function (project) {
                mstrApp.removeProjectCaches(project);
            });
        } else {
            
            if (mods['wsc@lo'] && (mods['wsc@am'] || (serverAuth === 2 || serverAuth === 3))) {        
                var projectDefaultAuth = server.pdc.am;

                
                $ARR.forEach(projects, function (project) {
                    
                    var projectAuth = (project.udc) ? projectDefaultAuth : project.pc.am;

                    
                    if (projectAuth === 2 || projectAuth === 64) {
                        
                        mstrApp.removeProjectCaches(project);
                    }
                });
            }
        }

        
        server.udc = (!serverAuth);

        
        if (!serverAuth) {
            
            serverCreds.lo = '';
            serverCreds.ps = '';
        }

        
        this.mobileConfigObj.setWebServerList(servers);

        
        return (isNewServer || !!mods.nm);
    }

    
    function validateProjectChanges(cfg, mods) {
        var servers = this.mobileConfigObj.getWebServersList(),
            projects = servers[cfg.parent.idx].pl,
            project = projects[cfg.idx],
            projectCreds = project.pc,                             
            projectAuth = projectCreds.am,                         
            isNewProject = project.isNew;

        
        if (isNewProject && (!mods.pn || !mods.sn)) {
            
            projects.splice(cfg.idx, 1);

            
            return false;
        }

        
        delete project.isNew;

        
        if (!isNewProject && (mods.pn || mods.sn || mods['pc@am'] || (projectAuth > 0 && mods.lo))) {
            
            mstrApp.removeProjectCaches(project.pid);

            
            
            this.mobileConfigObj.setPid(project);

            
            this.connectivityChanged = true;
        }

        
        project.udc = (!projectAuth);

        
        if (!projectAuth) {
            
            projectCreds.lo = '';
            projectCreds.ps = '';
        }

        
        return (isNewProject || !!mods.pn || !!mods.sn);
    }

    
    function validateGeneralSettingsChanges(cfg, mods) {
        var mobileConfig = this.mobileConfigObj,
            creds = mobileConfig.getDefaultServerCreds(),
            isAnonymousMode = (creds.am === 1);

        
        if (mods.am || (mods.lo && !isAnonymousMode)) {
            
            $ARR.forEach(mobileConfig.getWebServersList(), function (server) {
                
                if (server.udc) {
                    
                    var defaultProjAuth = server.pdc.am;

                    
                    $ARR.forEach(server.pl, function (project) {
                        
                        var projAuthMode = (project.udc) ? defaultProjAuth : project.pc.am;

                        
                        if (projAuthMode === 2 || projAuthMode === 64) {
                            mstrApp.removeProjectCaches(project.pid);
                        }
                    });
                }
            });
        }

        
        if (isAnonymousMode) {
            
            creds.lo = '';
            creds.ps = '';
        }

        
        return false;
    }

    
    function newAuthenticationItems(type, node) {

        var path = '',
            fnDisabled = mstrmojo.emptyFn,
            items;

        
        if (type === TYPE_EDIT_SERVER || type === TYPE_SERVER_CREDS) {
            
            items = convertListToItems([ $DESC(8441, 'Default'), $DESC(7778, 'Anonymous'), $DESC(7227, 'Basic'), $DESC(7779, 'Windows'),  $DESC(8027, 'Trusted') ]);

            
            if (type === TYPE_EDIT_SERVER) {
                
                path = 'wsc';
            }

            
            fnDisabled = function (v) {
                return (v < 2 || v === 64);
            };

            
            
            if ((type !== TYPE_SERVER_CREDS) && node.udc) {
                node[path].am = 0;
            }

        } else {
            
            items = [{
                n: $DESC(8441, 'Default'),
                v: 0
            }, {
                n: $DESC(3157, 'Standard'),
                v: 1
            }, {
                n: $DESC(7779, 'Windows'),
                v: 2
            }, {
                n: 'LDAP',
                v: 16
            }, {
                n: $DESC(1563, 'Database'),
                v: 32
            }, {
                n: mstrmojo.desc(8027, 'Trusted'),
                v: 64
            }];

            
            path = (type === TYPE_PROJECT_CREDS) ? 'pdc' : 'pc';

            
            fnDisabled = function (v) {
                
                return (!v || parseInt(v, 10) === 2 || parseInt(v, 10) === 64);
            };

            
            
            if ((type !== TYPE_PROJECT_CREDS) && node.udc) {
                node[path].am = 0;
            }
        }

        
        if (type === TYPE_SERVER_CREDS || type === TYPE_PROJECT_CREDS) {
            
            items.shift();
        }

        
        path = (path && path + '.') || '';

        
        var cfgLogin = {
                disabled: fnDisabled($HASH.walk(path + 'am', node)),
                fnDisabled: fnDisabled
            },
            userName = newEditItem.call(this, $DESC(17, 'User Name'), STYLE_TEXT, node, path + 'lo', cfgLogin),
            
            pwd = newEditItem.call(this, $DESC(18, 'Password'), STYLE_TEXT, node,  path + 'ps', $HASH.copy(cfgLogin, {
                pwd: true
            })),
            rtn = [];

        
        rtn.push(newListItem.call(this, $DESC(2822, 'Authentication'), node, path + 'am', items, {
            dependents: [ userName, pwd ]
        }));

        
        rtn.push(userName);
        rtn.push(pwd);

        return rtn;
    }

    
    function getEditProjectView(item) {
        var idx = item.idx,
            settingsCfg = getCurrentConfig.call(this),
            server = this.mobileConfigObj.getWebServersList()[settingsCfg.idx] || getNewServerNode(),
            project = server.pl[idx] || getNewProjectNode(),
            items = [];

        
        items.push(newEditItem.call(this, $DESC(11, 'Project'), STYLE_TEXT, project, 'pn', {
            showHint: true
        }));
        items.push(newEditItem.call(this, $DESC(5191, 'Server'), STYLE_TEXT, project, 'sn', {
            showHint: true
        }));

        
        items = items.concat(newAuthenticationItems.call(this, TYPE_EDIT_PROJECT, project));

        
        return {
            title: item.nm,
            items: addTabletHeader.call(this, items, item.nm, true),
            cfg: {
                type: TYPE_EDIT_PROJECT,
                item: item,
                idx: idx,
                parent: settingsCfg,
                fnVal: validateProjectChanges
            }
        };
    }

    
    function getEditServerView(item) {
        var controller = this,
            serverIndex = item.idx,
            server = this.mobileConfigObj.getWebServersList()[serverIndex] || getNewServerNode(),
            projects = server.pl || [],
            items = [];

        
        server.pl = projects;

        
        items.push(newEditItem.call(this, $DESC(7559, 'Name'), STYLE_TEXT, server, 'nm', {
            showHint: true
        }));

        items.push(newEditItem.call(this, $DESC(16, 'Port'), STYLE_NUMBER, server, 'po', {
            limits: {
                min: 0,
                max: 65535
            }
        }));
        items.push(newEditItem.call(this, $DESC(8489, 'Path'), STYLE_TEXT, server, 'pt'));
        items.push(newListItem.call(this, $DESC(8362, 'Web server type'), server, 'ty', convertListToItems([ 'J2EE', 'ASP.Net' ])));
        items.push(newCheckItem.call(this, $DESC(8363, 'Secure HTTP'), $DESC(9449, 'Use HTTPS to access the mobile server'), server, 'rt', 1, 0));

        
        items = items.concat(newAuthenticationItems.call(this, TYPE_EDIT_SERVER, server));

        
        items.push(newHeader($DESC(8364, 'Default Project Credentials')));
        items = items.concat(newAuthenticationItems.call(this, TYPE_PROJECT_CREDS, server));

        
        items.push(newHeader($DESC(37, 'Projects')));

        
        $ARR.forEach(projects, function (project, idx) {
            items.push(newViewItem.call(controller, project.pn, project.sn, getEditProjectView, {
                idx: idx,
                fnPress: showPopup
            }));
        });

        
        return {
            title: item.nm,
            items: addTabletHeader.call(this, items, item.nm, true),
            cfg: {
                type: TYPE_EDIT_SERVER,
                item: item,
                idx: serverIndex,
                parent: getCurrentConfig.call(this),
                fnVal: validateServerChanges
            }
        };
    }

    
    function getLegalView() {
        var items = [],
            title = $DESC(8365, 'Legal');

        if (!legalText) {
            legalText = "<p>" + $DESC(8633) + "</p>" + "<p>" + $DESC(8634) + "</p>" + "<p>" + $DESC(8635) + "</p>";
        }
        items.push(newItem(legalText, "", STYLE_TEXT_AREA, {
            noclick: true
        }));

        
        return {
            title: title,
            items: addTabletHeader.call(this, items, title),
            cfg: {
                type: TYPE_LEGAL
            }
        };
    }

    
    function getAboutView() {
        var items = [],
            title = mstrApp.isTablet() ? $DESC(1142, 'About') : $DESC(9457, 'About #').replace('#', 'MicroStrategy');

        items.push(newImage.call(this, {
            noclick: true,
            cls: 'mstr-logo'
        }));

        items.push(newItem.call(this, 'MicroStrategy Mobile 9.4.0', $DESC(8366, 'Build Number #').replace('#', mstrMobileApp.getAppVersion()), STYLE_BUTTON, {
            cls: 'build-info',
            noclick: true
        }));

        items.push(newHeader($DESC(9456, 'More Information'), {
            cls: 'more-info'
        }));
        items.push(newViewItem.call(this, $DESC(8365, 'Legal'), $DESC(9460, 'Copyright disclosure'), getLegalView));
        items.push(newBtnItem.call(this, $DESC(9458, 'Get in touch'), $DESC(9459, 'Send us an email with your feedback, suggestions and appreciation!'), function () {
            var bodyMsg = [ $DESC(9465, 'I was looking through the MicroStrategy Mobile Android App. Please contact me with details on how I can:') ];
            bodyMsg.push($DESC(9466, ' - Find out how I can use MicroStrategy Apps to drive my business.'));
            bodyMsg.push($DESC(9467, ' - Have apps, based on my workflow, specifications and design, in two weeks.'));
            bodyMsg.push($DESC(9468, ' - How I can partner with MicroStrategy for all my Mobile solutions.'));
            bodyMsg.push($DESC(9469, ' - Attend a free, hands-on, class to teach developers how to build and maintain Mobile Business Apps.'));
            bodyMsg.push('');
            bodyMsg.push($DESC(9470, 'Thank you.'));

            
            mstrMobileApp.sendEmail('info@microstrategy.com', $DESC(9464, 'Request information about MicroStrategy Mobile'), bodyMsg.join('\r\n'), '');
        }));

        
        return {
            title: title,
            items: addTabletHeader.call(this, items, title),
            cfg: {
                type: TYPE_ABOUT
            }
        };
    }

    
    function getBackgroundSyncingItems() {
        var settings = this.mobileConfigObj.getBackgroundSyncSettings(),
            fnDisabled = function (v) {
                return (!v || v === false);
            },
            depProps = {
                disabled: fnDisabled($HASH.walk('ebs', settings)),
                fnDisabled: fnDisabled
            },
            timeOfDay = newEditItem.call(this, $DESC(9807, 'Time of day'), STYLE_TIME, settings, 'tod'),
            updateInterval = newListItem.call(this, $DESC(9792, 'Update interval'), settings, 'ui', UPDATE_INTERVAL, $HASH.copy(depProps, {
                dependents: [timeOfDay]
            })),
            wifi = newCheckItem.call(this, $DESC(9793, 'Only over Wi-Fi'), null, settings, 'wo', true, false, depProps),
            charge = newCheckItem.call(this, $DESC(9794, 'Only if charging'), null, settings, 'co', true, false, depProps),
            enable = newCheckItem.call(this, $DESC(9795, 'Enable background syncing'), null, settings, 'ebs', true, false, {
                dependents: [updateInterval, timeOfDay, wifi, charge, timeOfDay]
            }),
            items = [];

        
        items.push(enable);
        items.push(updateInterval);
        items.push(timeOfDay);
        items.push(wifi);
        items.push(charge);

        
        timeOfDay.disabled = updateInterval.disabled || (updateInterval.v !== 24);
        timeOfDay.fnDisabled = function () {
            return (enable.v !== true) || (updateInterval.v !== 24);
        };

        return items;
    }

    function deleteCertificate(item) {
        var controller = this;
        confirmDelete(item.nm, function () {
            
            mstrApp.showMessage('Deleting...');


            window.setTimeout(function () {
                var cfg = getCurrentConfig.call(controller);

                
                mstrMobileApp.deleteCertificate();

                
                item.hidden = !mstrMobileApp.hasCertificate();

                
                $ARR.forEach(item.dependents, function (d) {
                    d.hidden = !item.hidden;
                });

                
                controller.view.getList(cfg.isHome).set('items', cfg.fnRedraw.call(controller, cfg.item).items);

                
                mstrApp.hideMessage();
            }, 100);
        });
    }

    function showPopupDeleteCertificate(item) {
        var controller = this,
            dialog;

        dialog = mstrApp.showDialog({
            title: item.nm,
            cssClass: 'mstrmojo-SimpleOptions',
            children: [{
                scriptClass: 'mstrmojo.android.SimpleList',
                isElastic: true,
                items: [{
                    n: $DESC(1900, 'View'),
                    v: 1
                }, {
                    n: $DESC(629, 'Delete'),
                    v: 2
                }],
                postselectionChange: function (evt) {
                    dialog.close();
                    if (this.items[evt.added[0]].v === 1) {
                        item.fn();
                    } else if (this.items[evt.added[0]].v === 2) {
                        deleteCertificate.call(controller, item);
                    }
                }
            }]
        });
    }

    
    function getCertificateDetailsView(item) {
        var detailsStr = mstrMobileApp.getCertificateDetails(),
            details = eval('(' + detailsStr + ')'),
            items = [],
            result = "",
            i;

        if (details.prs) {
            for (i = 0; i < details.prs.pr.length; ++i) {
                var pr = details.prs.pr[i];
                var name;

                if (pr.n === "edat") {
                    name = $DESC(8457, 'Expiration');
                } else if (pr.n === "issr_n") {
                    name = $DESC(8458, 'Issuer');
                } else {
                    name = pr.n;
                }
                result += name + ": " + pr.v + "<br/>";
            }
            items.push(newItem.call(this, result, "", STYLE_TEXT_AREA, {
                disabled: true
            }));
            return {
                title: item.nm,
                items: addTabletHeader.call(this, items, item.nm),
                cfg: {
                    type: TYPE_CERT,
                    item: item
                }
            };
        }

        throw details.message || 'No certificate details available';
    }

    
    function getTrustedCertificatesView(item) {
        var result = mstrMobileApp.getTrustedCertificates(),
            jsonResult = eval('(' + result + ')'),
            items = [],
            i;

        if (jsonResult && jsonResult.certs) {
            for (i = 0; i < jsonResult.certs.length; ++i) {
                var cert = jsonResult.certs[i].dsc;

                items.push(newItem(cert, "", STYLE_TEXT_AREA, {
                    disabled: true
                }));
            }
        }
        return {
            title: item.nm,
            items: addTabletHeader.call(this, items, item.nm),
            cfg: {
                type: TYPE_TRUSTED_CERTS,
                item: item
            }
        };
    }

    
    function getCertificateAuthenticationFieldsView(item) {
        var result = mstrMobileApp.getCertificateAuthenticationFields(),
            jsonResult = eval('(' + result + ')'),
            items = [],
            controller = this,
            i = 0;

        if (jsonResult.login_info) {
            var settings = {},
                loginInfoField = jsonResult.login_info.field;

            for (i = 0; i < loginInfoField.length; ++i) {
                var field = loginInfoField[i],
                    cfgAuth = {};

                settings[field.n] = "";
                if (!!field.pass) {
                    cfgAuth = $HASH.copy(cfgAuth, {
                        pwd: true
                    });
                }

                items.push(newEditItem.call(this, field.dn, ((field.tp === "numeric") ? STYLE_NUMBER : STYLE_TEXT), settings, field.n, cfgAuth));
            }
            
            items.push(newItem.call(this, "Submit", "", STYLE_BUTTON, {
                fn: function () {

                    
                    mstrApp.showMessage();

                    
                    window.setTimeout(function () {
                        
                        var responseStr = mstrMobileApp.getNewCertificate(JSON.stringify(settings));

                        
                        mstrApp.hideMessage();

                        
                        var response = eval('(' + responseStr + ')'),
                            message = response.message;
                        if (message) {
                            
                            window.alert(response.message);

                        } else {
                            
                            window.alert("Certificate obtained");

                            
                            if (item && item.nm === "Get Certificate") {
                                
                                item.hidden = mstrMobileApp.hasCertificate();

                                
                                $ARR.forEach(item.dependents, function (d) {
                                    d.hidden = !d.hidden;
                                });
                            }

                            
                            
                            
                            mstrApp.goBack();
                        }

                    }, 100);
                }
            }));

            var title = jsonResult.login_info.msg;

            return {
                title: title,
                items: addTabletHeader.call(this, items, title),
                cfg: {
                    type: TYPE_CERT_AUTH,
                    item: item
                }
            };
        }

        throw new Error(jsonResult.message);
    }

    
    function getGeneralSettingsView(item) {
        var mobileConfig = this.mobileConfigObj,
            generalSettings = mobileConfig.getGeneralSettings(),
            items = [];

        items.push(newEditItem.call(this, $DESC(8367, 'Network Timeout (seconds)'), STYLE_NUMBER, generalSettings, 'nt', {
            limits: {
                min: 0,
                max: 9999
            }
        }));

        items.push(newEditItem.call(this, $DESC(7840, 'Maximum Columns in Grid'), STYLE_NUMBER, generalSettings, 'mgc', {
            limits: {
                min: 0,
                max: 9999
            }
        }));

        
        if (generalSettings.usd) {
            var diagnosticMode = newCheckItem.call(this, $DESC(8760, 'Diagnostic Mode'), $DESC(9450, 'Store a log file in the device'), {
                b: mobileConfig.getDiagnosticMode()
            }, 'b', true, false);

            
            diagnosticMode.fn = function (value) {
                
                mobileConfig.setDiagnosticMode(value);

                
                this.v = value;
            };
            items.push(diagnosticMode);
        }

        
        var monitor = newCheckItem.call(this, $DESC(9471, 'Monitor Network Status'), $DESC(9790, 'Notify the user when connection quality is below optimal'), generalSettings, 'mns', true, false);

        
        var fn = function (value) {
            mstrMobileApp.setNetworkMonitoringEnabled(value);
        };

        monitor.fn = mstrmojo.func.composite([fn, monitor.fn]);

        
        if (generalSettings.mns === undefined) {
            
            monitor.v = true;
        }
        items.push(monitor);

        items.push(newHeader($DESC(8361, 'Mobile Server Default')));
        items = items.concat(newAuthenticationItems.call(this, TYPE_SERVER_CREDS, this.mobileConfigObj.getDefaultServerCreds()));

        
        
        if (generalSettings.usc) {
            items.push(newHeader($DESC(8368, 'Caching')));
            items.push(newListItem.call(this, $DESC(8369, 'Memory limit'), generalSettings, 'ml', MEMORY_LIMIT_LIST));
            items.push(newCheckItem.call(this, $DESC(8370, 'Folder caching'), $DESC(9451, 'Store folders information for offline analysis'), generalSettings, 'fc', true, false));
            items.push(newCheckItem.call(this, $DESC(8371, 'Clear cache when closed'), $DESC(9452, 'Delete reports and documents information after exiting the app'), generalSettings, 'cc', 2, 1));
        }

        items.push(newHeader($DESC(8459, 'Certificates')));

        
        if (generalSettings.ucs !== undefined && generalSettings.ucs !== '' && generalSettings.ucs) {
            var hasCert = mstrMobileApp.hasCertificate(),
                certItem,
                getCertItem;

            certItem = newViewItem.call(this, 'Device Certificate', '', getCertificateDetailsView, {
                fnPress: showPopupDeleteCertificate,
                hidden: !hasCert
            });
            getCertItem = newViewItem.call(this, 'Get Certificate', "", getCertificateAuthenticationFieldsView, {
                hidden: hasCert,
                dependents: [certItem]
            });
            certItem.dependents = [getCertItem];
            items.push(certItem);
            items.push(getCertItem);
        }
        items.push(newViewItem.call(this, $DESC(8447, 'Trusted Certificates'), "", getTrustedCertificatesView, {
            hidden: false
        }));

        
        if (mstrMobileApp.isDPCEnabled()) {
            items.push(newHeader($DESC(9481, 'Device Passcode')));
            items.push(newItem.call(this, $DESC(1905, 'Reset'), '', STYLE_BUTTON, {
                fn: function () {
                    mstrMobileApp.resetDPC();
                }
            }));
        }

        
        items.push(newHeader($DESC(9791, 'Background Syncing')));
        items = items.concat(getBackgroundSyncingItems.call(this));

        
        return {
            title: item.nm,
            items: addTabletHeader.call(this, items, item.nm),
            cfg: {
                type: TYPE_GENERAL,
                fnVal: validateGeneralSettingsChanges,
                item: item
            }
        };
    }

    
    function getMobileServersView(item) {
        var config = this.mobileConfigObj,
            servers = config.getWebServersList(),
            items = [];

        
        $ARR.forEach(servers, function (server, idx) {
            
            items.push(newViewItem.call(this, server.nm, '', getEditServerView, {
                idx: idx,
                fnPress: showPopup
            }));
        }, this);

        
        return {
            title: item.nm,
            items: addTabletHeader.call(this, items, item.nm),
            cfg: {
                type: TYPE_SERVERS,
                item: item
            }
        };

    }

    
    function getHomeSettingsView() {
        
        var items = [ newViewItem.call(this, $DESC(6560, 'General Settings'), '', getGeneralSettingsView), newViewItem.call(this, $DESC(8375, 'Mobile Servers'), '', getMobileServersView) ];

        
        if (mstrApp.isTablet()) {
            
            items.push(newViewItem.call(this, $DESC(1142, 'About'), '', getAboutView));
        }

        
        return {
            title: $DESC(7831, 'Settings'),
            items: items,
            cfg: {
                type: TYPE_HOME,
                isHome: true
            }
        };
    }

    
    function saveChanges(cfg, doSave) {
        var type = cfg.type,
            modifications = MODIFIED_ITEMS[cfg.type];

        
        if (modifications) {
            
            var fnValidate = cfg.fnVal;
            if (fnValidate) {
                
                fnValidate.call(this, cfg, modifications);
            }

            
            if (doSave) {
                
                this.mobileConfigObj.saveConfiguration();
            }

            
            delete MODIFIED_ITEMS[type];
        }
    }

    
    var $CTRL = mstrmojo.android.controllers.SettingsController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        null,

        
        {
            scriptClass: "mstrmojo.android.controllers.SettingsController",

            
            connectivityChanged: false,

            init: function (props) {
                this._super(props);

                
                this.mobileConfigObj = this.mobileConfigObj || mstrApp.getConfiguration();
            },

            start: function (params) {
                var viewFn = params.viewFn;

                this._super(params);

                
                mstrApp.cancelPending();

                
                this._viewInfos = [];

                
                var view = this.view = this.newView('Settings');

                
                this.rootCtrl.updateContent(view, $DESC(7831, 'Settings'));

                
                generateView.call(this, (viewFn && eval('(' + viewFn + ')')) || getHomeSettingsView);
            },

            
            getDefaultMenus: function getDefaultMenus() {
                
                return MENUS.HELP;
            },

            updateActionToolbar: function updateActionToolbar(tbCfg) {
                
                var cfg = getCurrentConfig.call(this),
                    cfgType = cfg && cfg.type,
                    deleteDescId = DELETE_TXT[cfgType],
                    addDescId = ADD_TXT[cfgType];

                
                if (addDescId) {
                    
                    var menuId = MENU_ADD_SERVER,
                        iconId = 19;

                    
                    if (cfgType === TYPE_EDIT_SERVER) {
                        
                        menuId = MENU_ADD_PROJECT;
                        iconId = 20;
                    }

                    
                    tbCfg.addToolbarBtn(menuId, $DESC(9446, 'Add #').replace('#', $DESC(addDescId, 'Item')), menuId, true, iconId);
                }

                
                if (deleteDescId) {
                    
                    tbCfg.addMenuItem(MENU_DELETE, $DESC(8379, 'Delete #').replace('#', $DESC(deleteDescId, 'Item')), MENU_DELETE, true, 16);
                }

                
                if (!mstrApp.isTablet() && cfgType !== TYPE_ABOUT && cfgType !== TYPE_LEGAL) {
                    
                    tbCfg.addMenuItem(MENU_ABOUT, $DESC(1142, 'About'), MENU_ABOUT, true, 21);
                }

                
                return this._super(tbCfg);
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                var cfg = getCurrentConfig.call(this),
                    type = cfg.type,
                    servers = this.mobileConfigObj.getWebServersList(),
                    isServer = (type === TYPE_EDIT_SERVER);

                switch (group) {
                case MENU_ABOUT:
                    
                    cacheViewState.call(this, -1);

                    
                    generateView.call(this, getAboutView);
                    break;

                case MENU_ADD_SERVER:
                case MENU_ADD_PROJECT:
                    
                    cacheViewState.call(this, -1);

                    
                    if (group === MENU_ADD_SERVER) {
                        
                        generateView.call(this, getEditServerView, {
                            nm: $DESC(9447, 'New Server'),
                            idx: servers.length
                        });

                    } else {
                        
                        var server = servers[cfg.item.idx];
                        generateView.call(this, getEditProjectView, {
                            nm: $DESC(9448, 'New Project'),
                            idx: (server && server.pl.length) || 0
                        });

                    }
                    break;

                case MENU_DELETE:
                    var collection;

                    
                    if (isServer) {
                        
                        collection = servers;

                    
                    } else if (type === TYPE_EDIT_PROJECT) {
                        
                        var idx = cfg.parent.idx;
                        collection = servers[idx] && servers[idx].pl;
                    }

                    
                    if (collection) {
                        var me = this,
                            item = collection[cfg.idx];

                        var okFn = function () {
                            
                            collection.splice(cfg.idx, 1);

                            
                            me.mobileConfigObj.reconcileHomescreen();

                            
                            me.mobileConfigObj.saveConfiguration();

                            
                            me.view.getList(cfg.isHome).set('items', cfg.parent.fnRedraw.call(me, cfg.parent.item).items);

                            
                            me.goBack();

                            me.connectivityChanged = true;
                        };

                        
                        if (item) {
                            confirmDelete(item.nm || item.pn, okFn);
                        } else {
                            okFn();
                        }
                    } else {
                        
                        this.goBack();
                    }
                    return false;
                }

                
                return this._super(group, cmdId);
            },

            goBack: function goBack() {
                
                if (this._super()) {
                    
                    return true;
                }

                var currentConfig = getCurrentConfig.call(this);
                
                saveChanges.call(this, currentConfig, true);

                
                var viewInfos = this._viewInfos;
                viewInfos.pop();

                
                
                
                if(currentConfig.type === TYPE_EDIT_SERVER && mstrApp.deviceType === 3 && this.mobileConfigObj.getWebServersList().length === 0){
                	viewInfos.pop();
                }

                
                var current = getLastViewInfo.call(this);
                if (!current || (mstrApp.isTablet() && viewInfos.length === 1)) {
                    
                    if (this.connectivityChanged) {
                        
                        this.rootCtrl.restart();
                        return true;
                    }

                    
                    return false;
                }

                
                showCurrentView.call(this);

                
                return true;
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    $ARR.forEach(this._viewInfos, function (view) {
                        
                        saveChanges.call(this, view.cfg);
                    }, this);

                    
                    this.mobileConfigObj.saveConfiguration();

                    
                    this.rootCtrl[(this.connectivityChanged) ? 'restart' : 'goHome']();
                }

                
                return true;
            },

            
            jumpTo: function jumpTo(idx, showView) {
                var viewInfos = this._viewInfos,
                    targetIdx = idx + 1;

                
                $ARR.forEach(viewInfos, function (view, vIdx) {
                    if (vIdx > targetIdx) {
                        
                        saveChanges.call(this, view.cfg);
                    }
                }, this);

                
                viewInfos.splice(targetIdx);

                
                if (showView) {
                    
                    showCurrentView.call(this);
                }
            }
        }
    );

    
    $CTRL.STYLES = {
        HEADER: STYLE_HEADER,
        BUTTON: STYLE_BUTTON,
        VIEW_BUTTON: STYLE_VIEW_BUTTON,
        TEXT: STYLE_TEXT,
        LIST: STYLE_LIST,
        CHECK: STYLE_CHECK,
        IMAGE: STYLE_IMAGE,
        TEXT_AREA: STYLE_TEXT_AREA,
        NUMBER: STYLE_NUMBER,
        TIME: STYLE_TIME
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.android.ui.ActionToolbar",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.android.ui.PropertiesView",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.string");

    mstrmojo.requiresDescs(1142, 8623, 8429, 8430, 8624, 8625, 9099, 11191);

    var $HASH = mstrmojo.hash,
        $AFE = mstrmojo.array.forEach,
        $DOM = mstrmojo.dom,
        TYPE_REPORT = 768,
        MENUS = mstrmojo.android.EnumMenuOptions,
        MNU_FULLSCREEN = MENUS.FULL_SCREEN,
        MNU_SHARE = MENUS.SHARE,
        MNU_ANNOTATION = MENUS.ANNOTATION,
        MNU_ABOUT = MENUS.ABOUT_RESULTSET,
        OBJECT_TYPE_REPORT = 3,             
        BOTTOM_ACTION_TOOLBAR_HEIGHT_160_DPI = 50;

    
    function restoreProjectId() {
        
        var oldPrjId = this._oldPID;
        if (oldPrjId) {
            
            mstrApp.setCurrentProjectId(oldPrjId);
        }
    }

    
    function reExecuteRS(params, callback, resParams, isRefresh ) {
        var model = this.model,
            prompts = model.prompts;

        if (prompts) {
            params.promptsAnswerXML = prompts.getAnswerXML();
        }

        
        params.useRefreshProgress = isRefresh;

        mstrApp.closeAllDialogs(); 

        model.execute(params, callback, resParams);
    }

    
    function refreshRS( callback ) {
        var model = this.model,
            prompts = model.prompts,
            params = {
                fresh: false,
                useRefreshProgress: mstrApp.isTablet()
            };

        if (prompts) {
            params.promptsAnswerXML = prompts.getAnswerXML();
        }

        
        mstrApp.closeAllDialogs();

        this.refresh( params, callback );
    }

    
    function updateLastOpenedList() {
        var startParams = this._startParams,
            action = startParams.action,
            newItem;

        
        if (!action || (action !== 'drillGrid' && action !== 'drill2Grid')) {
            
            newItem = startParams;
        }

        
        this.rootCtrl.updateLastOpened(newItem);
    }

    
    function initView(response, params) {
        
        params = params || {};

        
        var view = this.view = this.createView(response, $HASH.copy(params)),
            title = response.n || params.ttl || '',
            me = this;

        
        view.slot = 'containerNode';

        
        var frame = this.frame = this.newView('ResultSet', {
            controller: this
        });

        
        frame.addChildren([ view ]);

        
        this.rootCtrl.updateContent(frame, title);

        
        this.ttl = this._startParams.n = title;

        
        this.desc = response.dsc;

        
        updateLastOpenedList.call(this);

        
        window.setTimeout(function () {
            
            me.checkCache(response, params);
        }, 100);
    }

    
    function getViewCaptureConfig() {
    	
        
    	if (this.isFullScreen) {
    		this.cancelFlashFullScreen();
        }

    	var position = this.frame.getPosition(),
        	windowDim = $DOM.windowDim();

        position.ww = windowDim.w;
        position.wh = windowDim.h;

        return JSON.stringify(position);
    }

    
    mstrmojo.android.controllers.ResultSetController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        null,

        
        {
            scriptClass: "mstrmojo.android.controllers.ResultSetController",

            supportsFullScreen: true,

            start: function start(params) {
                this._super(params);

                
                this._startParams = $HASH.copy(params);

                var me = this,
                    newProjectId = params.projectID,
                    prevController = me.prevController,
                    fnViewFailed = function (e) {
                        
                        restoreProjectId.call(me);

                        
                        me.viewFailed(e);
                    },
                    fnLogMethod = function (isEntry) {
                        
                        $MAPF(isEntry, 'ResultSetController', 'start');
                    },
                    fnDocRequestComplete = function () {
                        
                        if (prevController && prevController.docRequestComplete) {
                            
                            prevController.docRequestComplete();
                        }
                    };

                
                var subtype = this.ctrlType = params.st;

                
                fnLogMethod(true);

                
                if (newProjectId) {
                    
                    this._oldPID = mstrApp.getCurrentProjectId();

                    
                    mstrApp.setCurrentProjectId(newProjectId);

                    
                    this.pid = newProjectId;

                }

                try {
                    
                    var action = params.action || 'execute';
                    delete params.action;

                    
                    var model = this.model = this.initModel();

                    
                    if (subtype) {
                        
                        model.st = subtype;
                        model.n = params.n;
                    }

                    
                    this.did = this.did || params.documentID || params.reportID || params.objectID;

                    
                    model[action](params, {
                        success: function (response) {
                            try {
                                
                                initView.call(me, response, params);

                            } catch (e) {
                                
                                fnViewFailed(e);
                            }
                        },

                        prompts: function () {
                            
                            me.openPrompts(params);
                        },

                        failure: function (details) {
                            
                            fnViewFailed(details);
                        },

                        complete: function () {
                            
                            fnLogMethod(false);

                            
                            fnDocRequestComplete();
                        },

                        canceled: function () {
                            
                            fnViewFailed();
                        }
                    });

                } catch (e) {
                    
                    fnViewFailed(e);

                    
                    fnDocRequestComplete();
                }
            },

            
            initModel: mstrmojo.emptyFn,

            
            canDelegateToolBar: function canDelegateToolBar() {
                return true;
            },

            
            createView: mstrmojo.emptyFn,

            getDefaultMenus: function getDefaultMenus() {
                
                return 0;
            },

            onorientationChange: function onorientationChange() {
                
                var frame = this.frame;
                if (frame && frame.hasRendered) {
                    
                    frame.rootOrientationChange({
                        isLandscape: !this.orientation
                    });
                }

                this._super();
            },

            
            refresh: function refresh(params, callback) {
                
                var view = this.view;
                
                this.model.refresh(params, mstrmojo.func.wrapMethods({
                    success: function (res) {
                        
                        if (res) {
                            
                            view.refresh();
                        }
                    }
                }, callback));
            },

            reExecute: function reExecute(view) {
                
                if (mstrApp.useBinaryFormat) {
                    mstrMobileApp.removeLiveCache(mstrApp.getCurrentProjectId(), this.model.ci.cid);

                    
                    var me = this;
                    reExecuteRS.call(this, {}, {
                        success: function (res) {
                            me.setData(res);
                        }
                    }, {
                        refresh: true
                    }, false );
                } else {
                    view.model.raiseEvent({
                        name: 'refresh'
                    });
                }
            },

            reprompt: function reprompt() {
                
                this.repromptFlag = true;

                
                this.openPrompts();
            },

            openPrompts: function openPrompts(params) {
                var me = this,
                    prompts = this.model.prompts,
                    size = prompts.size(),
                    supportedPrompts = [],
                    hasUnanswerdUnsupportedPrompts = false,
                    i;

                
                for (i = 0; i < size; i++) {
                    
                    var prompt = prompts.get(i);
                    if (prompt.supported()) {
                        
                        supportedPrompts.push(prompt);

                    } else {
                        
                        if (!prompt.hasAnswer) {
                            
                            if (prompt.req) {
                                
                                this.viewFailed({
                                    message: mstrmojo.desc(8623, 'Report cannot be executed because it contains unanswered, required prompts.')
                                });
                                return;

                            }

                            
                            hasUnanswerdUnsupportedPrompts = true;
                        }
                    }
                }

                var fnAnswerPrompts = function () {
                    
                    if (hasUnanswerdUnsupportedPrompts) {
                        
                        mstrmojo.alert(mstrmojo.desc(8624, 'Warning: Report contains unasnwered, unsupported prompts.'), function () {
                            me.answerPrompts();
                        });

                    } else {
                        
                        me.answerPrompts();
                    }
                };

                
                if (supportedPrompts.length > 0) {
                    
                    var frame = this.frame;
                    this.spawn(mstrApp.controllerFactory.newController('Prompts'), {
                        maskNode: frame && frame.getMaskNode(),
                        prompts: prompts,
                        supportedPrompts: supportedPrompts,
                        
                        n: (params && (params.n || params.ttl)) || this.ttl,
                        callback: function () {
                            fnAnswerPrompts();
                        }
                    });

                } else {
                    
                    fnAnswerPrompts();

                }
            },

            answerPrompts: function answerPrompts() {
                
                var me = this;
                this.model.answerPrompts({
                    success: function (response) {
                        
                        var nextController = me.nextController;
                        if (nextController) {
                            
                            nextController.destroy();
                        }

                        
                        if (me.repromptFlag) {
                            
                            me.afterReprompt(response);

                            
                            delete me.repromptFlag;

                            
                            me.rootCtrl.updateContent(me.frame, response.n);

                            
                            updateLastOpenedList.call(me);

                            
                            me.checkCache(response);

                        } else {
                            
                            initView.call(me, response);

                        }
                    },

                    prompts: function () {
                        
                        me.viewFailed({
                            message: mstrmojo.desc(8625, 'Prompts in prompts are not supported.')
                        });
                    },

                    failure: function (details) {
                        mstrApp.onerror(details);
                    }
                });
            },

            
            afterReprompt: function afterReprompt(response) {
                this.getPageByTree(true);
            },
            
            hasPageBy: mstrmojo.emptyFn,

            
            getPageByTree: function getPageByTree(override) {
                
                var hasData = !!this.pageByData;
                if ((!override && hasData) || !this.hasPageBy()) {
                    
                    return;
                }

                var ctrl = this,
                    view = this.view,
                    model = (view.isVis && view.isVis()) ? view.xtabModel : this.model;

                
                if (model.getPageByTree) {
                    
                    if (hasData) {
                        
                        this.set('pageByData', null);
                    }

                    
                    model.getPageByTree({
                        success: function (data) {
                            ctrl.set('pageByData', data);
                        },
                        failure: function (res) {
                            mstrApp.onerror(res);
                        }
                    });
                }
            },

            destroy: function destroy() {
                
                this.model.destroy();

                
                var frame = this.frame;
                if (frame) {
                    
                    frame.destroy();
                }

                this._super();
            },

            
            checkCache: function checkCache(res, params, callback, option, config) {
                
                
                
                

                var me = this,
                    dataService = this.model.getDataService(),
                    ifc = res && res.ifc;

                
                callback = callback || mstrmojo.emptyFn;

                
                if (!mstrApp.useBinaryFormat || !ifc) {
                    callback();
                    return;
                }
                

                
                params = params || {
                    did: this.did,
                    n: this.n,
                    st: this.st,
                    t: this.t,
                    sub_id: this.sub_id
                    
                };

                
                
                
                var fnDisableMenu = function (menuInactive) {
                    var isActive = (menuInactive !== true);
                    me.rootCtrl.setActionToolbarStatus(isActive);
                    me.frame.setActionToolbarStatus(isActive);
                };

                
                var showMessage = true,                     
                    refreshMethod = 1, 
                    reExecuteCallback = {
                        success: function (newData) {
                            if (showMessage && option !== 2) {
                                mstrmojo.toast(mstrmojo.desc(8617, 'Your view has been updated with the latest version of the document.'), 3000);
                            }
                            
                    	    if ( refreshMethod === 1) {
                                me.setData(newData, true);
                    	    }
                            me.getPageByTree(true);
                            
                            me.generateActionToolbar();
                            
                            callback();
                            fnDisableMenu();
                        },

                        prompts: function () {
                            mstrmojo.alert(
                                mstrmojo.desc(8619, 'New prompts were added to the document.'),
                                function () {
                                    fnDisableMenu();
                                    me.reprompt();
                                }
                            );
                        },

                        
                        failure: function () {
                            fnDisableMenu();
                        },

                        
                        canceled: fnDisableMenu
                    };

                fnDisableMenu(true);

                
                
                if (option === 1 && res.ci.cid === "00000000000000000000000000000000") {
                    showMessage = false;
                }

                dataService.checkCache($HASH.copy(res.ci || {}), {
                    success: function (cache) {
                    	
                        if (cache.needUpdate ) {
                        	if ( cache.refresh && option === 2) { 
                        		refreshMethod = 2;
                        		refreshRS.call(me, reExecuteCallback);
                        	} else {
                                reExecuteRS.call(me, params, reExecuteCallback, {}, mstrApp.isTablet() );
                        	}
                        } else {
                            callback();
                            fnDisableMenu();
                        }
                    },

                    failure: function () {
                        
                        
                        if (!mstrApp.onMobileDevice()) {
                        	if ( option === 2) { 
                        		refreshMethod = 2;
                        		refreshRS.call(me, reExecuteCallback);
                        	} else {
                                reExecuteRS.call(me, params, reExecuteCallback, {}, mstrApp.isTablet() );
                        	}
                        } else {
                            fnDisableMenu();
                        }
                    },

                    
                    canceled: fnDisableMenu
                }, config);
            },

            goBack: function goBack() {
                
                var rtn = this._super();
                if (!rtn) {
                    
                    restoreProjectId.call(this);
                }

                return rtn;
            },

            makeCurrent: function makeCurrent(isBack) {
                
                var frame = this.frame;
                if (frame) {
                    
                    this._super(isBack);

                    
                    this.rootCtrl.updateContent(frame, this._startParams.n, isBack);

                    
                    updateLastOpenedList.call(this);

                } else {
                    
                    this.doNotRefresh = true;
                    this.prevController.makeCurrent(isBack);
                }
            },

            onExecuteNewObject: function onExecuteNewObject(params) {
                
                var subtype = (params.objType === OBJECT_TYPE_REPORT) ? 768 : 14081;

                
                this.spawn(mstrApp.controllerFactory.newController(this.getViewKey(subtype), {
                    st : subtype
                }), params);
            },

            onDrill: function onDrill(params) {
                
                this.spawn(mstrApp.controllerFactory.newController(this.getViewKey(TYPE_REPORT)), $HASH.copy(params, {
                    action: (this.ctrlType === TYPE_REPORT) ? 'drillGrid' : 'drill2Grid',
                    st: TYPE_REPORT
                }));
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    var folderController = this.getController('ctrlType', 2048);
                    if (folderController) {
                        
                        folderController.makeCurrent(true);
                    } else {
                        
                        this.rootCtrl.goHome();
                    }
                }

                
                return true;
            },

            
            updateActionToolbar: function updateActionToolbar(tbCfg) {
            	if (mstrApp.getConfiguration().isMenuAllowed(MNU_SHARE, MNU_SHARE)) {
            		
            		if (mstrMobileApp['getSDKVersion']() >= 11) {
            			tbCfg.addToolbarBtn(MNU_ANNOTATION, mstrmojo.desc(11191, 'Annotation'), MNU_ANNOTATION, false, 24);
                	}
            		
                    
                	tbCfg.addToolbarBtn(MNU_SHARE, mstrmojo.desc(9099, 'Share'), MNU_SHARE, false, 22);
                }

                
                tbCfg.addMenuItem(MNU_ABOUT, mstrmojo.desc(1142, 'About'), MNU_ABOUT, false, 23);

                
                tbCfg = this._super(tbCfg);

                
                if (this.frame && this.frame.delegateToolbar(tbCfg)) {
                    
                    tbCfg = mstrmojo.android.ui.ActionToolbar.newToolbarConfig();
                }

                
                return tbCfg;
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                switch (group) {
                case MNU_ABOUT:
                    this.rootCtrl.updateItemProperties('', {
                        ttl: this.ttl,
                        st: this.st,
                        
                        did: this.did || this.getDepth(),
                        pid: this.pid,
                        desc: this.desc,
                        propsPopup: true
                    }, this.id, false);
                    return;

                case MNU_SHARE:
                    this.share('', false);

                    return;

                case MNU_FULLSCREEN:
                    
                    this[((cmdId === 11) ? 'enter' : 'exit') + 'FullScreen']();
                    return;

                case MNU_ANNOTATION:
                	this.startAnnotate();
                	return;
                }

                return this._super(group, cmdId);
            },

            beforeViewHidden: function beforeViewHidden(isBack) {
                this._super(isBack);

                
                var view = this.view;
                if (view && view.beforeViewHidden) {
                    
                    view.beforeViewHidden(isBack);
                }

                
                if (this.isFullScreen) {
                    
                    this.exitFullScreen(true, isBack);
                }

            },

            afterViewVisible: function afterViewVisible(isBackOperation) {

                this._super(isBackOperation);








                
                if (this.isFullScreen || !!this.model.fs || !!this.model.data.fs) {
                    
                    this.enterFullScreen();
                }
                
                else if (mstrMobileApp['getSDKVersion']() >= 16)
                {
                    window.setTimeout(function () {
                        mstrMobileApp.clearWebViewCache(false);
                    }, 100);
                }

                
                mstrMobileApp.hideProgress();

                
                if (!isBackOperation) {
                    
                    var id = this.id;
                    window.setTimeout(function () {
                        
                        var ctrl = mstrmojo.all[id];
                        if (ctrl && ctrl.rootCtrl.getCurrent() === ctrl) {
                            
                            ctrl.takeScreenShot();
                        }
                    }, 300);
                }
            },

            takeScreenShot: function takeScreenShot() {
                

                var view = this.view,
                    position = (view.getCaptureDimensions && view.getCaptureDimensions()) || $DOM.position(view.domNode),
                    windowDim = $DOM.windowDim(),
                    
                    id = this.did || this.getDepth(),
                    projId = mstrApp.getCurrentProjectId();

                
                $AFE(mstrmojo.android.ui.PropertiesView.getPreviewSizes(), function (preview) {
                    
                    mstrMobileApp.takeScreenShot(JSON.stringify({
                        pid: projId,
                        dssId: id,
                        x: position.x,
                        y: position.y,
                        w: Math.max(position.w, preview.w),
                        h: Math.max(position.h, preview.h),
                        pw: preview.w,
                        ph: preview.h,
                        ww: windowDim.w,
                        wh: windowDim.h
                    }));
                });
            },

            
            addFullScreenButton: function addFullScreenButton(tbCfg) {
                
                var lbl = mstrmojo.desc(8430, 'Enter Fullscreen'),
                    icon = 11;

                
                if (this.isFullScreen) {
                    
                    lbl = mstrmojo.desc(8429, 'Exit Fullscreen');
                    icon = 10;
                }

                
                tbCfg.addToolbarBtn(MNU_FULLSCREEN, lbl, icon, false, icon);
            },

            
            enterFullScreen: function enterFullScreen() {
                
                this.frame.enterFullScreen();

                
                this.rootCtrl.enterFullScreen();

                
                this.isFullScreen = true;

                
                this.generateActionToolbar();

                
                mstrmojo.touchManager.raiseEvent({
                    name: 'fullScreenStateChange'
                });
            },

            
            exitFullScreen: function exitFullScreen(noAnimation, isBack) {
                
                this.isFullScreen = false;

                
                this.frame.exitFullScreen(!noAnimation);

                
                this.rootCtrl.exitFullScreen(!noAnimation, isBack);

                
                this.generateActionToolbar();

                
                mstrmojo.touchManager.raiseEvent({
                    name: 'fullScreenStateChange'
                });
            },

            
            viewTap: function viewTap() {
                
                if (this.isFullScreen) {
                    
                    this.frame.flashFullScreen();

                    
                    this.rootCtrl.flashFullScreen();
                }
            },

            
            cancelFlashFullScreen: function cancelFlashFullScreen() {
                this.frame.cancelFlashFullScreen();

                this.rootCtrl.cancelFlashFullScreen();
            },

            
            getMagnifierConfig: function getMagnifierConfig() {
                var curtainPosition = this.frame.getPosition();
                return {curtainPosition: curtainPosition};
            },

            
            share: function share(subject, useDefault) {
            	var viewCaptureConfig = getViewCaptureConfig.call(this),
            		ttl = this.ttl;

            	window.setTimeout(function () {
            		mstrMobileApp.takeScreenShotAndSend(viewCaptureConfig, JSON.stringify({
            			attachmentName: mstrmojo.string.decodeHtmlString(ttl),
            			subject: subject,
            			useDefault: useDefault
                    }));
                }, 100);
            },

            
            getBottomToolBarHeight: function getBottomToolBarHeight() {

                return (!mstrApp.isTablet() && !this.isFullScreen && !mstrApp.isLandscape()) ?
                                (Math.round(BOTTOM_ACTION_TOOLBAR_HEIGHT_160_DPI * mstrMobileApp.getDeviceDPI() / 160)) :
                                0;
            },

            
            startAnnotate: function startAnnotate() {
            	if (!!this.ignoreAnnotationMenuItem) {
            		return;
            	}
            	
            	
            	this.ignoreAnnotationMenuItem = true;
            	
            	mstrMobileApp.showProgress([mstrmojo.desc(8445, 'Loading')], false );
            	
            	var viewCaptureConfig = getViewCaptureConfig.call(this),
            		me = this;
            	window.setTimeout(function () {
            		mstrMobileApp.startAnnotate(viewCaptureConfig, mstrmojo.string.decodeHtmlString(me.ttl),
            				'javascript:mstrmojo.all.' + me.id + '.onAnnotationFinished()');
            	}, 100);
            },
            
            
            onAnnotationFinished: function onAnnotationFinished() {
            	
            	this.ignoreAnnotationMenuItem = false;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ActionBar",
                         "mstrmojo.hash");    

    
    mstrmojo.android.medium.ui.ActionBar = mstrmojo.declare(
        mstrmojo.android.ui.ActionBar,

        null,

        
        {
            scriptClass: 'mstrmojo.android.medium.ui.ActionBar',

            setNavigation: function setNavigation(items, selectedIdx) {
                
                this.title.setListItems(items, selectedIdx);
            },

            restoreNavigation: function restoreNavigation() {
                
                var lastNav = this._lastNav;
                if (lastNav) {
                    
                    this.title.setListItems(lastNav.items, lastNav.idx);
                }
            },

            clearNavigation: function clearNavigation() {
                
                var lastNav = this.title.clearListItems();
                if (lastNav) {
                    this._lastNav = lastNav;
                }
            },

            getNavList: function getNavList() {
                return this.title.list;
            },
            
            onExitFullScreen: function onExitFullScreen(){            	
            	this.propogateMenuVisibleChange(true);
            },
            
            onEnterFullScreenEnd: function onEnterFullScreenEnd(){
            	this.propogateMenuVisibleChange(false);
            },
            
                         
            propogateMenuVisibleChange: function propogateMenuVisibleChange(isVisible) { 
            	this.toolbar.propogateMenuVisibleChange(isVisible);           
            }
        }
    );

    
    mstrmojo.android.ui.ActionBar.adjustLayoutConfig({
        160: 48,
        213: 64,
        240: 72,
        320: 96
    });
}());
(function(){

    mstrmojo.requiresCls(
            "mstrmojo.WidgetList",
            "mstrmojo.WidgetTreeBuilder", 
            "mstrmojo.TreeNodeSelector");
    
    var _loaded = false;
    
    
    mstrmojo.WidgetTree = mstrmojo.declare(
        
        mstrmojo.WidgetList,
        
        null,
        
        {   

                        
            scriptClass: "mstrmojo.WidgetTree",

            
            listBuilder: mstrmojo.WidgetTreeBuilder,
            
            
            listSelector: mstrmojo.TreeNodeSelector,
            
            
            renderOnScroll: true,

            
            itemIdField: "dssid",

            
            itemDisplayField: "n",

            
            itemIconField: "tp",
            
            
            itemChildrenField: "items",
            
            
            itemFunction: function ifn(item, idx, w){
                
                if (!_loaded) {
                    mstrmojo.requiresCls("mstrmojo.TreeNode");
                    _loaded = true;
                }
                var tree = w.tree || w,
                    iw = new mstrmojo.TreeNode({
                        data: item,
                        state: 0,
                        parent: w,
                        tree: tree,
                        multiSelect: w.multiSelect,
                        text: item[w.itemDisplayField],
                        textCssClass: tree.item2textCss(item),
                        items: item[w.itemChildrenField],
                        itemIdField: w.itemIdField,
                        itemDisplayField: w.itemDisplayField,
                        itemIconField: w.itemIconField,
                        itemChildrenField: w.itemChildrenField,
                        itemFunction: w.itemFunction,
                        listSelector: w.listSelector
                });
                return iw;
            },
            
            item2textCss: function item2textCss(item){
                return item[this.itemIconField];
            },
            
            
            selectionParentNode: null,
             
            
            init: function init(props) {
                this._super(props);
                this.selectionParentNode = this;
                this.tree = this;
            },
            
            clearTreeSelect: function clearTreeSelect(){ 
                (this.selectionParentNode || this).clearSelect();
            },
            
            
            prechange: function pchg(evt) {
                var ret = this._super(evt);
                
                this.onnodechange(evt);  
  
                return ret;
            },
            
            
            onnodechange: function ndchg(evt) {
                if (!evt) {
                    return;
                }
                var H = mstrmojo.hash,
                    nodeWas = this.selectionParentNode,
                    node = evt.src;
                if (node === nodeWas) {
                    
                    
                    
                    if (H.isEmpty(node.selectedIndices)){
                        node = this;
                        this.selectionParentNode = this;
                    }
                    this.raiseEvent({
                        name: "selectionChange",
                        parentNode: node,
                        parentNodeWas: nodeWas,
                        added: evt.added,
                        removed: evt.removed
                    });
                } else if (evt.added && evt.added.length) {
                    
                    var rmv = [];
                    if (!H.isEmpty(nodeWas.selectedIndices)) {
                        
                        rmv = mstrmojo.hash.keyarray(nodeWas.selectedIndices, true);
                        nodeWas.clearSelect();
                    }
                    this.selectionParentNode = node;
                    this.raiseEvent({
                        name: "selectionChange",
                        parentNode: node,
                        parentNodeWas: nodeWas,
                        added: evt.added,
                        removed: rmv
                    });
                } else {
                    
                    
                }
            }
        });
})();
(function(){
    
    mstrmojo.requiresCls(
            "mstrmojo.dom",
            "mstrmojo.css",
            "mstrmojo.hash",
            "mstrmojo.TreeNode"
    );
    
   var _D = mstrmojo.dom;

   
   mstrmojo.TreeBrowserNode = mstrmojo.declare(
       
       mstrmojo.TreeNode,
       
       null,
       {
          scriptClass: 'mstrmojo.TreeBrowserNode',
          
          markupString: '<li id="{@id}" class="mstrmojo-TreeNode {@cssClass}" style="{@cssText}" mstrAttach:mousedown,click,dblclick>'
              + '<div class="mstrmojo-TreeNode-div">'
                  + '<img class="mstrmojo-TreeNode-state" src="../images/1ptrans.gif" />'
                  + '<img class="mstrmojo-TreeNode-checkBox" src="../images/1ptrans.gif" />'
                  + '<span class="mstrmojo-TreeNode-text {@textCssClass}"></span>'
              + '</div>'
              + '<ul class="mstrmojo-TreeNode-itemsContainer">{@itemsHtml}</ul></li>',

           markupSlots: mstrmojo.hash.copy({
               checkBoxNode: function(){ return this.domNode.firstChild.childNodes[1];
               }
           }, mstrmojo.TreeNode.prototype.markupSlots),
               
           blockBegin: 1,
           
           allowUnlistedValues: false,
           
           
           
           contentRetrieved: false,  
           
           onstateChange: function onstateChange(){           
               if(!this.contentRetrieved && (this.state == 1)){
                   this.set('items', [this.tree.loadingItemCreaterFunc()]);
                   this.tree.getContent(this, this.blockBegin);
               }               
           },
           
           toggleState: function toggleState(){
               if (this.state !== 2) {
                   this.set("state", this.state === 1 ? 0 : 1);
               }
           },
           
           preclick: function preclick(evt){
               _D.clearBrowserHighlights(evt.hWin); 
               return false;
           },
           
           predblclick: function predblclick(evt){
               _D.clearBrowserHighlights(evt.hWin);
               return false;
           }, 
           
           premousedown: function pmd(evt) {
              var D = mstrmojo.dom,
                   t = mstrmojo.dom.eventTarget(evt.hWin, evt.e),
                   tree = this.tree,
                   isLeaf = (this.state == 2),
                   icn = D.contains(
                           this.itemsContainerNode,
                           D.eventTarget(evt.hWin, evt.e),
                           true,
                           this.domNode),
                   toggleOnClick = (tree.branchClickPolicy == mstrmojo.TreeBrowserEnum.BRANCH_POLICY_TOGGLE);
              
               
               if(this.isSpecialNode() || !(t == this.checkBoxNode || (t == this.textNode && (isLeaf || !toggleOnClick)))){
                   D.stopPropogation(evt.hWin, evt.e);
               }
               
               if ((t == this.stateNode) || (t == this.textNode && !isLeaf && toggleOnClick)) {
                   if(!isLeaf) {
                       this.toggleState();
                   }
               }  else if(t == this.checkBoxNode || icn){
                   if(this._super){
                       this._super(evt);
                   }
               } else {
                   this.handleNodeClicked();
               }
           },
           
           isSpecialNode: function isSpecialNode(){
               var st = this.data && this.data.st;
               return (st < 0);
           },
           
           handleNodeClicked: function handleNodeClicked() {
               var tree = this.tree,
                   w = this.parent,
                   data = this.data;
               switch(data && data.st){
                   case '-4'://previous items
                       mstrmojo.css.addClass(this.textNode, ['loading']);
                       tree.getContent(w, w.blockBegin - tree.blockCount);
                       break;
                       
                   case '-3'://next items
                       mstrmojo.css.addClass(this.textNode, ['loading']);
                       tree.getContent(w, w.blockBegin + tree.blockCount);
                       break;
                       
                   case '-1'://loading
                   case '-2'://failed
                       
                       break;   
                   default:
                       if(tree.handleNodeClicked){
                           tree.handleNodeClicked(data);
                       }
               }
           },
           
           init: function(props){
               this._super(props);
               this.set('state', this.tree.isBranch(this.data) ? 0 : 2); 
           },
           
           postBuildRendering: function postBuildRendering(){
               if(this._super){
                   this._super();
               }
               var _handler = function(e){
                   _D.preventDefault(window, e || window.event); 
                   return false;
               };
               
               
               _D.attachEvent(this.domNode, 'mousedown', _handler);
               
               
               if(this.isSpecialNode() || this.tree.noCheckBox){
                   this.checkBoxNode.style.display = 'none';
               }
           }
       });
   
})();
(function() {
    mstrmojo.requiresCls("mstrmojo.android.inputControls.CheckBoxDIC");
    
    mstrmojo.android.inputControls.MarkRowDIC = mstrmojo.declare(
            
            mstrmojo.android.inputControls.CheckBoxDIC,
            
            null,
            
            {
                scriptClass: 'mstrmojo.android.inputControls.MarkRowDIC',
                
                isSwitchStyle: false,

                oncheckedChange: function() {
                    if(this.markAll) {
                        var wm = this.group && this.group.widgetsMap, i;
                        for (i in wm){
                            if(wm.hasOwnProperty(i)) {
                                if  (wm[i].checked !== this.checked) {
                                    wm[i].set('checked', this.checked);
                                }
                            }
                        }
                    } else {
                        this._super();
                    }
                },
                
                postBuildRendering: function(){
                    this._super();
                    
                    
                    this.domNode.style.height = '30px';
                }
            }
    );
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.TableLayoutList",
                         "mstrmojo._IsTableLayoutListDIC",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.css");

    
    mstrmojo.android.inputControls.RadioListDIC = mstrmojo.declare(
        
        mstrmojo.TableLayoutList,
        
        [ mstrmojo._IsTableLayoutListDIC, mstrmojo._IsInputControl ],
        
        {
            scriptClass: 'mstrmojo.android.inputControls.RadioListDIC',

            styleCssClass: 'radio',

            init: function (props) {
                this._super(props);
                this.items = this.getItems();
                this.itemsPerRow = this.dic.ipr || 0;
            },

            ontouchend: function (evt) {
                this.onclick(evt);
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                mstrmojo.css.addClass(this.itemsNode || d, 'tx-active');
            }
        }
    );
}());
(function(){
    mstrmojo.requiresCls("mstrmojo._IsInputControl",
                         "mstrmojo.TableLayoutList",
                         "mstrmojo._IsTableLayoutListDIC",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $D = mstrmojo.dom,
        $C = mstrmojo.css,
        STYLES_LIST = {
            0: 'default',
            1: 'stars_dots'
        };

    mstrmojo.RatingDIC = mstrmojo.declare(
        
        mstrmojo.TableLayoutList,
        
        [mstrmojo._IsTableLayoutListDIC, mstrmojo._IsInputControl],
        
        {
            scriptClass: 'mstrmojo.RatingDIC',

            styleCssClass: 'rate',

            markupString: '<div id="{@id}" class="mstrmojo-ListBase {@cssClass}" style="{@cssText}" mstrAttach:click,mouseover,mouseout>' +
                              '<div class="{@icnCss}" style="{@icnCssText}">{@itemsHtml}</div>' +
                          '</div>',

            lastIdx: null,

            init: function (props) {
                this._super(props);
                this.items = this.getItems();
                this.starCount = this.items && this.items.length;
                $C.addWidgetCssClass(this, STYLES_LIST[this.dic.stl || 0]);
            },

            setRating: function (idx) {
                var i = 0,
                    starCount = this.starCount,
                    leCss = 'less_equal';
                if (this.lastIdx == undefined || this.lastIdx != idx){
                    for (; i < starCount; i++) {
                        if (i <= idx) {
                            $C.addClass(this._getItemNode(i), leCss);
                        } else {
                            $C.removeClass(this._getItemNode(i), leCss);
                        }
                    }
                    this.lastIdx = idx;
                }
            },

            onvalueChange: function() {
                this._super && this._super();
                var idx = mstrmojo.array.find(this.items, 'v', this.value);
                this.setRating(idx);
            },

            onmouseover: function(evt) {
                this._super && this._super(evt);
                var target = evt.target || $D.eventTarget(evt.hWin, evt.e),
                    idx = target && target.getAttribute('idx');
                if (idx != undefined) {
                    this.setRating(idx);
                }
            },

            onmouseout: function(evt) {
                this._super && this._super(evt);
                var idx = mstrmojo.array.find(this.items, 'v', this.value);
                this.setRating(idx);
            },

            postBuildRendering: function() {
                this._super();

                if (!mstrmojo.isDescendant(this.owner, this) && this.showByDefault) {
                    this.set('height', (this.openerStyle.ih || 0) + 'px');
                    this.set('width', (this.openerStyle.iw || 0) + 'px')
                }

                var idx = mstrmojo.array.find(this.items, 'v', this.value);
                if (idx > -1) {
                    this.setRating(idx);
                }
            }
        }
   )
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.TableLayoutList",
        "mstrmojo._IsTableLayoutListDIC",
        "mstrmojo._IsInputControl");

    function getTitleItems(items) {
        var arr = [];
        mstrmojo.array.forEach(items, function (v) {
            arr.push(v.n);
        });
        return arr;
    }

    mstrmojo.LikertScaleDIC = mstrmojo.declare(
        
        mstrmojo.TableLayoutList,

        
        [mstrmojo._IsTableLayoutListDIC, mstrmojo._IsInputControl],

        
        {
            scriptClass: 'mstrmojo.LikertScaleDIC',

            styleCssClass: 'scale',

            init: function (props) {
                this._super(props);
                this.items = this.getItems();
                this.titleItems = getTitleItems(this.items);
            },

            getDisplayValue: function getDisplayValue() {
                return (this.selectedIndex >= 0) ? this.items[this.selectedIndex].n : this.dv;
            },

            getLeftEndTitle: function getLeftEndTitle(idx) {
                return idx >= 0  ? (this.dic.mint || '') : '';
            },

            getRightEndTitle: function (idx) {
                return idx >= 0 ? (this.dic.maxt || '') : '';
            },

            postBuildRendering: function() {
                this._super();
                if (!mstrmojo.isDescendant(this.owner, this) && this.showByDefault) {
                    this.set('height', (this.openerStyle.ih || 0) + 'px');
                    this.set('width', (this.openerStyle.iw || 0) + 'px')
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.Popup",
                         "mstrmojo.array",
                         "mstrmojo.android.TextArea",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(1442);

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash;

    
    var $DIALOG = mstrmojo.android.Dialog = mstrmojo.declare(

        mstrmojo.android.Popup,

        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.Dialog",

            autoClose: false,

            
            btnVisible: true,

            init: function init(props) {
                this._super(props);

                var css = [ 'dialog' ];

                if (this.title) {
                    css.push('has-ttl');
                }

                
                if (props.anchor) {
                    
                    this.curtainPosition = mstrApp.getContentPosition();
                }

                $CSS.addWidgetCssClass(this, css);
            },

            
            preBuildRendering: function preBuildRendering() {
                
                var buttons = this.buttons;
                if (buttons && !this.btnHbox) {

                    
                    var ths = this,
                        id = this.id,
                        fn = function () {
                            
                            if (!ths.manualClose) {
                                
                                window.setTimeout(function () { 
                                    var dialog = mstrmojo.all[id];
                                    if (dialog) {
                                        dialog.close();
                                    }
                                }, 50);
                            }
                        };

                    
                    $ARR.forEach(buttons, function (btn) {
                        
                        btn.origFn = btn.onclick;

                        
                        btn.onclick = function (event) {
                            
                            if (this.origFn) {
                                
                                if (this.origFn() === false) {
                                    
                                    return;
                                }
                            }

                            
                            fn();

                            
                            event.e.stopPropagation();
                            event.e.cancelBubble = true;
                        };
                    });
                }

                this._super();
            },

            postBuildRendering: function postBuildRendering() {
                
                if (this.onTitleClick) {
                    
                    var id = this.id;
                    $DOM.attachEvent(this.titleNode, 'click', function (evt) {
                        mstrmojo.all[id].onTitleClick(evt);
                    });
                }

                return this._super();
            },

            
            getResizeHandler: function getResizeHandler() {
                var id = this.id,
                    fn = function () {
                        var dialog = mstrmojo.all[id];
                        if (dialog.dialogRefresh) {
                            dialog.dialogRefresh();
                        } else {
                            dialog.resizeDialog();
                            dialog.positionDialog();
                        }
                    };

                return fn;
            },

            resizeDialog: function resizeDialog() {
                this._super();

                
                var buttonCnt = this.buttons && this.buttons.length;
                if (buttonCnt) {
                    
                    var buttonNode = this.buttonNode,
                        btnVisible = this.btnVisible;

                    
                    if (!btnVisible) {
                        
                        this.set('btnVisible', true);
                    }

                    
                    var btns = this.btnHbox.children,
                        $CS = $CSS.getComputedStyle,
                        slotStyle = $CS(buttonNode),
                        btnStyle = $CS(btns[0].domNode);

                    
                    var availWidth = buttonNode.clientWidth - parseInt(slotStyle.paddingLeft, 10) - parseInt(slotStyle.paddingRight, 10),
                        btnOffset = parseInt(btnStyle.paddingLeft, 10) + parseInt(btnStyle.paddingRight, 10) + parseInt(btnStyle.borderLeftWidth, 10) + parseInt(btnStyle.borderRightWidth, 10),
                        btnSpace = availWidth - (buttonCnt * btnOffset);

                    
                    var buttonWidth = Math.floor(btnSpace / buttonCnt);

                    
                    $ARR.forEach(btns, function (btn) {
                        
                        btn.set('width', buttonWidth + 'px');
                    });

                    
                    this.set('btnVisible', btnVisible);
                }
            },

            
            resizeCurtain: function resizeCurtain() {
                var curtainNode = this.curtainNode,
                    body = document.body,
                    cs = curtainNode.style,
                    curtainPosition = this.curtainPosition;

                
                cs.width = body.scrollWidth + 'px';
                
                if (curtainPosition && curtainPosition.h) {
                	cs.height = curtainPosition.h + 'px';
                } else {
                	
                	
                	cs.height = body.scrollHeight + 'px';
                }
                
                if (curtainPosition && curtainPosition.y) {
                	cs.top = curtainPosition.y + 'px';
                }
                
                this.raiseEvent({name: 'resizeCurtain'});
            },
            
            setButtonVisibility: function setButtonVisibility(isVisible) {
                this.buttonNode.style.display = isVisible ? 'block' : 'none';
            },

            createTitleBarButton: function createTitleBarButton(className, fn, title) {
                var bl = document.createElement('div');
                bl.className = className;
                bl.setAttribute('title', title || '');
                
                bl[(mstrApp.isTouchApp()) ? 'ontouchend' : 'onclick'] = fn;

                this.titleNode.appendChild(bl);
            }
        }
    );

    
    var markupMethods = $HASH.copy($DIALOG.prototype.markupMethods);
    markupMethods.onbtnVisibleChange = function () {
        this.buttonNode.style.display = (this.btnVisible) ? 'block' : 'none';
    };
    $DIALOG.prototype.markupMethods = markupMethods;

    
    if (window.mstrConfig && !window.mstrConfig.simpleDialog) {

        var fnGetLabelChild = function (msg) {
            return [{
                scriptClass: 'mstrmojo.android.TextArea',
                text: msg,
                cssClass : 'mstrmojo-androidAlert',
                isElastic: true
            }];
        };

        
        mstrmojo.alert = function alrt(msg, fn, title) {
            mstrApp.showDialog({

                title: title || "MicroStrategy Mobile",
                buttons: [ mstrmojo.android.ui.Button.newButton(mstrmojo.desc(1442, 'OK'), function () {
                    if (fn) {
                        fn();
                    }
                })],
                children: fnGetLabelChild(msg)
            });

        };

        
        mstrmojo.confirm = function confirm(msg, buttons, title) {
            
            mstrApp.showDialog({
                title: title || 'MicroStrategy Mobile',
                buttons: buttons,
                children: fnGetLabelChild(msg)
            });
        };

        
        mstrmojo.toast = function toast(msg, duration) {
            mstrApp.showToastNotification(msg, duration || 3500);
        };

        
        mstrmojo.mask = {
            show: function show(msg) {
                mstrMobileApp.showProgress([ msg || ''], false );
            },

            hide: function hide() {
                mstrMobileApp.hideProgress();
            }
        };
    }
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.string",
                         "mstrmojo._HasPopup",
                         "mstrmojo.ListBase",
                         "mstrmojo.Editor",
                         "mstrmojo.SuggestionList");

    
    function stepSelect(isForward) {
        var list = this.list,
            idx = list.selectedIndex,
            len = list.items.length,
            clearTarget = (isForward) ? len - 1 : 0;

        if (idx === clearTarget) {
            list.clearSelect();
            return;
        }

        if (idx === null || idx < 0) {
            idx = (isForward) ? 0 : len - 1;
        } else {
            idx += (isForward) ? 1 : -1;
        }

        list.singleSelect(idx);
    }

    
    mstrmojo._HasSuggestion = mstrmojo.provide(
        "mstrmojo._HasSuggestion",

        mstrmojo.hash.copy(mstrmojo._HasPopup, {
            blockBegin: 1,

            blockCount: -1,

            
            suggestCount: 15,

            autoSelect: true,

            
            itemField: 'n',

            
            candidates: null,

            
            suggestionShown: false,

            
            suggestionItems: null,

            
            _last_hit: null,

            
            _request_pattern: null,

            
            browseItemVisible: false,

            
            folderLinksContextId: 25,

            
            browsableTypes: '1,8',


            
            REQUEST_THRESHOLD: 20,

            noCache: false,

            
            getCandidatesThroughTaskCall: mstrmojo.emptyFn,

            
            onSuggestionItemSelect: function onSuggestionItemSelect(item) {
                this.hideSuggestion();
            },

            
            getSearchPattern: function getSearchPattern() {
                return '';
            },

            
            getSuggestionPos: function getSuggestionPos() {
                return {
                    left: '100px',
                    top: '100px'
                };
            },

            
            getSuggestionTarget: function getSuggestionTarget() {
                return this;
            },

            
            
            showSuggestion: function showSuggestion(pattern) {
                var its = this.getSuggestion(pattern);

                
                if (!this.noCache && its !== -1) {
                    this.updateSuggestion(its);
                }
            },

            
            hideSuggestion: function hideSuggestion() {
                this.suggestionShown = false;
                if (this.suggestionPopup.visible) {
                    this.suggestionPopup.close();
                }
            },

            
            getSelected: function getSelected() {
                return (this.suggestionShown) ? this._lastOpened.getSelected() : null;
            },

            
            nextHighlight: function nextHighlight() {
                if (this.suggestionShown) {
                    this._lastOpened.nextHighlight();
                }
            },

            
            preHighlight: function preHighlight() {
                if (this.suggestionShown) {
                    this._lastOpened.preHighlight();
                }
            },


            
            getSuggestion: function getSuggestion(t) {
                var c = this.candidates,
                    its = c && c.items,
                    ic = c && c.isComplete,
                    lh = this._last_hit;

                if (!this.noCache && (c || lh)) {
                    var fcs = this.filterCandidates(its, t, this.REQUEST_THRESHOLD),
                        len = fcs.length,
                        sc = this.suggestCount,
                        hit = false;

                    
                    if (!ic && len < sc) {
                        var p = lh && lh.pattern;
                        if (lh && p && (t.indexOf(p) > -1)) {
                            hit = true;
                            var lhc = this.filterCandidates(lh.items, t, this.REQUEST_THRESHOLD),
                                llen = lhc && lhc.length,
                                A = mstrmojo.array,
                                ifd = this.itemField,
                                i;

                            for (i = 0; i < llen; i++) {
                                if (A.find(fcs, ifd, lhc[i][ifd]) === -1) {
                                    fcs.push(lhc[i]);
                                }
                            }

                            len = fcs.length;
                        }
                    }


                    
                    
                    if (!ic && ((t.length > 2 && len < this.REQUEST_THRESHOLD) || (len < sc))) {
                        this.requestCandidates(t);
                        
                        return -1;
                    }

                    return (len < sc) ? fcs : fcs.slice(0, sc);
                }



                
                this.requestCandidates(t);
                return -1;  
            },

            requestCandidates: function requestCandidates(t) {
                this._request_pattern = t;

                var me = this,
                    targetWas = this.getSuggestionTarget(),
                    callbacks = {
                        success: function (res) {
                            if (!res) {
                                return;
                            }

                            var target = me.getSuggestionTarget();
                            if (!target || (targetWas !== target)) { 
                                return;
                            }

                            var newPattern = target.getSearchPattern(),
                                its = res.items;

                            me._last_hit = {
                                items: its,
                                pattern: t
                            };
                            me.sz = res.sz;

                            
                            
                            if (!me.noCache && its) {
                                var c = me.candidates && me.candidates.items|| [],
                                    _its = [].concat(its); 
                                for (var i = 0, len = its.length; i < len; i ++) {
                                    var it = _its[i];

                                    if (mstrmojo.array.indexOf(c, it) > -1) {
                                        mstrmojo.array.removeItem(its, it);
                                    }
                                }
                                
                                if (me.candidates) {
                                    me.candidates.items = c.concat(its);
                                }
                            }

                            if (newPattern && newPattern.indexOf(t) > -1) {
                                var fcs = me.filterCandidates(its, newPattern);
                                me.updateSuggestion(fcs);
                            }
                        },

                        failure: function (res) {
                            mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                        }
                    };

                this.getCandidatesThroughTaskCall({
                    pattern: t,
                    blockBegin: this.blockBegin,
                    blockCount: this.blockCount,
                    isSuggest: true
                }, callbacks);
            },


            filterCandidates: function filterCandidates(its, t, max) {
                max = max || this.suggestCount;
                t = mstrmojo.string.regEscape(t);

                var itf = this.itemField,
                    fcs = mstrmojo.array.filter(its, function (it) {
                        return (new RegExp('\\s' + t + '|^' + t, 'i')).test(it[itf]);
                    }, {
                        max: max
                    });

                return fcs;
            },
            
            getHighlightedText: function getHighlightedText(pattern, n) {
                if (!this.highlightPattern || mstrmojo.string.isEmpty(pattern)) {
                    return n;
                }

                try {
                    if (!this.nameWildcards || mstr.$A.find([2, 32], parseInt(this.nameWildcards, 10)) > -1) { 
                        n = n.replace(new RegExp('(^|\\s)('+ pattern + ')', 'gi'), '$1<b>' + '$2' + '</b>');
                    } else {
                        var words = pattern.split(' '),
                            i,
                            len;

                        for (i = 0, len = words.length; i < len; i++) {
                            if (words[i] !== '') { 
                                n = n.replace(new RegExp('(' + words[i] + ')', 'gi'), '<b>' + '$1' + '</b>');
                            }
                        }
                    }
                } catch (e) {} 

                return n;
            },

            updateSuggestion: function updateSuggestion(items) {
                var len = items && items.length,
                    canBrowseItems = this.browseItemVisible;

                if (len || canBrowseItems) {
                    if (canBrowseItems) {
                        items = items || [];
                        items.push({
                            n: 'Browse...',
                            t: -99,
                            cssClass: ((len) ? 'br' : 'bro')
                        });
                    }

                    
                    this.set('suggestionItems', items);

                    
                    if (this.suggestionShown) {
                        
                        var popup = this._lastOpened;
                        if (popup && popup.nudge) {
                            popup.nudge();
                        }

                    } else {
                        this.openPopup('suggestionPopup', this.getSuggestionPos());
                        this.suggestionShown = true;
                    }

                } else {
                    this.hideSuggestion();

                }
            },

            ob: {
                scriptClass: "mstrmojo.Editor",
                title: mstrmojo.desc(5298, "Select an Object"),
                help: "Select_Objects_dialog_box_.htm",
                onClose: function () {
                    var o = this.opener;
                    if (o && o.onBrowserClose) {
                        o.onBrowserClose();
                    }
                },
                onOpen: function () {
                    var o = this.opener;
                    if (o && o.onBrowserOpen) {
                        o.onBrowserOpen();
                    }
                },
                children: [{
                    scriptClass : "mstrmojo.ObjectBrowser",
                    alias: "browser",
                    cssText: "width:200px;",
                    fishEyeVisible: false,
                    closeable: false,
                    closeOnSelect: false
                }]
            },

            onBrowserClose: function onBrowserClose() {
                this.browserShown = false;
            },

            handleSuggestionItemSelect: function handleSuggestionItemSelect(it) {
                
                if (this.browseItemVisible && it.t === -99) {
                    
                    this.hideSuggestion();

                    
                    mstrmojo.requiresCls("mstrmojo.ObjectBrowser");

                    
                    var zIndex = this.zIndex;
                    this.openPopup('ob', {
                        zIndex: (zIndex && (zIndex + 10)) || 110
                    });

                    
                    this.ob.browser.browse({
                        folderLinksContextId : this.folderLinksContextId,
                        onSelectCB: [this, 'onSuggestionItemSelect'],
                        browsableTypes: this.browsableTypes
                    });

                    this.browserShown = true;

                } else {
                    this.onSuggestionItemSelect(it);
                }
            },

            
            highlightPattern: true,

            suggestionPopup: {
                scriptClass: 'mstrmojo.Editor',
                cssClass: 'mstrmojo-ObjectInputBox-suggest',
                showTitle: false,
                modal: false,
                autoClose: true,
                nextHighlight: function () {
                    stepSelect.call(this, true);
                },

                preHighlight: function () {
                    stepSelect.call(this, false);
                },

                getSelected: function getSelected() {
                    var list = this.list;
                    return list.items[list.selectedIndex];
                },

                onOpen: function onOpen() {
                    var o = this.opener;
                    if (o && o.autoSelect) {
                        this.list.singleSelect(0);
                    }
                },

                onClose: function onClose() {
                    this.list.clearSelect();
                    if (this.opener) {
                        this.opener.suggestionShown = false;
                    }
                }
            },

            
            suggestionListClass: 'mstrmojo.SuggestionList',

            postApplyProperties: function postApplyProperties() {
                this.suggestionPopup.children = [{
                    scriptClass: this.suggestionListClass,
                    alias: 'list',
                    cssClass: 'mstrmojo-suggest-list'
                }];
            }
        })
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.Magnifier",
    					 "mstrmojo.hash");
    
    var SELECTED_CELL_CSS = 'xtab-selected-cell';

    
    mstrmojo._HasMagnifier = {
            
        scriptClass: 'mstrmojo._HasMagnifier',
        
        magnifiedNode: null,
        
        magnifier: null,

        
        magnifierHelper: null,
        
        onmagnifiedNodeChange: function(evt){
            var oldNd = evt.valueWas,
                newNd = evt.value;
            
            if (oldNd){
                mstrmojo.css.removeClass(oldNd, SELECTED_CELL_CSS);
            }
            if (newNd){
                mstrmojo.css.addClass(newNd, SELECTED_CELL_CSS);
            }
        },
        
        displayMagnifier: function dspMgnf(touch, config) {
            var helper = this.magnifierHelper,
                touchObj = helper.resolveTouchEvent(touch), 
                info, anchor, anchorPos;
            
            
            if (touchObj){
                anchor = touchObj.cell;
                anchorPos = touchObj.pos;
                
                
                if (anchor != this.magnifiedNode){
                    
                    info = helper.resolveInfoToDisplay(touchObj);
                
                    
                    if (info){
                        this.set('magnifiedNode', anchor);
                        
                        
                        if (!this.magnifier){
                            var me = this;
                            this.magnifier = mstrApp.showPopup(
                            	mstrmojo.hash.copy({
	                                scriptClass: 'mstrmojo.Magnifier',
	                                onClose: function(){
	                                    me.magnifier = null;
	                                    me.set('magnifiedNode', null);
	                                },
	                                helper: helper
                            	}, config), anchor
                            );
                        }
                        
                        
                        this.magnifier.updateContent();
                        this.magnifier.resizeAndPosition(anchorPos);
                    }else {
                        
                        if (this.magnifier){
                            this.magnifier.close();
                        }
                    }
                }else {
                    
                    if (this.magnifier){
                        this.magnifier.moveTo(anchorPos);
                    }
                }
            }
        }
    };
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.DocXtabGraph",
                         "mstrmojo.TouchScroller",
                         "mstrmojo.graph._MobileGraphAreaHelper",
                         "mstrmojo._TouchGestures");

    var $DOM = mstrmojo.dom;

    
    function updateTooltip(graph, x, y) {
        var dpos = mstrmojo.dom.position(graph.domNode, false),
            left = 0,
            top = 0,
            node = graph.node;

        if (dpos) {
            left = dpos.x;
            top = dpos.y;
        }

        graph.model.getDataService().handleUserSingleTap(node.data.sid, node.k, x - left, y - top, false, {
            success: function (res) {
                graph.displayTooltips(res.Areas, left, top);
            }
        });

    }

    

    
    function getGbKey(model) {
        var gbkey = '',
            gba = [],
            currKey,
            layouts,
            currlayout,
            l,
            index,
            gb;

        if (!model) {
            return gbkey;
        }

        currKey = model.currlaykey;
        gbkey = currKey + '_';
        layouts = model.data && model.data.layouts;
        for (index = 0; index < (layouts.length || 0); index++) {
            l = layouts[index];
            if (l.k === currKey) {
                currlayout = l;
                break;
            }
        }

        if (currlayout) {
            if (currlayout.gbys) {
                gba = currlayout.gbys.groupbys;
                for (index = 0; index < (gba.length || 0); index++) {
                    gb = gba[index];
                    gbkey = gbkey + gb.k + ':' + gb.lvl;
                    if (gb.unit) {
                        gbkey = gbkey + ':' + gb.unit.idx;
                    }
                    gbkey = gbkey + '_';
                }
            }
        }
        return gbkey;
    }

    function applySelectionChange(touch) {
        
        this.displayTooltips([], 0, 0);

        var me = this,
            dataService = this.model.getDataService(),
            pos = mstrmojo.dom.position(this.domNode, true),
            x = touch.pageX - pos.x,
            y = touch.pageY - pos.y,
            anchor = {                                            
                    getBoundingClientRect: function () {
                     var left = touch.pageX,
                         top = touch.pageY;

                     return {
                         left: left,
                         top: top,
                         right: left + 1,
                         bottom: top + 1
                     };
                    }
                 },
            callback = {
                success: function (res) {
                    var areas = res.Areas,
                        defn = me.defn,
                        k = me.k,
                        tks = res.tks;
                    
                    if (areas && areas.length > 0) {
                        if (areas[0].Selectable === 1) {
                            
                            me.highlightArea(me.selectionNode, areas);

                        } else if(areas[0].Selectable === -1) { 
                            
                            me.highlightedAreas = [];
                            
                            
                            me.clearHighlightArea(me.selectionNode);
                        }
                        
                        if(tks) {
                        	me.showInfoWin(tks, anchor);
                        }
                    } else {
                        
                        me.highlightedAreas = [];
                        
                        
                        me.clearHighlightArea(me.selectionNode);
                    }
                    
                    window.setTimeout(function () { 
                        mstrMobileApp.forceRepaint();

                        
                        me.model.slice({
                        	type: parseInt(defn.t, 10) || mstrmojo.EnumRWUnitType.GRAPH,
                        	src: k,
                        	ck: defn.ck,
                        	gk: k,
                        	sid: me.node.data.sid,
                        	x: x, 
                        	y: y,  
                        	tks:tks,
                        	anchor: anchor
                        });
                    
                    }, 0);
                }
            };

        dataService.handleUserSingleTap(me.node.data.sid, me.k, x, y, true, callback);

    }

    
    function setImageNodeSrc(src) {
        var imgNode = this.imgNode;

        
        if (imgNode.src !== src) {
            
            imgNode.src = src;

            
            $DOM.translate(imgNode, 0, 0, 0);
        }
    }

    
    mstrmojo.MobileDocXtabGraph = mstrmojo.declare(
        mstrmojo.DocXtabGraph,

        [ mstrmojo._TouchGestures, mstrmojo.graph._MobileGraphAreaHelper ],

        
        {
            scriptClass: "mstrmojo.MobileDocXtabGraph",

            
            areaMarkup: '<area shape="{@shape}" coords="{@coords}" ttl="{@tooltip}" aid="{@aid}" {@extra}/>',

            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                var  id = this.id,
                    model = this.model;
                

                
                if (parseInt(h, 10) > 0 && parseInt(w, 10) > 0) {
                    model.getDataService().getRWGraphImage({
                        w: w,
                        h: h,
                        k: this.k,
                        sid: this.node.data.sid,
                        gbk: getGbKey(model)
                    }, model.newCallback({
                        success: function (res) {
                            
                            setImageNodeSrc.call(mstrmojo.all[id], res);
                        }
                    }));
                }
            },

            invalidate: function invalidate() {
                
                setImageNodeSrc.call(this, '');
            },

            
            showTooltip: function showTooltip() {
                
                
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                
                this.restoreDefaultTouches(false);

                
                updateTooltip(this, touch.pageX, touch.pageY);
            },

            touchSelectMove: function touchSelectMove(touch) {
                
                this.restoreDefaultTouches(false);

                
                updateTooltip(this, touch.pageX, touch.pageY);
            },

            touchTap: function touchTap(touch) {
                
                this.restoreDefaultTouches(false);

                applySelectionChange.call(this, touch);
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.MobileGraph", 
                         "mstrmojo.graph._CanvasGraph");
    
    
    mstrmojo.graph.MobileXtabCanvasGraph = mstrmojo.declare(
        mstrmojo.MobileGraph,
        
        [ mstrmojo.graph._CanvasGraph ],
        
        
        {
            scriptClass: "mstrmojo.graph.MobileXtabCanvasGraph"
        }
    );
    
}());



        
(function() {

	var prevWidth,
		prevHeight;

	mstrmojo.requiresCls("mstrmojo.Container", "mstrmojo.DocPortlet");

	var FMTS = {'top':'top',
	            'left':'left',
	            'z-index':'zIndex',
	            'width':'width',
	            'height':'height'};

    
    mstrmojo.Vis = mstrmojo.declare(

        
        mstrmojo.Container,

        
        [mstrmojo._HasLayout],

        
        {
            
            scriptClass: 'mstrmojo.Vis',

            offsetTop:0,

            offsetLeft:0,

            isAndroid: window.navigator.userAgent.indexOf('Android') != -1,

            updated: false,

            reRenderOnDimensionChg: true,

            getFormats: function() {
                
                return this.fmts;
            },

            isVis: function() {
            	return true;
            },

            setModel: function setModel(model) {

            	this.set('model', model);

            	
                if (model.data) {
                    this.set('model', model.data);
                }
            	this.xtabModel = model;

                    
            	if (typeof (this.controller.getPageByTree) != 'undefined') {

                    this.controller.getPageByTree(false);
                }
            },

            destroy: function destroy() {
            	this._super();

            	var xtab = this.xtabModel;
            	if (xtab && xtab.destroy) {
            		xtab.destroy();
            		
            		delete this.xtabModel;
            	}

            },

            setDimensions: function setDimensions(h, w) {
            	var dimensionChanged = this._super(h, w);
            	if (dimensionChanged && this.hasRendered && this.reRenderOnDimensionChg ) {
            		this.reRender();
            	}
            	return dimensionChanged;
            },

            reRender: function reRender() {
            	this.unrender();
            	this.render();
            },

            getWidth: function getWidth() {
            	return parseInt(this.width, 10); 
            },

            getHeight: function getHeight() {
            	return parseInt(this.height, 10); 
            },























            buildRendering: function bldRn() {

            	if (!this.updated) {
            		this.update();
            	}

                
                if (this.parent instanceof mstrmojo.DocPortlet) { 
                    delete this.left;
                    delete this.top;
                    this.height = this.fmts && this.fmts.height;
                }

            	
            	this._super();
            },

            postBuildRendering: function postBR(){
            	prevWidth = this.width;
            	prevHeight = this.height;

            	this.adjustWidgetOffsets();

            	
            	this._super();
            },

            adjustWidgetOffsets: function adjustWidgetOffsets() {
            	var dn = this.domNode,
            	offset = {
            			top: 0,
            			left: 0
            	};

            	if (typeof(mstr) != 'undefined') {
            		offset.top = mstr.utils.BoxModel.getElementSumOffsetTop(dn);
            		offset.left = mstr.utils.BoxModel.getElementSumOffsetLeft(dn);
            	} else if (typeof(mstrmojo) != 'undefined') {
            		offset = mstrmojo.boxmodel.offset(dn);
            	}

            	this.offsetTop = offset.top;
            	this.offsetLeft = offset.left;
            },

        	
			initFromVisProps: function initFromVisProps(vp) {},

            update: function update(node) {
                node = node || this.node;
                if (node) { 
                	if (node.data) {
                	    this.set('model', node.data);
						
						
						if(this.xtabModel && this.xtabModel.set){
							this.xtabModel.set('data',node.data);
						}
                		this.model = node.data;
                		if (this.model.layoutModel) this.layoutModel = this.model.layoutModel;
                		if (this.model.layoutNode) this.layoutNode = this.model.layoutNode;

                        
                        mstrmojo.hash.copy(node.data.extProps, this);
                	}

            	 	this.fmts = node.defn.fmts || node.defn.units[this.model.k].fmts;

                    var fmts = this.fmts;
                    if(fmts){
                        for(var k in FMTS){
                            v = FMTS[k];
                            if(k in fmts){
                                this[v] = fmts[k];
                            }
                        }
                    }
                }

                if (this.model) {
                    this.initFromVisProps(this.model.vp);
                }
                this.updated = true;
            },

            getModel: function getModel(k) {
            	if (k) {
            		var m = mstrmojo.Vis.getVisGrid(this.layoutModel, this.layoutNode, k);
            		if (m) {
            			return m.data;
            		} else {
            			alert(mstrmojo.desc(8427,"Incorrect visualization properties encountered.  Data may be inconsistent.  Please reset your properties."));
            		}
            	} else {
            		return this.model;
            	}
            },

            getDataParser: function getDataParser(key) {
            	return new mstrmojo.Vis.DataParser(this.getModel(key));
            },

            
            renderErrorMessage: function renderErrorMessage(msg) {
            	this.domNode.innerHTML = "<div class=\"mstrmojo-message\">" + msg + "</div>";
            },

            getMessageID: function getMessageID() {
                return this.model.mid && this.model.mid || this.xtabModel && this.xtabModel.docModel && this.xtabModel.docModel.mid;
            },

            
            hasNoninfowindowTarget: function hasNoninfowindowTarget(actionObj) {
            	var xtabModel = this.xtabModel,
		    		docModel = (xtabModel && xtabModel.docModel);

            	var result = false;
				if (docModel) {
					var layouts = docModel.defn && docModel.defn.layouts,
						layout = null;
					var i;
					
					if (layouts) {
						for(i in layouts) {
							if (layouts[i].loaded) {
								layout = layouts[i];
								break;
							}
						}
					}

					var units = layout && layout.units;
					this.selectorTargets = {};
					if (units && actionObj.scObjList) {
						for(var i = 0; i < actionObj.scObjList.length; i++){
		        			var scObj = actionObj.scObjList[i];
		        			

		        			var tksList = scObj.sc.tks.split("\x1E");
		        			for(var j = 0; j < tksList.length; j++){
		        				var unit = units[tksList[j]];
		        				if (unit) {
		        					this.selectorTargets[tksList[j]] = unit;
		        					if (!this.isChildOfIfw(units, unit)) {
		        						result = true;
		        					}
		        				}
		        			}
		        		}
					}
				}

				return result;
            },

            isChildOfIfw: function isChildOfIfw(units, unit){
            	while(unit){
            		if(unit.ifw){
            			return true;
            		}
                	unit = units[unit.pnk];
            	}
            	return false;
            },

            performAction: function performAction(actionObj){
            	var action = this.xtabModel.getAction(actionObj),
            		handler = action && action.h;
            	if(handler && this.controller[handler]){
            		this.controller[handler](this, action.a);
            		return true;
            	}
            	return false;
			}
        }
    );

    
    mstrmojo.Vis.getVisGrid = function(m , n , k ) {
    	var origN = n;
    	var chldn = m.getChildren(n, false);
    	for (var i=0; i < chldn.length; i++) {
    		var c = chldn[i];
    		if (c.k == k) {
    			return c;
    		} else {
    			var g = mstrmojo.Vis.getVisGrid(m, c, k);
    			if (g) {
    				n = origN; 
    				return g;
    			}
    		}
    	}
    };

    mstrmojo.Vis.DataParser = function (m ) {
    	var ns = mstrmojo.Vis;

            	return {
            		getRowTitles: function() {
	            		return new ns.Titles(m, true);
	            	},

            		getColTitles: function() {
	            		return new ns.Titles(m, false);
	            	},

	            	findMetricValue: function(rvIdx , c ) {
	            		var rhs = m.ghs.rhs.items;
	            		for (var e in rhs) {
	            			var row = rhs[e].items;
	            			var found = true;
	            			for (var i in rvIdx) {
	            				if (rvIdx[i] != row[i].idx) {found = false; break;}
	            			}
	            			if (found) {
	            				return new mstrmojo.Vis.MetricValue(m.gvs.items[e].items[c]);
	            			}
	            		}
	            	},

	            	getTotalRows: function getTotalRows() {
	            		return m.eg ? 0 : m.ghs.rhs.items.length;
	            	},

            getTotalColHeaderRows : function getTotalColHeaderRows(){
                return (!m.ghs.chs.items ? 0: m.ghs.chs.items.length);
            },

        	getTotalCols: function getTotalCols() {
        		return this.getColHeaders(0).size();
        	},

        	getRowHeaders: function getRowHeaders(pos ) {
        		return new ns.Headers(m, pos, true);
        	},

        	getColHeaders: function getColHeaders(pos ) {
        		return new ns.Headers(m, pos, false);
        	},

        	getMetricValue: function getMetricValue(row, col) {
                return new ns.MetricValue(m, m.gvs.items[row].items[col]);
            },

            getColumnHeaderCount : function getColumnHeaderCount(){
                return m.gvs.items[0].items.length;
            },

            getCSSString : function getCSSString()
            {
                return m.cssString;
            }


    	};
    };

    mstrmojo.Vis.Titles = function (m, isRow) {
    	var t = (isRow) ? m.gts.row : m.gts.col;
    	return {
    		size: function size() {return t.length;},
            getTitle: function getTitle(pos) {return new mstrmojo.Vis.Title(t[pos]);},
            getCSS : function getCSS(pos) {return m.css[t[pos].cni].n;}
    	};
    };

    mstrmojo.Vis.Headers = function (m , i , isRow ) {
    	var t = (isRow) ? m.gts.row : m.gts.col;
    	var hs = (isRow) ? m.ghs.rhs : m.ghs.chs;
    	var h = hs.items && hs.items[i].items;

    	return {
    		size: function size() {return (!h ? 0: h.length);},
    		getHeader: function getHeader(pos) {
                return h && h[pos] && new mstrmojo.Vis.Header(h[pos], isRow ? t[pos] : t[i]);
            },
            getCSS : function getCSS(pos) {
                return h && m.css[h[pos].cni].n;
            },
            getHeaderCell : function(pos)
            {
                return h && h[pos];
            }

    	};
    };

    mstrmojo.Vis.Title = function (t ) {
    	return {
    		
    		getActionType: function() {return t.at;},
    		
    		getDrillPath: function() {return t.dp;},
    		getHeaderValues: function getHeaderValues() {return t.es;},
    		getHeaderName: function getHeaderValue(pos) {return t.es[pos].n;},
    		getHeaderId: function getHeaderValue(pos) {return t.es[pos].id;},
    		getForms: function getForms() {return t.fs;},
    		getFormId: function() {return t.fid;},
    		getFormType: function() {return t.ftp;},
    		getUnitId: function() {return t.id;},
    		
    		getLinkMap: function() {return t.lm;},
    		getName: function() {return t.n;},
            getUnitDssType: function() {return t.otp;},
            getSelectorControl : function() {return t.sc;}
    	};
    };

    mstrmojo.Vis.Header = function (h , t ) {
    	return {
    		getName: function getName() {
                return (h.idx === -1) ? "" :t.es[h.idx].n;
            },
            getElementId : function getElementId(){
                return (h.idx === -1) ? "" : t.es[h.idx].id;
            },
            getObjectId: function getId() {
                return (h.idx === -1) ? "" : t.es[h.idx].oid;
            },
            getElementIndex : function getElementIndex(){
                return h.idx;
            },
            getActionType : function getActionType(){
                return h.at;
            },
            isTotal : function isTotal(){
               return h.otr === 1;
            }
        };
    };

    mstrmojo.Vis.MetricValue = function (m, jsonObj) {
    	var v = jsonObj;
    	return {
            getValue: function getValue() {return v.v;},
            getThresholdType : function getThresholdType() { return v.ty;},
            getRawValue : function getRawValue() { return v.rv;},
            getCSS : function getCSS() { return m.css[v.cni].n;},
            getThresholdValue : function getThresholdValue(defaultValue)
            {
                if (v.ti == undefined) {
                    return defaultValue;
                }

                return m.th[v.ti].n;
            },
			getFillColor : function getFillColor(defaultValue)
            {
                if (v.ci == undefined) {
                    return defaultValue;
                }

                return m.fc[v.ci].n;
            }
    	};
    };
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.TextFieldDIC",
                         "mstrmojo.android._HasPreviewButton");

    mstrmojo.android.inputControls.TextFieldDIC = mstrmojo.declare(

        mstrmojo.TextFieldDIC,

        [ mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: 'mstrmojo.android.inputControls.TextFieldDIC',

            cssClass: 'mstrmojo-TextFieldDIC',

            cssDisplay: 'block',

            
            onfontChange: mstrmojo.emptyFn,

            
            applyChanges: function applyChanges() {
                
                
                
                this.domNode.blur();
                return this._super();
            },

            
            handleInvalid: function handleInvalid() {
                
                mstrmojo.alert(this.validationStatus.msg);
            },

            cancelChanges: function cancelChanges() {
                this.domNode.blur();
                this._super();
            },

            
            focus: function focus() {
                this.validate();
            },

            onfocus: function onfocus() {
                
                if (this.value != undefined && this.maxLength != undefined && String(this.value).length > this.maxLength) {
                    this.set('value', '');
                }
                
                window.setTimeout(function () {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },

            renderPreview: function renderPreview() {
                var openerNode = this.openerNode,
                    group = this.group || this,
                    showFullPreview = (group.openerType === 2) || !!this.dic.dm || this.dicChanged;   

                var displayValue = this.type === "password" ? '********' : this.dv;
                this.renderPreviewButton(openerNode, showFullPreview ? displayValue : openerNode.innerHTML);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.SelectBoxList",
                         "mstrmojo.array");

    
    mstrmojo.android.controllers._HasSelectBoxDialog = mstrmojo.provide(

        "mstrmojo.android.controllers._HasSelectBoxDialog",

        
        {
            _mixinName: 'mstrmojo.android.controllers._HasSelectBoxDialog',

            showSelectBoxDialog: function showSelectBoxDialog(items, fnSelect, dialogConfig) {

                
                var dialogChild = dialogConfig.children = [{
                    scriptClass: 'mstrmojo.android.ui.SelectBoxList',
                    isElastic: true,
                    items: items,
                    selectListChange: function (idx, item) {
                        
                        if (!fnSelect.call(this, idx, item)) {
                            
                            mstrApp.closeDialog();
                        }
                    }
                }][0];

                
                if (items.length === 1) {
                    var item = items[0];
                    items = item.items;

                    
                    dialogConfig.title = item.n;

                    
                    dialogChild.scriptClass = 'mstrmojo.ui.MobileCheckList';
                    dialogChild.items = items;
                    dialogChild.multiSelect = false;
                    dialogChild.selectedIndex = mstrmojo.array.find(items, 'on', true);

                    
                    dialogChild.postselectionChange = function (evt) {
                        this.selectListChange(0, items[evt.added[0]]);
                    };
                }

                
                mstrApp.showDialog(dialogConfig);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.TxEditDoc",
                         "mstrmojo.android.medium.ui.TxActionButtons",
                         "mstrmojo.css",
                         "mstrmojo.array");

    
    mstrmojo.android.medium.ui.TxEditDoc = mstrmojo.declare(

        mstrmojo.android.ui.TxEditDoc,

        null,

        
        {
            scriptClass: "mstrmojo.android.medium.ui.TxEditDoc",

            layoutConfig: {
                h: {
                    typeNode: 'auto',
                    txNode: '100%',
                    btmNode: 'auto'
                },
                w: {
                    typeNode: '100%',
                    txNode: '100%',
                    btmNode: '100%'
                }
            },

            addChildren: function addChildren(children, idx, silent) {
                
                children = children.concat([{
                    scriptClass: 'mstrmojo.android.medium.ui.TxActionButtons',
                    alias: 'btns',
                    cssClass: 'btns',
                    slot: 'btmNode'
                }]);

                this._super(children, idx, silent);
            },

            enableButtons: function enableButtons(enabled) {
                this.btns.set('enabled', enabled);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ViewSwitcher",
                         "mstrmojo.android.ui.TxDocList",
                         "mstrmojo.android.large.ui.TxEditDoc",
                         "mstrmojo.OfflineTransactionModel",
                         "mstrmojo.hash",
                         "mstrmojo.css");

    mstrmojo.requiresDescs(9249, 9753);

    var $HASH = mstrmojo.hash,
        $CSS = mstrmojo.css;

    var EnumTxType = mstrmojo.OfflineTransactionModel,
        PENDING = EnumTxType.PENDING,
        FAILED = EnumTxType.FAILED;

    var defaultTitle = mstrmojo.desc(9753, 'Transactions');

    
    function editDoc(item) {
        
        var editDocView = this._editDocView;
        if (!editDocView) {
            
            editDocView = this._editDocView = mstrApp.viewFactory.newView('TransactionsEditDoc', {
                model: this.model
            });
        } else {
            
            editDocView.set('docID', null);
        }

        
        this.switchView(editDocView);

        
        this.disposables.push(editDocView);

        
        editDocView.set('docID', item.v);

        
        var title = item.n;

        
        if (this.controller.isAllTransactionLevel()) {
            
            title = '<em>' + defaultTitle + '</em>' + title;
        }

        
        this.setTitle(title);
    }
    
    
    function showDocList() {
        
        this.enableButtons(false);

        var model = this.model,
            txs = (model && model.docsTx) || {},
            items = [],
            id = this.id;

        
        if ($HASH.isEmpty(txs)) {
            
            showEmptyList.call(this);
            return ;
        }
            
        
        $HASH.forEach(txs, function (v, k) {
            var pe = v[PENDING] || [],
                fe = v[FAILED] || [];

            
            items.push({
                n: v.name,
                v: k,
                c: pe.length + fe.length,
                desc: v.p.pn
            });
        });

        
        this.dirty = false;

        var docList = this._docList;
        if (!docList) {
            docList = this._docList = new mstrmojo.android.ui.TxDocList({
                cssClass: 'docList',
                items: items,
                postselectionChange: function (evt) {
                    var added = evt.added;
                    if (added) {
                        editDoc.call(mstrmojo.all[id], this.items[added[0]]);
                    }
                }
            });

            
            this.disposables.push(docList);

        } else {
            docList.set('items', items);
        }

        
        this.switchView(docList);

        
        this.setTitle(defaultTitle);

        
        var editDocView = this._editDocView;
        if (editDocView) {
            
            editDocView.set('docID', null);
        }
    }

        
    function showEmptyList() {
        
        var lbl = this._docList = new mstrmojo.Label({
            cssClass: 'txtEmpty',
            text: mstrmojo.desc(9249, 'No pending or failed transactions')
        });

        
        this.disposables.push(lbl);

        
        this.switchView(lbl);
        
        
        this.enableButtons(false);
    }
    
    
    mstrmojo.android.ui.TransactionView = mstrmojo.declare(
        mstrmojo.android.ui.ViewSwitcher,

        null,

        
        {
            scriptClass: 'mstrmojo.android.ui.TransactionView',

            
            context: null,

            
            model: null,

            
            controller: null,

            
            dirty: true,

            init: function init(props) {
                this._super(props);

                
                $CSS.addWidgetCssClass(this, 'mstrmojo-TxView');

            },

            onRender: function onRender() {
                
                var fnStart = function () {
                    
                    var model = this.model,
                        txs = (model && model.docsTx) || {},
                        context = this.context; 
                    
                    
                    if ($HASH.isEmpty(txs)) {
                        showEmptyList.call(this);
                        return ;
                    }
                    
                    if (context) {
                        
                        editDoc.call(this, {
                            v: context.id,
                            n: context.n
                        });
                    } else {
                        
                        showDocList.call(this);
                    }
                };

                
                if (!this._txListener) {
                    var txListener = this._txListener = this.model.attachEventListener('recordChanged', this.id, function () {
                        
                        this.dirty = true;

                        
                        fnStart.call(this);
                    });

                    
                    this.disposables.push(txListener);
                }

                
                fnStart.call(this);
            },

            
            deleteRecord: function deleteRecord() {
                var editDocView = this._editDocView,
                    isPending = (editDocView.getType() === 0),
                    tx = editDocView.getSelectedTx(),
                    id = this.id;

                
                this.controller.deleteTransactionRecord(editDocView.docID, isPending, tx.v, {
                    success: function (r) {
                        
                        var view = mstrmojo.all[id];
                        view.dirty = true;

                        
                        editDocView.generateTypeList();

                        
                        editDocView.setType((isPending || !r.length) ? 0 : 1);
                    }
                });

            },

            
            editRecord: function editRecord() {
                var editDocView = this._editDocView,
                    tx = editDocView.getSelectedTx();

                
                this.controller.editTransactionRecord(editDocView.docID, (editDocView.getType() === 0), tx.v);
            },

            
            enableButtons: mstrmojo.emptyFn,

            
            setTitle: mstrmojo.emptyFn,

            
            goBack: function goBack() {
                
                if (!this.controller.isAllTransactionLevel()) {
                    
                    return false;
                }

                
                var currentView = this.getCurrentView();
                if (!currentView || currentView === this._docList) {
                    
                    return false;
                }

                
                showDocList.call(this);

                
                return true;
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.TransactionView");
    
    var TTL_REG_EXP = /<\/em>(.*)$/;

    
    mstrmojo.android.medium.ui.TransactionView = mstrmojo.declare(
        mstrmojo.android.ui.TransactionView,

        null,

        
        {
            scriptClass: 'mstrmojo.android.medium.ui.TransactionView',

            enableButtons: function enableButtons(enabled) {
                
                var editDocView = this._editDocView;
                if (editDocView) {
                    editDocView.enableButtons(enabled);
                }
            },
            
            setTitle: function setTitle(title) {
                
                var subTitle = title.match(TTL_REG_EXP);
                this.controller.rootCtrl.updateContent(null, (subTitle && subTitle[1]) || title);
            }
        }
    );

}());

(function () {

    mstrmojo.requiresCls("mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.desc",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.android.controllers._HasSelectBoxDialog");


    mstrmojo.requiresDescs(221, 1442, 5136, 2941);

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        $DESC = mstrmojo.desc,
        $BTN = mstrmojo.android.ui.Button.newButton;

    
    function displayPageByDialog(title, isDoc) {
        var pageByData = $HASH.clone(this.pageByData),       
            pageElements = pageByData.es,
            dialogCfg = {
                title: title,
                dialogRefresh: function () {
                    
                    this.refresh();
                }
            },
            ctrl = this,
            pageCnt = 0,
            depth,
            pageBys,
            selections,
            selectedIndices,
            fnClearPageBy,
            fnPageHeader,
            fnGetPages,
            fnIterateSelections,
            fnSubmit;

        
        fnClearPageBy = function (node) {
            
            var idx = selectedIndices.shift(),
                item = node.ph.h[idx];

            
            delete item.cet;

            
            if (item.ph) {
                
                fnClearPageBy(item);
            }
        };

        
        fnPageHeader = function (node) {
            
            var page = node.ph;

            
            if (!page) {
                
                return;
            }

            var items = [],
                selectedPageHeader;

            
            $ARR.forEach(page.h, function (v, idx) {
                var ix = v.ix,
                    cet = v.cet || 0;

                var el = pageElements[ix];
                items[idx] = {
                    n: el.en,
                    v: ix,          
                    on: cet
                };

                
                if (cet) {
                    
                    selections[depth] = items[idx];

                    
                    selectedIndices[depth] = idx;

                    
                    selectedPageHeader = v.ph;
                }
            });

            
            var selected = selections[depth];

            
            pageBys.push({
                n: page.n,
                items: items,
                v: selected.n
            });

            
            depth++;

            
            fnPageHeader($HASH.copy(selected, {
                ph: selectedPageHeader
            }));
        };

        
        fnGetPages = function () {
            
            depth = 0;
            pageBys = [];
            selections = [];
            selectedIndices = [];

            
            fnPageHeader(pageByData);

            
            pageCnt = pageBys.length;
        };

        
        fnIterateSelections = function (fnModifier) {
            var pageHeader = pageByData.ph;
            $ARR.forEach(selections, function (v) {
                
                var headers = pageHeader.h,
                    index = $ARR.find(headers, 'ix', v.v),
                    selectedHeader;

                if (index < 0) {
                    index = (isDoc && headers.length > 1)  ? 1 : 0;
                }

                selectedHeader = headers[index];

                
                fnModifier(selectedHeader, pageHeader);

                
                pageHeader = selectedHeader.ph;
            });
        };

        
        fnSubmit = function () {
            
            var pageByKeys = [];

            
            fnIterateSelections(function (selectedHeader, pageHeader) {
                
                pageByKeys.push({
                    id: pageHeader.id || 'm',               
                    tp: pageHeader.tp,
                    v: pageElements[selectedHeader.ix].ei
                });
            });

            
            ctrl.pageByData = pageByData;

            
            ctrl.onPageBy(pageByKeys);
        };

        
        fnGetPages();

        
        if (pageCnt > 1) {
            
            dialogCfg.buttons = [ $BTN($DESC(221, 'Cancel')), $BTN($DESC(1442, 'OK'), function () {
                fnSubmit();
            }) ];
        }

        
        this.showSelectBoxDialog(pageBys, function (idx, item) {
            
            fnClearPageBy(pageByData);

            
            selections[idx] = item;

            
            fnIterateSelections(function (selectedHeader) {
                
                selectedHeader.cet = 1;
            });

            
            fnGetPages();

            
            if (pageCnt > 1) {
                
                this.set('items', pageBys);

            } else {
                
                fnSubmit();

            }

            
            return (pageCnt > 1);

        }, dialogCfg);

    }

    
    mstrmojo.android.controllers._HasPageBy = mstrmojo.provide(

        'mstrmojo.android.controllers._HasPageBy',

        

        $HASH.copy(mstrmojo.android.controllers._HasSelectBoxDialog, {

            _mixinName: 'mstrmojo.android.controllers._HasPageBy',

            
            showGroupByDialog: function showGroupByDialog() {
                displayPageByDialog.call(this, mstrmojo.desc(2941, 'Grouping'), true);
            },

            
            showPageByDialog: function showPageByDialog() {
                displayPageByDialog.call(this, mstrmojo.desc(5136, 'Page By'), false);
            }
        })
    );

}());

  
  (function () {

    mstrmojo.requiresCls("mstrmojo.Vis",
                         "mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.GeoLocation",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.DropDownList",
                         "mstrmojo.Label");

	mstrmojo.requiresDescs(7736, 8068, 8069, 8102, 8395, 8954);

    var $A = mstrmojo.array,
        $M = mstrmojo.android.EnumMenuOptions,
        REPROMPT = $M.REPROMPT,
        MAX_MARKERS = 1000; 

    
    function CustomMarker(lbl, latlng, rad, index, color) {
        this.title = lbl;
        this._latlng = latlng;
        this._rad = rad;
        this._ix = index;
        this._color = color;
    }

    function initCustomMarker() {

       CustomMarker.prototype = new google.maps.OverlayView();

       CustomMarker.prototype.draw = function() {

           
           var div = this.div_;
           if (!div) {
               
               div = this.div_ = document.createElement('DIV');
               
               var sty = div.style,
                   rad = this._rad,
                   radD2 = rad / 2,
                   radD2Px = radD2 + "px " + radD2 + "px",
                   panes = this.getPanes(),
                   me = this;

               sty.position = "absolute";
               sty.paddingLeft = "0px";
               sty.cursor = 'pointer';
               sty.backgroundColor = this._color;
               sty.opacity = '.65';
               sty.borderRadius = radD2Px;
               sty.height = sty.width = rad + "px";
               sty.border = "2px solid black";

               google.maps.event.addDomListener(div, "click", function(event) {
                   google.maps.event.trigger(me, "click");
               });

               
               panes.overlayMouseTarget.appendChild(div);
           }

           
           var point = this.getProjection().fromLatLngToDivPixel(this._latlng);
           if (point) {
               div.style.left = (point.x - this._rad / 2) + 'px';
               div.style.top = (point.y - this._rad / 2) + 'px';
           }
       };

       CustomMarker.prototype.remove = function() {
           
           var dv = this.div_;
           if (dv) {
               dv.parentNode.removeChild(dv);
               this.div_ = null;
           }
       };

       CustomMarker.prototype.getPosition = function() {
           return this._latlng;
       };

   }

    var getBounds = function getBounds(markers){
        var bnds;
        if(markers.length > 0){

            bnds = new google.maps.LatLngBounds();
            for(var i in markers){
                var m = markers[i],
                    p = m.getPosition();



                bnds.extend(p);
            }
        }
        return bnds;
    };

    function getFromPoint(laOrln, value){
        return value.replace(/POINT[ ]?\(|\)/g,"").split(' ')[laOrln == 'lat' ? 1 : 0];
    }

    function _getMapType() {
        return this._mapTypeToGoogleMapTypeId[this.mapType];
    }


    
    mstrmojo.maps.jsmap.AndroidMap = mstrmojo.declare(
        mstrmojo.Vis,

        [ mstrmojo._TouchGestures ],

        {
            scriptClass: "mstrmojo.maps.jsmap.AndroidMap",

            cssClass : "mstr-googleMapView",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@domNodeCssText}">' +
                             '<div></div>' +
                              '<div class="androidMap-metricSelector"><span class="androidMap-toggleHeader"></span></div>' +
                              '<div class="mstr-googleMap" id="map_canvas_{@id}"></div>' +
                          '</div>',

            reRenderOnDimensionChg: false,
            
            noMapsMsg: mstrmojo.desc(8954,"Google Maps have not been configured for this device. Please check with your mobile administrator to enable Google Maps in the mobile configuration."),
            
            
            selMetricIx : 0,

           
            markerArr : [],

           
           googleMap : null,

           
           bubblesMaxInfo : [],

           
           maxBubbleSize : 50,
           minBubbleSize : 20,

           
           markupSlots : {
               msg : function() { return this.domNode.childNodes[0]; },
               metricSelector : function(){ return this.domNode.childNodes[1];},
               map : function(){ return this.domNode.childNodes[2];}
           },

            markupMethods: {
                onheightChange: function(){
                    this.domNode.style.height = this.getHeight() + 'px';
                },
                onwidthChange: function(){
                    this.domNode.style.width = this.getWidth() + 'px';
                }
            },

           
           layoutConfig: {
               h: {
                   metricSelector: '32px',
                   map: '100%'
               },
               w: {
                   metricSelector: '200px',
                   map: '100%'
               }
           },

           children: [{
                   scriptClass: 'mstrmojo.android.DropDownList',
                   slot: 'metricSelector',
                   options: null,
                   onidxChange: function(evt) {
                       this._super(evt);
                       this.parent.onselMetricIxChange( evt );
                       this.set('value', this.options[evt.value].v);
                   },
                   visible: false,
                   alias: "metricSel"
                },{
                   scriptClass: 'mstrmojo.Box',
                   slot: 'map'

                }, {
                    scriptClass: 'mstrmojo.Label',
                    cssClass: "androidMap-errorMsg",
                    visible: true,
                    alias: "errorMsg",
                    slot: "msg"
                }
            ],

            setModel: function setModel(model) {
                this.set('model', model);
                this.xtabModel = model;
                if ( model.data ) {
                    this.set('gridData', model.data);
                }
            },

            ongridDataChange: function() {
                this.parser = new mstrmojo.Vis.DataParser(this.gridData);
            },

            update: function update(node) {
                node = node || this.node;
                if (node) { 
                	if (node.data) {
                	
                	    this.set('gridData', node.data);

                        var gd = this.gridData;
                		if (gd.layoutModel) this.layoutModel = gd.layoutModel;
                		if (gd.layoutNode) this.layoutNode = gd.layoutNode;
                	}
                    var fmts = node.defn.fmts || node.defn.units[this.xtabModel.k].fmts;

                    this.width = parseInt(fmts.width, 10);
                    this.height = parseInt(fmts.height, 10);
                    this.top = parseInt(fmts.top,10);
                    this.left = parseInt(fmts.left,10);
                    this.fmts = fmts;
                }

                if (this.xtabModel) {
                	this.initFromVisProps(this.gridData.vp);
                }
                this.updated = true;
            },

            getMapModel: function() {
                return this.xtabModel;
            },

			initFromVisProps: function initFromVisProps(vp) {
				if(!vp) return;

				
				if(vp.dv) {
					this.mapType = parseInt(vp.dv,10);
				}				
                this.usePt = ( vp.gr == "1" );
                this.useAttributes = ( vp.af === "0" );
                this.geoAttr = vp.ga;
                this.markerType = vp.mtp;
                this.attrThresholds = vp.at;
                this.flong = vp.flong;
                this.flat = vp.flat;
                this.fpt = vp.fpt;
                this.mstyl = vp.mstyl;
                this.maxBubbleSize = vp.mbs || 50;
            },

            showErrorMsg: function showErrorMsg(show,msg) {
                this.errorMsg.set("text", msg );
                this.metricSelector.style.display = show ? "none" : "block";
                this.map.style.display = show ? "none" : "block";
                this.msg.style.display = show ? "block" : "none";
            },
			
            postBuildRendering : function postBuildRendering(){
console.log("JSMAP:androiMap:postBuildRendering");
               this._super();

               if ( typeof this.gridData.eg !== "undefined" ) {
                   this.showErrorMsg( true, this.gridData.eg );
               } else if ( typeof google === "undefined" || ( google && typeof google.maps === "undefined" )) {
                   this.showErrorMsg(true,this.noMapsMsg);
               } else {

                   this.showErrorMsg(false);

                    
                    var selectorCtrl = this.children[0];

                    selectorCtrl.idx = 0;
                    selectorCtrl.unset = true;
                    selectorCtrl.options = [{ v: '-1', n: '' }];

                    if( 
                        ( typeof google !== "undefined" && google.maps ) ) {

                        
                        if ( !mstrApp.isInfoWindow ) {
                            this.markerArr = [];
                            this.bubblesMaxInfo = [];
                        }

                        this._mapTypeToGoogleMapTypeId = [  google.maps.MapTypeId.ROADMAP,
                                                            google.maps.MapTypeId.SATELLITE,
                                                            google.maps.MapTypeId.HYBRID,
                                                            google.maps.MapTypeId.TERRAIN ];

                        
                        initCustomMarker();
                        
                        if(this.gridData){

                            var showSelector = this.buildMetricSelector(),
                                selectorHeight = showSelector ? parseInt(this.layoutConfig.h.metricSelector,10) : 0;

                            this.metricSel.set('visible',showSelector);

                            this.map.style.height = this.getHeight() + "px";
                           	this.map.style.width = (this.getWidth() - 1) + "px";

                            this.metricSelector.style.height = selectorHeight + "px";
                            this.metricSelector.style.display = showSelector ? "block" : "none";

                            this.initMap();

                            if ( this.map.firstChild ) {
                                this.map.firstChild.style.zIndex = 1;
                            }
                        }
                    }
               }
           },



            gup: function gup(n){
            	n = n.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
            	var rxs = "[\\?&]"+n+"=([^&#]*)",
            	    rx = new RegExp(rxs),
            	    r = rx.exec(window.location.href);
            	return r == null ? "" : r[1];
            },

           
           onselMetricIxChange: function(evt){
               var f = function(map,mks){
                   for(var i in mks){
                       if(mks[i].setMap){
                           mks[i].setMap(map);
                       }
                   }
               };

               
               if(this.openedInfoWindow){
                   this.openedInfoWindow.close();
               }
               
               var mks = this.getMarkers(evt.value),
                   oldMks = this.getMarkers(evt.valueWas);

               this.selMetricIx = evt.value;

               
               f(null, oldMks);
               
               f(this.googleMap, mks);
           },

           
           buildMetricSelector : function buildMetricSelector() {
               var  col = this.gridData.gts.col,
                    useSelector = false;

               if ( col.length > 0 ) {
                   var metrics = col[0].es;

                   if( metrics.length > 1 ) {

                        var  items = [],
                             x = -1;

                        
                        $A.forEach(metrics, function (m, idx) {
                            
                            items[++x] = {
                                n: m.n,
                                v: x,
                                id: m.id
                            };
                        });

                        var selector = this.children[0];

                        selector.set('options',items);
                        selector.set('value', 0 );

                        useSelector = true;
                    }
               }
               return useSelector;
           },

            

            initMap : function () {
                var map,
                    gm = google.maps,
                    gme = gm.event,
                    mapType = _getMapType.call(this) || gm.MapTypeId.ROADMAP,
                   
                   mapOptions = {
                       mapTypeControl : true,
                       mapTypeControlOptions: {
                           position: gm.ControlPosition.TOP_LEFT,
                           style: gm.MapTypeControlStyle.HORIZONTAL_BAR 
                       },
                       streetViewControl :false,
                       mapTypeId : mapType,
                       navigationControlOptions : {
                         position : gm.ControlPosition.RIGHT_BOTTOM,
                         style : gm.NavigationControlStyle.ANDROID
                       },
                       zoomControlOptions: {
                           style: gm.ZoomControlStyle.LARGE
                       },
                       tilt: 0

                     };

                
                this.googleMap = map = new gm.Map(this.map, mapOptions);

                
                this.selMetricIx = this.selMetricIx;

                
                var markers = this.getMarkers(this.selMetricIx);

                if ( markers.length > 0 ) {
                    
                    var bnds = this.mapBounds; 

                   
                   if ( bnds ) {
                       map.fitBounds(bnds);
                       map.setCenter(bnds.getCenter());
                   }
                } else {
                    
                    var mstrHQ = new gm.LatLng(38.893444,77.221648);
                    map.setCenter(mstrHQ);
                }

                
                
                var INTERVAL = 30,
                    t = 0,
                    mz = map.getZoom(),
                    ti = setInterval(function() {
	                	mz = map.getZoom();	                	
	                    t += INTERVAL;
	                    if ( mz !== undefined ) {
	                        
                            
			                if ( mz > 20 ) {
			                    map.setZoom(15);			
			                } else if ( mz < 2 ) {
			                    map.setZoom(2);
			                }
	                        clearTimeout(ti);
	                    } else if (t > 10*INTERVAL) {
	                        
	                        clearTimeout(ti);
	                        map.setZoom(2);
	                    }
	                }, INTERVAL);	                
           },

           
            getMarkers : function getMarkers(metricIx){
                
                if(!!this.markerArr[metricIx]){
                    return this.markerArr[metricIx];
                }

                var map = this.googleMap,
                    d = this.gridData,
                    vp = d.vp,
                    gts = d.gts,
                    row = gts.row,
                    usePt = this.usePt,
                    minVals = (usePt ? 1 : 2 ),  
                    useAttributes = this.useAttributes,
                    geoAttr = this.geoAttr,
                    longs, lats, labels,
                    longIdx = -1, latIdx = -1, labelIdx = -1,
                    mks = [],
                    tIcon = null;

                for( var r = 0, numRows = row.length, totalForms = 0; r < numRows; ++r ) {
                    var curRow = row[r],
                        rid = curRow.id;
					
                    

                    
                    if ( usePt ) {
                        
                        if ( rid == this.fpt ) {
                            longs = lats = curRow;
                            longIdx = latIdx = totalForms;
                        }
                    } else {
                        
                        
                        if ( rid == this.flong ) {
                            longs = curRow;
                            longIdx = totalForms;

                        
                        } else if ( rid == this.flat ) {
                            lats = curRow;
                            latIdx = totalForms;
                        }
                    }

                    for( var f = 0, numForms = curRow.fs.length; f < numForms; ++f ) {
                        var curForm = curRow.fs[f],
                            fid = curForm.id;

                        
                        if ( usePt ) {
                            
                            if ( fid == this.fpt ) {
                                longs = lats = curRow;
                                longIdx = latIdx = totalForms + f;
                            }
                        } else {
                            
                            
                            if ( fid == this.flong ) {
                                longs = curRow;
                                longIdx = totalForms + f;
                            
                            } else if ( fid == this.flat ) {
                                lats = curRow;
                                latIdx = totalForms + f;
                            }
                        }

                        
                        if ( labelIdx < 0 ) {
                            labels = curRow;
                            labelIdx = totalForms + f;
                        }
                    }

                    totalForms += numForms;
                }

                
                if ( Math.min(longIdx,latIdx,labelIdx) < 0 ) {
                    throw new Error(mstrmojo.desc(8395, 'Not enough data to display map.'));
                }

                var rhs = d.ghs.rhs.items,
                    numMarkers = Math.min( rhs.length , MAX_MARKERS ),
                    lat_hi = -90, lat_lo = 90, lng_hi = -180, lng_lo = 180;

                for( var i = 0; i < numMarkers; i++ ) {
                    var vals = rhs[i].items; 

                    
                    
                    if ( vals.length < minVals) {
                        continue;
                    }
                    
                    
                    var longV = longs.es[vals[longIdx].idx].n,
                        lon = parseFloat( usePt ? getFromPoint("long", longV ) : longV ),
                        lat = parseFloat( usePt ? getFromPoint("lat", longV ) : lats.es[vals[latIdx].idx].n ),
                        lbl = labels.es[vals[labelIdx].idx].n,
                        marker,
                        metricItem = d.gvs.items[i];

                    
                    if ( isNaN(lat) || isNaN(lon)) {
                        continue;
                    }

                    
                    lat_lo = ( lat < lat_lo ) ? lat : lat_lo;
                    lat_hi = ( lat > lat_hi ) ? lat : lat_hi;
                    lng_lo = ( lon < lng_lo ) ? lon : lng_lo;
                    lng_hi = ( lon > lng_hi ) ? lon : lng_hi;

                    
                    latLng = new google.maps.LatLng(lat, lon);

                    
                    if ( this.markerType == "2" ) {
                        marker = this.getMetricBubble(d.gvs.items[i], lbl, latLng, i, metricIx);
                    } else {

                        
                    	tIcon = "../" + this.mstyl;
                    	
                    	var gvsItem = d.gvs.items[i];
	                    if ( gvsItem ) {
	
	                    	var	mitems = gvsItem.items;
	                    	if ( mitems ) {
	                    		var mi = mitems[metricIx];

	                    		
		                        if( mi && (mi.ts == 4) && (this.attrThresholds == "1")){
		                            tIcon = this.getImage(mi.v);
		                        }
	                    	}
	                    }

                        
                        marker = new google.maps.Marker({
                            position: latLng,
                            title: lbl,
                            _ix : i,
                            icon : tIcon,
                            zIndex: i       
                        });
                    }

                    
                    marker.eid = labels.es[vals[labelIdx].idx].id;
                    marker.attrid = labels.id;

                    marker.setMap(map);

                    
                    google.maps.event.addListener(marker, 'click', function(ths,m) {
                        return function() {

                            
                            

                            
                            ths.handleMarkerClick(map,m);
                        };
                    }(this,marker) );

                    
                    mks[mks.length] = marker;
                }

                

                this.mapBounds = new google.maps.LatLngBounds(
                    new google.maps.LatLng(lat_lo,lng_lo),
                    new google.maps.LatLng(lat_hi,lng_hi)
                 );

                
                this.markerArr[metricIx] = mks;

               return mks;
           },

           handleMarkerClick: function(map,marker) {
                
                if( this.openedInfoWindow){
                    this.openedInfoWindow.close();
                    this.openedInfoWindow = null;
                }
                this.openInfoWindow(map,marker);

                this.postHandleMarkerClick(map,marker);
           },

           
           postHandleMarkerClick: mstrmojo.emptyFn,

           
           getImage: function getImage(url) {
                var app = mstrApp,
                    config = app.getConfiguration();

                if (config && url && url.indexOf('://') === -1) {

                    url = config.getHostUrlByProject(app.getCurrentProjectId()) + url;
                }

                return (mstrApp.useBinaryFormat) ? String(mstrMobileApp.getImage(url)) : url;
            },


          

           getMetricBubble : function getMetricBubble(metricItem, lbl, latLng, index, metricIx){

               var d = this.gridData,
                   mValues = d.gvs.items, 
                   maxVal = this.bubblesMaxInfo[metricIx], 
                   mv = parseFloat(metricItem.items[metricIx].rv), 
                   color = "red", 
                   bubbleRange = Math.abs(this.maxBubbleSize - this.minBubbleSize );

               
               if(!maxVal){
                   for(var i in mValues){
                       var item = mValues[i].items[metricIx],
                           v = parseFloat(item.rv) || 0; 
                       if(!maxVal){
                           maxVal = v;
                       }
                       maxVal = Math.max(maxVal,v);
                   }
                   
                   this.bubblesMaxInfo[metricIx] = maxVal;
               }

               
               if(this.attrThresholds == "1" && (typeof metricItem.items[metricIx].ty !== "undefined" )){
                    
                    var ty = metricItem.items[metricIx].ty;
                    if ( ty == 2 ) {
                        
                        color = d.th[metricItem.items[metricIx].ti].n;
                    } else {
                        
                        color = "#FFF";
                    }
               }

               
               return new CustomMarker(lbl, latLng, this.minBubbleSize + Math.round((mv/maxVal) * bubbleRange), index, color);
           },

           
           openInfoWindow : function(map,marker){
                var ix = marker._ix,
                    w = this.getInfoWindow(map,marker);

                
                
                if ( w ) {
                    
                    this.openedInfoWindow = w;
                    w.open(map,marker);
                }
           },

           
           getInfoWindow : function(map,marker){
               return this.getDefaultInfoWindow(this.gridData, marker );
           },

           getDefaultInfoWindow : function getDefaultInfoWindow(d , marker ){
                var ix = marker._ix,
                    
                    mLabels = [],  
                    mValues = d.gvs.items,      
                    res = document.createElement("div"),
                    innerHTML = '<table><tbody><tr>' +
                                   '<td colspan="2" class="androidMap-infoWindowTitle" style="padding-right: 20px">'+ marker.title +'</td>' +
                               '</tr>';
							   
				if (d.gts.col.length != 0) {
					mLabels = d.gts.col[0].es;
				}
							   
               for(var i in mLabels){
                   var item = mValues[ix].items[i];

                   
                   if(item.ts == 4){
                       var path = item.v;
                       if ( path.indexOf("http") !== 0 ) {
                           path = "../" + path;
                       }
                       innerHTML += '<tr><td class="androidMap-infoWindowText">'+ mLabels[i].n +'</td><td><img src="'+ path +'"></td></tr>';
                   } else {
                       
                       var fColor = 'black',
                           bColor = 'white';

                       
                       if(d.th && this.attrThresholds == "1" && (typeof item.ti !== "undefined") ){
                           fColor = d.th[item.ti].n;   
                       }
                       innerHTML += '<tr><td class="androidMap-infoWindowText">'+ mLabels[i].n +'</td><td style="background-color:'+ bColor +';color:'+ fColor +';">'+ item.v + '</td></tr>';
                   }
               }

               innerHTML += '</tbody></table>';

               res.innerHTML = innerHTML;

                return new google.maps.InfoWindow({
                    content: res
                });
            },
               		
            
            touchBegin: function(touch) {
               touch.stop();
               return false;
            },

            rebuildLayout: mstrmojo.emptyFn,

            setDimensions: function setDimensions(h, w) {
                var map = this.googleMap,
                    center = map ? map.getCenter() : null,
                    dimensionChanged = this._super(h, w);

                if ( map ) {
                    this.map.style.height = this.getHeight() + "px";
                   	this.map.style.width = (this.getWidth() - 1) + "px";
                   	map.setCenter(center);
                }
               	
                return dimensionChanged;            	
            },

            unrender: function unrn(ignoreDom) {
                if ( this.googleMap ) {
                    delete this.googleMap;
                }

            	this._super(ignoreDom);
            },
            
            destroy: function destroy() {
                if ( this.googleMap ) {
                    delete this.googleMap;
                }

            	this._super();
            }
        }
    );
})();

(function() {

	mstrmojo.requiresCls("mstrmojo.Vis",
						 "mstrmojo.VisChartUtils",
						 "mstrmojo.VisChartData",
						 "mstrmojo.boxmodel"
						 );

	function getTooltipName(ch, s) {
		var nm = "",
			l = ch.length;
		
		if(l !== s.hi.length) {
			
			return ch[0].items[s.hi[0]].n;
		}
		
		for(var i = 0; i < l; i++) {
			nm += (i > 0 ? " " : "") + ch[i].items[s.hi[i]].n;
		}

		return nm;
	}
		
	
	mstrmojo.VisChart = mstrmojo.declare(
			
			mstrmojo.Vis,

			
			null,
					
			{
				
				scriptClass: 'mstrmojo.VisChart',

				
				utils: mstrmojo.VisChartUtils,                        

				
				data: mstrmojo.VisChartData,                        

				
				model: null,

				
				prevYLabel: {x:0, y:0, h:0},

				
				prevXLabel: {x:0, y:0, w:0},

				
				context: null,

				
				themeColor: '#000000',

				
				highlightColor: '#ff8833',

				
				margin: {t:50, r:2, b:30, l:2},

				
				offsetLeft: null,

				
				xLabelPadding: 10,

				
				yLabelPadding: 10,

				
				isDrawAxis: true,

				
				drawXAxisLabels: true,

				
				drawYAxisLabels: true,

				
				isHighlightOnTouch: true,

				
				isLinearChart: true,

				
				showHighlightLine: true,

				browserSupportsHtml5: true,

				
				multiLine: true,

				
				drawGridLines: 3,

				
				drawHorizontalGridLines: 1,

				
				drawVerticalGridLines: 2,

				
				switchSeriesOnTouch: true,

				
				seriesIndex: -1,

				
				displayMode: 0,
				
				
				markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};position:relative;" ' +
				' mstrAttach:mousedown,mouseup,mousemove,click ' +                             
				'><canvas width="{@width}" height="{@height}"></canvas>' + 
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' + 
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
				'<div id="{@id}-tooltip" class="mstrmojo-Chart-tooltip"></div>' + 
				'</div>',

				
				markupSlots: {
					
					canvas: function(){ return this.domNode.firstChild; },

					
					animationCanvas: function(){ return this.domNode.childNodes[1]; },

					
					highlightCanvas: function(){ return this.domNode.childNodes[2]; },

					
					tooltip: function(){ return this.domNode.childNodes[3]; }
				},

				
				postBuildRendering: function postBR() {
					if (this._super) {
						this._super();
					}
					this.browserSupportsHtml5 = this.canvas.getContext; 
	                if (!this.browserSupportsHtml5) {
	                	this.renderErrorMessage(mstrmojo.desc(8126,'Your browser does not support HTML5')); 
	                	return;
	                }
	                if (!this.model) {
	                	this.renderErrorMessage(mstrmojo.desc(8426,'No model provided'));
	                	return; 
	                }
	                
	                if(this.model.err || this.model.eg) {
						this.renderErrorMessage(this.model.err  || this.model.eg);
						return;
					}
	                
	                
	                if(this.isLinearChart) {
	                	this.data.processLinearData(this);
	                } else {
	                	this.data.process(this);
	                }
	                
	                
	                this.windowSize = this.model.series[0].rv.length;						

					
	                this.context = this.canvas.getContext('2d');
					this.highlightContext = this.highlightCanvas.getContext('2d');
					this.animationContext = this.animationCanvas.getContext('2d');
										
					
					this.utils.fillBackground(this);

					if(this.windowSize <= 1) {
						return; 
					}
					
					this.plot();
				},
				
				
				getMaxValue: function getMaxV(){
					var vals = this.model.mvalues;					
					return vals && vals[vals.length - 1];
				},
				
				
				getMinValue: function getMinV(){
					var vals = this.model.mvalues;
					
					return vals && vals[0];
				},

				
				plot: function plt() {

					
					this.drawChart();

					
					
					if(this.model.err  || this.model.eg) {
						return;
					}

					
					if(this.isDrawAxis) {
						
						if(this.isTimeSeries || !(this.isAnimateLines && (!this.multiLine || this.model.series.length === 1 ))) {
							this.drawLabels();
						}
						else{
							this.drawAxis();
						}
					}
				},

				
				drawChart: function drwchrt() {},

				
				drawAxis: function drwAxs() {
					var utils = this.utils,
						margin = this.margin,
						width = this.getWidth(),
						height = this.canvas.height,
						context = this.context;

					context.save();

					
					context.strokeStyle =  utils.getColor(this);
					context.lineWidth = 2;
					context.globalAlpha = 0.3;

					
					utils.drawRectangle(this, margin.l, margin.t, width - margin.l - margin.r, height - margin.t - margin.b);

					context.restore();
				},

				
				drawLabels: function drwlbls() {
					if (!this.isDrawAxis || !this.drawYAxisLabels) return;
					var model = this.model,
					utils = this.utils,
					margin = this.margin,
					v = model.mvalues,
					ylbls = model.ylbls,
					l = v.length,
					dgl = this.drawGridLines;

					this.prevYLabel.x = 0;
					this.prevYLabel.y = 0;
					this.prevYLabel.h =0;
					
					for(var i = 0; i < l; i++) {
						var y = utils.getYValue(this, v[i]);
						var lbl = utils.addDataLabel(this, ylbls[i], y, this.prevYLabel);
						
						var yPos = Math.floor(y) + 0.5;
						if(lbl && (dgl & this.drawHorizontalGridLines) && i > 0 && i < l-1 ) {
							utils.drawHighlightLine(this, yPos);
						}
						if(i == l-1 && this.isTimeSeries && lbl && (dgl & this.drawHorizontalGridLines)){
							utils.drawHighlightLine(this, yPos);
						}
					}
				},

				renderTooltip: function rndrttp(valIndex, touchX, touchY) {
					if (valIndex < 0) {
						this.tooltip.style.display = 'none';
						return;
					}

					var m = this.model, 
						s = m.series,
						utils = this.utils,
						l = s.length,
						si = this.seriesIndex,
						ch = m.colHeaders,
						ttp = this.tooltip;

					
					var sn = ''; 

					
					if(!this.multiLine) {
						sn = getTooltipName(ch,s[0]) + ': ' + s[0].v[valIndex];
					} else {
						
						
						if(this.showHighlightLine) {
							for(var i = 0; i < l; i++) {
								sn += (i === 0 ? '' : '<br/>') + getTooltipName(ch,s[i]) + ': ' + s[i].v[valIndex];
							}
						} else {
							
							sn = getTooltipName(ch,s[si]) + ': ' + s[si].v[valIndex];
						}

					}

					
					var rVal = this.model.categories.items[valIndex];

					
					ttp.innerHTML = rVal + '<br/>' + sn;

					
					ttp.style.display = 'block';

					

					
					var tooltipWidth = ttp.offsetWidth;

					var toolx = touchX - tooltipWidth /2;
					var margin = this.margin;

					if (toolx < margin.l) {
						toolx = margin.l;
					} else if (toolx > this.getWidth() - margin.r - tooltipWidth) {
						toolx = this.getWidth() - margin.r - tooltipWidth;
					}

					
					if(this.showHighlightLine) {
						utils.translateCSS(toolx, 0, false, ttp);
					} else {
						
						
						var yPos = utils.getYValue(this, s[si].rv[valIndex]) - ttp.offsetHeight - 20;
						if(yPos < 0 ) {
							yPos = utils.getYValue(this, s[si].rv[valIndex]);
						}
						utils.translateCSS(toolx, yPos, false, ttp);
					}

				},

				
				getTouchValue: function gtvlindx(x,y) {
					var md = this.model,
						m = this.margin;

					var sz = md.rne - md.rns > 0 ? md.rne - md.rns > 1 ? md.rne - md.rns : 2 : this.windowSize;
					var touchVal = Math.round(((x - m.l) * (sz - 1))/(this.getWidth() - m.l - m.r - 1));
					return (touchVal < sz) ? touchVal: null;
				},

				
				highlightPoint: function hghlghtpnt(x, touchY) {

				},

				
				handleTouchBegin: function handleTouchBegin(touchX, touchY) {
					if(!this.isHighlightOnTouch || !this.browserSupportsHtml5) {
						return;
					}
					this.tooltipOn = true;
					this.adjustWidgetOffsets();
					this.handleTouchMove(touchX, touchY);
				},

				
				handleTouchMove: function handleTouchMove(touchX, touchY) {
					var me = this,
						m = me.model;
						
					if (!me.tooltipOn || !me.isHighlightOnTouch || !this.browserSupportsHtml5 || this.windowSize <= 1) {
						return;
					}

		             var touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);	
					touchX = touchPointOnWidget.touchX;
					touchY = touchPointOnWidget.touchY;     

					var margin = me.margin;

					
					if(touchX < margin.l || touchY < margin.t || touchY > me.canvas.height - margin.b) {
						return;
					}

					
					var touchVal = me.getTouchValue(touchX,touchY);

					
					if (touchVal !== null) {

					

						
						var rns = (m.rne - m.rns > 1) ? m.rns : m.rns - 1;

						
						if(me.seriesIndex === -1 || me.switchSeriesOnTouch) {
							me.seriesIndex = me.utils.getSeriesIndexAndYValue(me, rns + touchVal, touchY).si;
						}

						
						if(m.series[me.seriesIndex].rv[rns + touchVal] === "") {
							return;
						}
						
						
						me.prevHighlight = me.currentHighlight;
						
						
						me.currentHighlight = touchVal;
						
						
						me.renderTooltip(touchVal, touchX, touchY);
						
						
						if(this.isTimeSeries){
							me.highlightPoint(touchVal, touchX, touchY);
						}else{
							me.highlightPoint(touchVal, touchY);	
						}
						
					}
				},

				
				handleTouchEnd: function handleTouchEnd() {
			        if (!this.browserSupportsHtml5) {
			        	return;
			        }
					var me = this;
					
					if(me.model.err || this.model.eg) {
						return;
					}
					me.tooltipOn = false;

					me.seriesIndex = -1;
					me.currentHighlight = null;
					
					
					
					me.highlightCanvas.height = me.highlightCanvas.height;

					
					me.tooltip.style.display = 'none';
				},
				
				
				onmousedown: function(evt) {
					if(!this.isAndroid) {
						this.handleTouchBegin(evt.e.pageX, evt.e.pageY);
					}
				},

				
				onmouseup: function(evt) {
					if(!this.isAndroid) {
						this.handleTouchEnd();
					}
				},

				
				onmousemove: function(evt) {
					if (!this.isAndroid) {
						this.handleTouchMove(evt.e.pageX, evt.e.pageY);
					}
				}				
			}
	);

})();
(function(){

    mstrmojo.requiresCls('mstrmojo.url', 'mstrmojo.Vis', 'mstrmojo._CanSupportTransaction');
    
    mstrmojo.PhotoUploader = mstrmojo.declare(
            
            mstrmojo.Vis,
            
            [mstrmojo._CanSupportTransaction, mstrmojo._TouchGestures],
            
            {
                scriptClass: 'mstrmojo.PhotoUploader',
                
                photoNum: 0,
                
                markupString: '<div id="{@id}" class="mstrmojo-PhotoUploader" style="left:{@left};top:{@top};width:{@width};height:{@height}" mstrAttach:click>' +
                                  '<div class="actionButton" style="line-height:{@height}">{@n}</div>' +
                                  '<img class="preview"></img>' +
                                  '<div class="numberBadge">' +
                                      '<div class="badgeText"></div>' +
                                  '</div>' +
                              '</div>',
                
                markupSlots: {
                    buttonNode: function(){ return this.domNode.firstChild;},
                    previewNode: function(){ return this.domNode.childNodes[1];},
                    badgeNode: function() { return this.domNode.lastChild;},
                    badgeTextNode: function() {return this.domNode.lastChild.firstChild;}
                },
                
                markupMethods:{
                    onphotoNumChange: function(){
                        mstrmojo.css.toggleClass(this.domNode, 'empty', this.photoNum == 0);
                        if (this.photoNum > 0){
                            this.badgeTextNode.innerHTML = this.photoNum;
                        }
                    }
                },
               
                preBuildRendering: function(){
                    this._super();
                    
                    var dp = this.getDataParser(),
                        rowTitles = dp.getRowTitles(),
                        colTitles = dp.getColTitles(),
                        firstRow, t1, t2, t3, atid1, atid2;
                    
                    if (rowTitles.size() < 3 && colTitles.size() < 1){
                        
                        mstrmojo.alert("Incorrect grid template structure!");
                        return false;
                    } else if (dp.getTotalRows() < 10){
                        
                        mstrmojo.alert("At least 10 rows required!");
                        return false;
                    } 
                    
                    firstRow = dp.getRowHeaders(0);
                    t1 = rowTitles.getTitle(0); 
                    t2 = rowTitles.getTitle(1); 
                    atid1 = t1.getUnitId(); 
                    atid2 = t2.getUnitId();
                    t3 = colTitles.getTitle(0).getHeaderValues()[0]; 
                    
                    this.cellInfo = [{
                        atid: atid1,
                        form_id: t1.getFormId(),
                        ui: 0
                    }, {
                        atid: atid2,
                        form_id: t2.getFormId(),
                        ui: (atid1 == atid2) ? 0:1 
                    }, {
                        metric_id: t3.oid
                    }];

                    this.photoNum = 0; 
                    this.n = mstrmojo.desc(8470);
                },
                
                
                setModel: function(model){
                    this.model = this.txModel = model && model.docModel;
                },
                
                
                getKeyContext: function(k){
                    return { o: parseInt(k, 10) };
                },
                
                
                getUpdateObject: function(i){
                    var udvs = this.getUpdatedValues(),
                        CHANGE_DATA = 2, 
                        cells = [], ci = this.cellInfo;
                    
                    for (var i in udvs){
                        var udv = udvs[i],
                            photoPath = mstrmojo.string.encodeXMLAttribute(String(udv.v[0])),
                            photoDesc = mstrmojo.string.encodeXMLAttribute(String(udv.v[1])),
                            count = '1';
                        cells.push({
                            rowOrdinal: udv.o, 
                            attId: ci[0].atid,
                            formId: ci[0].form_id,
                            unitIndex: ci[0].ui,
                            newValue: photoPath
                        }, {
                            rowOrdinal: udv.o, 
                            attId: ci[1].atid,
                            formId: ci[1].form_id,
                            unitIndex: ci[1].ui,
                            newValue: photoDesc
                        }, {
                            rowOrdinal: udv.o, 
                            colOrdinal: 0,
                            newValue: count
                        });
                    }
                    
                    return {
                        manipulation: CHANGE_DATA,
                        nodeKey: this.k,
                        sliceId: this.sid,
                        cells: cells,
                        autoRefresh: false
                    };
                },
                
                
                getUpdates: function getUpdates(){
                    var eg = [], 
                        w = this, 
                        j, udt = false,
                        udvs = this.getUpdatedValues(), udv,
                        TX_ELEM_ATT_FORM = 1,
                        TX_ELEM_METRIC = 2,
                        DssXmlDataTypeVarChar = 9,
                        DssXmlDataTypeInteger = 1,
                        ci = this.cellInfo;
                    
                    eg.push('<gr rw_tree_type="' + this.defn.tt + '" rw_node_key="' + w.k + '" slice_id="' + (w.sid || 0) + '">');
                    
                    for(j in udvs) {
                        if(udvs.hasOwnProperty(j)) {
                            udv = udvs[j];
                            
                            for (var i = 0; i < 2; i++){
                                eg.push('<cli ax="1" attribute_id="' + ci[i].atid + '" form_id="' + ci[i].form_id + '">' + 
                                            '<updt types="' + TX_ELEM_ATT_FORM +'" ordinal="' + udv.o + '" value="' + udv.v[i] + '" dt="' + DssXmlDataTypeVarChar + '"/>' +
                                        '</cli>');
                            }
                            
                            eg.push('<cli cordinal="0" metric_id="' + ci[2].metric_id + '">' + 
                                        '<updt types="' + TX_ELEM_METRIC + '" rordinal="' + udv.o + '" value="1" dt="' + DssXmlDataTypeInteger + '"/>' +
                                    '</cli>');
                            
                            udt = true;
                        }
                    }
                    eg.push('</gr>');
                    if (!udt){
                        eg = [];
                    }
                    
                    return eg.join('');
                },
                
                
                photoUploaded: function(imagePath, description){
                    mstrMobileApp.setWaitScreenVisibility(false);
                    var url = mstrmojo.url.getAbsoluteURL(imagePath, mstrApp.getConfiguration().getCurrentProjectWebServerUrl()),
                        desc = description,
                        currentIdx = this.photoNum;
                    
                    this.previewNode.src = url;
                    
                    this.dataChanged(currentIdx, {}, {v: [url, desc]});

                    this.set('photoNum', currentIdx + 1);
                },
                
                touchTap: function(){
                    this.onclick();
                },
                
                onclick: function(){
                    if (this.photoNum == 10){
                        mstrmojo.alert("can upload at most 10 photos");
                    }else{
                        var params = {
                            serverUrl: mstrApp.getConfiguration().getTaskUrlByProject(mstrApp.getCurrentProjectId()),
                            sessionState: mstrApp.getSessionState(),
                            descs: {
                                'ADD_PHOTO' : mstrmojo.desc(8470),
                                'TAKE_NEW_PHOTO' : mstrmojo.desc(8471),
                                'CHOOSE_FROM_GALLERY' : mstrmojo.desc(8472),
                                'DONE' : mstrmojo.desc(8473),
                                'CANCEL' : mstrmojo.desc(221)
                            }
                        };
                        
                        
                        mstrMobileApp.uploadPhotos(JSON.stringify(params), 'mstrmojo.all["' + this.id + '"].photoUploaded');
                    }
                }
            }
    );

}());

  
  (function () {

    mstrmojo.requiresCls("mstrmojo.Vis",
                         "mstrmojo.hash",
                         "mstrmojo.GeoLocation",
                         "mstrmojo._TouchGestures");

    var GD_SEP = '\u001F',
    	GR_SEP = '\u001E',
    	GC_SEP = '\u001D',
    	GI_SEP = '\u001C',
    	GV_SEP = '\u001B';
    
    
    function togglePreviewCtrl(preview, opacity) {
    	if (!!preview && !!preview.imgNode) { 
            var imgNodeStyle = preview.imgNode.style;
            
            imgNodeStyle.opacity = opacity;
    	}
    }
    
    
    
    var PREVIEW_CLS_NAME = mstrmojo.Image.baseCssClass + '-prv';

    
    mstrmojo.maps.androidmap.AndroidMap = mstrmojo.declare(
        mstrmojo.Vis,

        null,

        {
            scriptClass: "mstrmojo.maps.androidmap.AndroidMap",

            cssClass : "mstr-googleMapView",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@domNodeCssText}" mstrAttach:touchstart>' +
                          '</div>',

            reRenderOnDimensionChg: false,
            
            mapRendered: false,
            
            firstScreen: true,
            
            children: [{
                scriptClass: 'mstrmojo.Image',
                alias: 'imgPreview',
                cssClass: 'prv',
                cssText: 'position:absolute;left:0;top:0;',
                firstLoad:false,
                onload: function () {
                    
                    togglePreviewCtrl(this, 1);
                    var ths = this;
                    window.setTimeout(function() 
              		{
              			ths.parent.postImageProcessing(ths.firstLoad);
              			ths.firstLoad = false;
              		},300);
                }
            }],
            
           
           markupSlots : {
               containerNode : function() {return this.domNode;}
           },

            markupMethods: {
                onheightChange: function(){
                    this.domNode.style.height = this.getHeight() + 'px';
                },
                onwidthChange: function(){
                    this.domNode.style.width = this.getWidth() + 'px';
                }
            },

            setModel: function setModel(model) {
                this.set('model', model);
                this.xtabModel = model;
                if ( model.data ) {
                    this.set('gridData', model.data);
                }
            },
            
            postImageProcessing:function postImageProcessing(firstLoad) {
            	if (firstLoad && this.controller && this.controller.takeScreenShot) {
            		this.controller.takeScreenShot();
            	}
            	if (this.imgPreview.src != '' && mstrMobileApp && mstrMobileApp.hideMapView) {
                    window.setTimeout(function(){
                        mstrMobileApp.hideMapView(0);
                    }, 100);
                }
            },

            ongridDataChange: function() {
                this.parser = new mstrmojo.Vis.DataParser(this.gridData);
                
                delete this.dataMap;
            },

            update: function update(node) {
                node = node || this.node;
                if (node) { 
                	if (node.data) {
                	
                	    this.set('gridData', node.data);

                        var gd = this.gridData;
                		if (gd.layoutModel) this.layoutModel = gd.layoutModel;
                		if (gd.layoutNode) this.layoutNode = gd.layoutNode;
                		
                		delete gd.layoutModel;
                		delete gd.layoutNode;
                	}
                    var fmts = node.defn.fmts || node.defn.units[this.xtabModel.k].fmts;

                    this.width = parseInt(fmts.width, 10);
                    this.height = parseInt(fmts.height, 10);
                    this.top = parseInt(fmts.top,10);
                    this.left = parseInt(fmts.left,10);
                    this.fmts = fmts;
                }

                if (this.xtabModel) {
                	this.initFromVisProps(this.gridData.vp);
                }
                this.updated = true;
                
            },

            getMapModel: function() {
                var pid = mstrApp.getCurrentProjectId(),
                	sessions = mstrApp.serverProxy.getSessions();

                return {
                    pid: pid,
                    sessions: sessions,
                    mapId: this.id,
                    hasTarget: false,
                    hostUrl: mstrApp.getConfiguration().getHostUrlByProject(pid)
                };
            },
            
            getGridModel: function() {
            	var gridModel = mstrmojo.hash.copy(this.gridData, {}); 
            	
            	return gridModel;
            },

			initFromVisProps: function initFromVisProps(vp) {
                this.vp = vp;
            },
			
            dispatchMapData: function dispatchMapData() {
                var mapModel = this.getMapModel(),
                	gd = this.simplifyGridData();

                mstrMobileApp.loadMap(JSON.stringify(mstrmojo.hash.copy(mapModel, {
                	gdProp: gd.prop,
                    infoWindow: {dft: true}
                })), gd.es, gd.data, '');
                
                
                this.mapRendered = true;
            },
            
            
            simplifyGridData: function simplifyGridData() {
            	if(this.dataMap) {
            		return this.dataMap;
            	}
            	var gd = this.gridData,
            		ghs = [],
            		gvs = [],
            		gts = {row: [], col: []}, o, row, col, ges = [], res = [], ces = [],
            		rd = [], items = [], cv, 
            		ritems, citems, i, iLen, j, jLen;
            	
            	
            	if (typeof(gd.ghs) == 'undefined' || (gd.gts.row.length == 0)) {
            		gd.eg = 'no data returned';
            	}
            	
            	if(gd.eg) {
            		this.dataMap = {prop: {}, data: '', es: ''};
            	} else {
            		
                	for(i = 0, ritems = gd.ghs.rhs.items, iLen = ritems.length; i < iLen; i++) {
                		
                		for(j = 0, citems = ritems[i].items, jLen = citems.length; j < jLen; j++) {
                			rd.push(citems[j].idx);
                		}
                		
                		ghs.push(rd.join(GC_SEP));
                		
                		rd = [];
                	}

                	
                	for(i = 0, ritems = gd.gvs.items, iLen = ritems.length; i < iLen; i++) {
                		
                		for(j = 0, citems = ritems[i].items, jLen = citems.length; j < jLen; j++) {
                			
                			items.push(citems[j].v);
                			
                			items.push(citems[j].rv || 0);
                			
                			if(citems[j].ti !== undefined || citems[j].ts !== undefined) {
                				
                				v = '';
                				if(citems[j].ti !== undefined) {
                					
                					gd.th[citems[j].ti].ty = citems[j].ty;
                					v = citems[j].ti;
                				}
                				
                				v += GV_SEP;
                				if(citems[j].ts !== undefined) {
                					v += citems[j].ts;
                				}
                				items.push(v);
                			}
                			
                			rd.push(items.join(GI_SEP));
                			items = [];
                		}
                		
                		gvs.push(rd.join(GC_SEP));
                		rd = [];
                	}
                	
                	
                	
                	row = gd.gts.row;
                	mstrmojo.array.forEach(row, function(v){
                		o = {};
                		
                		mstrmojo.hash.copyProps(['n', 'id', 'fid', 'fs', 'sc'], v, o);
                		gts.row.push(o);
                		rd = [];
                		
                		mstrmojo.array.forEach(v.es, function(elem) {
                			rd.push(elem.n);
                		});
                		
                		res.push(rd.join(GI_SEP));
                	});
                	
                	ges.push(res.join(GR_SEP));
                	
                	
                	col = gd.gts.col;
                	mstrmojo.array.forEach(col, function(v) {
                		o = {};
                		mstrmojo.hash.copyProps(['n', 'id', 'fid'], v, o);
                		gts.col.push(o);
                		rd = [];
                		
                		mstrmojo.array.forEach(v.es, function(elem) {
                			rd.push(elem.n);
                		});
                		
                		ces.push(rd.join(GI_SEP));
                	});
                	
                	ges.push(ces.join(GR_SEP));
                	
                	
                	this.dataMap = {
                		prop: {
                			vp: gd.vp,
                			th: gd.th,
                			gts: gts
                		},
                		es: ges.join(GD_SEP),
                		data: ghs.join(GR_SEP) + GD_SEP + gvs.join(GR_SEP)
                	};
            	}
            	
            	return this.dataMap;
            },
            
            getModel: function getModel() {
                return this.gridData;
            },
            
            handleMarkerSelection: mstrmojo.emptyFn,
			
            postBuildRendering : function postBuildRendering(){
               
               this.dispatchMapData();
               
               this._super();
            },

            rebuildLayout: mstrmojo.emptyFn,

            resetLayout: mstrmojo.emptyFn,

            setDimensions: function setDimensions(h, w) {
                var map = this.googleMap,
                    center = map ? map.getCenter() : null,
                    dimensionChanged = this._super(h, w);

                if ( map ) {
                    this.map.style.height = this.getHeight() + "px";
                   	this.map.style.width = (this.getWidth() - 1) + "px";
                   	map.setCenter(center);
                }
               	
                return dimensionChanged;            	
            },
            
            unrender:function unrender() {
            	this.imgPreview.src = '';
            	if(this.mapRendered) {
                    this.removeMap();
                    this.mapRendered = false;
                }
            	this._super();
            },
            
            removeMap:function removeMap() {
            	mstrMobileApp.hideMapView("1");
            },
            switchToImage: function switchToImage(src,width,height) {
                
                var imgPreview = this.imgPreview;
                imgPreview.firstLoad = this.firstScreen;
                this.firstScreen = false;
                if (src && imgPreview.hasRendered) {
                    
                    if (imgPreview.src !== src) {
                        
                        togglePreviewCtrl(imgPreview, 0);
        
                        
                        imgPreview.domNode.className = PREVIEW_CLS_NAME;
        
                        
                        imgPreview.set('src', src);
                        
                        imgPreview.set('width',width);
                        imgPreview.set('heihgt',height);
                        
                        
                    } else if (mstrMobileApp && mstrMobileApp.hideMapView) {
                    	togglePreviewCtrl(this.imgPreview,1);
                    	
                    	this.postImageProcessing(false);
                    }
                } else {
                    mstrMobileApp.hideMapView(0);
                }
            },
            hidePreview:function hidePreview() {
            	togglePreviewCtrl(this.imgPreview,0);
            },
            showPreview:function showPreview() {
            	togglePreviewCtrl(this.imgPreview,1);
            },
            closeInfoWindow: function closeInfoWindow() {
                
                do{
                    mstrApp.closeDialog();
                } while(mstrmojo.all.mstrMapInfoWindow);
            },
            ontouchstart: function ontouchstart() {
                if(this.mapRendered) {
                    mstrMobileApp.showMapView(0);
                }
            },
            
            destroy: function destroy() {
                
                var p = this.parent;
                while(p) {
                    if(p._scroller && p.scrollMoveListener) {
                        
                    }
                    p = p.parent;
                }                
            	this._super();
            	if (this.mapRendered) {
            	    mstrMobileApp.navigateAway();
            	}
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Vis");

    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    mstrmojo.VisMicroChartBullet = mstrmojo.declare(

        mstrmojo.Vis,

        null,

        {

            scriptClass: 'mstrmojo.VisMicroChartBullet',

            isDrawAxis: false,

            margin: {t: 0, r: 5, b: 0, l: 5},

            showHighlightLine: false,

            themeColor: '#FFFFFF',

            noBackground: true,

            isAnimateLines: false,

            toolTipMain: null,

            mainWidth: 0,

            mainLeftPos: 0,

            showMinLabel: false,

            markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};position:relative;" ' +
                ' mstrAttach:mousedown,mouseup,mousemove,click ' +
                '><canvas width="{@width}" height="{@height}"></canvas>' +
                
                
                '<div style="position:absolute;left:0px;bottom:0px;display:none;font:7px Arial;text-align:left;line-height:7px;"></div>' +
                '<div style="width:100%;height:{@height};top:0px;left:0px;position:absolute;display:none;font:10pt Arial;overflow: hidden; text-overflow: ellipsis; white-space:nowrap"></div>' +
                '</div>',

            markupSlots: {

                canvas: function () {
                    return this.domNode.firstChild;
                },
                minLabel: function () {
                    return this.domNode.childNodes[1];
                },
                errorMsg: function () {
                    return this.domNode.childNodes[2];
                }
                
                
                
            },
            postBuildRendering: function postBR() {
                if (this._super) {
                    this._super();
                }
                this.browserSupportsHtml5 = this.canvas.getContext;
                if (!this.browserSupportsHtml5) {
                    this.renderErrorMessage(mstrmojo.desc(8126, 'Your browser does not support HTML5'));
                    return;
                }
                if (!this.model) {
                    this.renderErrorMessage(mstrmojo.desc(8426, 'No model provided'));
                    return;
                }

                if (this.model.err || this.model.eg) {
                    this.renderErrorMessage(this.model.err || this.model.eg);
                    return;
                }

                this.context = this.canvas.getContext('2d');
                
                
                this.setColorByTheme();
                this.drawChart();
            },

            setColorByTheme: function setColorByTheme() {
                var bulletProps = this.config;
                var dpi = mstrMobileApp && mstrMobileApp.getDeviceDPI() || 160;
                if (this.theme == DEFAULT_DARK_THEME) {
                    this.bandColor1 = "#494949";
                    this.bandColor2 = "#595959";
                    this.bandColor3 = "#727272";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = dpi >= 160 ? 2 : 1;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = bulletProps.mwNegCol;
                } else if (this.theme == DEFAULT_LIGHT_THEME) {
                    this.bandColor1 = "#A5A5A5";
                    this.bandColor2 = "#B3B3B3";
                    this.bandColor3 = "#C4C4C4";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = dpi >= 160 ? 2 : 1;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = bulletProps.mwNegCol;
                } else {
                    this.bandColor1 = bulletProps.mwBand1 || "#999999";
                    this.bandColor2 = bulletProps.mwBand2 || "#BBBBBB";
                    this.bandColor3 = bulletProps.mwBand3 || "#DEDEDE";

                    this.refLinePosColor = bulletProps.mwRefLineCol;
                    this.refLineNegColor = bulletProps.mwRefLineCol;
                    this.blueBarPosColor = bulletProps.mwPosCol;
                    this.blueBarNegColor = bulletProps.mwNegCol;
                }
            },

            showTooltip: function shwttp(touchX, touchY) {
                if (!this.config.mbShowTooltip) {
                    return false;
                }
                var minValue = this.config.mfMinValue;
                var refV = this.refv;
                var mc3 = refV[2].rv - minValue;
                var mc4 = refV[3].rv - minValue;
                var ttp = this.toolTipMain;

                var model = this.model;
                var metrics = model.mtrcs.items;

                var bulletProps = this.config;

                var ofht = 17;
                var line1;

                if ( this.widget.bulletProps.mstrAssMetric) {
                    line1 = this.widget.bulletProps.mstrAssMetric + ": " + refV[2].v;
                }
                else {
                    line1 = metrics[2] + ": " + refV[2].v;
                }
                var maxWidth = this.widget.getTextWidthByCanvas(line1, ttp);
                if (bulletProps.mbRefLine) {
                    line1 = '<div style="margin-left:5px;margin-top:5px;"><div style="float:left;margin-right:5px;margin-top:2px;width:12px;height:10px;background-color:' + this.targetColor + ';"></div><div style="float:left;text-align:top;">' + line1 + "</div></div>";
                } else {
                    line1 = '<div style="margin-left:5px;margin-top:5px;margin-bottom:5px;"><div style="float:left;margin-right:5px;margin-top:2px;width:12px;height:10px;background-color:' + this.targetColor + ';"></div><div style="float:left;text-align:top;">' + line1 + "</div></div>";
                }

                if (bulletProps.mbRefLine) {
                    ofht += 17;
                    var line2 = metrics[6] + ": " + refV[6].v;
                    var line2Width = this.widget.getTextWidthByCanvas(line2, ttp);
                    if (line2Width > maxWidth) {
                        maxWidth = line2Width;
                    }
                    line2 = '<div style="margin-left:5px;margin-bottom:5px;"><div style="float:left;margin-left:5px;margin-top:2px;margin-right:10px;width:2px;height:10px;background-color:' + this.refLineColor + ';"></div><div style="float:left;">' + line2 + "</div></div>";
                    line1 += "<br/>" + line2;
                }
                ofht += 10;

                
                
                
                
                
                

                if (this.tooltipErrMsg) {
                    ttp.innerHTML = this.tooltipErrMsg;
                } else {
                    ttp.innerHTML = line1;
                }

                var pos = mstrmojo.dom.position(this.domNode, true);
                var posWdt = mstrmojo.dom.position(this.widget._leftChart.domNode, true);
                maxWidth += 28;
                ttp.style.display = 'block';
                ttp.style.borderColor = this.targetColor;
                ttp.style.width = maxWidth + "px";
                var tpof = 0;
                if ((this.getHeight() - ofht) % 2 == 0) {
                    tpof = (pos.y - posWdt.y + (this.getHeight() - ofht) / 2);
                } else {
                    tpof = (pos.y - posWdt.y + (this.getHeight() - ofht - 1) / 2);
                }

                if (tpof < 0) {
                    tpof = 0;
                }
                if (tpof + ofht > this.widget.getHeight()) {
                    tpof = this.widget.getHeight() - ofht - 5;
                }
                ttp.style.top = tpof + "px";

                
                var ttpLeft = 0;
                if (pos.x + pos.w / 2 > (posWdt.x + posWdt.w / 2)) {
                    
                    ttpLeft = pos.x - posWdt.x - maxWidth - 10;
                } else {
                    
                    ttpLeft = pos.x - posWdt.x + pos.w + 10;
                }
                if (ttpLeft < 0) {
                    ttpLeft = 0;
                }

                ttp.style.left = ttpLeft + "px";
                return true;
            },

            drawChart: function drwchrt() {
                var bulletProps = this.config;
                var minValue = bulletProps.mfMinValue;
                var refV = this.refv;
                var mc3, mc4, mc5, mc6, mc7;
                
                var mMc3, mMc4, mMc5, mMc6, mMc7;
                mMc3 = parseFloat(refV[2].rv);
                mMc4 = parseFloat(refV[3].rv);
                mMc5 = parseFloat(refV[4].rv);
                mMc6 = parseFloat(refV[5].rv);
                mMc7 = parseFloat(refV[6].rv);
                mc3 = mMc3 - minValue;
                mc4 = mMc4 - minValue;
                mc5 = mMc5 - minValue;
                mc6 = mMc6 - minValue;
                mc7 = mMc7 - minValue;

                var isInverted = bulletProps.mbInvertAxis;
                var hasRefLine = bulletProps.mbRefLine;
                var hasRefBands = bulletProps.mbRefBands;
                var mShowTooltip = bulletProps.mbShowTooltip;
                var ctx = this.context;
                var ratioBetweenMetricViewWidth;
                var bulletHeight;

                var minLabelHeight = 7, minLabelWidth;
                var xPadding = 0, yPadding = 5;

                if (isNaN(mc3) || isNaN(mc4) || isNaN(mc5) || isNaN(mc6)) {
                    var err = mstrmojo.desc(10860, 'Insufficient data to plot the graph');
                    this.errorMsg.innerHTML = err;
                    this.errorMsg.style.display = 'block';
                    this.minLabel.style.display = "none";

                    this.tooltipErrMsg = err;
                    return;
                } else if (mc3 * mc4 > 0 && Math.abs(mc3) > Math.abs(mc4)) {
                    var err = mstrmojo.desc(10381, 'Metric of Butllet is out of the max graph range');
                    this.errorMsg.innerHTML = err;
                    this.errorMsg.style.display = 'block';
                    this.minLabel.style.display = "none";

                    this.tooltipErrMsg = err;
                    return;
                } else {
                    this.errorMsg.style.display = 'none';

                    this.tooltipErrMsg = null;
                }

                var xOri;
                var redComp, greenComp, blueComp;
                var mcOriX, mcOriY;
                var mcHeight, mcWidth;

                if (mc3 < 0 && mc4 > 0) {
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / (mc4 - mc3);
                    xOri = xPadding - mc3 * ratioBetweenMetricViewWidth;
                    bulletHeight = this.getHeight() - minLabelHeight - 2 * yPadding - 2;
                    
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        
                        if (mc6 > mc3 && mc6 < mc4) {
                            mcWidth = (mc6 - mc3) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor2;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        
                        if (mc5 > mc3 && mc5 < mc4) {
                            mcWidth = (mc5 - mc3) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor1;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = Math.abs(mc3) * ratioBetweenMetricViewWidth;
                    mcOriX = xPadding;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    
                    if (hasRefLine && mc7 > mc3 && mc7 < mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + mc7 * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }
                } else if (mc3 < 0 && mc4 < 0) {
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / (Math.abs(mc4));
                    xOri = xPadding;
                    bulletHeight = this.getHeight() - minLabelHeight - 2 * yPadding - 2;
                    isInverted = !isInverted;
                    
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        
                        if (mc6 < 0 && mc6 > mc4) {
                            mcWidth = Math.abs(mc6) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor2;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        
                        if (mc5 < 0 && mc5 > mc4) {
                            mcWidth = Math.abs(mc5) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor1;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = Math.abs(mc3) * ratioBetweenMetricViewWidth;
                    mcOriX = xPadding;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    
                    if (hasRefLine && mc7 < 0 && mc7 > mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + Math.abs(mc7) * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }
                } else if (mc3 > 0 && mc4 > 0) {
                    if (this.showMinLabel) {
                        yPadding = 9.5;
                    } else {
                        yPadding = 5;
                    }
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / mc4;
                    xOri = xPadding;
                    bulletHeight = this.getHeight() - 2 * yPadding;
                    
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        
                        if (mc6 > 0 && mc6 < mc4) {
                            mcWidth = mc6 * ratioBetweenMetricViewWidth;
                            mcOriX = xOri;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            ctx.fillStyle = this.bandColor2;
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        
                        if (mc5 > 0 && mc5 < mc4) {
                            mcWidth = mc5 * ratioBetweenMetricViewWidth;
                            mcOriX = xOri;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            ctx.fillStyle = this.bandColor1;
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = mc3 * ratioBetweenMetricViewWidth;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    mcOriX = xOri;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    
                    if (hasRefLine && mc7 > 0 && mc7 < mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + mc7 * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }

                } else {
                    
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / (mc3 - mc4);
                    bulletHeight = this.getHeight() - minLabelHeight - 2 * yPadding - 2;
                    xOri = xPadding - mc4 * ratioBetweenMetricViewWidth;
                    ;
                    isInverted = !isInverted;

                    
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        
                        if (mc6 < mc3 && mc6 > mc4) {
                            mcWidth = (mc3 - mc6) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                            ctx.fillStyle = this.bandColor2;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        
                        if (mc5 < mc3 && mc5 > mc4) {
                            mcWidth = (mc3 - mc5) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                            ctx.fillStyle = this.bandColor1;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = Math.abs(mc3) * ratioBetweenMetricViewWidth;
                    mcOriX = xOri;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    
                    if (hasRefLine && mc7 < mc3 && mc7 > mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + mc7 * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }
                }

                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                

                
                if (mc3 < 0) {
                    mcHeight = bulletHeight;
                    mcWidth = 2;
                    mcOriX = xOri;
                    mcOriY = yPadding;
                    redComp = 0;
                    greenComp = 0;
                    blueComp = 0;

                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }

                    ctx.fillStyle = "#000000";
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                    
                    minValue = minValue + "";
                    var disPlayValue = (minValue == "0") ? "" : "$";
                    var mlen = 0;
                    for (var i = 0; i < minValue.length; i++) {
                        if (minValue[i] == '.') {
                            break;
                        }
                        mlen++;
                    }
                    for (var i = 0; i < minValue.length; i++) {
                        disPlayValue += minValue[i];
                        mlen--;
                        if (mlen % 3 == 0 && mlen > 0) {
                            disPlayValue += ",";
                        }
                    }
                    minValue = disPlayValue;
                    var textWidth = this.widget.getTextWidthByCanvas(minValue, this.minLabel);

                    minLabelWidth = textWidth - 1;

                    mcOriX = xOri;

                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    if (mcOriX - minLabelWidth / 2 <= xPadding) {
                        this.minLabel.style.paddingLeft = xPadding;
                    } else if (mcOriX + minLabelWidth / 2 <= this.getWidth() - xPadding) {
                        this.minLabel.style.paddingLeft = Math.round(mcOriX - minLabelWidth / 2) + "px";
                    }
                    else {
                        this.minLabel.style.paddingLeft = Math.round((this.getWidth() - xPadding - minLabelWidth)) + "px";
                    }

                    this.minLabel.style.bottom = yPadding + "px";

                    
                    this.minLabel.style.fontSize = "7pt";
                    
                    if (this.labelColorRGB) {
                        this.minLabel.style.color = 'rgb(' + this.labelColorRGB[0] + ',' + this.labelColorRGB[1] + ',' + this.labelColorRGB[2] + ')';
                    } else {
                        this.minLabel.style.color = "";
                    }
                    this.minLabel.innerHTML = minValue;
                    this.minLabel.style.display = "block";

                } else {
                    this.minLabel.style.display = "none";
                }

            },

            convertColor: function convrtClr(ngv) {
                var ret = "#";
                var base = parseInt("0xff");
                var blueComp = ngv & base;
                base = parseInt("0xff00");
                var greenComp = ((ngv & base) >> 8);
                base = parseInt("0xff0000");
                var redComp = ((ngv & base) >> 16);
                var redP = redComp.toString(16);
                if (redP.length < 2) {
                    redP = "0" + redP;
                }

                var greenP = greenComp.toString(16);
                if (greenP.length < 2) {
                    greenP = "0" + greenP;
                }

                var blueP = blueComp.toString(16);
                if (blueP.length < 2) {
                    blueP = "0" + blueP;
                }
                ret += redP;
                ret += greenP;
                ret += blueP;
                return ret;
            },

            drawRect: function (ctx, x, y, width, height) {
                
                x = Math.round(x);
                y = Math.round(y);
                width = Math.round(width);
                height = Math.round(height);
                ctx.fillRect(x, y, width, height);
            },

            reDrawChart: function reDrwchart() {
                var context = this.context,
                    canvas = this.canvas,
                    wd = canvas.width,
                    ht = canvas.height;
                context.clearRect(0, 0, wd, ht);
                this.postBuildRendering();
            }
        }
    );

})();
(function () {

	mstrmojo.requiresCls("mstrmojo.Vis", "mstrmojo._TouchGestures", "mstrmojo.TouchScroller", "mstrmojo._HasTouchScroller", "mstrmojo.css");

	var $CSS = mstrmojo.css;
	
	var FONT_SIZE = 15;
	
	function getTouchedElement(touch) {
        var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode);
		
        return item || null;
    }
    
    function setScrollerPosition() {
		var scl = this._scroller;
	        
	    var realWidth =  this.timeSelectorListContainer.width;
		
		var realOffSetWidth = this.timeSelectorList.offsetWidth;
		if(realOffSetWidth > realWidth) {
			this.scrollPast = true;
		}
		var offsetEnd = realOffSetWidth > realWidth? realOffSetWidth - realWidth : 0;
	    scl.origin = {
				x: 0,
				y: 0
		};

		scl.showScrollbars = true;
		scl.noHScroll = false;
		scl.hScroll = (offsetEnd !== 0 && scl.noHScroll !== true) || this.scrollPast;

		if (scl.hScroll) {
			
			scl.offset = {
				x: {
					start: 0,
					end: offsetEnd
				},
				scrollPast: this.scrollPast
			};
		}
		var icn = this.timeSelectorList;
		this.widget.utils.translateCSS(0,0,false,icn);
		
	}
    
     
    mstrmojo.VisTimeSeriesTimeSelector = mstrmojo.declare(

    
    mstrmojo.Vis,

    
    [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

    {
        
        scriptClass: 'mstrmojo.VisTimeSeriesTimeSelector',

        
        scrollerConfig: {
            bounces: false,
            showScrollbars: true,
            useTranslate3d: true
        },

        
        scrollPast: false,
        
        isAndroidTab: false,
		
		offsetx: 0,
         
        widget:null,
        
        markupString: '<div id="{@id}-TimeSelector-Container" class="mstrmojo-timeseries-timeselector-div" style="position:absolute; left:{@offsetx}px; overflow:hidden;">' +
						'<div id="{@id}-TimeSelector-List" style="position:absolute;left:0;top:0"></div>' +
					'</div>' ,
			
        
        markupSlots: {
		
			timeSelectorListContainer: function(){return this.domNode;},
			
			timeSelectorList: function(){return this.domNode.firstChild;}
		
        },
        
        toggleSelected: function toggleSelected(el, selected){
        	if(!el){
        		return;
        	}
			var style = el.style;
			var ts = this.widget;
			var textClr = ts.utils.rgb2rgbStr(ts.formatProp.textClr);
			var bgClr = ts.utils.rgb2rgbStr(ts.formatProp.backgroundClr);
			if(selected){
				style.backgroundColor = textClr;
				style.color = bgClr;
			}else{
				style.backgroundColor = '';
				style.color = textClr;
			}
		},
		
        
        toggleGlowEffect: function toggleGlowEffect(el, glow){
        	if(!el){
        		return;
        	}
        	if(glow){
        		$CSS.applyShadow(el, 0, 0, 20, this.widget.glowColor );
        	}else{
        		$CSS.removeShadow(el);
        	}
        },
        
        drawTimeSelectorLabels: function drwtslbls() {
		    var tsl = this.widget.baseModel.vp.rl;
		    var chartStatus = this.chartStatus;
		    
		    if (tsl) {
		        var ts = this.widget,
		            mg = ts.margin,
		            utils = ts.utils,
		            width = ts.getWidth(),
		            totalWidth = 0;
		
		        
		        this.timeSelectorListContainer.width = width - mg.l - mg.r;
		        this.timeSelectorListContainer.style.width = (width - mg.l - mg.r) + 'px';
		        this.timeSelectorListContainer.style.height = mg.t + 'px';
		        
		        var d = tsl.length;
		
		        var x = (width - mg.l - mg.r) / (d + 1);
		
		        var id = ts.id,timeSelectorList = this.timeSelectorList;
		        
		        if(timeSelectorList.childNodes.length == 0){
		        	
		        	
		        	 ts.currSelection = null;
					for (var i = 0; i < d; i++) {
			            var lbl = document.createElement("div");
			            lbl.id = 'timeseries-intervals';
			            lbl.className = 'timeseries-intervals';
						
						lbl.style.fontWeight = "bold";
						lbl.style.fontFamily = "Arial";
						lbl.style.fontSize = FONT_SIZE + "px";
			            lbl.innerHTML = tsl[i].n;
			            lbl.setAttribute("clk", "S");
			            lbl.setAttribute("value", i);
			            lbl.style.position = 'relative';
			            lbl.style.whiteSpace = 'nowrap';
			            lbl.style.cssFloat = 'left';
			            
			            if (i === 0 && chartStatus.currSelectionIdx == -1 && !chartStatus.usingCustomInterval) {
			            	
			            	
			            	this.toggleSelected(lbl, true);			               
			                ts.currSelection = lbl;
			            } else if (!chartStatus.usingCustomInterval && chartStatus.currSelectionIdx == i) {
			            	
			            	
			            	this.toggleSelected(lbl, true);	
			                ts.currSelection = lbl;
			            }else{
			            	this.toggleSelected(lbl, false);	
			            }
			            
			            timeSelectorList.appendChild(lbl);
			
			            
			            offsetWidth = lbl.offsetWidth;
			            
			            totalWidth += offsetWidth;
			            
			            spaceWidth = offsetWidth < x? x - offsetWidth : 20;
			            
			            totalWidth += spaceWidth;
			            
			            if(i == 0){
							timeSelectorList.insertBefore(this.createWhiteSpace(spaceWidth) , timeSelectorList.firstChild);
							totalWidth += spaceWidth;
			            }
						timeSelectorList.appendChild(this.createWhiteSpace( spaceWidth ));
			        }
		        }else{
		        	
		        	var childNodes = timeSelectorList.childNodes;
		        	var childNodesLength = childNodes.length;
		        	for(var i = 0; i < childNodesLength; i ++){
		        		var lbl = childNodes[i];
		        		
			            offsetWidth = lbl.offsetWidth;
			            
			            totalWidth += offsetWidth;
						
						if (i == 0) {
							continue;
						}
			            
			            spaceWidth = offsetWidth < x? x - offsetWidth : 20;
			            
			            totalWidth += spaceWidth;
			            
			            if(i == 1){
			            	childNodes[0].style.paddingLeft = spaceWidth + 'px';
			            }
			            i++;
			            childNodes[i].style.paddingLeft = spaceWidth + 'px';
		        	}
		        }

		        
		        
		       this.timeSelectorList.style.width = totalWidth+'px';
		    }
	},

	postBuildRendering: function postBR() {
		
		FONT_SIZE = Math.round(15 * this.widget.utils.getScreenZoomFactor());
						
		this.scrollerConfig.scrollEl = this.timeSelectorList;
	
		if (this._super) {
			this._super();
		}

		this.drawTimeSelectorLabels();
	
	    setScrollerPosition.call(this);
	},
	
	
    reRender: function reRender() {   	
    	
    	this.drawTimeSelectorLabels();
    	
	    setScrollerPosition.call(this);
    },
	
	createWhiteSpace: function crtWhtSpc(w){
		var spaceDiv = document.createElement("div");
		spaceDiv.style.height = '30px';
		spaceDiv.style.position = 'relative';
		spaceDiv.style.whiteSpace = 'nowrap';
		spaceDiv.style.cssFloat = 'left';
		spaceDiv.style.paddingLeft = w + 'px';
		return spaceDiv;
	},

	initScroller: function initScroller(scroller) {
			scroller.hScroll = true;

			this._super(scroller);
	},
		
	touchBegin: function touchBegin(touch) {
		
		this.widget.hiddenTooltipAndShowTimeSelector();
	    
	},   
    
    touchSelectEnd: function touchEnd(touch) {	    
    	var currSelection = this.widget.currSelection;
    	if(currSelection){
    		this.toggleGlowEffect(currSelection, false);   
    	}
		
    },
    
    touchSelectBegin: function touchSelectBegin(touch) {
    	var item = getTouchedElement.call(this, touch);
		if (item) {
			var value = item.value;
			if (value === 'S'){
				this.widget.timeSelectorOnClick(item);
			}
		} 
    },
    
    touchTap: function touchTap(touch) {
    	var item = getTouchedElement.call(this, touch);
		if (item) {
			var value = item.value;
			if (value === 'S'){
				this.widget.timeSelectorOnClick(item);
			}
		} 
		this.toggleGlowEffect(this.widget.currSelection, false);   
    },
    
	destroy: function destroy() {
		if(this._super){
			 this._super();
		}
		
	}
    
    
    });

})();
(function () {

	mstrmojo.requiresCls( "mstrmojo.Vis", "mstrmojo._TouchGestures", "mstrmojo.TouchScroller", "mstrmojo._HasTouchScroller");

	var legendFontFamily = "Helvetica",
		legendFontStyle = "bold 14px Helvetica",
		legendFontStyleHighlight = "bold 20px Helvetica",
		legendSwitcherBarHeight = 30,
		zf = 1;

	function resetSizeByDPI(zoomfactor){
		zf = zoomfactor;
		legendFontStyle = "bold "+ Math.round(14*zf)+"px Helvetica";
		legendFontStyleHighlight = "bold "+Math.round(20*zf)+"px Helvetica";
		legendSwitcherBarHeight = Math.round(30*zf)
	}

	function getTouchedElement(touch) {
        var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode);
        return item || null;
    }

    function setScrollerPosition() {
		var scl = this._scroller;

		var realHeight = this.height - this.legendBarSwitcher.height - 15*zf;

		var realOffSetHeight = this.legendListDiv.offsetHeight;
		if(realOffSetHeight > realHeight) {
			this.scrollPast = true;
		}
		var offsetEnd = realOffSetHeight > realHeight? realOffSetHeight - realHeight : 0;
		scl.origin = {
				x: 0,
				y: 0
		};

		scl.showScrollbars = true;
		scl.noVScroll = false;
		scl.vScroll = (offsetEnd !== 0 && scl.noVScroll !== true) || this.scrollPast;

		if (scl.vScroll) {

			scl.offset = {
					y: {
				start: 0,
				end: offsetEnd
			},
			scrollPast: this.scrollPast
			};
		}
		var icn = this.legendListDiv;
		this.utils.translateCSS(0,0,false,icn);
	}

     
    mstrmojo.VisTimeSeriesLegend = mstrmojo.declare(

    
    mstrmojo.Vis,

    
    [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

    {
        
        scriptClass: 'mstrmojo.VisTimeSeriesLegend',

        
        scrollerConfig: {
            bounces: false,
            showScrollbars: true,
            useTranslate3d: true
        },

         
        multiTouch: true,

        
        scrollPast: false,
        
        isAndroidTab: false,

		  
		legendBarWidth : 30,

		  
		isLegendBarOpen : false,

	      
         isLegendSelected:false,
	        	 
         legendSelectedIndex:-1,

         maxLegendAttrLength:0,
         
         widget:null,
        
         y_axis_interval: 25,
        
        markupString: '<div id="{@id}-legend-bar" style="position:absolute;top:{@top};right:{@right};z-index:{@zIndex};" >' +
							'<div id="{@id}-legend-switcher" class="mstrmojo-timeseries-legend-switcher" clk="S">'+
								'<canvas id="{@id}-legend-triangle" width="15px" height="17px" style="position:absolute;" ></canvas>' +
								'<div id="{@id}-legend-shadow" class="timeseries-legend-switcher-shadow" style="height:0px; width:0px;position:absolute"></div>' +
							'</div>' +
							'<div class="mstrmojo-timeseries-legend-List-Div" style="overflow:hidden;">' +
								'<div id="{@id}-legend-List" ></div>' +
							'</div>' +
							'<canvas style="z-index:-1;" clk="C"></canvas>' +
						'</div>' ,

        
        markupSlots: {
		
		legendBarDiv: function(){return this.domNode;},

		
		legendBarSwitcher: function(){return this.domNode.firstChild;},

		triangle: function(){return this.domNode.firstChild.firstChild;},

		
		legendListDivContainer: function(){return this.domNode.childNodes[1];},
		
		legendListDiv: function(){return this.domNode.childNodes[1].firstChild;},

		
		legendCanvas: function(){return this.domNode.childNodes[2];}
        },

		switchLegendBar : function switchLegendBar(){
		    this.isLegendBarOpen = !this.isLegendBarOpen;

		    this.calculateAndSetLegendWidth();

		    this.widget.reDrawSlaveChartImpl();

		    this.renderLegend(true);

		     setScrollerPosition.call(this);
		},

		enableLegendGlowEffect: function enableLegendGlowEffect(index,clr){
			 var selectedLegend = this.legendListDiv.childNodes[index];
			 var color = clr || selectedLegend.style.color;
			 selectedLegend.style.textShadow = color + '0px 0px 8px';
			 selectedLegend.style.font = legendFontStyleHighlight;
		},

		hiddenLegendGlowEffect: function hiddenLegendGlowEffect(index){
			var selectedLegend = this.legendListDiv.childNodes[index];
			selectedLegend.style.textShadow = 'none';
			selectedLegend.style.font = legendFontStyle;
		},

		toggleTriangle: function toggleTriangle(open){
			var canvas = this.triangle,
				tStyle = canvas.style,
				cntx = canvas.getContext('2d'),
				ts = this.widget;

			var triH = Math.round(17*zf),
				triW = Math.round(15*zf);
			
			canvas.height = triH;
			canvas.width = triW;

			tStyle.top = Math.round(7*zf) + 'px';
			tStyle.left = Math.round(8*zf) + 'px';

			cntx.save();
			cntx.fillStyle =  ts.utils.rgb2rgbStr(ts.formatProp.textClr, 0.75);

			cntx.beginPath();
			if(open){
				cntx.moveTo(0,0);
				cntx.lineTo(triW, triH/2);
				cntx.lineTo(0, triH);
				cntx.lineTo(0,0);
			}else{
				cntx.moveTo(0,triH/2);
				cntx.lineTo(triW, 0);
				cntx.lineTo(triW, triH);
				cntx.lineTo(0,triH/2);
			}

			cntx.closePath();
			cntx.fill();
			cntx.restore();
		},

		renderLegend: function renderLegend(hasGlowEffect) {
			var model = this.model,
				s = model.series,
				sl = s && s.length || 0,
				h = this.height,
				utils = this.utils,
				ch = model.colHeaders,
				lc = this.legendCanvas.getContext('2d'),
				legendListDiv = this.legendListDiv,
				legendBarSwitcher = this.legendBarSwitcher;


			this.legendBarDiv.style.width = this.legendBarWidth + 'px';
			this.legendBarDiv.style.height = h + 'px';
			legendListDiv.style.width = this.legendBarWidth+ 'px';

			legendBarSwitcher.width = this.legendBarWidth;
			legendBarSwitcher.height = legendSwitcherBarHeight;
			legendBarSwitcher.style.width = this.legendBarWidth + 'px';

			this.legendCanvas.width = this.legendBarWidth;
			this.legendCanvas.height = h;

			if(this.isLegendSelected && this.legendSelectedIndex >= sl){
			
				 this.legendSelectedIndex = 0;
				 this.widget.setLegendSelected(this.isLegendSelected,this.legendSelectedIndex);
			 }

			if(legendListDiv.childNodes.length == 0){
				
				for(var i = 0; i < sl; i++){
					var legendAttr = document.createElement("div");
					legendAttr.id = 'legendAttr'+i;

					legendAttr.style.font = legendFontStyle;
					legendAttr.className = 'timeseries-legendAttr';
					legendAttr.innerHTML = this.widget.getLegendName(ch,s,i);
					legendAttr.setAttribute("clk", "LA");
					legendAttr.setAttribute("vIndex",i);
					legendAttr.style.color = this.widget.getSerieColor(i) ;

					legendListDiv.appendChild(legendAttr);
					utils.changeElementSize(legendAttr,'height', utils.getScreenZoomFactor());
				}
				this.y_axis_interval = Math.max(legendAttr.offsetHeight, 25);

			}


			if(this.isLegendBarOpen){
				this.toggleTriangle(true);
				legendListDiv.style.display = 'block';

				
				this.legendListDivContainer.style.height = (h - legendBarSwitcher.height - 15*zf) + "px";
				this.legendListDivContainer.style.weight = this.legendBarWidth +"px";
				this._scroller.updateScrollBars();
				this.utils.translateCSS(0,legendBarSwitcher.height,false,this.legendListDivContainer);

				if(this.isLegendSelected){
					this.enableLegendGlowEffect(this.legendSelectedIndex);
				}
				 
				this.legendCanvas.height = h ;
				this.legendCanvas.style.position = "absolute";
				this.legendCanvas.style.top = "0px";
				this.legendCanvas.style.left = "0px";

				this.drawLegendOutline(h, legendBarSwitcher.height, lc);
			 }
			 else{
				this.toggleTriangle(false);

				legendListDiv.style.display = 'none';

				
				this.legendCanvas.height = h ;
				this.legendCanvas.style.position = "absolute";
				this.legendCanvas.style.top = "0px";
				this.legendCanvas.style.left = "0px";

				this.drawLegendOutline(h, legendBarSwitcher.height, lc);
				lc.save();
				var x = this.legendBarWidth/2;
				var y = this.y_axis_interval / 2;
				var r = Math.round(5*zf);

				
				for(var i = 0; i < sl && y+this.y_axis_interval< h-15*zf; i++){
					lc.fillStyle = this.widget.getSerieColor(i);
					y +=this.y_axis_interval;
					utils.drawArc(this, x, y, r, 0, Math.PI * 2, true, true, lc);
				}
				lc.restore();

			 }
			 var glowDiv = this.legendBarSwitcher.lastChild;
			 if(hasGlowEffect){
			 	glowDiv.className = "timeseries-legend-switcher-shadow";
			 	glowDiv.style.left = Math.round(15*zf) + 'px';
				glowDiv.style.top = Math.round(15*zf) + 'px';
				glowDiv.style.display = "";
				glowDiv.style.visibility = "visible"
			 }
			 else{
			 	glowDiv.className = "";
			 	glowDiv.style.visibility = "hidden";
			 }
		},

		
        reRender: function reRender() {
        	
        	this.calculateAndSetLegendWidth();

        	this.height = this.calculateHeight();

        	this.renderLegend(false);

        	this.legendBarDiv.style.top = this.widget.margin.t + "px";

		    setScrollerPosition.call(this);
        },

		hiddenSwitcherArrowGlowEffect: function hiddenSwitcherArrowGlowEffect(){
        	var glowDiv = this.legendBarSwitcher.lastChild;
        	
        	glowDiv.innerHTML = "";
        	glowDiv.style.visibility = "hidden";
        },

        drawLegendOutline: function drawLegendOutline(totalH, switcherH, context){
        	var utils = this.utils,
        		formatProp = this.widget.formatProp;

        	context.save();

        	context.globalAlpha = 1;
        	context.strokeStyle = utils.rgb2rgbStr(formatProp.textClr, 0.5) || '#58595B';
        	context.lineWidth = 2;
        	
			utils.drawHalfRoundedRectangle(this, 1, 1, this.legendBarWidth, totalH-2, Math.round(15*zf), false, context);

			var gradient = context.createLinearGradient(0, 0, this.legendBarWidth - 2, 0);
			var topGradient = utils.rgb2rgbStr(formatProp.textClr, 0.5) || '#58595B';
			var bottomGradient = utils.rgb2rgbStr(formatProp.textClr, 0.13) || '#222222';
			gradient.addColorStop(0, topGradient);
        	gradient.addColorStop(1, bottomGradient);
        	context.strokeStyle = gradient;
			context.lineWidth = 1;
			var yPos = switcherH - 0.5;
			utils.drawLineSet(this, [{
				x: 2,
				y: yPos
			}, {
				x: this.legendBarWidth,
				y: yPos
			}], false, context);

			context.restore();
        },

		calculateMaxLegendAttrLength: function calculateMaxLegendAttrLength( useHighlightFontStyle ){
			var model = this.model,
				s = model.series,
				sl = s.length,
				ch = model.colHeaders;
			for(var i = 0; i < sl; i++){
				 var tmpLegendLength = 0;
				 var legendName = this.widget.getLegendName(ch,s,i);
				 var fontStyle = useHighlightFontStyle ? legendFontStyleHighlight  : legendFontStyle ;
				 tmpLegendLength = this.widget.getTextWidth(legendName,fontStyle);
				 this.maxLegendAttrLength = Math.max(this.maxLegendAttrLength,tmpLegendLength);
			 }
			 
			 this.maxLegendAttrLength = this.maxLegendAttrLength + 10;
		},

		calculateAndSetLegendWidth: function cLegendWidth(){

			if(this.isLegendBarOpen){
				var maxLegendBarWidth = (this.widget.getWidth() - 50)*0.3+20;
				this.legendBarWidth = Math.min(maxLegendBarWidth, this.maxLegendAttrLength);
		    }
		    else{
		    	this.legendBarWidth = Math.round(40*zf);
		    }
			this.widget.setlegendStatus(this.isLegendBarOpen, this.legendBarWidth);
		},

		calculateHeight: function cHeight(){
			var m = this.widget.margin;
			return this.widget.getHeight() - this.widget.masterChartHeight - m.t - m.b;
		},

		postBuildRendering: function postBR() {
			resetSizeByDPI(this.utils.getScreenZoomFactor());

			this.height = this.calculateHeight();

			
			var sLength = this.model.series && this.model.series.length;
			if(sLength == 1){
				 this.isLegendSelected = true;
				 this.legendSelectedIndex = 0;
				 this.widget.setLegendSelected(this.isLegendSelected,this.legendSelectedIndex);
			}

			this.calculateMaxLegendAttrLength(sLength == 1);

			this.calculateAndSetLegendWidth();

			this.scrollerConfig.scrollEl = this.legendListDiv;

			if (this._super) {
				this._super();
			}

			this.renderLegend(false);

		    setScrollerPosition.call(this);

		  
		},

		 initScroller: function initScroller(scroller) {
			scroller.vScroll = true;

			this._super(scroller);
		},

		touchBegin: function touchBegin(touch) {
			
		 	this.widget.hiddenTooltipAndShowTimeSelector();
		    
		    var item = getTouchedElement.call(this, touch);
		    if (item) {
				var value = item.value;

				if (value === 'S' ){
					this.switchLegendBar();
				}else if(!this.isLegendBarOpen && value === 'C'){
					
					this.switchLegendBar();
				}

		    }
		},

		touchTap: function touchTap(touch) {

		    
		    var item = getTouchedElement.call(this, touch);
		    if (item) {
				var value = item.value;
				if(value === 'LA'){
					var itemIndex = mstrmojo.dom.findAncestorByAttr(touch.target, "vIndex", true, this.domNode);
					if(itemIndex){
						this.handleLegendItemTap(parseInt(itemIndex.value, 10));
					}
				}
		    }
		},

		touchEnd: function touchEnd(touch) {
	    	var me = this;

            me.hiddenSwitcherArrowGlowEffect();


	    },

		touchSelectBegin: function touchSelectBegin(touch) {
			var item = getTouchedElement.call(this, touch);
			if (item) {
				var value = item.value;
				if (value === 'LA' ){
					var itemIndex = mstrmojo.dom.findAncestorByAttr(touch.target, "vIndex", true, this.domNode);
					if(itemIndex){
						var fontStyle = (itemIndex.value == this.legendSelectedIndex)? legendFontStyleHighlight  : legendFontStyle ;
						var tmpItemLength = this.widget.getTextWidth(item.node.innerHTML, fontStyle);

						
						if(tmpItemLength > this.legendBarWidth - 12){
						
							var tooltipY = item.node.offsetTop -this._scroller.origin.y + this.widget.margin.t + this.legendBarSwitcher.height -5;
							this.widget.showLegendTooltip(item.node);
						}
					}
				}
			}
		},

		touchSelectEnd: function touchSelectEnd(touch) {
			this.widget.hiddenLegendTooltip();
			
	
		},

		touchMultiBegin: function touchMultiBegin(touch){
			this.touchSelectEnd(touch);
		},

		onCrossWidgetMultitouch: function onCrossWidgetMultitouch(){
			this.widget.hiddenLegendTooltip();
			this.hiddenSwitcherArrowGlowEffect();
		},

		handleLegendItemTap:function handleLegendItemTap(vIndex){
			
			if(this.model.series.length == 1){
				return;
			}
			if(this.isLegendSelected){
				if( this.legendSelectedIndex === vIndex){
					this.isLegendSelected  =  false;
					this.hiddenLegendGlowEffect(vIndex);
					this.legendSelectedIndex  = -1;
				}else{
					this.hiddenLegendGlowEffect(this.legendSelectedIndex);
					this.legendSelectedIndex =  vIndex;
					this.enableLegendGlowEffect(vIndex);
				}
			}else{
				this.isLegendSelected = true;
				this.legendSelectedIndex =  vIndex;
				this.enableLegendGlowEffect(vIndex);

			}
			this.widget.setLegendSelected(this.isLegendSelected,this.legendSelectedIndex);
			this.widget.reDrawSlaveChart();
		},

		destroy: function destroy() {
			if(this._super){
				 this._super();
			}
		}

    });

})();
(function() {

	mstrmojo.requiresCls("mstrmojo.Vis",
			"mstrmojo.VisChartUtils",
			"mstrmojo._TouchGestures",
			"mstrmojo._HasTouchScroller",
			"mstrmojo.color",
			"mstrmojo.array",
			"mstrmojo.css" );


	var browserSupportsHtml5 = true;

	var DISPLAY_MODE_AUTOMATIC = "0",
		DISPLAY_MODE_AREA = "1",
		DISPLAY_MODE_BUBBLE = "2";

	var MARKER_UNDEFINED = 0,
		MARKER_IMAGE = 1,
		MARKER_BUBBLE = 2;

	var SHAPE_FILE_UNDEFINED = 0,
		SHAPE_FILE_POLYGON = 1,
		SHAPE_FILE_POINT = 2;

	var THRESHOLD_UNDEFINED = 0,
		THRESHOLD_COLOR = 1,
		THRESHOLD_IMAGE = 2;

	var SIZE_MODE_AUTOMATIC = 0,
		SIZE_MODE_MANUAL = 1;
	
	
	var MAX_RATIO_UP_LIMIT = 1.0,
		MAX_RATIO_LOW_LIMIT = 0.01;
	
	var MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER = 0.3,
		MAX_SIZE_DEFAULT_RATIO_FOR_AUTOMATIC = 0.3,
		MAX_SIZE_DEFAULT_RATIO_FOR_MANUAL = 0.3;

	var HIGHLIGHT_MODE_NORMAL = 0,
		HIGHLIGHT_MODE_HOVER = 1,
		HIGHLIGHT_MODE_SELECTED = 2;

	var THEME_DARK = 0,
		THEME_LIGHT = 1;
		
	var DRILLING_ACTION = 1,
		SELECTOR_ACTION = 2,
		HYPERLINK_ACTION = 4;
		
	var ROW_AXIS = 1,
		COL_AXIS = 2;

	var DEFAULT_BG_COLOR = "#FFFFFF";

	var POLY_COLOR_NO_ALT_DARK_THEME = "RGBA(139,139,139,0.8)", 
		POLY_COLOR_NO_COLORBY_DARK_THEME = "RGBA(33,195,255,0.8)", 
		POLY_COLOR_NO_ALT_LIGHT_THEME = "RGBA(195,195,195,0.8)", 
		POLY_COLOR_NO_COLORBY_LIGHT_THEME = "RGBA(112,168,207,0.8)", 
		POLY_STROKE_COLOR_DARK_THEME = "#4C4C4C",
		POLY_STROKE_COLOR_LIGHT_THEME = "#FFFFFF",
		POLY_NORMAL_OPACITY = 0.8,
		POLY_ABOVE_BG_OPACITY = 0.7,
		POLY_UNDER_BUBBLE_OPACITY = 1,
		POLY_HOVER_OPACITY = 0.5,
		POLY_LINKDRILL_OPACITY = 0.5,
		POLY_SELECTED_OPACITY_WITHOUT_BG = 1,
		POLY_SELECTED_OPACITY_WITH_BG = 0.7,
		POLY_UNSELECTED_OPACITY = 0.5,
		POLY_SELECTED_HOVER_OPACITY_WITH_BG = 0.7,
		POLY_SELECTED_HOVER_OPACITY_WITHOUT_BG = 1,
		POLY_STROKE_COLOR_HOVER_DARK_THEME = "#FFFFFF",
		POLY_STROKE_COLOR_HOVER_LIGHT_THEME = "#000000",
		POLY_STROKE_COLOR_LINKDRILL_DARK_THEME = "#FFFFFF",
		POLY_STROKE_COLOR_LINKDRILL_LIGHT_THEME = "#000000",
		POLY_STROKE_COLOR_SELECTED_DARK_THEME = "#FFFFFF",
		POLY_STROKE_COLOR_SELECTED_LIGHT_THEME = "#000000",
		POLY_STROKE_COLOR_SELECTED_HOVER_DARK_THEME = "RGBA(0,0,0,0)",
		POLY_STROKE_COLOR_SELECTED_HOVER_LIGHT_THEME = "RGBA(0,0,0,0)",
	
		BUBBLE_COLOR_NO_COLORBY_DARK_THEME = "RGBA(33,195,255,0.8)", 
		BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME = "RGBA(31,119,180,0.8)", 
		BUBBLE_STROKE_COLOR_DARK_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_STROKE_COLOR_LIGHT_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_NORMAL_OPACITY = 0.8,
		BUBBLE_HOVER_OPACITY = 0.5,
		BUBBLE_SELECTED_OPACITY = 1,
		BUBBLE_LINKDRILL_OPACITY = 0.8,
		BUBBLE_STROKE_COLOR_HOVER_DARK_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_STROKE_COLOR_HOVER_LIGHT_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_STROKE_COLOR_LINKDRILL_DARK_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_STROKE_COLOR_LINKDRILL_LIGHT_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_STROKE_COLOR_SELECTED_DARK_THEME = "RGBA(255,255,255,0.8)", 
		BUBBLE_STROKE_COLOR_SELECTED_LIGHT_THEME = "RGBA(0,0,0,0.8)", 
		BUBBLE_HIGHLIGHT_STROKE_COLOR_DARK_THEME = "#FFFFFF",
		BUBBLE_HIGHLIGHT_STROKE_COLOR_LIGHT_THEME = "#000000";
	

	
	var ERROR_MSG_FONT_COLOR_DARK_THEME = "#FFF",
		ERROR_MSG_FONT_COLOR_LIGHT_THEME = "#000";
	
	
	var RENDERING_TIME = 300;
	
	
	
	function isOwnEmpty(obj) {
		var name;
		for (name in obj) {
			if(obj.hasOwnProperty(name)) {
				return false;
			}
		}
		return true;
	}
	
	
	function getLighterColor(c) {
		
		var rgb = mstrmojo.color.hex2rgb(c);
		mstrmojo.array.forEach(rgb, function (v, idx) {
			
			rgb[idx] = Math.floor(v * 0.75);
		});

		return 'rgb(' + rgb.join(',') + ')';
	}

	
	function positionTooltip(tooltip, touchX, touchY) {
		var tooltipStyle = tooltip.style,
			translateValue = 'translate(' + touchX + 'px, ' + touchY + 'px)',
			translateValue3d = translateValue.replace('late(', 'late3d(').replace('px)', 'px, 0)');

		tooltipStyle.MozTransform = translateValue;
		tooltipStyle.msTransform = translateValue;
		tooltipStyle.webkitTransform = translateValue3d;
		tooltipStyle.transform = translateValue3d;
	}

	
	function inPoly(poly, px, py) {
		var npoints = poly.length, 
			inside = false,
			xnew,
			ynew,
			xold,
			yold,
			x1,
			y1,
			x2,
			y2,
			i;

		if (npoints / 2 < 3) { 
			return false;
		}

		xold = poly[npoints - 2];
		yold = poly[npoints - 1];

		for (i = 0; i < npoints; i = i + 2) {
			xnew = poly[i];
			ynew = poly[i + 1];

			if (xnew > xold) {
				x1 = xold;
				x2 = xnew;
				y1 = yold;
				y2 = ynew;
			} else {
				x1 = xnew;
				x2 = xold;
				y1 = ynew;
				y2 = yold;
			}
			if ((xnew < px) === (px <= xold) && ((py - y1) * (x2 - x1) < (y2 - y1) * (px - x1))) {
				inside = !inside;
			}

			xold = xnew;
			yold = ynew;
		}

		return inside;
	}
	
	
	function drawPoly(ctx, coordsArray, offset, strokeColor, strokeWidth, fillColor) {
		try {
			var offsetX = offset ? offset.x : 0,
				offsetY = offset ? offset.y : 0;
			
			var getPointAt = function(j){
				var offset = j%2  ? offsetY : offsetX;
				return pointsArray[j] + offset;
			};
			
			var i, j;
			for (i = 0; i < coordsArray.length; i++) {
				var pointsArray = coordsArray[i];

				ctx.beginPath();
				ctx.moveTo(getPointAt(0), getPointAt(1));

				for (j = 2; j < pointsArray.length - 1; j = j + 2) {
					var xx = getPointAt(j),
						yy = getPointAt(j + 1);

					ctx.lineTo(xx, yy);

				}
				
				
				var x = getPointAt(0),
					y = getPointAt(1),
					fillStyle = fillColor;
				
				ctx.lineTo(x, y);
				ctx.fillStyle = fillStyle;
				ctx.fill();
				ctx.strokeStyle = strokeColor;
				ctx.lineWidth = strokeWidth;
				ctx.stroke();
			}
		} catch (e) {
			
		}
	}

	
	function drawBubble(context, pt, offset, color, radius) {
		context.fillStyle = color;
		context.beginPath();
		context.arc(pt[0] + offset.x, pt[1] + offset.y, radius, 0, Math.PI * 2, true);
		context.closePath();
		context.fill();
	}

	
	function drawStroke(context, pt, offset, color, radius, strokeWidth) {
		context.strokeStyle = color;
		context.lineWidth = strokeWidth;
		context.beginPath();
		context.arc(pt[0] + offset.x, pt[1] + offset.y, radius, 0, Math.PI * 2, true);
		context.closePath();
		context.stroke();
	}

	
	function getShapeFileType(coords) {
		if (coords) {
			var elem;
			for (elem in coords) {
				if (coords.hasOwnProperty(elem)) {
					if (elem === "bgImage") {
						continue;
					}
					if (coords[elem][0]) {
						if (coords[elem][0].length === 2) {
							return SHAPE_FILE_POINT;
						} else if (coords[elem][0].length > 2) {
							return SHAPE_FILE_POLYGON;
						} else {
							return SHAPE_FILE_UNDEFINED;
						}
					} else {
						return SHAPE_FILE_UNDEFINED;
					}
				}				
			}
		} else {
			return SHAPE_FILE_UNDEFINED;
		}
		
	}


	
	function getPolygonCenter(pointsArr) {
		var sumX=0,
			sumY=0
			i;
		for (i=0; i<pointsArr.length; i++) {
			sumX = sumX + pointsArr[i];
			i++;
			sumY = sumY + pointsArr[i];
		}
		var centerX = sumX / (pointsArr.length/2),
			centerY = sumY / (pointsArr.length/2),
			center1 = [centerX, centerY]
			center2 = [];
		center2.push(center1);
		
		return center2;
	}
	
	
	function getCentroidOfPolygon(points) {
		if (points == null || points.length < 4) {
			return null;
		}

		var area = 0,
			len = points.length,
			i,
			px,
			py,
			p2x,
			p2y;

		for (i=0; i<len-2; i+=2) {
			px = points[i];
			py = points[i+1];
			p2x = points[i+2];
			p2y = points[i+3];
	
			area += (px * p2y - p2x * py);
		} 
		px = points[len-2];
		py = points[len-1];
		p2x = points[0];
		p2y = points[1];
		area += (px * p2y - p2x * py);
		area = Math.abs(area / 2.0);

		if (area <= 0) {
			return null;
		}

		var centroid = [0, 0];
		for (i=0; i<len-2; i+=2) {
			px = points[i];
			py = points[i+1];
			p2x = points[i+2];
			p2y = points[i+3];
			centroid[0] += ((px + p2x) * (px * p2y - p2x * py));
			centroid[1] += ((py + p2y) * (px * p2y - p2x * py));
		}
		px = points[len-2];
		py = points[len-1];
		p2x = points[0];
		p2y = points[1];
		centroid[0] += ((px + p2x) * (px * p2y - p2x * py));
		centroid[1] += ((py + p2y) * (px * p2y - p2x * py));

		centroid = [Math.abs(centroid[0] / (area * 6.0)), Math.abs(centroid[1] / (area * 6.0))];
		
		var two_dim_centroid = [];
		two_dim_centroid.push(centroid);

		return two_dim_centroid;
	}

		
	function getOpacityColor(color, opacity) {
		var opacityColor,
			i;
		var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
		if (color) {
			var colorNew;
			if (/^(rgba|RGBA)/.test(color)) {
				var tempColor = color.replace(/rgba\(|RGBA\(/, "");
				tempColor = tempColor.replace(")", "");
				colorNew = tempColor.split(",");
				opacityColor = "RGBA(" + colorNew[0] + "," + colorNew[1] + "," + colorNew[2] + "," + opacity + ")";
				return opacityColor;
			} else if (/^(rgb|RGB)/.test(color)) {
				colorNew = color.replace(/rgb\(|RGB\(/, "");
				colorNew = colorNew.replace(")", "");
				opacityColor = "RGBA(" + colorNew + "," + opacity + ")";
				return opacityColor;
			} else if (reg.test(color)) {
				if (color.length === 4) {
					colorNew = "#";
					for (i=1; i<4; i++) {
						colorNew += color.slice(i,i+1).concat(color.slice(i,i+1));
					}
					color = colorNew;
				}
				var colorChange = [];
				for (i=1; i<7; i+=2) {
					colorChange.push(parseInt("0x" + color.slice(i,i+2)));
				}
				colorChange.push(opacity);
				opacityColor = "RGBA(" + colorChange.join(",") + ")";
				return opacityColor;
			} else {
				return color;
			}
		} else {
			return null;
		}
		
	}
	

	
	
	function getThemeMode(color) {
		var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/,
			i,
			r,
			g,
			b,
			brightness;
		if (color) {
			var colorNew,
				tempColor;
			if (/^(rgba|RGBA)/.test(color)) {
				tempColor = color.replace(/rgba\(|RGBA\(/, "");
				tempColor = tempColor.replace(")", "");
				colorNew = tempColor.split(",");
				r = colorNew[0];
				g = colorNew[1];
				b = colorNew[2];
			} else if (/^(rgb|RGB)/.test(color)) {
				tempColor = color.replace(/rgb\(|RGB\(/, "");
				tempColor = tempColor.replace(")", "");
				colorNew = tempColor.split(",");
				r = colorNew[0];
				g = colorNew[1];
				b = colorNew[2];
			} else if (reg.test(color)) {
				if (color.length === 4) {
					colorNew = "#";
					for (i=1; i<4; i++) {
						colorNew += color.slice(i,i+1).concat(color.slice(i,i+1));
					}
					color = colorNew;
				}
				var colorChange = [];
				for (i=1; i<7; i+=2) {
					colorChange.push(parseInt("0x" + color.slice(i,i+2)));
				}
				r = colorChange[0];
				g = colorChange[1];
				b = colorChange[2];
			} else {
				return THEME_DARK;
			}
			
			brightness = (r*299 + g*587 + b*114) / 1000;
			if (brightness > 150) {
				return THEME_LIGHT;
			} else {
				return THEME_DARK;
			}
		} else {
			return THEME_DARK;
		}
	}
	
	
	
	function drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height) {
		hlContext.strokeStyle = "#FFF";
		hlContext.lineWidth = 2;
		hlContext.beginPath();
		hlContext.moveTo(xOffset+width*0.25, yOffset);
		hlContext.lineTo(xOffset, yOffset);
		hlContext.lineTo(xOffset, yOffset+height*0.25);
		hlContext.moveTo(xOffset, yOffset+height*0.75);
		hlContext.lineTo(xOffset, yOffset+height);
		hlContext.lineTo(xOffset+width*0.25, yOffset+height);
		hlContext.moveTo(xOffset+width*0.75, yOffset+height);
		hlContext.lineTo(xOffset+width, yOffset+height);
		hlContext.lineTo(xOffset+width, yOffset+height*0.75);
		hlContext.moveTo(xOffset+width, yOffset+height*0.25);
		hlContext.lineTo(xOffset+width, yOffset);
		hlContext.lineTo(xOffset+width*0.75, yOffset);
		hlContext.stroke();
		hlContext.closePath();
	}
	
	
	
	


	mstrmojo.AndroidVisMap = mstrmojo.declare(

			mstrmojo.Vis,

			[mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

			{

				scriptClass: 'mstrmojo.AndroidVisMap',
				
				
				model: null,

				
				utils: mstrmojo.VisChartUtils,  
				
				scrollerConfig : {
					bounces : false,
					showScrollbars : false,
					useTranslate3d : true,
					vScroll: true,
					hScroll: true,
					offset : {
							y: {
								start: 0,
								end: 0
							},
							x: {
								start: 0,
								end: 0
							}
					},
					origin: {
						x: 0,
						y: 0
					}
				},
				
				
				relScaleFactor: 1, 
				
				
				scaleFactor: 1,
				
				
				currSelectedObj: null,
				
				
				defaultSelectedObjs: {},
				
				
				currHoverObj: null,
				
				
				currLinkObj: null,
				
				
				tooltipOn: false,
				
				
				context: null,
				
				
				multiTap: true,
				
				
				multiTouch: true,

				browserSupportsHtml5: true,
				

				
				markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};z-index:{@zIndex};position:absolute;{@cssText};overflow:hidden;" ' +
									' mstrAttach:mouseover,mousemove >' +
									
									'<div id="{@id}"-scroll-element style="position:absolute;left:0;top:0;width:{@width};height={@height}">' +
										'<canvas id="{@id}-highlightCanvas" style="position:absolute;left:0;top:0;z-index:100" width="{@width}" height="{@height}"></canvas>' +
										'<canvas id="{@id}-animationCanvas" style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>'+
									'</div>'+
									'<div id="{@id}-tooltip" style="z-index:200" class="mstrmojo-ImageLayout-tooltip" clk="clk"><table style="margin:5px 7px"></table></div>' +
									'<div id="{@id}-infowindow-anchor" style="position:absolute;width:18px;height:18px;display:block"></div>'+
									'<div id="{@id}-css" style="display:none"></div>'+
									'<div id="{@id}-errMsg" align="center" style="position:absolute; z-index:300; top:35%; word-wrap:break-word;"></div>'+
								'</div>',

				
				markupSlots: {
					
					
					
					
					scrollableCanvasDiv: function () { return this.domNode.childNodes[0]; },

					
					highlightCanvas: function () { return this.domNode.childNodes[0].firstChild; },

					
					animationCanvas: function () { return this.domNode.childNodes[0].lastChild; },

					
					tooltip: function () { return this.domNode.childNodes[1]; },
					
					
					infowindowAnchor: function() {return this.domNode.childNodes[2];},
					
					
					cssDiv: function() { return this.domNode.childNodes[3]; },
					
					
					errorMessage: function() { return this.domNode.childNodes[4]; }
				},
				
				postBuildRendering: function postBuildRendering() {
					var me = this;
					
					
					me.setFontByDPI();

					browserSupportsHtml5 = me.highlightCanvas.getContext;
					if (!browserSupportsHtml5) {
						me.renderErrorMessage(mstrmojo.desc(8126, 'Your browser does not support HTML5'));
						return;
					}
					
					
					if (me.model.hasOwnProperty("eg")) {
						var errorMessage = me.model.eg,
							wrongTemplateStr = "The Image Layout requires:";
						if (errorMessage.match(wrongTemplateStr)) {
							me.renderErrorMessage(mstrmojo.desc(9853, errorMessage));
						} else {
							me.renderErrorMessage(errorMessage);
						}
						
						return;
					}

					me.newRenderFlag = true;
					
					me.attrIndices = me.getAttrIndices();
					me.createTooltipTable();
					
					
					
					



















					
					
					me.getDefaultSelectedObjs();
					
					
					
					me.highlightContext =  me.highlightCanvas.getContext('2d');
					me.animationContext =  me.animationCanvas.getContext('2d');
					
					
					var sclConfig = me.scrollerConfig;
					sclConfig.scrollEl = me.scrollableCanvasDiv;
					sclConfig.offset.x.start = 0;
					sclConfig.offset.x.end = me.getWidth() * (me.scaleFactor - 1);
					sclConfig.offset.y.start = 0;
					sclConfig.offset.y.end = me.getHeight() * (me.scaleFactor - 1);
					if (sclConfig.origin.x > sclConfig.offset.x.end) {
						sclConfig.origin.x = sclConfig.offset.x.end;
					}
					if (sclConfig.origin.y > sclConfig.offset.y.end) {
						sclConfig.origin.y = sclConfig.offset.y.end;
					}

					
					me.animationCanvas.width = me.highlightCanvas.width = me.getWidth() * 2;
					me.animationCanvas.height = me.highlightCanvas.height = me.getHeight() * 2;
					
















					
					
					if (!me.model.coords) {






						
						
						if(typeof(mstrApp) != 'undefined' && mstrApp.serverRequest) {
							
							var xhrCfg = {
									success: function(res) {
										if (!res) {
											return;
										}
										me.model.coords = res.coords;
										
										me.drawMap();
										if (me.markerType !== MARKER_IMAGE) {
											
											
											me.highlightPoint();
										}
										
										me.adjustWidgetOffsets();
										
										
										if (!me.mapDataScreenshotTaken) {
											me.mapDataScreenshotTaken = true;
											me.localTakeScreenshot(RENDERING_TIME);
										}
									},
									
									failure: function(res) { 



									}
															
								};
							
							params = {
									taskId: 'getMapCoordinates'
							};
							var vp = me.model.vp;
							if (vp && vp.mf) {
								params.coordinatesFile = vp.mf;
							}
							mstrApp.serverRequest(params,xhrCfg,{src:"postBuildRendering"});
						}
					} else {






						
						
						me.drawMap();
						
						me.highlightPoint();
						
						
						this.adjustWidgetOffsets();
					}
					
					if(this._super) {
						this._super();
					}
					
					
					
					if (this._tn) {
						var backup = this._tsCallback;
						this._tsCallback = function(e) {
							me.infowindowOn = me.model.infowindowOn;
							me.currSelectedObjBackup = me.currSelectedObj; 
							backup.call(this, e);
						};
						mstrmojo.dom.detachEvent(this._tn, mstrmojo.dom.TOUCHSTART, backup);
						mstrmojo.dom.attachEvent(this._tn, mstrmojo.dom.TOUCHSTART, this._tsCallback);
					}
					
					
					var xtabModel = me.xtabModel,
						docModel = (xtabModel && xtabModel.docModel);
					if(docModel){
						me.docModelListener = me.xtabModel.docModel.attachEventListener('infoWindowClosed', this.id, function (evt) {
							












							me.model.infowindowOn = false;
							if (!me.hasNonifwTarget && me.currSelectedObj) {
								window.setTimeout(function() {
									
									me.currSelectedObj = null;
									me.highlightPoint();
								}, 10);
							}



						});
					}
					
					
					
					me.fullScreenListener = mstrmojo.touchManager.attachEventListener('fullScreenStateChange', this.id, function(evt) {
						me.adjustWidgetOffsets();
					});
					
					
					
					

					





				},
				
				
				getFullPath: function getFullPath(path) {
					var fullPath = '';
					var reg = /^[A-z]:\/\//; 
					if (reg.test(path)) {
						
						fullPath = path;
					} else {
						
						
						
						var tempReg1 = /^(..\/|..\\)/; 
						var tempReg2 = /^(.\/|.\\)/;
						var tempReg3 = /^(\/|\\)/;
						path = path.replace(tempReg1, '');
						path = path.replace(tempReg2, '');
						path = path.replace(tempReg3, '');
						
						if (typeof(mstrApp)!='undefined' && mstrApp.getConfiguration) {
							fullPath = mstrmojo.url.getAbsoluteURL(path, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());
						}
					}
					
					return fullPath;
				},
				
				
				touchMultiBegin: function (touch) {
					
					this.hideTooltip();
					
					
					
					
					var touch1,
						touch2;
					if (touch.evt.touches && touch.evt.touches.length == 2) {
						touch1 = touch.evt.touches[0];
						touch2 = touch.evt.touches[1];
					} else {
						touch1 = touch;
						touch2 = {pageX: 100, pageY:100};
					}
					var xDiff = touch1.pageX - touch2.pageX,
						yDiff = touch1.pageY - touch2.pageY;
					this.initDiffDiff = xDiff * xDiff + yDiff * yDiff;
					this.initCenterX = (touch1.pageX + touch2.pageX)>>1;
					this.initCenterY = (touch1.pageY + touch2.pageY)>>1;
					this.initScrollX = this._scroller.origin.x;
					this.initScrollY = this._scroller.origin.y;
					
					this.relScaleFactor = 1;
					
					
				},
				
				touchMultiMove: function (touch) {
					
					
					
					var touch1,
						touch2;
					if (touch.evt.touches && touch.evt.touches.length == 2) {
						touch1 = touch.evt.touches[0];
						touch2 = touch.evt.touches[1];
					} else {
						touch1 = touch;
						touch2 = {pageX: 100, pageY: 100};
					}
					var xDiff = touch1.pageX - touch2.pageX,
						yDiff = touch1.pageY - touch2.pageY,
						curDiffDiff = xDiff * xDiff + yDiff * yDiff,
						curCenterX = (touch1.pageX + touch2.pageX)>>1,
						curCenterY = (touch1.pageY + touch2.pageY)>>1;
					
					var scale = Math.sqrt(curDiffDiff / this.initDiffDiff);
					
					var offset = { 
						x: scale * (this.initCenterX + this.initScrollX) - curCenterX,
						y: scale * (this.initCenterY + this.initScrollY) - curCenterY
					};
					var transform = {scale: scale, offset: offset};
					
					this.relScaleFactor = scale;
					
					this.applyTransform(transform);
				},
				
				touchMultiEnd: function (touch) {
					if (this.relScaleFactor * this.scaleFactor < 1) {
						
						this.relScaleFactor = 1 / this.scaleFactor;
						this.applyTransform({scale: this.relScaleFactor}, 500, this.postScale);
					} else if(this.relScaleFactor * this.scaleFactor > 2) {
						var scaleBack = this.relScaleFactor * this.scaleFactor / 2;
						this.relScaleFactor = 2 / this.scaleFactor;
						this.applyTransform({scale: this.relScaleFactor, scaleBack: scaleBack}, 500, this.postScale);
					} else {
						this.postScale();
					}
				},
				
				
				handleTouchSelectWithIfw: function handleTouchSelectWithIfw (touchX, touchY) {
					var me = this,
						nearestObj = me.getAreaOrNearestBubble(false, touchX, touchY);
					
					if (!nearestObj) { 
						me.closeInfowindow();
					} else if (nearestObj.hdrIndex < 0) { 
						me.closeInfowindow();
					} else if (!me.currSelectedObj || nearestObj.touchVal !== me.currSelectedObj.touchVal) {
						me.showInfowindow(nearestObj);						
						me.currSelectedObj = nearestObj;

						me.highlightPoint();
					} else { 
						
					}
				},
				
				handleTouchSelectNoIfw: function handleTouchSelectNoIfw (touchX, touchY) {
					var me = this,
						nearestObj = me.getAreaOrNearestBubble(false, touchX, touchY);
					
					if (!nearestObj) { 
						me.hideTooltip();
					} else if (!me.currHoverObj || nearestObj.touchVal !== me.currHoverObj.touchVal) {
						me.currHoverObj = nearestObj;
						
						me.highlightPoint();
					} else {
						me.renderTooltip(nearestObj.touchVal, nearestObj.point.x, nearestObj.point.y, nearestObj.hdrIndex);
					}
				},
				
				touchSelectBegin: function (touch) {
					if (touch.evt.ctrlKey) { 
						this.touchMultiBegin(touch);
						return;
					}
					
					if (this.infowindowOn) {
						this.touchSelectWithIfw = true;
						this.handleTouchSelectWithIfw(touch.pageX, touch.pageY);						
					} else {
						this.handleTouchSelectNoIfw(touch.pageX, touch.pageY);
					}

				},
				
				touchSelectMove: function (touch) {
					if (touch.evt.ctrlKey) {
						this.touchMultiMove(touch);
						return;
					}
					
					if (this.touchSelectWithIfw) {
						this.handleTouchSelectWithIfw(touch.pageX, touch.pageY);
					} else {
						this.handleTouchSelectNoIfw(touch.pageX, touch.pageY);
					}				

				},
				
				touchSelectEnd: function (touch) {
					if (touch.evt.ctrlKey) {
						this.touchMultiEnd(touch);
					}
					this.touchSelectWithIfw = false;
					return;
				},				
				
				
				touchSwipeBegin: function touchSwipeBegin(touch) {
					this.hideTooltip();
					

					if (this._super) {
						this._super(touch);
					}
				},
				
				applyTransform: function (transform, duration, callback) {
					var scl = this._scroller;
					
					if (duration === undefined) {
						duration = 0;
					}
					scl.scrollEl.style["webkitTransformOrigin"] = "left top";
					
					scl.transform = "scale(" + transform.scale + "," + transform.scale + ")";
					var scrollX,
						scrollY;
					if (transform.offset) {
						scrollX = transform.offset.x;
						scrollY = transform.offset.y;
					} else {
						var scaleBack = transform.scaleBack || 1;
						scrollX = this._scroller.origin.x / scaleBack;
						scrollY = this._scroller.origin.y / scaleBack;
					}
					
					var scrollerOffsetScale = this.scaleFactor * this.relScaleFactor - 1,
						vOffsetEnd = this.getHeight() * scrollerOffsetScale,
						hOffsetEnd = this.getWidth() * scrollerOffsetScale;
					if (scrollerOffsetScale < 0) { 
						scl.offset = {
								y: {
									start: vOffsetEnd,
									end: 0
								},
								x: {
									start: hOffsetEnd,
									end: 0
								}
						};
					} else { 
						scl.offset = {
								y: {
									start: 0,
									end: vOffsetEnd
								},
								x: {
									start: 0,
									end: hOffsetEnd
								}
						};
					}
					this._scroller.scrollTo(scrollX, scrollY, duration);
					if (callback) {
						var that = this;
						setTimeout(function () {callback.apply(that); that = null;}, duration);
					}
						
					
				},
				
				pointCanBeSelected: function pointCanBeSelected(touchObj){
					
					var me = this,
						m = me.model,
						gts = m.gts,
						colHeaders = gts.col,
						colHL = colHeaders.length,
						rowHeaders = gts.row,
						rowHL = rowHeaders.length,
						i;

					for(i = 0; i < rowHL; i++){
						var rowH = rowHeaders[i];
						if(rowH.sc && rowH.sc.tks){
							return true;
						}
						if(rowH.lm && rowH.lm[0] && rowH.lm[0].links && rowH.lm[0].hasOwnProperty("di")){ 
							return true;
						}
					}
					return false;
				},
				
				getModelK: function getModelK(){
					var k = this.model && this.model.k;
					
					return k;
				},
				
				getActionObj: function getActionObj(touchedObj, selectedAll, sameAsCurrSelectedPoint){
					var scObjList = [],
						actionType = 0,
						actionObjList = [],
						linkDrillNode = null;
				
					var me = this,
						model = me.model,
						gts = model.gts,
						rowH = gts.row[0];
						
					
					if(rowH.sc && rowH.sc.tks && (!touchedObj || touchedObj.hdrIndex>=0)){
						if(selectedAll && (rowH.sc.all === "false" || rowH.sc.all === false)){
							
							return null;
						}
						var scObj = {};
						scObj.sc = rowH.sc;
						if (touchedObj && touchedObj>=0) {
							scObj.es = rowH.es[touchedObj.hdrIndex].n;
						} else {
							scObj.es = null;
						}
						
						scObj.eid = selectedAll ? "OA:(All)" : rowH.es[touchedObj.hdrIndex].id;					
						scObjList.push(scObj);
						actionType = rowH.at || 0;
					}
					if(rowH.lm && rowH.lm[0] && rowH.lm[0].links && !linkDrillNode && touchedObj && touchedObj.hdrIndex>=0){
						
						linkDrillNode = {};
						linkDrillNode.titleInfo = rowH;
						linkDrillNode._e = rowH.es[touchedObj.hdrIndex];
					}
					
					
					var colH = gts.col && gts.col.length>0 && gts.col[0];
					
								
					if(scObjList.length >0){
						actionType = actionType | SELECTOR_ACTION;
						if (touchedObj && touchedObj.hdrIndex>=0) {
							if (!sameAsCurrSelectedPoint) {
								if (this.hasIfwTarget) {
									
									this.getAnchorStyle(touchedObj);								
									
									
									
									this.model.infowindowOn = true;
									
									return {at:actionType, k:this.getModelK(), scObjList:scObjList, anchor:this.infowindowAnchor};									
								} else {
									return {at:actionType, k:this.getModelK(), scObjList:scObjList};
								}

							} else {
								
								
								return {at:actionType, k:this.getModelK(), scObjList:scObjList};
							}
						} else if (touchedObj && touchedObj.hdrIndex<0) {
							
							return {at:actionType, k:this.getModelK(), scObjList:scObjList};
						} else if (!touchedObj) { 
							
							
							
							
							return {at:actionType, k:this.getModelK(), scObjList:scObjList};
						}

					}
					
					if(!linkDrillNode && touchedObj && touchedObj.hdrIndex>=0){
					
						var metricH = colH,
							metricHL = metricH && metricH.es && metricH.es.length,
							i;
						if (metricH && metricHL>0) {
							for(i = metricHL - 1; i >= 0; i--){
								var metric = metricH.es[i],
									lm = metricH.lm[i];
								
								if(lm && lm.links){
									linkDrillNode = {};
									linkDrillNode.titleInfo = metricH;
									
									linkDrillNode.mix = i;
									
									var currNode = linkDrillNode,
										nodeLP = {};
									nodeLP.titleInfo = rowH;
									nodeLP._e = rowH.es[touchedObj.hdrIndex];						
												
									currNode._lp = nodeLP;
									currNode.axis = ROW_AXIS;
								}
							}
						}						
					}
					if(linkDrillNode){
						actionType = actionType | HYPERLINK_ACTION;
						return {at:actionType, k:this.getModelK(), node:linkDrillNode};
					}
					return null;
				},
				
				getAnchorStyle: function getAnchorStyle(touchedObj) {
					if (!touchedObj) { return; }
					
					var touchVal = touchedObj.touchVal,
						me = this,
						model = me.model,
						coords = model.coords,
						i,
						j,
						k;
					
					
					me.infowindowAnchor.style.left = (touchedObj.point.x - 9) + 'px';
					me.infowindowAnchor.style.top = (touchedObj.point.y - 9) + 'px';
					
					if(me.displayMode === DISPLAY_MODE_AREA) {
						var minX = Number.POSITIVE_INFINITY,
							maxX = 0,
							minY = Number.POSITIVE_INFINITY,
							maxY = 0;
						if (coords.hasOwnProperty(touchVal)) {
							var rgn = coords[touchVal];
							for (i in rgn) {
								if (!rgn.hasOwnProperty(i)) {
									continue;
								}
								var c = rgn[i];
								for (j=0; j<c.length; j++) {
									if (minX > c[j]) { minX = c[j]; }
									if (maxX < c[j]) { maxX = c[j]; }
									j++;
									if (minY > c[j]) { minY = c[j]; }
									if (maxY < c[j]) { maxY = c[j]; }
								}
							}
							me.infowindowAnchor.style.left = (minX + me.leftOffset - me._scroller.origin.x) + "px";
							me.infowindowAnchor.style.top = (minY + me.topOffset - me._scroller.origin.y) + "px";
							me.infowindowAnchor.style.width = (maxX - minX) + "px";
							me.infowindowAnchor.style.height = (maxY - minY) + "px";
							
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						if (me.shapeFileType === SHAPE_FILE_POLYGON) {
							coords = model.polygonCenters;
						}
						if (coords.hasOwnProperty(touchVal)) {
							if (me.markerType === MARKER_BUBBLE) {
								var ct = coords[touchVal][0],
									rd = me.getRadiusFromName(touchVal);
								me.infowindowAnchor.style.left = (ct[0] + me.leftOffset - rd - me._scroller.origin.x) + "px";
								me.infowindowAnchor.style.top = (ct[1] + me.topOffset - rd - me._scroller.origin.y) + "px";
								me.infowindowAnchor.style.width = (2 * rd) + "px";
								me.infowindowAnchor.style.height = (2 * rd) + "px";
							} else if (me.markerType === MARKER_IMAGE) {
								var ct = coords[touchVal][0],
									_image = model["imageIcon_" + touchVal],
									_width = 0,
									_height = 0;
								
								if (_image) {
									_width = _image.width;
									_height = _image.height;
								}
								
								me.infowindowAnchor.style.left = (ct[0] + me.leftOffset - _width/2 - me._scroller.origin.x) + "px";
								me.infowindowAnchor.style.top = (ct[1] + me.topOffset - _height/2 - me._scroller.origin.y) + "px";
								me.infowindowAnchor.style.width = _width + "px";
								me.infowindowAnchor.style.height = _height + "px";
							}
							
						}
					}
				},
				
				
				getLastHighlightPoint: function gtLstHighlightPnt(){
					
					return this.currHoverObj || null;
				},
				
				
				getTouchedObj: function getTouchedObj(isTap, touchX, touchY){
					var me = this;
					if( me.displayMode == DISPLAY_MODE_AREA ){
						
						return this.getAreaOrNearestBubble(isTap, touchX, touchY);

					}else if( me.displayMode == DISPLAY_MODE_BUBBLE ){
						var touchedObj = this.getLastHighlightPoint(),
							touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);
						
						
						var touchPointInHighlightArea = false,
							tx = 0,
							ty = 0,
							twx = 0,
							twy = 0;
						if (touchedObj && touchPointOnWidget) {
							tx = touchedObj.point.x;
							ty = touchedObj.point.y;
							twx = touchPointOnWidget.touchX;
							twy = touchPointOnWidget.touchY;
							
							touchPointInHighLightArea = this.tooltipOn && (tx-twx)*(tx-twx) + (ty-twy)*(ty-twy)<= this.bias * this.bias; 
						}
						
						
						
						
					
						if(touchPointInHighlightArea){
							
							me.hideTooltip();	
							touchedObj = this.getLastHighlightPoint();
						}else{
							touchedObj = this.getAreaOrNearestBubble(isTap, touchX, touchY);
						}  
						
						return touchedObj;
						
					}
				
					return null;
				},
				
				closeInfowindow: function closeInfowindow() {
					var me = this;
					me.getFirstInfowindow();
					if (me.model.infowindowOn && me.infowindow) {
						me.model.infowindowOn = false;
						me.infowindow.close();
						if (me.infowindow._tchHandler) { 
							mstrmojo.touchManager.detachEventListener(me.infowindow._tchHandler);
							delete me.infowindow._tchHandler; 
						}
					}
					
				},
				
				getFirstInfowindow: function getFirstInfowindow() {
					var me = this,
						model = me.model,
						xtabModel = me.xtabModel,
						docModel = (xtabModel && xtabModel.docModel),
						row = model && model.gts && model.gts.row,
						tks = null;
					if (row && row.length>0) {
						tks = row[0] && row[0].sc && row[0].sc.tks;
					}
					if (docModel && tks) {
						var ifws = docModel.getTargetInfoWin(tks);
						if (ifws && ifws.length>0) {
							var ifwunit = docModel.infoWinByKey[ifws[0]],
								id = ifwunit && (ifwunit.id + "_ifw");
							me.infowindow = mstrmojo.all[id];						
						}
					}
				},
				
				hasNoninfowindowTarget: function hasNoninfowindowTarget(actionObj) {	
					var xtabModel = this.xtabModel,
						docModel = (xtabModel && xtabModel.docModel);
					if (docModel) {
						var layouts = docModel.defn && docModel.defn.layouts,
							layout = null,
							i;
						
						if (layouts) {
							for(i in layouts) {
								if (layouts.hasOwnProperty(i)) {
									if (layouts[i].loaded) {
										layout = layouts[i];
										break;
									}
								}								
							}
						}
						
						var units = layout && layout.units;
						if (units) {
							for(i = 0; i < actionObj.scObjList.length; i++){
								var scObj = actionObj.scObjList[i];
								
								
								var tksList = scObj.sc.tks.split("\x1E"),
									j;
								for(j = 0; j < tksList.length; j++){
									var unit = units[tksList[j]];
									if (unit) {
										if (!unit.ifw) {
											return true;
										}
									}
								}								
							}
						}
					}
					
					return false;
				},
				
				hasInfowindowTarget: function hasInfowindowTarget(actionObj) {	
					var xtabModel = this.xtabModel,
						docModel = (xtabModel && xtabModel.docModel);
					if (docModel) {
						var layouts = docModel.defn && docModel.defn.layouts,
							layout = null,
							i;
						
						if (layouts) {
							for(i in layouts) {
								if (layouts.hasOwnProperty(i) && layouts[i].loaded) {
									layout = layouts[i];
									break;
								}
							}
						}
						
						var units = layout && layout.units;
						if (units) {
							for(i = 0; i < actionObj.scObjList.length; i++){
								var scObj = actionObj.scObjList[i];
								
								







								
								var tksList = scObj.sc.tks.split("\x1E"),
									j;
								for(j = 0; j < tksList.length; j++){
									var unit = units[tksList[j]];
									if (unit) {
										if (unit.ifw) {
											return true;
										}
									}
								}								
							}
						}
					}
					
					return false;
				},
				
				
				touchTap: function touchTap(touch){
					
					var me = this;
					if (touch.count == 2) { 
						
						me.hideTooltip();
						
						me.relScaleFactor = 1 / me.scaleFactor;
						me.applyTransform({scale: me.relScaleFactor}, 500, me.postScale);
					} else if (touch.count == 1) { 
						
						
						var actionObj;
						if (me.tooltipOn) {
							var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode) || null;
							if (item) {
								var value = item.value;
								if (value === "clk" ){
									me.hideTooltip();
									return;
								}						
							} 
						}
						
						var touchedObj = this.getTouchedObj(true, touch.pageX, touch.pageY);
						
						if (touchedObj && touchedObj.hdrIndex>=0){
							
							var canBeSelected = me.pointCanBeSelected(touchedObj),
								sameAsCurrSelectedPoint = me.currSelectedObjBackup && (touchedObj.touchVal == me.currSelectedObjBackup.touchVal),
								sameAsLastHighlight;
							
							if (canBeSelected){
								
								if (!sameAsCurrSelectedPoint){
									
									me.defaultSelectedObjs = {};
									
									
																		
									me.hideTooltip();								
									
									actionObj = this.getActionObj(touchedObj);
									if (actionObj && actionObj.scObjList){
										me.currSelectedObj = touchedObj;
										
										if (!me.hasOwnProperty("hasNonifwTarget") || !me.hasOwnProperty("hasIfwTarget")) {
											me.hasNonifwTarget = me.hasNoninfowindowTarget(actionObj);
											me.hasIfwTarget = me.hasInfowindowTarget(actionObj);
											actionObj = this.getActionObj(touchedObj);
										}
										


















										
										me.highlightPoint();
										
										me.performAction([actionObj]);
									
									} else if (actionObj && actionObj.node) { 
										me.currLinkObj = touchedObj;
										me.highlightPoint();
										
										me.performAction([actionObj]);
										me.currLinkObj = null;
										
									} 
									
									
								} else { 
									
									
									
									
									if (this.currHoverObj && this.currSelectedObj && this.currHoverObj.touchVal===this.currSelectedObj.touchVal){ 
										
									} else {
										if (me.hasNonifwTarget) { 
											
											actionObj = me.getActionObj(touchedObj, true, true);	
											if(actionObj){ 
												me.performAction([actionObj]);	
												me.currSelectedObj = null;
												me.highlightPoint();
											} else { 
												
												me.getFirstInfowindow();
												if (!me.infowindowOn && me.infowindow) {
													me.model.infowindowOn = true;
													me.infowindow.open();
												}
												
											}
										}										
									}
									
									me.hideTooltip();
								}
							} else { 
								sameAsLastHighlight = me.currHoverObj && (touchedObj.touchVal == me.currHoverObj.touchVal);
								if(!sameAsLastHighlight){
									
									me.currHoverObj = touchedObj;
									
									me.highlightPoint();
								} else { 
									me.hideTooltip();
								}
								
							}
						
						} else if (touchedObj && touchedObj.hdrIndex<0) { 
							
							sameAsLastHighlight = me.currHoverObj && (touchedObj.touchVal == me.currHoverObj.touchVal);
							if (!sameAsLastHighlight){
								
								me.currHoverObj = touchedObj;
								
								me.highlightPoint();
							} else {
								me.hideTooltip();
							}
						} else if (!touchedObj){ 
							
							
							me.hideTooltip();
							
							
														
							if (me.currSelectedObjBackup && me.hasNonifwTarget){
								
								
								actionObj = this.getActionObj(touchedObj, true);	
								
								if (actionObj){
									me.performAction([actionObj]);
									me.currSelectedObj = null;
									me.highlightPoint();
								}
								
							}
						}
					}
					
							
				},
				
				showInfowindow: function showInfowindow(touchedObj) {
					var me = this,
						actionObj;
					
					if (touchedObj && touchedObj.hdrIndex>=0){
						
						var canBeSelected = me.pointCanBeSelected(touchedObj),
							sameAsCurrSelectedPoint = me.currSelectedObj && (touchedObj.touchVal == me.currSelectedObj.touchVal);
						
						if( canBeSelected ){
							
							if( !sameAsCurrSelectedPoint ){
								
								me.hideTooltip();
								
								actionObj = me.getActionObj(touchedObj);
								if (actionObj && actionObj.scObjList){
									me.currSelectedObj = touchedObj;
								}
								
								
								me.highlightPoint();
								
								me.performAction([actionObj]);
								
							} else { 
								if (this.currHoverObj && this.currSelectedObj && this.currHoverObj.touchVal===this.currSelectedObj.touchVal){ 
									
									me.hideTooltip();
								} else {
									me.hideTooltip();
																		
									actionObj = this.getActionObj(touchedObj, true, true);	
									
									if (actionObj){					
										me.performAction([actionObj]);	
										me.currSelectedObj = null;
										me.highlightPoint();
									}
								}
							}
						} else { 

						}					
					} else if ((touchedObj && touchedObj.hdrIndex<0) || !touchedObj){ 
						
						
						
						me.hideTooltip();
						
						
													
						if(me.currSelectedObj){
							
							
							actionObj = me.getActionObj(touchedObj, true);	
							
							if(actionObj){
								me.performAction([actionObj]);
								me.currSelectedObj = null;
								me.highlightPoint();
							}
							
						}
					}
				},
				
				
				
				
				postScale: function () {
					delete this._scroller.transform;
					this._scroller.scrollTo(this._scroller.origin.x, this._scroller.origin.y, 0);
					this.scaleFactor *= this.relScaleFactor;
					this.refreshWidget();
				},
				
				
				refreshWidget: function () {
					this.drawMap();
					this.highlightPoint();
				},
				
				
				getAttrIndices: function getAttrIndices() {
					var me = this,
						model = me.model,
						rows = model && model.gts && model.gts.row,
						i,j;
					
					if (rows) {
						var attrIndices = [],
							idx = 0;
						for (i=0; i<rows.length; i++) {
							var fs = rows[i] && rows[i].fs;
							attrIndices.push(new Array());
							if (fs) {
								for (j=0; j<fs.length; j++) {
									attrIndices[i].push(idx++);
								}
							}						
						}					
						return attrIndices;
					} else {
						return null;
					}
				},
				
				createTooltipTable: function createTooltipTable() {
					var me = this,
						model = me.model,
						table = me.tooltip.childNodes[0],
						rows = model && model.gts && model.gts.row,
						cols = model && model.gts && model.gts.col && model.gts.col[0] && model.gts.col[0].es,
						i;
					
					if (table.childNodes.length===0 && rows && rows.length>0) {
						var trNum = rows.length + (cols?cols.length:0); 
						for (i=0; i<trNum; i++) {
							var tr = document.createElement("tr");
							
							var tdLeft = document.createElement("td");
							tdLeft.align = "right";
							tdLeft.style.color = "#545462";
							tr.appendChild(tdLeft);
							
							var tdRight = document.createElement("td");
							tdRight.align = "left";
							tdRight.style.color = "#000000";
							tr.appendChild(tdRight);
							
							table.appendChild(tr);
						}
					}
					
				},
				
				localTakeScreenshot: function localTakeScreenshot(_time) {
					var me = this;
					window.setTimeout(function() {
						var ctrlID = me.controller.id;
						var ctrl = mstrmojo.all[ctrlID];
						if (ctrl && ctrl.rootCtrl.getCurrent() === ctrl) {
							ctrl.takeScreenShot();
							
						}
					}, _time);
				},
				
				
				getDefaultSelectedObjs: function getDefaultSelectedObjs() {
					var me = this,
						model = me.model,
						idxs = model && model.ghs && model.ghs.rhs && model.ghs.rhs.items,
						gts_rows = model && model.gts && model.gts.row,
						i,name,idx,item;
					
					
					if (me.haveGotDftSltObjs) {
						return;
					} else {
						me.haveGotDftSltObjs = true;
					}
					
					me.defaultSelectedObjs = {};
					if (idxs && gts_rows && gts_rows.length>0) {
						for (i in idxs) {
							if (idxs.hasOwnProperty(i)) {
								item = idxs[i].items[0];
								if (item && item.hasOwnProperty("cet")) {
									idx = item.idx;
									name = gts_rows[0].es[idx].n;
									if (!(me.defaultSelectedObjs.hasOwnProperty(name))) {
										me.defaultSelectedObjs[name] = idx;
									}							
								}
							}						
						}
					}
						
				},
				
				renderErrorMessage: function renderErrorMessage(errorMessage) {
					
									
					
					var me = this,
						msgDiv = me.errorMessage,
						newErrorMessage = errorMessage.replace(/-/g, "<br />-");
					msgDiv.innerHTML = newErrorMessage;
					
					msgDiv.style.width = me.getWidth() + "px";
					msgDiv.style.fontSize = me.errMsgFontSize + "px";
					msgDiv.style.fontFamily = "Tahoma";
					msgDiv.style.color = ERROR_MSG_FONT_COLOR_DARK_THEME;
					msgDiv.style.backgroundColor = "RGBA(0,0,0,0)";
					
					var bgColor = DEFAULT_BG_COLOR;
					if (me.model.hasOwnProperty("vp") && me.model.vp.hasOwnProperty("bc") && me.model.vp.bc!=="") {
						bgColor = "#" + me.model.vp.bc;
					} else {
						bgColor = me.utils.getAncestorBgColor(me) || DEFAULT_BG_COLOR;
					}		
					me.domNode.style.backgroundColor = bgColor;
					me.model.themeMode = getThemeMode(bgColor);
					if (me.model.themeMode === THEME_LIGHT) {
						msgDiv.style.color = ERROR_MSG_FONT_COLOR_LIGHT_THEME;
					}
					
				},
				
				setFontByDPI: function setFontByDPI() {
					
					if (this.setFontByDPIFlag) {
						return;
					}
					var me = this;
					me.setFontByDPIFlag = true;
					
					
					me.hoverBubbleRadiusLarger = 5;
					me.bubbleStrokeWidth = 2;
					me.baseMaxBubbleSizeAuto = 12;
					me.baseMaxBubbleSizeManual = 24;
					me.polygonStrokeWidth = 1;
					me.highlightPolygonStrokeWidth = 2;
					me.borderSpace = 5;
					
					me.tooltipFontSize = 12; 
					me.tooltipBorderWidth = 1; 
					me.tooltipBorderRadius = 5;
					
					me.errMsgFontSize = 16; 
					me.bias = 30; 
					me.tooltipRightShadowWidth = 4; 
					
					
					var xtabModel = me.xtabModel,
						docModel = (xtabModel && xtabModel.docModel),
						fitToPage = false, 
						microApp = false;
					if (docModel) {
						fitToPage = docModel.zt && (docModel.zt==2);
						var layouts = docModel.defn && docModel.defn.layouts,
							layout,
							i;
						
						for(i in layouts) {
							if (layouts.hasOwnProperty(i) && layouts[i] && layouts[i].loaded) {
								layout = layouts[i];
								break;
							}
						}
						if (layout && layout.hasOwnProperty("fch")) {
							microApp = layout.fch;
						}
					}
					if (fitToPage && microApp) {




						
						var devicedpi = mstrMobileApp.getDeviceDPIX();
						var baseDpi = 149;
						var ratio = 1;
						if (devicedpi > 0 ) { ratio = devicedpi / baseDpi; }
						
						if (ratio > 1) {
							me.hoverBubbleRadiusLarger *= ratio;
							me.bubbleStrokeWidth *= ratio;
							me.baseMaxBubbleSizeAuto *= ratio;
							me.baseMaxBubbleSizeManual *= ratio;
							me.polygonStrokeWidth *= ratio;
							me.highlightPolygonStrokeWidth *= ratio;
							me.borderSpace *= ratio;
							me.tooltipFontSize *= ratio;
							me.tooltipBorderWidth *= ratio;
							me.tooltipBorderRadius *= ratio;
							me.errMsgFontSize *= ratio;
							me.bias *= ratio;
							me.tooltipRightShadowWidth *= ratio;
							
											
							
							var tooltip = me.tooltip,
								table = tooltip.childNodes[0];
							
							tooltip.style.fontSize = me.tooltipFontSize + "px";
							tooltip.style.borderWidth = me.tooltipBorderWidth + "px";
							tooltip.style.borderRadius = me.tooltipBorderRadius + "px";
							tooltip.style.boxShadow = 3*ratio + "px " + 3*ratio + "px " + 4*ratio + "px " + "RGBA(0,0,0,0.45)";
							table.style.margin = 5*ratio + "px " + 7*ratio + "px";
						}
					}
					
					
				},
				
				initScroller: function initScroller(scroller) {
					scroller.vScroll = true;
					scroller.hScroll = true;

					this._super(scroller);
				},
				
				
				
				getIndexFromHdrindex: function getIndexFromHdrIndex(hdrIndex) {
					var me = this,
						idxs = me.model.ghs.rhs.items;
					
					if (idxs) {
						var i,
							curRow,
							nextRow;
						for (i=0; i<idxs.length; i++) {
							curRow = idxs[i].items;
							if (curRow.length>0 && curRow[0].idx==hdrIndex) {
								if (i===idxs.length-1) {
									return i;
								} else {
									nextRow = idxs[i+1].items;
									if (nextRow.length>0 && nextRow[0].idx!=hdrIndex) {
										return i;
									} else {
										continue;
									}
								}
							} else {
								continue;
							}
						}
					}
					
					return 0;
				},

				
				drawMap: function drawMap(){
					var me = this,
						model = me.model;
					
					
					
					
					
					me.animationCanvas.width = me.animationCanvas.width;
					me.highlightCanvas.width = me.highlightCanvas.width;
				
					
					if (!me.hasOwnProperty("displayMode")) { me.displayMode = DISPLAY_MODE_AUTOMATIC; }
					if (!me.hasOwnProperty("markerType")) { me.markerType = MARKER_UNDEFINED; }
					if (!me.hasOwnProperty("shapeFileType")) { me.shapeFileType = SHAPE_FILE_UNDEFINED; }
					if (!me.hasOwnProperty("colorByIndex")) { me.colorByIndex = -1; }
					if (!me.hasOwnProperty("sizeByIndex")) { me.sizeByIndex = -1; }
					
					if (!me.hasOwnProperty("drawBgImageFlag")) { me.drawBgImageFlag = false; } 
					
					if (!me.hasOwnProperty("thresholdType")) { me.thresholdType = THRESHOLD_UNDEFINED; }
					
					if (!me.hasOwnProperty("curPolygonOpacity")) { me.curPolygonOpacity = POLY_NORMAL_OPACITY; }
					if (!model.hasOwnProperty("infowindowOn")) { model.infowindowOn = false; }
					if (!me.hasOwnProperty("touchSelectWithIfw")) { me.touchSelectWithIfw = false; }
					
					if (me.model.hasOwnProperty("vp")) {
						var bgColor = DEFAULT_BG_COLOR;
						if (me.model.vp.hasOwnProperty("bc") && me.model.vp.bc!=="") {
							bgColor = "#" + me.model.vp.bc;
						} else {
							bgColor = me.utils.getAncestorBgColor(me) || DEFAULT_BG_COLOR;
						}
						me.domNode.style.backgroundColor = bgColor;
						me.model.themeMode = getThemeMode(bgColor);
						me.model.bgColor = bgColor;
						
						me.tooltip.style.top = "0px";
						
						me.setDisplayParas();
						
						if (me.displayMode === DISPLAY_MODE_AREA) { 
							me.drawAreaMap();
						} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
							me.drawBubbleMap();
						}
					}

				},
				
				
				getIndexById: function getIndexById(id) {
					var me = this,
						model = me.model,
						gtsCol = model.gts && model.gts.col,
						gtsColEle = null,
						i;
					if (gtsCol && gtsCol.length > 0 && gtsCol[0].hasOwnProperty("es")) {
						gtsColEle = gtsCol[0].es;
						
						for (i=0; i<gtsColEle.length; i++) {
							if (gtsColEle[i].oid === id) {
								return i;
							}
						} 
					}
					
					return -1;
				},
				
				
				
				setDisplayParas: function setDisplayParas(){
					
					var me = this,
						model = me.model;  
					
					
					if (!me.hasOwnProperty("setDisplayParasFlag")) {
						me.setDisplayParasFlag = true;
					} else {
						return;
					}

					me.shapeFileType = getShapeFileType(model.coords);
					
					var colCount = 0;
					if (model.hasOwnProperty("gvs") 
							&& model.gvs.hasOwnProperty("items") 
							&& model.gvs.items.length > 0
							&& model.gvs.items[0].hasOwnProperty("items")
							&& model.gvs.items[0].items.length > 0) {
						colCount = model.gvs.items[0].items.length;
					}
					
					me.displayMode = model.vp.mt;
					if (me.displayMode === DISPLAY_MODE_AREA) {
						if (colCount > 0) {
							if (model.vp.hasOwnProperty("ColorBy")) {
								me.colorByIndex = me.getIndexById(model.vp.ColorBy);
								if (me.colorByIndex < 0) {
									me.colorByIndex = 0;
								}
							} else {
								me.colorByIndex = 0;
							}
							
							me.thresholdType = me.getThresholdType(me.colorByIndex);
							
							











						} else { 
							
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						if (colCount > 0) {
							this.setBubbleModeParasWithData(colCount);
						} else { 
							
							me.markerType = MARKER_BUBBLE;
						}					
					} else if (me.displayMode === DISPLAY_MODE_AUTOMATIC) {
						if (colCount > 0) {
							me.displayMode = DISPLAY_MODE_BUBBLE;
							this.setBubbleModeParasWithData(colCount);
						} else { 
							if (me.shapeFileType === SHAPE_FILE_POLYGON) {
								me.displayMode = DISPLAY_MODE_AREA;
							} else if (me.shapeFileType === SHAPE_FILE_POINT) {
								me.displayMode = DISPLAY_MODE_BUBBLE;
								me.markerType = MARKER_BUBBLE;
							}						
							
						}
						
					} else if (!me.displayMode) { 
						if (colCount > 0) {
							me.displayMode = DISPLAY_MODE_BUBBLE;
							this.setBubbleModeParasWithData(colCount);
						} else { 
							if (me.shapeFileType === SHAPE_FILE_POLYGON) {
								me.displayMode = DISPLAY_MODE_AREA;
							} else if (me.shapeFileType === SHAPE_FILE_POINT) {
								me.displayMode = DISPLAY_MODE_BUBBLE;
								me.markerType = MARKER_BUBBLE;
							}						
							
						}
					}
					
					






					
				},
				
				
				setBubbleModeParasWithData: function setBubbleModeParasWithData(colCount) {
					var me = this,
						model = me.model;
					if (model.vp.hasOwnProperty("SizeBy")) {
						me.sizeByIndex = this.getIndexById(model.vp.SizeBy);
						if (me.sizeByIndex < 0) {
							me.sizeByIndex = 0;
						}
					} else {
						me.sizeByIndex = 0;
					}
					
					if (model.vp.hasOwnProperty("ColorBy")) {
						me.colorByIndex = this.getIndexById(model.vp.ColorBy);
						if (me.colorByIndex < 0) {
							me.colorByIndex = 0;
						}
						
						me.thresholdType = me.getThresholdType(me.colorByIndex);
						if (me.thresholdType === THRESHOLD_IMAGE) {
							me.markerType = MARKER_IMAGE;
						} else {
							me.markerType = MARKER_BUBBLE;
						}
					} else {
						if (colCount===1) {
							me.colorByIndex = 0;
							me.thresholdType = this.getThresholdType(0);
							if (me.thresholdType === THRESHOLD_IMAGE) {
								me.markerType = MARKER_IMAGE;
							} else {
								me.markerType = MARKER_BUBBLE;
							}
						} else if (colCount>1) {
							var firstThresholdType = this.getThresholdType(0); 
							if (firstThresholdType === THRESHOLD_IMAGE) {
								me.colorByIndex = 0;
								me.thresholdType = firstThresholdType;
								me.markerType = MARKER_IMAGE;
							} else {
								me.colorByIndex = 1;
								me.thresholdType = this.getThresholdType(1);
								if (me.thresholdType === THRESHOLD_IMAGE) {
									me.markerType = MARKER_IMAGE;
								} else {
									me.markerType = MARKER_BUBBLE;
								}
								
							}
						}
					}

				},
				
				
				getThresholdType: function getThresholdType(colIndex) {
					var me = this,
						th = me.model && me.model.th,
						subTh = th && th[colIndex],
						gvs = me.model && me.model.gvs,
						gts_es = me.model.gts.row[0].es,
						elem,
						i,
						cellData;
					
					if (subTh && gvs.items.length>0) { 
						if (colIndex >= gvs.items[0].items.length || colIndex<0 || subTh.length === 0) { 
							return THRESHOLD_UNDEFINED; 
						}
						for (i in gts_es) {
							if (gts_es.hasOwnProperty(i)) {
								cellData = gvs.items[me.getIndexFromHdrindex(i)].items[colIndex];
								if (cellData.hasOwnProperty("ty") && parseInt(cellData.ty,10)===4) {
									return THRESHOLD_IMAGE;
								}
							}						
						}
						
						var isImgReg = /(jpg|jpeg|png|gif|tiff|bmp)$/i;
						for (elem in subTh) {
							if (subTh.hasOwnProperty(elem) && isImgReg.test(subTh[elem].n)) {
								return THRESHOLD_IMAGE;
							}
						}

						for (i in gts_es) {
							if (gts_es.hasOwnProperty(i)) {
								cellData = gvs.items[me.getIndexFromHdrindex(i)].items[colIndex];
								if (cellData.hasOwnProperty("ty") && parseInt(cellData.ty,10)===2) {
									return THRESHOLD_COLOR;
								}
							}						
						}
						return THRESHOLD_UNDEFINED;
					} else { 
						return THRESHOLD_UNDEFINED;
					}
				},
				
				
				scalePolygonCoords: function scalePolygonCoords() { 
					var me = this,
						model = me.model,
						coords = model.coords;
					
					var maxX = 0,
						maxY = 0, 
						rgn, c, i, j, k;

					for (i in coords) {
						if (coords.hasOwnProperty(i)) {
							if (i === "bgImage") {
								continue;
							}
							rgn = coords[i];
							for (j in rgn) {
								if (rgn.hasOwnProperty(j)) {
								c = rgn[j];
									for (k = 0; k < c.length; k++) {
										if (c[k] > maxX) {
											maxX = c[k];
										}
										k++;
										if (c[k] > maxY) {
											maxY = c[k];
										}							
									}
								}							
							}
						}					
					}

					var xRatio = maxX / ((this.getWidth() - 10) * this.scaleFactor),
						yRatio = maxY / ((this.getHeight() - 10) * this.scaleFactor),
						ratio = Math.max(yRatio, xRatio) ;
					
					
					this.topOffset = (this.getHeight()*this.scaleFactor - maxY/ratio) / 2 ;
					this.leftOffset = (this.getWidth()*this.scaleFactor - maxX/ratio) / 2 ;
					
					
					for (i in coords) {
						if (coords.hasOwnProperty(i)) {
							if (i === "bgImage") {
								continue;
							}
							rgn = coords[i];
							for (j in rgn) {
								if (rgn.hasOwnProperty(j)) {
									c = rgn[j];
									for (k = 0; k < c.length; k++) {
										c[k] = parseInt(c[k] / ratio, 10);
									}
								}							
							}
						}					
					}
				},
				
				
				getBubbleColorFromName: function getBubbleColorFromName(elem) {
					if (this.allBubblesColor && this.allBubblesColor.hasOwnProperty(elem)) {
						return this.allBubblesColor[elem];
					} else {
						return null;
					}
				},
				
				getBgColorFromCSS: function getBgColorFromCSS(cellData) {
					var cssDiv = this.cssDiv,
						csss = null,
						th = null,
						cni,
						cssStyle;
					if (this.model.hasOwnProperty("css")) {
						csss = this.model.css;
					}
					if (this.model.hasOwnProperty("th")) {
						th = this.model.th && this.model.th[this.colorByIndex];
					}
									
					if (csss && th && cellData && cellData.hasOwnProperty("ty")) {
						if ((parseInt(cellData.ty, 10) === 2 || parseInt(cellData.ty, 10) === 4) && cellData.hasOwnProperty("ti") && th.length>cellData.ti && th[cellData.ti].udbg===1) {
							
							cni = th[cellData.ti].cni;
							cssDiv.className = cni && csss[cni] && csss[cni].n;
							cssStyle = mstrmojo.css.getComputedStyle(cssDiv);
							if (cssStyle.hasOwnProperty("backgroundColor")) {
								return cssStyle.backgroundColor;
							}




						}
					}

					return null;
				},

				
				drawPolygonInMap: function drawPolygonInMap(opacity) {
					var me = this,
						model = me.model,
						coords = model.coords,
						context = this.animationContext,
						elem;
					
					me.animationCanvas.width = me.animationCanvas.width;
					
					
					if (me.drawBgImageFlag && model.bgImg) {
						var xRatio = me.oriBgImageWidth / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
							yRatio = me.oriBgImageHeight / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
							ratio = Math.max(yRatio, xRatio); 
						
						me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
						me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;

						context.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
					}
					
					me.curPolygonOpacity = opacity;
					
					var noAltColor = POLY_COLOR_NO_ALT_DARK_THEME,
						noColorByColor = POLY_COLOR_NO_COLORBY_DARK_THEME,
						strokeColor = POLY_STROKE_COLOR_DARK_THEME;
					if (model.themeMode === THEME_LIGHT) {
						noAltColor = POLY_COLOR_NO_ALT_LIGHT_THEME;
						noColorByColor = POLY_COLOR_NO_COLORBY_LIGHT_THEME;
						strokeColor = POLY_STROKE_COLOR_LIGHT_THEME;
					}
					
					if (model.vp && model.vp.npc) {
						noAltColor = getOpacityColor("#"+model.vp.npc, POLY_NORMAL_OPACITY);
					}
					
					
					for (elem in coords) {
						if (!coords.hasOwnProperty(elem)) {
							continue;
						}
						if (coords.hasOwnProperty(elem)) {
							if (elem === "bgImage") {
								continue;
							}
							
							
							var clr = noAltColor;
							
							
							if (me.displayMode === DISPLAY_MODE_AREA) {
								var hdrIndex = this.getHeaderIndex(elem);
								if (hdrIndex >= 0) {
									if (me.colorByIndex >= 0) { 
										var mv = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
										clr = me.getBgColorFromCSS(mv);
										if (!clr) {
											clr = noColorByColor;
										}
										if (me.drawBgImageFlag) {
											clr = getOpacityColor(clr, POLY_ABOVE_BG_OPACITY);
										} else {
											clr = getOpacityColor(clr, POLY_NORMAL_OPACITY);
										}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
									} else {
										clr = noColorByColor;
									}
								} else {
									clr = noAltColor;
								}
							} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
								clr = noAltColor;
							}
						}					
						
						clr = getOpacityColor(clr, opacity);

						
						
						
						drawPoly(context, coords[elem], {x:this.leftOffset,y:this.topOffset}, strokeColor, me.polygonStrokeWidth, clr);
					}
				},
				
				
				getRadiusFromName: function getRadiusFromName(name) {
					var me = this,
						model = me.model;
					
					if (model.coords.hasOwnProperty(name)) {
						if (me.model.hasOwnProperty("oriBubbleSize")) {
							return me.model.oriBubbleSize[name] * me.scaleFactor;
						} else {
							if (me.model.hasOwnProperty("maxBubbleRadius")) {
								return me.model.maxBubbleRadius * me.scaleFactor;
							} else {
								return 2;
							}
						}					
					} else {
						return -1;
					}
				},


				
				drawBubblesInMap: function drawBubblesInMap() {
					var me = this,
						model = me.model,
						coords = model.coords,
						elem;
					if (model.hasOwnProperty("polygonCenters")) {
						coords = model.polygonCenters;
					}
					
					me.highlightCanvas.width = me.highlightCanvas.width;
					
					var defBubbleColor = BUBBLE_COLOR_NO_COLORBY_DARK_THEME,
						strokeColor = BUBBLE_STROKE_COLOR_DARK_THEME;
					if (model.themeMode === THEME_LIGHT) {
						defBubbleColor = BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME;
						strokeColor = BUBBLE_STROKE_COLOR_LIGHT_THEME;
					}
					var defRadius = Math.max(2, Math.min(12, MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER*0.15*Math.min(me.getWidth(),me.getHeight())));
					defRadius = defRadius * me.scaleFactor;
					
					var th = model.th && model.th[me.colorByIndex];
					if (me.markerType === MARKER_IMAGE) {
						var notFoundImageIconPath = me.getFullPath("images/image_not_found.jpg");
							defaultImageIconPath = me.getFullPath("images/roundedpp.png");
						
							
							
						for (elem in coords) {
							if (coords.hasOwnProperty(elem)) {
								if (elem === "bgImage") {
									continue;
								}
								var propName = "imageIcon_" + elem;
								
								
								if (model.hasOwnProperty(propName)) {
									var _image = model[propName];
									if (_image && _image.width && _image.height && _image.width<me.getWidth()*me.scaleFactor && _image.height<me.getHeight()*me.scaleFactor) {
										var xOffset = coords[elem][0][0] - _image.width/2 + me.leftOffset,
											yOffset = coords[elem][0][1] - _image.height/2 + me.topOffset;
										me.animationContext.drawImage(_image, xOffset, yOffset);
									}
									continue;
								}
								
								
								var hdrIndex = me.getHeaderIndex(elem);
								if (th && hdrIndex >= 0 && me.colorByIndex >= 0 && me.thresholdType === THRESHOLD_IMAGE) {
									var cellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
									if (cellData.hasOwnProperty("ty") && parseInt(cellData.ty, 10) === 4) {
										var iconPath = th.length>cellData.ti && th[cellData.ti].n;
										if (iconPath) {
											var fullIconPath = me.getFullPath(iconPath);
											model[propName] = new Image();
											model[propName].src = fullIconPath;
											model[propName].id = elem;
											model[propName].onload = function() {
												if (this.width<me.getWidth()*me.scaleFactor && this.height<me.getHeight()*me.scaleFactor) {
													var xOffset = coords[this.id][0][0] - this.width/2 + me.leftOffset,
														yOffset = coords[this.id][0][1] - this.height/2 + me.topOffset;
													me.animationContext.drawImage(this, xOffset, yOffset);
													
													
													



													
													
													
													
													
													
													if (me.defaultSelectedObjs.hasOwnProperty(this.id)) {
														me.highlightCanvas.width = me.highlightCanvas.width;
														for (var dftSltObj in me.defaultSelectedObjs) {
															if (me.defaultSelectedObjs.hasOwnProperty(dftSltObj)) {
																me.highlightImageIcon(me.highlightContext, coords, dftSltObj, 0);
															}
														}
													}
												}
											};
											model[propName].onerror = function() {
												model["imageIcon_" + this.id].src = notFoundImageIconPath;
											};
										}								
									} else { 
										
										model[propName] = new Image();
										model[propName].src = defaultImageIconPath;
										model[propName].id = elem;
										model[propName].onload = function() {
											if (this.width<me.getWidth()*me.scaleFactor && this.height<me.getHeight()*me.scaleFactor) {
												var xOffset = coords[this.id][0][0] - this.width/2 + me.leftOffset,
													yOffset = coords[this.id][0][1] - this.height/2 + me.topOffset;
												me.animationContext.drawImage(this, xOffset, yOffset);
												
												if (me.defaultSelectedObjs.hasOwnProperty(this.id)) {
													me.highlightImageIcon(me.highlightContext, coords, this.id, 0);
												}
											}
										};
										model[propName].onerror = function() {
											model["imageIcon_" + this.id].src = notFoundImageIconPath;
										};
									}							
								} else { 
									delete coords[elem];
								}
							}
							
						}
						
						if (!me.imageIconScreenshotTaken) {
							me.imageIconScreenshotTaken = true;
							
						}					
					} else if (me.markerType === MARKER_BUBBLE) {
						for (elem in coords) {
							if (!coords.hasOwnProperty(elem)) {
								continue;
							}
							if (elem === "bgImage" 
								|| elem === (me.currHoverObj && me.currHoverObj.touchVal)
								|| elem === (me.currSelectedObj && me.currSelectedObj.touchVal)
								|| elem === (me.currLinkObj && me.currLinkObj.touchVal)
								|| (!isOwnEmpty(me.defaultSelectedObjs) && me.defaultSelectedObjs.hasOwnProperty(elem))) {
								continue;
							}
							var bubbleColor = defBubbleColor,
								bubbleRadius = defRadius,
								hdrIndex = me.getHeaderIndex(elem);
							if (hdrIndex >= 0) { 
								if (me.sizeByIndex >= 0) {
									
									bubbleRadius = me.getRadiusFromName(elem);
								}
								if (me.colorByIndex >= 0 && me.thresholdType === THRESHOLD_COLOR) {
									bubbleColor = me.getBubbleColorFromName(elem);
									
									if (!bubbleColor) {
										bubbleColor = defBubbleColor;
									} else {
										bubbleColor = getOpacityColor(bubbleColor, BUBBLE_NORMAL_OPACITY);
									}
								}
								
								var offset = {x:me.leftOffset, y:me.topOffset};
								drawBubble(me.highlightContext, coords[elem][0], offset, bubbleColor, bubbleRadius);
								drawStroke(me.highlightContext, coords[elem][0], offset, strokeColor, bubbleRadius, me.bubbleStrokeWidth);
							} else { 
								delete coords[elem];
							}						
						}
					}			   	

				},
				
				
				getOriPolygonCoords: function getOriPolygonCoords() {
					var me = this,
						model = me.model,
						coords = model.coords,
						i,
						j,
						k,
						rgn,
						c;
					
					if (!model.hasOwnProperty("oriPolyCoords")) {
						model.oriPolyCoords = {};
						for (i in coords) {
							if (coords.hasOwnProperty(i)) {
								if (i === "bgImage") {
									continue;
								}
								var arr2 = [];
								rgn = coords[i];
								for (j in rgn) {
									if (rgn.hasOwnProperty(j)) {
										c = rgn[j];
										var arr1 = [];
										for (k=0; k<c.length; k++) {
											arr1.push(c[k]);
										}
										arr2.push(arr1);
									}								
								}
								model.oriPolyCoords[i] = arr2;
							}
						}
					}
				},
				
				
				getAllBubblesColor: function getAllBubblesColor() {
					var me = this,
						model = me.model,
						coords = model.coords,
						elem;
					
					
	 
					if (me.haveAllBubblesColor) {
						return;
					} else {
						
						
						
						me.allBubblesColor = {};
					}
					
					var defBubbleColor = BUBBLE_COLOR_NO_COLORBY_DARK_THEME;
					if (model.themeMode === THEME_LIGHT) {
						defBubbleColor = BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME;
					}
					
					if (me.markerType === MARKER_BUBBLE && me.colorByIndex >= 0 && me.thresholdType === THRESHOLD_COLOR) {
						for (elem in coords) {
							if (coords.hasOwnProperty(elem)) {
								if (elem === "bgImage") {
									continue;
								}
								var hdrIndex = me.getHeaderIndex(elem);
								if (hdrIndex >= 0) { 
									var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex],
										bubbleColor = me.getBgColorFromCSS(colorByCellData);
									
									if (!bubbleColor) {
										bubbleColor = defBubbleColor;
									}
									me.allBubblesColor[elem] = bubbleColor;
								} else { 
									
								}
							}												
						}
					}
				},
				
				
				getOriBubbleSize: function getOriBubbleSize() {
					var me = this,
						model = me.model,
						gvs = model.gvs,
						idxs = model.ghs.rhs.items,
						gts_es = model.gts.row[0].es,
						elem,i,j,k,pt,
						maxRadius = 0;
					
					
					





					
					
					var ratio = 1;
					if (model.vp.ty === "0") { 
						if (me.sizeByIndex < 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER;
						} else if (me.sizeByIndex >= 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_AUTOMATIC;
						}
					} else if (model.vp.ty === "1") { 
						if (model.vp.hasOwnProperty("val") && model.vp.val!==null && model.vp.val!=="") {
							ratio = parseFloat(model.vp.val);
							if (ratio > MAX_RATIO_UP_LIMIT) { ratio = MAX_RATIO_UP_LIMIT; }
							if (ratio < MAX_RATIO_LOW_LIMIT) { ratio = MAX_RATIO_LOW_LIMIT; }
						} else {
							if (me.sizeByIndex < 0) {
								ratio = MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER;
							} else if (me.sizeByIndex >= 0) {
								ratio = MAX_SIZE_DEFAULT_RATIO_FOR_MANUAL;
							}
						}					
					} else { 
						if (me.sizeByIndex < 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER*2;
						} else if (me.sizeByIndex >= 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_MANUAL*2;
						}
					}
					var maxMaxSize = me.baseMaxBubbleSizeAuto;
					if (me.sizeByIndex >= 0) { maxMaxSize = me.baseMaxBubbleSizeManual; }
									
					var baseSize = 0.15*Math.min(me.getWidth(), me.getHeight());
					if (model.vp.ty === "0") {
						maxRadius = Math.min(ratio*baseSize, maxMaxSize);
					} else if (model.vp.ty === "1") {
						maxRadius = ratio * baseSize;
					} else { 
						maxRadius = ratio * baseSize;
					}
					
					if (maxRadius <= 2) { maxRadius = 3; }
					me.model.maxBubbleRadius = maxRadius;
					
					
					if (me.sizeByIndex >= 0) {
						var idx = me.sizeByIndex,
							maxValue = Math.abs(parseFloat(gvs.items[0].items[idx].rv)),
							minValue = Math.abs(parseFloat(gvs.items[0].items[idx].rv));
						for (i in gts_es) {
							if (gts_es.hasOwnProperty(i)) {
								var gvsIndex = me.getIndexFromHdrindex(i),
									tempVal = Math.abs(parseFloat(gvs.items[gvsIndex].items[idx].rv));
								if (maxValue < tempVal) {
									maxValue = tempVal;
								}
								if (minValue > tempVal) {
									minValue = tempVal;
								}
							}						
						}
						
						var oriBubbleSize = {};
						if (maxValue > minValue) { 
							var minRadius = maxRadius * minValue / maxValue;
							if (minRadius < 2) { minRadius = 2; }
							var step = (maxRadius - minRadius) / (maxValue - minValue),
								radius;
							for (i in gts_es) {
								if (gts_es.hasOwnProperty(i)) {
									radius = (Math.abs(parseFloat(gvs.items[me.getIndexFromHdrindex(i)].items[idx].rv))-minValue) * step + minRadius;
									oriBubbleSize[gts_es[i].n] = radius;
								}							
							}

						} else {
							for (i=0; i<gts_es.length; i++) {
								oriBubbleSize[gts_es[i].n] = maxRadius;
							}
						}
						
						
						
						me.model.oriBubbleSize = oriBubbleSize;
						
					}
					
				},
				
				
				
				storeOriPoints: function storeOriPoints() {
					var coords = this.model.coords,
						oriCoords = {},
						point,
						newPoint,
						elem;
					for(elem in coords) {
						if (coords.hasOwnProperty(elem)) {
							point = coords[elem][0];
							newPoint = [point[0], point[1]];
							oriCoords[elem] = newPoint;
						}
					}
					return oriCoords;
				},
				
				
				drawBubbleMap: function drawBubbleMap() {
					var me = this,
						model = me.model,
						context = this.animationContext,
						coords = model.coords,
						elem,i,j,k,pt;
					
					



					
					
					me.getAllBubblesColor();
					
					me.getOriBubbleSize();

					
					if (model.hasOwnProperty("bgImg") && model.bgImg.hasOwnProperty("src") && model.bgImg.src!="" && model.bgImg.src!=null) {
						me.drawBgImageFlag = true;
						if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = model.bgImg.width; }
						if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = model.bgImg.height; }
						if (!me.hasOwnProperty("oriCoords")) { me.oriCoords = me.storeOriPoints(); }
						
						var xRatio = model.bgImg.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
							yRatio = model.bgImg.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
							ratio = Math.max(yRatio, xRatio); 
						
						me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
						me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
						
						context.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
						
						if (me.shapeFileType === SHAPE_FILE_POLYGON) {
						
							var polygonCenters = {};
							for (i in coords) {
								if (coords.hasOwnProperty(i)) {
									if (i === "bgImage") {
										continue;
									}
									var center = getCentroidOfPolygon(coords[i][0]);
									polygonCenters[i] = center;
									polygonCenters[i][0][0] /= ratio;
									polygonCenters[i][0][1] /= ratio;
								}
							}
							model.polygonCenters = polygonCenters;
						} else {
							
								var oriCoords = me.oriCoords;
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										pt = coords[i][0];
										pt[0] = parseInt(oriCoords[i][0] / ratio, 10);
										pt[1] = parseInt(oriCoords[i][1] / ratio, 10);
									}
								}
							
						}

						me.drawBubblesInMap();
					} else {
						model.bgImg = new Image();

						model.bgImg.onerror = function() {
							var errorMessage = "The backgrond Image cannot be found.";
							me.renderErrorMessage(mstrmojo.desc(9856, errorMessage));
							return;
						};

						model.bgImg.onload = function() {
							
							me.drawBgImageFlag = true;
							if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = this.width; }
							if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = this.height; }
							if (!me.hasOwnProperty("oriCoords")) { me.oriCoords = me.storeOriPoints(); }
							
							var xRatio = this.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
								yRatio = this.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
								ratio = Math.max(yRatio, xRatio); 
							
							me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
							me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
							
							me.animationCanvas.width = me.animationCanvas.width;
							context.drawImage(this, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
							
							if (me.shapeFileType === SHAPE_FILE_POLYGON) {
								
								var polygonCenters = {};
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										var center = getCentroidOfPolygon(coords[i][0]);
										polygonCenters[i] = center;
										polygonCenters[i][0][0] /= ratio;
										polygonCenters[i][0][1] /= ratio;
									}									
								}
								model.polygonCenters = polygonCenters;
							} else {
								
									var oriCoords = me.oriCoords;
									for (i in coords) {
										if (coords.hasOwnProperty(i)) {
											if (i === "bgImage") {
												continue;
											}
											pt = coords[i][0];
											pt[0] = parseInt(oriCoords[i][0] / ratio, 10);
											pt[1] = parseInt(oriCoords[i][1] / ratio, 10);
										}
									}
								
							}
								
							me.drawBubblesInMap();

							if (!me.bgImageScreenshotTaken) {
								me.bgImageScreenshotTaken = true;
								me.localTakeScreenshot(RENDERING_TIME);
							}						
						};
					}
					
					if (coords.hasOwnProperty("bgImage") && coords.bgImage!=="") {
						if (!model.hasOwnProperty("bgImg") || !model.bgImg.hasOwnProperty("src") || model.bgImg.src=="" || model.bgImg.src==null) {
							var bgImgPath = coords.bgImage;
							model.bgImg.src = me.getFullPath(bgImgPath);
							
							
						}					
					} else if (me.shapeFileType === SHAPE_FILE_POLYGON) { 
						me.drawBgImageFlag = false;
						me.scalePolygonCoords();
						me.drawPolygonInMap(POLY_UNDER_BUBBLE_OPACITY);
						
						
						var polygonCenters = {};
						for (i in coords) {
							if (coords.hasOwnProperty(i)) {
								if (i === "bgImage") {
									continue;
								}
								var center = getCentroidOfPolygon(coords[i][0]);
								polygonCenters[i] = center;
							}						
						}
						model.polygonCenters = polygonCenters;
						
						me.drawBubblesInMap();
					}
					
					

				},

				
				drawAreaMap: function drawAreaMap() {
					var me = this,
						model = me.model,
						context = this.animationContext,
						coords = model.coords,
						elem,i,j,k,rgn,oriRng,c,oriC,pt;
					
					if (!model.hasOwnProperty("oriPolyCoords")) {
						me.getOriPolygonCoords();
					}
					
					var oriCoords = model.oriPolyCoords;
					
					context.save();
					context.lineWidth = 2;
					context.strokeStyle = '#AAAAAA';
					
					
					if (model.hasOwnProperty("bgImg") && model.bgImg.hasOwnProperty("src") && model.bgImg.src!="" && model.bgImg.src!=null) {
						if (me.shapeFileType === SHAPE_FILE_POINT) { 
								me.drawBgImageFlag = false;
							} else if (me.shapeFileType === SHAPE_FILE_POLYGON) { 
								me.drawBgImageFlag = true;
								
								if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = model.bgImg.width; }
								if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = model.bgImg.height; }
								
								var xRatio = model.bgImg.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
									yRatio = model.bgImg.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
									ratio = Math.max(yRatio, xRatio);
								
								me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
								me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
								
								context.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
								
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										rgn = coords[i];
										oriRgn = oriCoords[i];
										for (j in rgn) {
											if (rgn.hasOwnProperty(j)) {
												c = rgn[j];
												oriC = oriRgn[j];
												for (k=0; k<c.length; k++) {
													c[k] = parseInt(oriC[k]/ratio, 10);
												}
											}										
										}
									}								
								}
								
								
								var polygonCenters = {};
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										var center = getCentroidOfPolygon(coords[i][0]);
										polygonCenters[i] = center;
									}								
								}
								model.polygonCenters = polygonCenters;
							
								me.drawPolygonInMap(POLY_ABOVE_BG_OPACITY);
							}
					} else {
						model.bgImg = new Image();
						
						model.bgImg.onerror = function() {
							var errorMessage = "The backgrond Image cannot be found.";
							me.renderErrorMessage(mstrmojo.desc(9856, errorMessage));
							return;
						};
						
						model.bgImg.onload = function() {
							if (me.shapeFileType === SHAPE_FILE_POINT) { 
								me.drawBgImageFlag = false;
							} else if (me.shapeFileType === SHAPE_FILE_POLYGON) { 
								me.drawBgImageFlag = true;
								
								if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = this.width; }
								if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = this.height; }
								
								var xRatio = this.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
									yRatio = this.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
									ratio = Math.max(yRatio, xRatio);
								
								me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
								me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
								
								context.drawImage(this, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
								
								
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										rgn = coords[i];
										oriRgn = oriCoords[i];
										for (j in rgn) {
											if (rgn.hasOwnProperty(j)) {
												c = rgn[j];
												oriC = oriRgn[j];
												for (k=0; k<c.length; k++) {
													c[k] = parseInt(oriC[k]/ratio, 10);
												}
											}
										}
									}
								}
								
								
								var polygonCenters = {};
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										var center = getCentroidOfPolygon(coords[i][0]);
										polygonCenters[i] = center;
									}								
								}
								model.polygonCenters = polygonCenters;
								
								me.drawPolygonInMap(POLY_ABOVE_BG_OPACITY);
							}
							if (!me.bgImageScreenshotTaken) {
								me.bgImageScreenshotTaken = true;
								me.localTakeScreenshot(RENDERING_TIME);
							}						
						}; 
					}
					
					
					if (coords.hasOwnProperty("bgImage") && coords.bgImage!=="") {
						if (!model.bgImg.hasOwnProperty("src") || model.bgImg.src=="" || model.bgImg.src==null) {
							model.bgImg.src = me.getFullPath(coords.bgImage);
						}					
					} else if (me.shapeFileType === SHAPE_FILE_POLYGON) {
						me.drawBgImageFlag = false;
						
						this.scalePolygonCoords();
						
						
						var polygonCenters = {};
						for (i in coords) {
							if (coords.hasOwnProperty(i)) {
								if (i === "bgImage") {
									continue;
								}
								var center = getCentroidOfPolygon(coords[i][0]);
								polygonCenters[i] = center;
							}						
						}
						model.polygonCenters = polygonCenters;
						
						
						











						
						this.drawPolygonInMap(POLY_NORMAL_OPACITY);

					}
					
					context.restore();
				},

				
				getHeaderIndex: function getHeaderIndex(headerName) {
					var hdrIndex = -1,
						hdrs = this.model.gts.row[0].es,
						i;

					if (headerName) {
						headerName = headerName.toLowerCase();
						for (i = 0; i < hdrs.length; i++) {
							var name = hdrs[i].n;
							if (name && name.toLowerCase() === headerName) {
								hdrIndex = i;
								break;
							}
						}
					}

					return hdrIndex;
				},
				
				
				getNewColorForOpacityChange: function getNewColorForOpacityChange(bgColor, haveBgImage, curColor, curOpacity, destOpacity) {
					if (curOpacity>1 || curOpacity<0 || destOpacity>1 || destOpacity<0) {
						return curColor;
					}
					
					var eps = 0.0001,
						newBgColor = bgColor;
					if (!bgColor || haveBgImage) { newBgColor = "#FFFFFF"; }				
					
					if (destOpacity >= curOpacity) {
						if (curOpacity + eps > 1) {
							return curColor;
						} else {
							return getOpacityColor(curColor, (destOpacity-curOpacity)/(1-curOpacity));
						}
					} else if (destOpacity < curOpacity) {
						if (curOpacity - eps < 0) {
							return getOpacityColor(curColor, 0);
						} else {
							return getOpacityColor(newBgColor, (curOpacity-destOpacity)/curOpacity);
						}
					}
				},
				
				
				drawPartOpacityBG: function drawPartOpacityBG(ctx, coordsArray, bgOpacity) {
					ctx.save();
				
					var me = this,
						model = me.model,
						offsetX = me.leftOffset ? me.leftOffset : 0,
						offsetY = me.topOffset ? me.topOffset : 0;
					
					var getPointAt = function(j){
						var offset = j%2  ? offsetY : offsetX;
						return pointsArray[j] + offset;
					};
					
					ctx.beginPath();
					
					var i,
						j;
					for (i = 0; i < coordsArray.length; i++) {
						var pointsArray = coordsArray[i],
							minX = getPointAt(0),
							minY = getPointAt(1),
							maxY = getPointAt(1),
							x,
							y;
		
						
						ctx.moveTo(getPointAt(0), getPointAt(1));
		
						for (j = 2; j < pointsArray.length - 1; j = j + 2) {
							x = getPointAt(j);
							y = getPointAt(j + 1);
		
							ctx.lineTo(x, y);
		
							
							maxY = Math.max(y, maxY);
							minY = Math.min(y, minY);
							minX = Math.min(x, minX);
						}
						
						
						x = getPointAt(0);
						y = getPointAt(1);
						ctx.lineTo(x, y);
					}
					
					ctx.clip();
					
					
					ctx.globalAlpha = bgOpacity;
					
					var xRatio = me.oriBgImageWidth / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
						yRatio = me.oriBgImageHeight / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
						ratio = Math.max(yRatio, xRatio);
					
					me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
					me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
					
					ctx.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
					
					
					ctx.restore();
				},
				
				
				highlightImageIcon: function highlightImageIcon(hlContext, coords, touchVal, radiusLarget) {
					var me = this,
						model = me.model,
						fillColor = "RGBA(255,255,255,0.5)",
						iconName = "imageIcon_" + touchVal;
					
					if (model.hasOwnProperty(iconName)) {								
						var imgIcon = model[iconName],
							width = imgIcon.width + radiusLarget*2,
							height = imgIcon.height + radiusLarget*2,
							xOffset = coords[touchVal][0][0] - width/2 + me.leftOffset,
							yOffset = coords[touchVal][0][1] - height/2 + me.topOffset;
						
						
						hlContext.fillStyle = fillColor;
						hlContext.fillRect(xOffset, yOffset, width, height);
						
						
						
						drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height);
						
					}
				},

				
				highlightPoint: function highlightPoint() {
					var me = this,
						model = me.model,
						hlContext = me.highlightContext,
						hdrIndex; 
					
					
					me.highlightCanvas.width = me.highlightCanvas.width;
					
					
					if (me.currSelectedObj===null && isOwnEmpty(me.defaultSelectedObjs) && me.displayMode===DISPLAY_MODE_AREA) {
						if (me.drawBgImageFlag) {
							if (me.curPolygonOpacity !== POLY_ABOVE_BG_OPACITY) {
									me.drawPolygonInMap(POLY_ABOVE_BG_OPACITY);
							}
						} else {
							if (me.curPolygonOpacity !== POLY_NORMAL_OPACITY) {
								me.drawPolygonInMap(POLY_NORMAL_OPACITY);
							}
						}
					}

					if (me.displayMode === DISPLAY_MODE_AREA) {
						
						var bgColor = model.bgColor,
							selectedStrokeColor = POLY_STROKE_COLOR_SELECTED_DARK_THEME,
							hoverStrokeColor = POLY_STROKE_COLOR_HOVER_DARK_THEME,
							selectedHoverStrokeColor = POLY_STROKE_COLOR_SELECTED_HOVER_DARK_THEME,
							noAltColor = POLY_COLOR_NO_ALT_DARK_THEME,
							noColorByColor = POLY_COLOR_NO_COLORBY_DARK_THEME;
						if (model.themeMode === THEME_LIGHT) {
							selectedStrokeColor = POLY_STROKE_COLOR_SELECTED_LIGHT_THEME;
							hoverStrokeColor = POLY_STROKE_COLOR_HOVER_LIGHT_THEME;
							selectedHoverStrokeColor = POLY_STROKE_COLOR_SELECTED_HOVER_LIGHT_THEME;
							noAltColor = POLY_COLOR_NO_ALT_LIGHT_THEME;
							noColorByColor = POLY_COLOR_NO_COLORBY_LIGHT_THEME;
						}
						if (model.vp && model.vp.npc) {
							noAltColor = getOpacityColor("#"+model.vp.npc, POLY_NORMAL_OPACITY);
						}
						
						var fillColor = noAltColor;
						
						
						var dftSltObjs = me.defaultSelectedObjs;
						if (!isOwnEmpty(dftSltObjs)) {
							if (me.curPolygonOpacity !== POLY_UNSELECTED_OPACITY) {
								me.drawPolygonInMap(POLY_UNSELECTED_OPACITY);
							}	
							
							var i;
							for (i in dftSltObjs) {
								if (dftSltObjs.hasOwnProperty(i)) {
									if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null
											&& me.currHoverObj.touchVal===i) {
										continue;
									} else {
										var hIndex = me.defaultSelectedObjs[i]; 
										if (hIndex >= 0) {
											if (me.colorByIndex>=0) {
												if (me.thresholdType === THRESHOLD_COLOR) {
													var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hIndex)].items[me.colorByIndex];
													fillColor = me.getBgColorFromCSS(colorByCellData);
													if (!fillColor) {
														fillColor = noColorByColor;
													}
												} else {
													fillColor = noColorByColor;
												}								
											} else {
												fillColor = noColorByColor;
											}
																		
										} else {
											fillColor = noAltColor;
										}
										
										if (me.drawBgImageFlag) {
											fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITH_BG);
										} else {
											fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITHOUT_BG);
										}
										
										drawPoly(hlContext, model.coords[i], {x:me.leftOffset, y:me.topOffset}, selectedStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
									}
								}						
							}
							
							fillColor = noAltColor;
						} else if (me.currSelectedObj!==null && me.currSelectedObj.hasOwnProperty("touchVal") && me.currSelectedObj.touchVal!=="" && me.currSelectedObj.touchVal!==null) {
							if (me.curPolygonOpacity !== POLY_UNSELECTED_OPACITY) {
								me.drawPolygonInMap(POLY_UNSELECTED_OPACITY);
							}						
							
							if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null
									&& me.currHoverObj.touchVal===me.currSelectedObj.touchVal) {
								
							} else {
								if (me.currSelectedObj.hasOwnProperty("hdrIndex")) {
									hdrIndex = me.currSelectedObj.hdrIndex;
								} else {
									hdrIndex = me.getHeaderIndex(me.currSelectedObj.touchVal);
								}
								if (hdrIndex>=0) {
									if (me.colorByIndex>=0) {
										if (me.thresholdType === THRESHOLD_COLOR) {
											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
											fillColor = me.getBgColorFromCSS(colorByCellData);
											if (!fillColor) {
												fillColor = noColorByColor;
											}
										} else {
											fillColor = noColorByColor;
										}								
									} else {
										fillColor = noColorByColor;
									}
																
								} else {
									fillColor = noAltColor;
								}
								
								if (me.drawBgImageFlag) {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITH_BG);
								} else {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITHOUT_BG);
								}
								
								drawPoly(hlContext, model.coords[me.currSelectedObj.touchVal], {x:me.leftOffset, y:me.topOffset}, selectedStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
							}
						} else if (me.currLinkObj!==null && me.currLinkObj.hasOwnProperty("touchVal") && me.currLinkObj.touchVal!=="" && me.currLinkObj.touchVal!==null) {
							if (me.currLinkObj.hasOwnProperty("hdrIndex")) {
									hdrIndex = me.currLinkObj.hdrIndex;
								} else {
									hdrIndex = me.getHeaderIndex(me.currLinkObj.touchVal);
								}
								if (hdrIndex>=0) {
									if (me.colorByIndex>=0) {
										if (me.thresholdType === THRESHOLD_COLOR) {
											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
											fillColor = me.getBgColorFromCSS(colorByCellData);
											if (!fillColor) {
												fillColor = noColorByColor;
											}
										} else {
											fillColor = noColorByColor;
										}
									} else {
										fillColor = noColorByColor;
									}
																
								} else {
									fillColor = noAltColor;
								}
								
								if (me.drawBgImageFlag) {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_ABOVE_BG_OPACITY, POLY_LINKDRILL_OPACITY);
								} else {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_NORMAL_OPACITY, POLY_LINKDRILL_OPACITY);
								}						
								
								drawPoly(hlContext, model.coords[me.currLinkObj.touchVal], {x:me.leftOffset, y:me.topOffset}, hoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
						}
						if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null) {
								var hvObj = me.currHoverObj;
								
								if (hvObj.hasOwnProperty("hdrIndex")) {
									hdrIndex = hvObj.hdrIndex;
								} else {
									hdrIndex = me.getHeaderIndex(hvObj.touchVal);
								}
								
								if (hdrIndex>=0) {
									if (me.colorByIndex>=0) {
										if (me.thresholdType === THRESHOLD_COLOR) {
											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
											fillColor = me.getBgColorFromCSS(colorByCellData);
											if (!fillColor) {
												fillColor = noColorByColor;
											}
										} else {
											fillColor = noColorByColor;
										}
									} else {
										fillColor = noColorByColor;
									}						
								} else {
									fillColor = noAltColor;
								}
								
								
								if (me.currSelectedObj!==null || !isOwnEmpty(me.defaultSelectedObjs)) { 
		
		
		
									
									if (me.drawBgImageFlag) {
										fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_HOVER_OPACITY_WITH_BG);
									} else {
										fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_HOVER_OPACITY_WITHOUT_BG);
									}

									drawPoly(hlContext, model.coords[me.currHoverObj.touchVal], {x:me.leftOffset, y:me.topOffset}, selectedHoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
								} else { 
									
									if (me.drawBgImageFlag) {
										
										var bgOpacity = (POLY_ABOVE_BG_OPACITY - POLY_HOVER_OPACITY) / POLY_ABOVE_BG_OPACITY;
										this.drawPartOpacityBG(hlContext, model.coords[me.currHoverObj.touchVal], bgOpacity);
										
										fillColor = "RGBA(0,0,0,0)";
										drawPoly(hlContext, model.coords[me.currHoverObj.touchVal], {x:me.leftOffset, y:me.topOffset}, hoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
									} else {
										fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_NORMAL_OPACITY, POLY_HOVER_OPACITY);
										drawPoly(hlContext, model.coords[me.currHoverObj.touchVal], {x:me.leftOffset, y:me.topOffset}, hoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
									}
									
									
								}						
								
								
								if (me.newRenderFlag) {
									
									me.newRenderFlag = false;
									var polygonCenter = me.model.polygonCenters && me.model.polygonCenters[me.currHoverObj.touchVal] && me.model.polygonCenters[me.currHoverObj.touchVal][0];
									if (polygonCenter) {
										var xOnWidget = polygonCenter[0] + me.leftOffset - me._scroller.origin.x;
										var yOnWidget = polygonCenter[1] + me.topOffset - me._scroller.origin.y;
										me.renderTooltip(this.currHoverObj.touchVal, xOnWidget, yOnWidget, this.currHoverObj.hdrIndex);
									}
								} else {
									me.renderTooltip(this.currHoverObj.touchVal, this.currHoverObj.point.x, this.currHoverObj.point.y, this.currHoverObj.hdrIndex);
								}
								
								

											
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						var selectedStrokeColor = BUBBLE_STROKE_COLOR_SELECTED_DARK_THEME,
							hoverStrokeColor = BUBBLE_STROKE_COLOR_HOVER_DARK_THEME,
							linkdrillStrokColor = BUBBLE_STROKE_COLOR_LINKDRILL_DARK_THEME,
							highlightStrokeColor = BUBBLE_HIGHLIGHT_STROKE_COLOR_DARK_THEME,
							noColorByColor = BUBBLE_COLOR_NO_COLORBY_DARK_THEME;
						if (model.themeMode === THEME_LIGHT) {
							selectedStrokeColor = BUBBLE_STROKE_COLOR_SELECTED_LIGHT_THEME;
							hoverStrokeColor = BUBBLE_STROKE_COLOR_HOVER_LIGHT_THEME;
							linkdrillStrokColor = BUBBLE_STROKE_COLOR_LINKDRILL_LIGHT_THEME;
							highlightStrokeColor = BUBBLE_HIGHLIGHT_STROKE_COLOR_LIGHT_THEME;
							noColorByColor = BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME;
						}
						if (me.markerType === MARKER_BUBBLE) {
							me.drawBubblesInMap();
							
							
							var dftSltObjs = me.defaultSelectedObjs;
							if (!isOwnEmpty(dftSltObjs)) {
								var i;
								for (i in dftSltObjs) {
									if (dftSltObjs.hasOwnProperty(i)) {
										var sltBubbleRadius = me.getRadiusFromName(i);
										fillColor = me.getBubbleColorFromName(i);
										if (!fillColor) {
											continue;
										}
										
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
										
										
										fillColor = getOpacityColor(fillColor, BUBBLE_SELECTED_OPACITY);
										
										
										if (me.shapeFileType === SHAPE_FILE_POLYGON) {
											if (model.hasOwnProperty("polygonCenters")) {
												sltCoord = model.polygonCenters[i][0];
											}
										} else if (me.shapeFileType === SHAPE_FILE_POINT) {
											sltCoord = model.coords[i][0];
										}
										
										drawBubble(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, sltBubbleRadius);
										drawStroke(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, selectedStrokeColor, sltBubbleRadius, me.bubbleStrokeWidth);
									}								
								}
								
								fillColor = noAltColor;
							} else if (me.currSelectedObj!==null && me.currSelectedObj.hasOwnProperty("touchVal") && me.currSelectedObj.touchVal!=="" && me.currSelectedObj.touchVal!==null) {
								var fillColor = noColorByColor,
									sltCoord,
									sltBubbleRadius;
								
								
								sltBubbleRadius = me.getRadiusFromName(me.currSelectedObj.touchVal);
								
								
								fillColor = me.getBubbleColorFromName(me.currSelectedObj.touchVal);
								if (!fillColor) {
									fillColor = noColorByColor;
								}






















								
								
								fillColor = getOpacityColor(fillColor, BUBBLE_SELECTED_OPACITY);
								
								
								if (me.shapeFileType === SHAPE_FILE_POLYGON) {
									if (model.hasOwnProperty("polygonCenters")) {
										sltCoord = model.polygonCenters[me.currSelectedObj.touchVal][0];
									}
								} else if (me.shapeFileType === SHAPE_FILE_POINT) {
									sltCoord = model.coords[me.currSelectedObj.touchVal][0];
								}
								
								drawBubble(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, sltBubbleRadius);
								drawStroke(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, selectedStrokeColor, sltBubbleRadius, me.bubbleStrokeWidth);
							} else if (me.currLinkObj!==null && me.currLinkObj.hasOwnProperty("touchVal") && me.currLinkObj.touchVal!=="" && me.currLinkObj.touchVal!==null) {
								var linkCoord,
									linkBubbleRadius;
								
								
								linkBubbleRadius = me.getRadiusFromName(me.currLinkObj.touchVal);
								
								
								fillColor = me.getBubbleColorFromName(me.currLinkObj.touchVal);
								if (!fillColor) {
									fillColor = noColorByColor;
								}
								























								
								fillColor = getOpacityColor(fillColor, BUBBLE_LINKDRILL_OPACITY);
								
								
								if (me.shapeFileType === SHAPE_FILE_POLYGON) {
									if (model.hasOwnProperty("polygonCenters")) {
										linkCoord = model.polygonCenters[me.currLinkObj.touchVal][0];
									}
								} else if (me.shapeFileType === SHAPE_FILE_POINT) {
									linkCoord = model.coords[me.currLinkObj.touchVal][0];
								}
								
								drawBubble(hlContext, linkCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, linkBubbleRadius);
								drawStroke(hlContext, linkCoord, {x:me.leftOffset,y:me.topOffset}, linkdrillStrokColor, linkBubbleRadius, me.bubbleStrokeWidth);
								drawStroke(hlContext, linkCoord, {x:me.leftOffset,y:me.topOffset}, highlightStrokeColor, linkBubbleRadius+me.hoverBubbleRadiusLarger, me.bubbleStrokeWidth);
							}
							if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null) {
								var hoverCoord, 
									hoverBubbleRadius,
									hoverTouchVal = me.currHoverObj.touchVal;
								
								
								hoverBubbleRadius = me.getRadiusFromName(hoverTouchVal);
								
								
								fillColor = me.getBubbleColorFromName(hoverTouchVal);
								if (!fillColor) {
									fillColor = noColorByColor;
								}
								























								
								var nodeStrokeColor = hoverStrokeColor;
								if ((me.currSelectedObj && me.currSelectedObj.touchVal===hoverTouchVal) 
										|| (!isOwnEmpty(me.defaultSelectedObjs) && me.defaultSelectedObjs.hasOwnProperty(hoverTouchVal))) {
									fillColor = getOpacityColor(fillColor, BUBBLE_SELECTED_OPACITY);
									nodeStrokeColor = selectedStrokeColor;
								} else {
									fillColor = getOpacityColor(fillColor, BUBBLE_HOVER_OPACITY);
								}
															
								
								
								if (me.shapeFileType === SHAPE_FILE_POLYGON) {
									if (model.hasOwnProperty("polygonCenters")) {
										hoverCoord = model.polygonCenters[me.currHoverObj.touchVal][0];
									}
								} else if (me.shapeFileType === SHAPE_FILE_POINT) {
									hoverCoord = model.coords[me.currHoverObj.touchVal][0];
								}
								
								drawBubble(hlContext, hoverCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, hoverBubbleRadius); 
								drawStroke(hlContext, hoverCoord, {x:me.leftOffset,y:me.topOffset}, nodeStrokeColor, hoverBubbleRadius, me.bubbleStrokeWidth);
								drawStroke(hlContext, hoverCoord, {x:me.leftOffset,y:me.topOffset}, highlightStrokeColor, hoverBubbleRadius+me.hoverBubbleRadiusLarger, me.bubbleStrokeWidth);
								
								
								if (me.newRenderFlag) {
									
									me.newRenderFlag = false;
									var _center;
									if (me.shapeFileType === SHAPE_FILE_POLYGON) {
										_center = me.model.polygonCenters && me.model.polygonCenters[me.currHoverObj.touchVal] && me.model.polygonCenters[me.currHoverObj.touchVal][0];
									} else if (me.shapeFileType === SHAPE_FILE_POINT) {
										_center = me.model.coords && me.model.coords[me.currHoverObj.touchVal] && me.model.coords[me.currHoverObj.touchVal][0];
									}
									if (_center) {
										var xOnWidget = _center[0] + me.leftOffset - me._scroller.origin.x;
										var yOnWidget = _center[1] + me.topOffset - me._scroller.origin.y;
										me.renderTooltip(this.currHoverObj.touchVal, xOnWidget, yOnWidget, this.currHoverObj.hdrIndex);
									}
								} else {
									me.renderTooltip(this.currHoverObj.touchVal, this.currHoverObj.point.x, this.currHoverObj.point.y, this.currHoverObj.hdrIndex);
								}
								
					
							}
							
						} else if (me.markerType === MARKER_IMAGE) { 
							var coords = model.coords;
							if (model.hasOwnProperty("polygonCenters")) {
								coords = model.polygonCenters;
							}
							
							
							var dftSltObjs = me.defaultSelectedObjs;
							if (!isOwnEmpty(dftSltObjs)) {

								var i;

								for (i in dftSltObjs) {
									if (dftSltObjs.hasOwnProperty(i)) {
										me.highlightImageIcon(hlContext, coords, i, 0);
















									}								
								}
								

							} else if (me.currSelectedObj!==null && me.currSelectedObj.hasOwnProperty("touchVal") && me.currSelectedObj.touchVal!=="" && me.currSelectedObj.touchVal!==null) {
								var touchVal = me.currSelectedObj.touchVal;
								me.highlightImageIcon(hlContext, coords, touchVal, 0);

								
















								
							} else if (me.currLinkObj!==null && me.currLinkObj.hasOwnProperty("touchVal") && me.currLinkObj.touchVal!=="" && me.currLinkObj.touchVal!==null) {
								var touchVal = me.currLinkObj.touchVal;


								
								me.highlightImageIcon(hlContext, coords, touchVal, me.hoverBubbleRadiusLarger);
















							}
							if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null) {
								var touchVal = me.currHoverObj.touchVal,
									fillColor = "RGBA(255,255,255,0.5)";
								
								var iconName = "imageIcon_" + touchVal;
								if (model.hasOwnProperty(iconName)) {
									var imgIcon = model[iconName],
										width = imgIcon.width + me.hoverBubbleRadiusLarger*2,
										height = imgIcon.height + me.hoverBubbleRadiusLarger*2,
										xOffset = coords[touchVal][0][0] - width/2 + me.leftOffset,
										yOffset = coords[touchVal][0][1] - height/2 + me.topOffset;
									
									
									hlContext.fillStyle = fillColor;
									hlContext.fillRect(xOffset, yOffset, width, height);
									
									
									
									var sltObj = me.currSelectedObj,
										hvTouchVal = me.currHoverObj.touchVal;
									if ((sltObj!==null && sltObj.hasOwnProperty("hdrIndex") && sltObj.hdrIndex >= 0 && sltObj.touchVal === hvTouchVal) 
											|| (!isOwnEmpty(me.defaultSelectedObjs) && me.defaultSelectedObjs.hasOwnProperty(hvTouchVal))) {
										
									} else {
										drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height);
									}
								}
								
								
								if (me.newRenderFlag) {
									
									me.newRenderFlag = false;
									var _center;
									if (me.shapeFileType === SHAPE_FILE_POLYGON) {
										_center = me.model.polygonCenters && me.model.polygonCenters[me.currHoverObj.touchVal] && me.model.polygonCenters[me.currHoverObj.touchVal][0];
									} else if (me.shapeFileType === SHAPE_FILE_POINT) {
										_center = me.model.coords && me.model.coords[me.currHoverObj.touchVal] && me.model.coords[me.currHoverObj.touchVal][0];
									}
									if (_center) {
										var xOnWidget = _center[0] + me.leftOffset - me._scroller.origin.x;
										var yOnWidget = _center[1] + me.topOffset - me._scroller.origin.y;
										me.renderTooltip(this.currHoverObj.touchVal, xOnWidget, yOnWidget, this.currHoverObj.hdrIndex);
									}
								} else {
									me.renderTooltip(this.currHoverObj.touchVal, this.currHoverObj.point.x, this.currHoverObj.point.y, this.currHoverObj.hdrIndex);
								}
								
					
							}
						}
					}
					
				},
					

				
				getTouchValue: function getTouchValue(x, y) {
					var me = this,
						model = this.model,
						coords = model.coords,
						elem,
						i;				

					
					if (me.displayMode === DISPLAY_MODE_AREA) {
						if (me.shapeFileType === SHAPE_FILE_POLYGON) {
							for (elem in coords) {
								if (coords.hasOwnProperty(elem)) {
									if (elem === "bgImage") {
										continue;
									}
									var coordsArray = coords[elem],
										l = coordsArray.length;
									for (i = 0; i < l; i++) {
										if (inPoly(coordsArray[i], x, y)) {
											return elem;
										}
									}
								}							
							}
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						if (me.shapeFileType === SHAPE_FILE_POLYGON && model.hasOwnProperty("polygonCenters")) {
							coords = model.polygonCenters;
						}
						var minDistance = Number.MAX_VALUE,
							touchName = "";
						for (elem in coords) {
							if (coords.hasOwnProperty(elem)) {
								if (elem === "bgImage") {
									continue;
								}
								var coord = coords[elem][0],
									distance = Math.sqrt((x-coord[0])*(x-coord[0])+(y-coord[1])*(y-coord[1]));
								if (distance < minDistance) {
									minDistance = distance;
									touchName = elem;
								}
							}						
						}
						
						if (minDistance < this.bias) {
							return touchName;
						}
											
					}
					










					return null;
				},


				
				
				getAreaOrNearestBubble: function (isTap, touchX, touchY){
					var me = this,
						model = me.model,
						coords = model.coords;
					
					
					
					var touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);
					touchX = touchPointOnWidget.touchX;
					touchY = touchPointOnWidget.touchY;
					
					
					var x = touchX+ me._scroller.origin.x-me.leftOffset,
						y = touchY+ me._scroller.origin.y-me.topOffset,
						touchVal;
					if (isTap && me.tooltipOn && me.currHoverObj!==null) {
						var crHP = null;
						if (me.shapeFileType === SHAPE_FILE_POLYGON){
							crHP = model.polygonCenters && model.polygonCenters[me.currHoverObj.touchVal] && model.polygonCenters[me.currHoverObj.touchVal][0];
						} else if (me.shapeFileType === SHAPE_FILE_POINT) {
							crHP = coords[me.currHoverObj.touchVal] && coords[me.currHoverObj.touchVal][0]; 
						}
						
						if (crHP) {
							var dis = Math.sqrt((x-crHP[0])*(x-crHP[0]) + (y-crHP[1])*(y-crHP[1]));
							if (dis < me.bias) {
								touchVal = me.currHoverObj.touchVal;
							} else {
								touchVal = me.getTouchValue(x, y);
							}
						}
					} else {
						touchVal = me.getTouchValue(x, y);
					}
					
					if(!touchVal){
						return null;
					}
					
					var hdrIndex = me.getHeaderIndex(touchVal);

							
					return {touchVal:touchVal, hdrIndex:hdrIndex, point:{x:touchX, y:touchY}};
				},
				
				renderTooltip: function renderTooltip(touchVal, touchX, touchY, hdrIndex) {
					var me = this,
						tooltip = this.tooltip,
						model = this.model,
						table = this.tooltip.childNodes[0],
						tooltipIndex = 0,
						i, j, tr, tdLeft, tdRight;
					
					
					if (table) {
						for (i=0; i<table.childNodes.length; i++) {
							tr = table.childNodes[i];
							if (tr) {
								tr.childNodes[0].innerHTML = '';
								tr.childNodes[1].innerHTML = '';
							}
						}
					}
					
					
					this.tooltip.style.visibility = "visible";
					
					if (!me.tooltipOn) {				
						me.tooltipOn = true;
						
						var touchManager = mstrmojo.touchManager;
						me.tooltipListener = touchManager.attachEventListener('touchesBegin', me.id, function (evt) {
							if(!me.isTouchedOnWidget(evt.touch)){
								me.hideTooltip();
							}
						});
					}				

					var gts = model.gts,
						leftHtml,
						rightHtml;

					if (hdrIndex >= 0) {
						var rows = gts.row,
							idxs = model.ghs.rhs.items,
							idx;
						
						
						tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
						if (tr) {
							
							tr.childNodes[0].style.display = 'table-cell';
							tr.childNodes[1].style.align = 'left';
							
							tr.childNodes[0].style.paddingRight = "5px";
							leftHtml = rows[0].n + ':';
							tr.childNodes[0].innerHTML = leftHtml;
							
							rightHtml = rows[0].es[hdrIndex].n;
							tr.childNodes[1].innerHTML = rightHtml;
						}
						
						
						var ghsIndex = me.getIndexFromHdrindex(hdrIndex);
						for (i=1; i<rows.length; i++) {
							tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
							if (tr) {
								tr.childNodes[0].style.paddingRight = "5px";
								leftHtml = rows[i].n + ':';
								tr.childNodes[0].innerHTML = leftHtml;
								rightHtml = '';
								var _indices = me.attrIndices[i];
								if (_indices) {
									for (j=0; j<_indices.length; j++) {
										
										idx = idxs[ghsIndex].items[_indices[j]].idx;
										rightHtml += rows[i].es[idx].n;
										if (j !== _indices.length-1) {
											rightHtml += ' ';
										}
									}							
								}						
								tr.childNodes[1].innerHTML = rightHtml;
							}
						}
						
						
						var gtsCol = gts.col;
						if (gtsCol && gtsCol.length>0) {
							var units = gtsCol[0].es,
								values = model.gvs.items[ghsIndex].items;

							for (i = 0; i < units.length; i++) {
								tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
								if (tr) {
									tr.childNodes[0].style.paddingRight = "5px";
									var mv = values[i],
										v = mv.v;
									
									if (mv && mv.hasOwnProperty('ty') && mv.ty!=4 && mv.ty!=10 && mv.ty!=3 && mv.hasOwnProperty('ti')) {
										var th = model.th && model.th[i];
										v = (th && th[mv.ti] && th[mv.ti].n) ? th[mv.ti].n : mv.v;
									}
									
									leftHtml = units[i].n + ':';
									tr.childNodes[0].innerHTML = leftHtml;
									rightHtml = '' + v;
									tr.childNodes[1].innerHTML = rightHtml;
								}							
							}
						} else {
							
						}
					} else if (hdrIndex < 0) {
						rightHtml = touchVal;
						tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
						if (tr) {
							tr.childNodes[1].innerHTML = rightHtml;
							tr.childNodes[0].style.display = 'none';
							tr.childNodes[1].style.align = 'center';
							
							
						}					
					}
					
					
					var TLx = touchX + this.bias,
						TLy = touchY - this.bias - tooltip.offsetHeight,
						RightX = this.getWidth() - tooltip.offsetWidth - this.tooltipRightShadowWidth, 
						RightY = this.getHeight() - tooltip.offsetHeight;   
					if (TLx > RightX) {
						if (TLy < 0) {
							TLy = 0;
							TLx = Math.max(touchX - this.bias - tooltip.offsetWidth, 0);
						} else if (TLy >= 0) {
							TLx = RightX;
						}
					} else if (TLx <= RightX) {
						if (TLy < 0) {
							TLy = 0;
						} else if (TLy >= 0) {
							
						}
					}
					
					
					positionTooltip(tooltip, TLx, TLy);
				},
				
				
				hideTooltip: function hideTooltip() {
					if(this.tooltipOn){	
						this.tooltipOn = false;	
						this.currHoverObj = null;					
						this.highlightPoint();	
						






						
						
						
						this.tooltip.style.visibility = "hidden";
						
						
						
						if (this.tooltipListener) {
							
							
							mstrmojo.touchManager.detachEventListener(this.tooltipListener);
							delete this.tooltipListener;
						}						
					}
				},

				
				
				isTouchedOnWidget: function isTouchedOnWidget(touch) {
					
					if(!touch){
						return false;
					}
					
					var me = this,
						touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me),
						x = touchPointOnWidget.touchX,
						y = touchPointOnWidget.touchY;

					if ((x > 0 && x < me.getWidth()) && (y >0 && y < me.getHeight())) {
						return true;
					}
					return false;
				},
				
				unrender: function unrender(ignoreDom) {
					var me = this,
						model = me.model;
										
					if (this._super) {
						this._super(ignoreDom);
					}
					
					if (me.docModelListener) {
						if (me.xtabModel && me.xtabModel.docModel) {
							me.xtabModel.docModel.detachEventListener(me.docModelListener);
						}						
						delete me.docModelListener;
					}
					
					if (me.fullScreenListener) {
						mstrmojo.touchManager.detachEventListener(me.fullScreenListener);
						delete me.fullScreenListener; 
					}
	
					if (me.tooltipListener) {
						mstrmojo.touchManager.detachEventListener(me.tooltipListener);
						delete me.tooltipListener;
					}
					
					if (me.highlightContext) {
						delete me.highlightContext;
					}
					if (me.animationContext) {
						delete me.animationContext;
					}
									
					if (me._tn) {
						delete me._tn;
					}
					
				},
				
				destroy: function destroy() {
					
					if (this._super) {
						this._super();
					}
				}

			}

			

	);

}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.Vis", 
                         "mstrmojo.url",
                         "mstrmojo._TouchGestures", 
                         "mstrmojo.HBox",
                         "mstrmojo.Label",
                         "mstrmojo.Image",
                         "mstrmojo._HasTouchScroller");
    
    var $M = Math,
        $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        BORDER_WIDTH = 30,
        MARGIN_BOTTOM = 50,
        DOT_INTERVAL = 32;
    
    
    function getDimension(dimension) {
        
        var n = 'container' + dimension;
        if(!this[n]) {
            var domNode = this.domNode,
            x = parseInt(this[dimension.toLowerCase()], 10);
            
            
            this[n] = (isNaN(x)) ? domNode['client' + dimension] : x;
        }
        return this[n];
    }    
    
    
    function getColGroupHTML(len) {
        var i, cols = '';
        if(len > 0) {
            for(i = 0; i < len; i++) {
                
                cols += '<col style="width:' + (100/len) + '%" />';
            }
        }
        return '<colgroup>' + cols + '</colgroup>';
    }
        
    
    function getImagePath(n) {
        return mstrmojo.url.getAbsoluteURL(n, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());
    }
    
    
    function transitTo(domNode, xpos) {
        domNode.style[$DOM.CSS3_TRANSITION_DURATION] = '500ms';
        $DOM.translate(domNode, xpos, 0, 0, '', true);
    }
    
    
    function resizeImage(n, w, h) {
        
        if(!n) {
            return ;
        }
        var iw = n.clientWidth, 
            ih = n.clientHeight, 
            rw, rh,
            resized = false;
        
        
        if(w < iw || h < ih) {
            resized = true;
            rw = w/iw; 
            rh = h/ih; 

            
            if(rw < rh) {
                
                n.width = w;
            } else {
                
                n.height = h;
            }
        }
        return resized;
    }
    
    
    function getHeadersByColumn(dp) {
        var cols = [], r, c, col,
            rhs, hds,
            rc = dp.getTotalRows(), 
            cc = rc > 0 ? dp.getRowTitles().size() : 0; 
        
        for(r = 0; r < rc; r++) {
            
            rhs = dp.getRowHeaders(r);
            
            for(c = 0; c < cc; c++) {
                
                if(!cols[c]) {
                    cols[c] = [];
                }
                
                hds = rhs.getHeader(c);
                
                cols[c].push({n: hds.getName()});
            }      
        }
        return cols;
    }
    
        
    mstrmojo.ImageCarousel = mstrmojo.declare(
        
        mstrmojo.Vis,
        
        [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],
                
        {
            scriptClass: 'mstrmojo.ImageCarousel',
            
            markupString: '<div class="mstrmojo-ImageCarousel {@cssClass}" style="overflow:hidden;{@cssText}">'+
                              '<div class="imageViewer" mstrAttach:click>{@noImageMsg}</div>' +
                              '<div class="imageTitle"></div>' +
                              '<div class="statusBar" style="overflow:hidden"></div>' +
                          '</div>',            
        
            markupSlots: {
                viewerNode: function() { return this.domNode.firstChild; },
                textNode: function() { return this.domNode.childNodes[1]; },
                statusBarNode: function() { return this.domNode.lastChild; }
            },
                          
            formatHandlers: {
                domNode: [ 'RW' ]
            },
            
            
            scrollerConfig: {
                friction: 0.0087,
                bounces: false,
                vScroll: false,
                hScroll: true
            },            
                        
            
            selected: -1,
            
            
            children: [{
                scriptClass: 'mstrmojo.HBox',
                slot: 'viewerNode',
                alias: 'viewer',                
                onitemsChange: function() {
                    var v, i, len, c = [],
                        vp = this.parent.vp,
                        bdcss;
                    
                    v = this.items;
                    if(!this.hasRendered) {
                        var p = this.parent,
                            cw = getDimension.call(p, 'Width'), 
                            ch = getDimension.call(p, 'Height'); 

                        if(this.children) {
                            this.removeChildren();
                        }                        
                        
                        len = v.length;
                        
                        this.colHTML = getColGroupHTML(len);
                        
                        
                        this.cssText = 'width:' + (cw*len) + 'px;height:' + (ch - MARGIN_BOTTOM) + 'px';
                        
                        bdcss = (vp && vp.bw) ? ('border:' + vp.bw + 'px solid #' + (vp.bc || 'FFF')) : ''; 
                        
                        for(i = 0; i < len; i++) {
                            c.push({
                                scriptClass: 'mstrmojo.Image',
                                cssText: bdcss,
                                cssDisplay: 'inline-block',
                                src: getImagePath(v[i].n || v[i].v),
                                onload: function() {
                                    
                                    resizeImage(this.imgNode, cw - BORDER_WIDTH, ch - MARGIN_BOTTOM);
                                }
                            });
                        }
                        this.addChildren(c);
                    }
                }
            },{
                scriptClass: 'mstrmojo.Label',
                slot: 'textNode',
                alias: 'description'
            }, {
                scriptClass: 'mstrmojo.HBox',
                slot: 'statusBarNode',
                alias: 'sb',
                onitemsChange: function() {                
                    var v = this.items, c = [], i, len;
                    
                    
                    if(this.children) {
                        this.removeChildren();
                        delete this.numVisibleDots;
                        this.lastSelected = -1;
                    }
                    
                    for(i = 0, len = v.length; i < len; i++) {
                        c.push({
                            scriptClass: 'mstrmojo.Label'                            
                        });
                    }
                    this.addChildren(c);
                    
                    
                },
                lastSelected: 0, 
                select: function(idx) {
                    var lstPg, curPg, dn = this.domNode, dts = this.numVisibleDots; 
                    
                    if(this.selectedNode) {
                        $CSS.removeClass(this.selectedNode.domNode, 'selected');
                    }
                    
                    
                    if(this.items.length > 0) {
                        this.selectedNode = this.children[idx];
                        $CSS.addClass(this.selectedNode.domNode, 'selected');
                        
                        
                        
                        if(!dts) {
                            dts = this.numVisibleDots = $M.floor(getDimension.call(this.parent, 'Width')/DOT_INTERVAL);
                            if(this.items.length < dts) {
                                $CSS.addClass(dn, 'center');
                            } else {
                                $CSS.removeClass(dn, 'center');
                            }
                        }
                        
                        lstPg = $M.floor(this.lastSelected/this.numVisibleDots);
                        curPg = $M.floor(idx/this.numVisibleDots);
                        
                        if(lstPg !== curPg) {
                            transitTo(dn, -curPg * dts * DOT_INTERVAL);
                        } 
                        this.lastSelected = idx;
                    }
                }
            }],
            
            
            updateScrollerConfig: function updateScrollerConfig() {
                var len = this.viewer.items.length;
                mstrmojo.hash.copy({
                    scrollEl: this.viewerNode,
                    origin: {x: 0, y: 0},
                    offset: {
                        x: {
                            start: 0,
                            end: ((len > 0) ? (len - 1) : 0) * getDimension.call(this, 'Width')
                        }    
                    }
                }, this.scrollerConfig);
                return this._super();
            },
            
            touchSwipeEnd: function touchSwipeEnd(touch) {
                var delta = touch.delta,
                    len = this.viewer.items.length;
                
                
                if(delta && delta.x > 0) {
                    this.set('selected', Math.max(0, this.selected - 1));
                } else if(delta && delta.x < 0) {
                    this.set('selected', Math.min(this.selected + 1, len));
                }
            },
            
            
            
            onclick: function(e) {
                var dlgCfg;
                
                if(mstrApp.getScreenDimensions && this.selectedImage) {
                    dlgCfg = {
                            cssClass: 'image-FullScreen',
                            onclick: function() { this.close(); },
                            
                            resizeDialog: function() {
                                var d = mstrApp.getScreenDimensions(),
                                    dm = this.domNode,
                                    ds = dm && dm.style;
                                if(d && ds) {
                                    ds.width = d.w + 'px';
                                    ds.height = d.h + 'px';
                                }
                            },
                            
                            children:[{
                                scriptClass: 'mstrmojo.Image',
                                src: this.selectedImage,
                                onload: function() {
                                    var d = mstrApp.getScreenDimensions();
                                    if(d) {
                                        
                                        
                                        resizeImage(this.imgNode, d.w, d.h);
                                        
                                        
                                        this.parent.positionDialog();
                                    }
                                }
                            }]};
                    mstrApp.showDialog(dlgCfg);
                }
            },
            
            touchTap: function(e) {
                this.onclick(e);
            },
            
            preBuildRendering: function preBuildRendering() {
                var dp = this.getDataParser(),
                    headers = getHeadersByColumn(dp),
                    imgs, desc;
                
                
                if(!this.vp) {
                    this.vp = this.model.vp;
                }
                
                imgs = headers[0] || []; 
                desc = headers[1] || []; 
                this.viewer.set('items', imgs);
                
                this.sb.set('items', desc);
                this.selected = -1;
                
                
                if(imgs.length > 0) {
                    this.cssClass = this.cssClass ? '' : this.cssClass.replace(/noImage/, '');
                    this.noImageMsg = '';
                } else {
                    this.cssClass += this.cssClass ? '' : ' noImage';
                    this.noImageMsg = 'No Photo Found';
                }
                
                
                if(this.vp && this.vp.bgc) {
                    this.cssText = 'background-color:#' + this.vp.bgc + ';';
                }
                
                this._super();
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                
                this.set('selected', 0);
            },
            
            
            onselectedChange: function onselectedChange() {
                var idx = this.selected, 
                    s = this.sb,
                    img = this.viewer.items[idx],
                    desc = s.items[idx];
                
                
                if(img) {
                    
                    this._scroller.scrollTo(idx * getDimension.call(this, 'Width'), 0, 500);
                    
                    this.selectedImage = getImagePath( (img && img.n) || '');
                    
                    
                    s.select(idx);
                    
                    
                    this.description.set('text', (desc && desc.n) || '');
                }
            }
            
            
        });
}());
(function() {

	mstrmojo.requiresCls("mstrmojo.Vis",
						 "mstrmojo.dom",
						 "mstrmojo.VisHeatMapColorTheme",
						 "mstrmojo.VisHeatMapPopup",
						 "mstrmojo.VisHeatMapTree",
						 "mstrmojo._TouchGestures",
						 "mstrmojo._HasTouchScroller",
						 "mstrmojo.num",
						 "mstrmojo._HasWaitIcon",
						 "mstrmojo.EnumReadystate",
						 "mstrmojo.css",
						 "mstrmojo.VisHeatMapCanvas"
						 );

	var $READYSTATE = mstrmojo.EnumReadystate;
	var DRILLING_ACTION = 1,
		SELECTOR_ACTION = 2,
		HYPERLINK_ACTION = 4,
		INFOWINDOW_ACTION = 4;
	var $CSS = mstrmojo.css,
		cssShow = "heatmap-show";
	var LabelSize = {
		On : 0,
		Off : 1,
		Proportional : 2
	};
	var AggregationType = {
		Sum : 0,
		Avg : 1,
		Cnt : 2,
		Max : 3,
		Min : 4,
		GeoAvg : 5
	};
	var BandDirection = {
		LeftToRight : 0,
		RightToLeft : 1,
		Center : 2,
		None : 3
	};
	var LayoutAlgorithm = {
		Squarified : 0,
		PivotByMiddle : 1,
		SliceAndDice : 2
	};

	var LayoutProperties = {
		Padding : 6,
		MaxLegendHeight : 60,
		LegendMenuEditorWidth: 70,
		LegendTickCount: 5,
		LegendMinWidth: 15,
		LegendTickLength: 4,
		LegendMaxBandWidth: 400,
		LegendWidthPercent: 0.9,
		LegendMinPadding: 15,
		LegendBottomPadding: 3,
		LegendGutter: 5,
		LegendBandAspect: 10,
		MinShowLabelDimension: 6,
        DeletedListHeight: 500,
        EditorDialogWidth: 565,
        EditorDialogHeight: 574,
        EditButtonWidth: 60,
        EditButtonHeight: 40,
        EditButtonRight: 10,
        
        WaitIconWidth: 205,
        WaitIconHeight: 105,
        WaitIconMargin: 10,
        WaitIconFontSize: 20
	};

    var Spec = {
            heatmap_popup_panel_title: {
                    font_size: {value: 18, unit: 'pt'}
            },
            heatmap_gray_label: {
                    padding_bottom: { value: 7, unit: 'px' },
                    font_size: { value:10, unit: 'pt' },
                    height: { value: 32, unit: 'px' },
                    padding_left: {value: 22, unit: 'px' }
            },

            
            heatmap_tree_button: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_one_level_1: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_multi_level_1: {
                    font_size: {value: 24, unit: 'pt'}
            },
            heatmap_two_level_2: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_multi_level_2: {
                    font_size: {value: 20, unit: 'pt'}
            },
            heatmap_multi_level_3: {
                    font_size: {value: 10, unit: 'pt'}
            },
            heatmap_size_legend: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend_label: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend_tooltip: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_editor_button: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_tooltip_gray_bold: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tooltip_gray: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tooltip_black_bold: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tooltip_black: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tree_div: {
                    font_size: {value: 18, unit: 'pt'}
            },
            heatmap_tree_root__heatmap_tree_div: {
                    font_size: {value: 14, unit: 'pt'}
            }
    };





	var Fake_Metric_ID = "--";
	var Background_Color = 0xF5F5F7;
	var EID_SELECTALL = "OA:(All)";
	function adjustPixel(px,forceFix){
            var DPIX = 149,
                base = 160;
            if(forceFix){
                    base = 149;
            }
            if(this.enableMultiDPI || forceFix){
                    DPIX = this.DPIX;
            }
            return parseInt(px*(DPIX/base));
	}

	

	

	function getCSSColor(rgb) {
		var c = 0x1000000 + rgb;
		var str = '#' + c.toString(16).substring(1).toUpperCase();
		return str;
	}
	function roundNumber(n, l) { 
		return Math.round(n*Math.pow(10,l))/Math.pow(10,l);
	}
	function createPath(x, y, w, h, r, ctx) {
		ctx.beginPath();
	    ctx.moveTo(x + r, y);
	    ctx.lineTo(x + w - r - 1, y);
	    ctx.quadraticCurveTo(x + w - 1, y, x + w - 1, y + r);
	    ctx.lineTo(x + w - 1, y + h - r - 1);
	    ctx.quadraticCurveTo(x + w - 1, y + h - 1, x + w - r - 1, y + h - 1);
	    ctx.lineTo(x + r, y + h - 1);
	    ctx.quadraticCurveTo(x, y + h - 1, x, y + h - r - 1);
	    ctx.lineTo(x, y + r);
	    ctx.quadraticCurveTo(x, y, x + r, y);
	    ctx.closePath();
	}


	function updateEntityAggValue(ev, rawValue, needsCopy) {
		if (needsCopy && ev.total === undefined) {
			ev.avgTotal = ev.total = ev.geomProduct = ev.max = ev.min = ev.value;
			ev.count = isNaN(ev.value) ? 0 : 1;
			ev.positiveCount = ev.value > 0 ? 1 : 0;
		}
		ev.value = rawValue;
		ev.allChildrenCount++;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.total)) {
				ev.total = rawValue;
			} else {
				ev.total += rawValue;
			}
			if (isNaN(ev.avgTotal)) {
				ev.avgTotal = rawValue;
			} else {
				ev.avgTotal += rawValue;
			}
			if (isNaN(ev.max)) {
				ev.max = rawValue;
			} else {
				ev.max = Math.max(ev.max, rawValue);
			}
			if (isNaN(ev.min)) {
				ev.min = rawValue;
			} else {
				ev.min = Math.min(ev.min, rawValue);
			}
			if (isNaN(ev.geomProduct)) {
				if (rawValue > 0) {
					ev.geomProduct = rawValue;
					ev.positiveCount++;
				}
			} else {
				if (rawValue > 0) {
					ev.geomProduct *= rawValue;
					ev.positiveCount++;
				}
			}
			ev.count++;
		}
	}
	function updateEntityContainerAggValue(ev, oldev) {
		var rawValue = oldev.total;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.total)) {
				ev.total = rawValue;
			} else {
				ev.total += rawValue;
			}
			ev.count++;
		}
		rawValue = oldev.avg;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.avgTotal)) {
				ev.avgTotal = rawValue;
			} else {
				ev.avgTotal += rawValue;
			}
		}
		rawValue = oldev.max;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.max)) {
				ev.max = rawValue;
			} else {
				ev.max = Math.max(ev.max, rawValue);
			}
		}
		rawValue = oldev.min;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.min)) {
				ev.min = rawValue;
			} else {
				ev.min = Math.min(ev.min, rawValue);
			}
		}
		rawValue = oldev.geomAvg;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.geomProduct)) {
				if (rawValue > 0) {
					ev.geomProduct = rawValue;
					ev.positiveCount++;
				}
			} else {
				if (rawValue > 0) {
					ev.geomProduct *= rawValue;
					ev.positiveCount++;
				}
			}
		}
	}
	function decodeXML(s){
		return s.replace(/&lt;/g, "<"
			   ).replace(/&gt;/g, ">"
			   ).replace(/&quot;/g,"\"");
			   
	}

	var delStatus = {
			dftUnDel: 0, 
			dftDel: 1, 
			usrDel: 2 
	};

	function parseDeletedList(s){
		var oParser = new DOMParser(),
			oDOM = oParser.parseFromString(decodeXML(s), "text/xml"),
			i = 0,
			ce = oDOM.childNodes[0], 
			l = oDOM.childNodes[0].childElementCount; 
		if(l == 0) return {};
		var	cr = ce.firstElementChild,
			at = cr.attributes,
			al = at.length,
			ret = this.props.deletedList || {},
			dict = ret,
			key;
		while (i < l) {
			dict = ret;
			at = cr.attributes;
			for (var j = 0; j < al; j++) {
				key = at[j].value;
				if (j === (al - 1)) {
					dict[key] = delStatus.dftDel; 
				} else {
					if (!dict[key]) {
						dict[key] = {};
					}
					dict = dict[key];
				}
			}
			i++;
			cr = cr.nextElementSibling;
		}
		return ret;
	}

    function loadSession() {
            var props = this.props,
                session = this.controller.view.model.session;
            if(session) {
                    
                    if(session.db !== undefined) {
                            props.delButtonEnabled = session.db;
                    }
                    
                    if(session.dl !== undefined) {
                            props.deletedList = mergeDeletedList(props.deletedList, session.dl);
                    }
                    
                    if(session.ps != undefined) {
                            this.previousSelected = lookUpSelectionDic.call(this, session.ps);
                    }

                    this.isUsingSavedColorTheme = session.isUsingSavedColorTheme;
                    this.isUsingDefaultColorTheme = session.isUsingDefaultColorTheme;
            }

            function lookUpSelectionDic(sd) {
                    var root = this.root;
                    for(var i = 0, len = sd.length; i < len; i++) {
                            var children = root.entityChildren;
                            for(var j = 0, l = children.length; j < l; j++){
                                    var ret = null;
                                    if(this.getEntityDisplayName(children[j]) === sd[i]){
                                            ret = children[j];
                                            root = ret;
                                            break;
                                    }
                            }
                    }
                    return ret;
            }

            function mergeDeletedList(d1, d2) {
                    
                    function merge(a, b) {
                            var keys = Object.keys(b),
                                len = keys.length;
                            for(var i = 0; i < len; i++) {
                                    var key = keys[i];
                                    if(typeof b[key] !== 'object') {
                                            a[key] = b[key];
                                    }else {
                                            if(a[key] === undefined) {
                                                    a[key] = {};
                                            }
                                            merge(a[key], b[key]);
                                    }
                            }
                    }
                    var ret = {};
                    merge(ret, d1);
                    merge(ret, d2);
                    return ret;
            }
    }

    function storeSession() {
            var cvm = this.controller.view.model,
                session = {},
                props = this.props;
            cvm.session = session;
            if(props.delButtonEnabled !== undefined) {
                    session.db = props.delButtonEnabled;
            }
            if(props.deletedList !== undefined) {
                    session.dl = props.deletedList;
            }
            if(this.previousSelected) {
                    session.ps = generateSelectionDic.call(this, this.previousSelected);
            }

            session.isUsingSavedColorTheme = this.isUsingSavedColorTheme;
            session.isUsingDefaultColorTheme = this.isUsingDefaultColorTheme;

            function generateSelectionDic(entity) {
                    var sd = [];
                    while(entity.parent){
                            sd.push(this.getEntityDisplayName(entity));
                            entity = entity.parent;
                    }
                    return sd;
            }
    }



	function loadProps() {
		this.props = {};
		var props = this.props,
			m = this.model,
			propValue = m.vp? m.vp : {},
			temp;
		
        props.deletedList = {};
		props.delButtonEnabled = false;
		props.showMetricValues = false;
		props.refreshType = 0;
		props.labelSize = LabelSize.On;
		props.showLegend = true;

		props.sizeMetricEnabled = true;
		props.colorMetricEnabled = true;
		props.layout = LayoutAlgorithm.Squarified;
		props.legendAsc = true;

		var w = mstrmojo.VisHeatMapColorTheme.newInstance();
		w.initialize();
		this.colorTheme = w;

		if(propValue.dl){
			props.deletedList = parseDeletedList.call(this, propValue.dl);
		}
		if(propValue.ed){
			props.delButtonEnabled = (propValue.ed == "true" ? true:false);
		}
		if(propValue.mv){
			props.showMetricValues = (propValue.mv == "true" ? true:false);
		}
		if(propValue.rt != ""){
			props.refreshType = parseInt(propValue.rt);
		}
		if(propValue.ml){
			temp = propValue.ml.split(',');
			if(temp.length >= 2){
				props.sizeMetricID = temp[0];
				props.colorMetricID = temp[1];
			}
		}
		if(propValue.lb){
			temp = propValue.lb;
			if(temp == "Off"){
				props.labelSize = LabelSize.Off;
			}else if(temp == "Proportional"){
				props.labelSize = LabelSize.Proportional;
			}
		}
		if(propValue.lg){
			props.showLegend = (propValue.lg == "true" ? true:false);
		}
		if(propValue.rlp == "false" && propValue.abs)
			w.convertAbsoluteToBlend(this,propValue);

		if(propValue.blc){
			w.isBlend = (propValue.blc == "true" ? true:false);
		}
		if(propValue.gradientColors && propValue.bandColors){
			w.createDataProviderFromString(propValue.gradientColors, propValue.bandColors);
		}
		
		if(propValue.la){
			props.layout = parseInt(propValue.la, 10);
		}
        
        if(propValue.rlp == "false" && propValue.abs){
                this.colorTheme.convertAbsoluteToBlend(this,propValue);
                this.colorTheme.createDataProviderFromString(propValue.gradientColors, propValue.bandColors);
        }

	}

    function setLayout(){
		var widgetWidth = parseInt(this.width, 10),
			widgetHeight = parseInt(this.height, 10),
			heatMapWidth = widgetWidth - 2*this.LayoutProperties.Padding,
			legendHeight = 0, heatMapHeight;
		
		if(this.model.gvs.items.length <= 0)
			this.props.showLegend = false;
		if(this.props.showLegend){
                legendHeight = Math.min(Math.floor(0.2*(widgetHeight-2*this.LayoutProperties.Padding)), this.LayoutProperties.MaxLegendHeight);
                heatMapHeight = widgetHeight - legendHeight - 3*this.LayoutProperties.Padding;
        }else
                heatMapHeight = widgetHeight - 2*this.LayoutProperties.Padding;
		this.heatMapSize = {
				x : 0,
				y : 0,
				w : heatMapWidth,
				h : heatMapHeight
		};
        this.legendSize = {
                x : 0,
                y : widgetHeight - 2*this.LayoutProperties.Padding - legendHeight,
                w : widgetWidth,
                h : legendHeight
        };
        this.infoWindowSize = {
                maxWidth : parseInt(this.width) - 60,
                maxHeight : parseInt(this.height) - 60
        };

        
        this.maxScale = 10;
		
		
        
        
    }
	function resetMetricIndices() {
		
		var m = this.model,
			l = m.ghs.chs.items[0] ? m.ghs.chs.items[0].items.length:0,
			sid = this.props.sizeMetricID,
			cid = this.props.colorMetricID,
			a = [];
		this.metricArray = a;
		for(var i = 0; i < l; i++){
			a.push(getMetricID.call(this, i));
		}
		a.push(Fake_Metric_ID);
		l++;

		
		this.sizeMetricIndex = 0;
		this.colorMetricIndex = l>2 ? 1:0;
		
			
		
			
		
		
		
		for(var i = 0; i < l; i++){
			if(sid == a[i]){
				this.sizeMetricIndex = i;
			}
			if(cid == a[i]){
				this.colorMetricIndex = i;
			}
		}
		
		if(sid === undefined){
			
				
				
					
					
				
			sid = a[this.sizeMetricIndex];
			this.props.sizeMetricID = sid;
		}

		if(cid === undefined){
			
				
				
					
					
				
			cid = a[this.colorMetricIndex];
			this.props.colorMetricID = cid;
		}

        var gvs = m.gvs && m.gvs.items,
            lgvs = gvs && gvs.length,
            i,
            sidx = this.sizeMetricIndex,
            cidx = this.colorMetricIndex;
        this.sizeByMetricMissing = true;
        this.colorByMetricMissing = true;
        for(i = 0; i < lgvs; i++) {
            var values = gvs[i] && gvs[i].items;
            if(values[sidx] === undefined || values[sidx].rv !== '') {
                this.sizeByMetricMissing = false;
                break;
            }
        }
        for(i = 0; i < lgvs; i++) {
            var values = gvs[i] && gvs[i].items;
            if(values[cidx] === undefined || values[cidx].rv !== '') {
                this.colorByMetricMissing = false;
                break;
            }
        }

        if(this.sizeByMetricMissing) {
            this.props.sizeMetricEnabled = false;
            this.sizeMetricIndex = a.length -1;
            this.props.sizeMetricID = a[this.sizeMetricIndex];
        }
        if(this.colorByMetricMissing) {
            this.props.colorMetricEnabled = false;
        }

		if(this.props.sizeMetricID === Fake_Metric_ID)
			this.props.sizeMetricEnabled = false;
		if(this.props.colorMetricID === Fake_Metric_ID){
			this.props.colorMetricEnabled = false;
            this.colorTheme.hasNoColorMetric = true;
        }

		if(this.props.sizeMetricEnabled == false && this.props.colorMetricEnabled == false)
			this.props.showLegend = false;

	}
	function loadMetricsInfo(){
		this.aggFunctions = [];
		var props = this.props,
			cid = props.colorMetricID,
			af = this.aggFunctions,
			m = this.model,
			propValue = m.vp? m.vp : {},
			ar = this.metricArray,
			l = ar.length - 1;
		
		if(cid != Fake_Metric_ID){
			var mlEnabled = (propValue["mle"+cid] == "true") ? true : false;
			if(mlEnabled){
				var val = parseFloat(propValue["mlma"+cid]);
				if(!isNaN(val)){
					this.mlmax = val;
				}
				val = parseFloat(propValue["mlmi"+cid]);
				if(!isNaN(val)){
					this.mlmin = val;
				}
			}
		}
		
		for(var i = 0; i < l; i++){
			var id = "agf" + ar[i];
			if(propValue[id] !== undefined){
				af.push(parseInt(propValue[id]));
			}else{
				af.push(AggregationType.Sum);
			}
		}
	}
	function totalRow(row){
		for(var i = 0; i < row.length; i++){
			var obj = row[i].etk;
			if(obj == -1 || obj == "-1"){
				return true;
			}
		}
		return false;
	}

    function convertDataToModels() {
            resetMetricIndices.call(this);
            loadMetricsInfo.call(this);
            var m = this.model,
            deletedList = this.props.deletedList,
            att = m.gts.row, 
            atl = att.length, 
            mv = m.gvs.items, 
            
            rl = m.ghs.rhs? m.ghs.rhs.items.length : 0;
            ml = mv[0] ? mv[0].items.length:0, 
            rhs = m.ghs.rhs.items;


            if(atl <= 0){
                    var errmsg = "The Heat Map requires at least one attribute on row axis to render properly; it is recommended that two metrics be placed on the column axis as well.";

                    m.err = mstrmojo.desc(11147, errmsg);
                    return ;
            }
            this.singleSelection = false;
            this.hasNegativeSizeValue = false;

            this.levelAttributes = [];
            
            
            this.root = {
                    aggValues : [],
                    entityChildren : [],
                    level : 0
            };
            
            for ( var i = 0; i < atl; i++) {
                    this.levelAttributes[i] = {
                            index : i,
                            order : i + 1,
                            isInLOA : i + 1 > 0 ? true : false
                    }
            }
            var hashDict = {},
            attSpan = [];
            
            for(var i = 0; i < atl; i++){
                    var o = att[i].fs;
                    attSpan[i] = Math.max(1, o ? o.length: 1);
            }
            this.attSpan = attSpan;

            var isAllSelectable = true,
                lastSerialRowIndex,
                serialEntity,
                highestLevelEntity,
                highestLevelIndex;

            
            for (var i = 0; i < rl; i++) { 
                    var attributeArray = [],
                    rowHeaderData = rhs[i].items,
                    k;
                    if(totalRow(rowHeaderData)) continue;

                    
                    var levelID = "",
                        delDict = deletedList,
                        parent = this.root,
                        cur = 0,
                        entity,
                        str,
                        serialEndIndex = -1;
                    for (var j = 0; j < atl; j++) {
                            var index,
                                newEntity;
                            str = "";
                            for(var k = 0; k < attSpan[j]; k++, cur++){
                                    index = rowHeaderData[cur].idx;
                                    if(index == -1)
                                            continue;
                                    str += att[j].es[index].n + " ";
                                    if(k == 0){
                                            levelID += index;
                                    }
                            }
                            str = str.substring(0, str.length-1);
                            if (delDict) {
                                    delDict = delDict[decodeXML(str)];
                            }
                            
                            if(j != atl -1){
                                    if (hashDict[levelID] !== undefined) {
                                            parent = hashDict[levelID];
                                    } else {
                                            var entityContainer = {
                                                    aggValues : [],
                                                    entityChildren : [],
                                                    parentEntity : parent
                                            };
                                            var childrenArray = parent.entityChildren;
                                            childrenArray.push(entityContainer);
                                            hashDict[levelID] = entityContainer;
                                            parent = entityContainer;
                                            entityContainer["deleted"] = false;
                                            entityContainer["text"] = str;
                                            entityContainer["label"] = str;
                                            entityContainer["level"] = j;
                                            entityContainer["index"] = i;
                                    }
                                    levelID += ":";
                                    newEntity = entityContainer;
                            }else { 
                                    if (hashDict[levelID] !== undefined) {
                                            entity = hashDict[levelID];
                                            var indice = entity.indices;
                                            indice.push(i);
                                            for ( var k = 0; k < ml + 1; k++) {
                                                    var ev = entity.aggValues[k];
                                                    var rawValue;
                                                    
                                                    if (k == ml) {
                                                            rawValue = 1.0;
                                                    } else {
                                                            rawValue = mv[i].items[k].rv;
                                                    }
                                                    updateEntityAggValue(ev, parseFloat(rawValue), true);
                                                    if (!isNaN(rawValue)) {
                                                            this.aggregated = true;
                                                    }
                                            }
                                    } else {
                                            entity = {
                                                    indices : [],
                                                    aggValues : [],
                                                    parentEntity : parent
                                            };
                                            var indice = entity.indices;
                                            indice.push(i);
                                            var aggValues = entity.aggValues;
                                            for (var k = 0; k < ml + 1; k++) {
                                                    var ev = {};
                                                    aggValues[k] = ev;
                                                    var rawValue;
                                                    
                                                    if (k == ml) {
                                                            rawValue = 1.0;
                                                    } else {
                                                            rawValue = mv[i].items[k].rv;
                                                    }
                                                    
                                                    ev.value = parseFloat(rawValue);
                                                    ev.allChildrenCount = 1;
                                            }
                                            this.aggregated = false;
                                            
                                            if (delDict) { 
                                                    entity["deleted"] = true;
                                                    this.colorTheme.useDefault = false;
                                            }
                                            
                                            var childrenArray = parent.entityChildren;
                                            childrenArray.push(entity);
                                            entity["level"] = atl - 1;
                                            entity["text"] = str;
                                            entity["label"] = str;
                                            hashDict[levelID] = entity;
                                            
                                            
                                            
                                            
                                            
                                    }
                                    newEntity = entity;
                            }
                            
                            if(rowHeaderData[j].cet != undefined){
                                    if(j - serialEndIndex != 1 || (!isNaN(lastSerialRowIndex) && lastSerialRowIndex != i))
                                            isAllSelectable = false;
                                    if(isAllSelectable){
                                            serialEntity = newEntity;
                                            serialEndIndex = j;
                                            lastSerialRowIndex = i;
                                    }
                                    if(isNaN(highestLevelIndex) || highestLevelIndex < j){
                                            highestLevelIndex = j;
                                            highestLevelEntity = newEntity;
                                    }
                            }
                    }

            }
            if(isAllSelectable)
                    this.previousSelected = serialEntity;
            else
                    this.previousSelected = highestLevelEntity;
            
            
            
            checkSelector.call(this);
            checkLinkDrill.call(this);
    }

	function clearMaxMinValues(){
		this.cmax = NaN;
		this.cmin = NaN;
		this.smax = NaN;
		this.smin = NaN;
	}

	function checkLinkDrill(){
			this.hasLinkDrill = false;
			
			var rowHeader = this.model.gts.row,
			rl = rowHeader.length;
			for(var i = 0; i < rl; i++){
					var attr = rowHeader[i];
					if(attr.lm){
							for(var j = 0; j < attr.lm.length; j++)
									if(attr.lm[j].links)break;
							if(j != attr.lm.length){
									this.hasLinkDrill = true;
									this.firstRowLinkDrillIndex = i;
									break;
							}
					}
			}

			
			var metricH = this.model.gts.col[0];
            if(!metricH)
                    return;
            var metricHL = metricH.es.length;
			for(var i = 0; i < metricHL; i++){
					var metric = metricH.es[i],
						lm = metricH.lm[i];
					if(lm && lm.links){
						this.hasLinkDrill = true;
						this.firstColLinkDrillIndex = i;
						break;
					}
			}
	}
	function checkSelector(){
		this.hasSelector = false;
		var m = this.model,
			rown = m.gts.row, 
			rl = rown.length;
        var xtabModel = this.xtabModel,
            docModel = (xtabModel && xtabModel.docModel),
            layouts = (docModel && docModel.defn && docModel.defn.layouts),
            currentLayout;
        for(var i = 0; layouts && i < layouts.length; i++){
                if(layouts[i].loaded == true){
                        currentLayout = layouts[i];
                        break;
                }
        }

        var units =  (currentLayout && currentLayout.units);

		for(var i = 0; i < rl; i++){
			var att = rown[i];
            if(att.otp != -1 && att.sc !== undefined){
                    this.hasSelector = true;
                    
                    var targets = att.sc.tks;
                    if(typeof targets != 'string')
                            continue;
                    targets = targets.split('\x1E');

                    var len = targets.length;
                    this.hasGridTarget = false;
                    for(var j = 0; j < len; j++){
                            if(targets[j] == '')
                                    continue;
                            targetName = targets[j];
                            if(units && units[targetName] && !units[targetName]['ifw']){
                                    this.hasGridTarget = true;
                                    return ;
                            }
                    }
            }
		}
      
      
      
              
	}

	function layoutEntities() {
		var width = this.width - 2*this.LayoutProperties.Padding;
		var legendHeight = 0;
		if(this.props.showLegend){
			legendHeight = Math.min(Math.floor(0.2*(parseInt(this.height)-2*this.LayoutProperties.Padding)), this.LayoutProperties.MaxLegendHeight);
		}
		var hm = this,
			area = copyRect(this.heatMapSize);
		area.w *= this.scaleFactor;
		area.h *= this.scaleFactor;
		var min = Math.min(area.w, area.h);
		var ch = this.root.entityChildren;
		switch (this.props.layout) {
		case LayoutAlgorithm.Squarified:
			var arr = ch.slice(0);
			arr.sort(function sortEntity(s, t) {
				var vs = getSizeValue(s, hm);
				var vt = getSizeValue(t, hm);
				if (isNaN(vs)) {
					if (isNaN(vt))
						return 0;
					return 1;
				} else {
					if (isNaN(vt))
						return -1;
					return vs < vt ? 1 : -1;
				}
				return 0;
			});
			squarify.call(this, arr, {
				r : []
			}, min, area);
			break;
		case LayoutAlgorithm.SliceAndDice:
			sliceAndDice.call(this, ch, area);
			break;
		case LayoutAlgorithm.PivotByMiddle:
			var arr = getVisibleEntities.call(this, ch), l = arr.length;
			if (l > 0) {
				pivotByMiddle.call(this, arr, 0, l - 1, area);
			}
			break;
		}
	}
	
	
	
	
	function squarify(t, r, m, c, a) {
		var newRow = false;
		if (t.length == 0) {
			setLayoutOrder.call(this, r, c);
		} else {
			var area = c.w * c.h;
			var cwa;
			if (a !== undefined) {
				cwa = a;
			} else {
				cwa = worstAspect.call(this, r, m, area);
															
			}

			var data = t[0], arr = r.r;
			arr.push(data);

			var fwa = worstAspect.call(this, r, m, area); 
															
			if (cwa >= fwa || cwa == -1) {
				t.shift();
				squarify.call(this, t, r, m, c, fwa);
			} else {
				r.r.pop();
				setLayoutOrder.call(this, r, c);
				m = Math.min(c.w, c.h);
				if (r.t === undefined) {
					squarify.call(this, t, {
						r : []
					}, m, c);
				} else {
					squarify.call(this, t, {
						r : [],
						t : r.t
					}, m, c);
				}
			}
		}
	}

	function getTextStyle(l, w) {
		var fs, css, len = w.levelAttributes.length;
		if(len == 1){
			if(l == 0){
				css  = "heatmap-one-level-1";
                fs = this.Spec.heatmap_one_level_1.font_size.value;
				
			}
		}
		else if (len == 2) {
			if(l == 0){
				css = "heatmap-multi-level-1";
                fs = this.Spec.heatmap_multi_level_1.font_size.value;
				
			}else if(l == 1){
				css = "heatmap-two-level-2";
                fs = this.Spec.heatmap_two_level_2.font_size.value;
				
			}
		}
		else if (len >= 3) {
			if(l == 0){
				css = "heatmap-multi-level-1";
                fs = this.Spec.heatmap_multi_level_1.font_size.value;
				
			}else if(l == 1){
				css = "heatmap-multi-level-2";
                fs = this.Spec.heatmap_multi_level_2.font_size.value;
				
			}else{
				css = "heatmap-multi-level-3";
                fs = this.Spec.heatmap_multi_level_3.font_size.value;
				
			}
		}
		return {css:css, size:fs};
	}
	function getRectangleGap(e) {
			var getGapPixel = function(){
					var te = e, level = e.level,
					l = this.levelAttributes.length;
					if (l == 1)
							return 1;
					
							
							
							
									
									
									
									if (l == 2) {
											if (level == 0)
													return 3;
											return 1;
									}
									if (l == 3) {
											if (level == 0)
													return 6;
											if (level == 1)
													return 3;
											return 1;
									} else {
											if (level == 0)
													return 8;
											if (level == 1)
													return 4;
											if (level == 2)
													return 2;
											return 1;
									}
			};
			var ret,
                gap = getGapPixel.call(this);
            if(this.DPI > 160)
                    ret = adjustPixel.call(this,gap);
            else
                    ret = gap;
            if(ret <= 0)
                    ret = 1;
            return ret;

	}

	function rectIsValid(a){
		return a.w > 0 && a.h > 0;
	}

	function rectIntersection(a, b) {
		var x = Math.max(a.x, b.x);
		var y = Math.max(a.y, b.y);
		var w = Math.min(a.x + a.w, b.x + b.w) - x;
		var h = Math.min(a.y + a.h, b.y + b.h) - y;
		if (w < 0 || h < 0) {
			return {
				x : NaN,
				y : NaN,
				w : NaN,
				h : NaN
			};
		}
		return {
			x : x,
			y : y,
			w : w,
			h : h
		};
	}

    function rectIsEqual(a ,b) {
            if(a.x == b.x && a.y == b.y && a.w == b.w && a.h == b.h)
                    return true;
            else
                    return false;
    }

    
    function rectCanEncircle(a, b) {
            var c = rectIntersection(a, b);
            return rectIsEqual(c,b);
    }

    
    function rectPutAside(a, b, c) {
            var p = [{x: b.x - a.w, y: b.y + b.h/2 - a.h/2, w:a.w, h:a.h},
                     {x: b.x + b.w, y: b.y + b.h/2 - a.h/2, w:a.w, h:a.h},
                     {x: b.x + b.w/2 - a.w/2, y: b.y - a.h, w:a.w, h:a.h},
                     {x: b.x + b.w/2 - a.w/2, y: b.y + b.h, w:a.w, h:a.h}];
            for(var i = 0; i < 4; i++){
                    if(rectCanEncircle(c, p[i]))
                            return {rect:p[i], index:i};
            }
    }

	function swapRect(a) {
		var temp = a.x;
		a.x = a.y;
		a.y = temp;
		temp = a.w;
		a.w = a.h;
		a.h = temp;
		return a;
	}
	function copyRect(a) {
		var b = {};
		b.x = a.x;
		b.y = a.y;
		b.w = a.w;
		b.h = a.h;
		return b;
	}

	function worstAspect(r, m, a) {
		var worst, arr = r.r, l = arr.length;
		if (l > 0 && a > 0) {
			var e = arr[0];
			var pval = getSizeValue(e.parentEntity, this);
			if (isNaN(pval) || pval <= 0) {
				return -1;
			}
			var min, max, sum = 0, val, e, inited = false;
			for ( var i = 0; i < l; i++) {
				e = arr[i];
				if (!e.deleted) {
					val = getSizeValue(e, this);
					if (!isNaN(val)) {
						if (inited == false) {
							max = min = val;
							inited = true;
						} else {
							max = Math.max(val, max);
							min = Math.min(val, min);
						}
						sum += val;
					}
				}
			}
			var suba = a * sum / pval, otherMin = suba / m, newMin = (m < otherMin) ? m
					: otherMin;
			max = a * max / pval;
			min = a * min / pval;
			var e1 = max / (newMin * newMin);
			var e2 = min / (newMin * newMin);
			e1 = (e1 > 1) ? e1 : (1 / e1);
			e2 = (e2 > 1) ? e2 : (1 / e2);
			worst = Math.max(e1, e2);
		} else {
			worst = -1;
		}
		return worst;
	}

	function layoutRow(r, c, n, sum, swapped) {
		var width, height, ch = r.r, l = ch.length, w, h, tmpc, localSwapped = false;
		if (l == 0)
			return;
		if (n < c.h) {
			w = n;
			h = c.h;
			tmpc = c;
		} else {
			w = c.h;
			h = n;
			var tmpc = copyRect(c);
			swapRect(tmpc);
			localSwapped = true;
		}
		var x = tmpc.x, y = tmpc.y, bound = {
			x : x,
			y : y,
			w : w,
			h : h
		};
		var gap = getRectangleGap.call(this, ch[0]);

		for ( var i = 0; i < l; i++) {
			var e, rect, minDim;
			e = ch[i];
			if (e.deleted) {
				if ((swapped == true && localSwapped != true)
						|| (swapped == false && localSwapped == true)) {
					e.size = {
						x : y,
						y : x,
						w : 0,
						h : 0
					};
				} else {
					e.size = {
						x : x,
						y : y,
						w : 0,
						h : 0
					};
				}
				continue;
			}
			var value = getSizeValue(e, this);
			height = (sum <= 0 || e.deleted) ? 0 : Math.ceil(h * value / sum);
			width = w;
			if (e.entityChildren !== undefined) {
				if (value < sum) {
					if (i == 0) {
						if (gap > 1) {
							height -= (gap>>1);
						} else {
							height--;
						}
					} else if (i < l - 1) {
						if (gap > 1) {
							height -= gap;
						} else {
							height--;
						}
					} else {
						height = h + tmpc.y - y ;
					}
				}
				var nc = {
					x : x,
					y : y,
					w : width,
					h : height
				};
				rect = rectIntersection(nc, bound);
				if ((swapped == true && localSwapped != true)
						|| (swapped == false && localSwapped == true)) {
					swapRect(nc);
					swapRect(rect);
				}
				if(rectIsValid(rect)){
					e.size = rect;
				}
				else{
					e.size = {
						x : rect.x,
						y : rect.y,
						w : 0,
						h : 0
					};
				}
				minDim = Math.min(rect.w, rect.h);
				var hm = this;
				var arr = e.entityChildren.slice(0);
				arr.sort(function sortEntity(s, t) {
					var vs = getSizeValue(s, hm);
					var vt = getSizeValue(t, hm);
					if (isNaN(vs)) {
						if (isNaN(vt))
							return 0;
						return 1;
					} else {
						if (isNaN(vt))
							return -1;
						return vs < vt ? 1 : -1;
					}
					return 0;
				});
				squarify.call(this, arr, {
					r : []
				}, minDim, nc);
				y += height + gap;
			} else {
				if (value < sum) {
					if (i == 0 || i == l - 1) {
						if (gap > 1) {
							if (height > (gap>>1)) {
								height -= (gap>>1);
							}
						} else {
							if (height > 1) {
								height--;
							}
						}
					} else {
						if (height > gap) {
							height -= gap;
						}
					}
				}
				width = Math.max(0, width);
				height = Math.max(0, height);
				var rect = rectIntersection({
					x : x,
					y : y,
					w : width,
					h : height
				}, bound);
				rect.x = x;
				rect.y = y;
				y += height + gap;
				if (y >= tmpc.y + h) {
					rect.h = tmpc.y + h - rect.y;
				}
				if ((swapped == true && localSwapped != true)
						|| (swapped == false && localSwapped == true)) {
					rect = swapRect(rect);
				}
				if(rectIsValid(rect)){
					e.size = rect;
				}
				else{
					e.size = {
						x : rect.x,
						y : rect.y,
						w : 0,
						h : 0
					};
				}
			}
		}
	}

	function setLayoutOrder(r, c) {
		var sum = 0.0, arr = r.r, l = arr.length;
		if (l == 0)
			return;

		var ra, p = arr[0].parentEntity, ch = p.entityChildren, ll = ch.length;
		for ( var i = 0; i < l; i++) {
			var e = arr[i], v = getSizeValue(e, this);
			if (!e.deleted && v > 0) {
				sum += v;
			}
		}
		if (r.t === undefined) {
			var t = 0.0;
			for ( var i = 0; i < ll; i++) {
				var e = ch[i], v = getSizeValue(e, this);
				if (!e.deleted && v > 0) {
					t += v;
				}
			}
			r.t = t;
		}

		var e = arr[0], gap = getRectangleGap.call(this, e), bound = {
			x : 0,
			y : 0,
			w : 0,
			h : 0
		};

		if (e == this.root) {
			ra = this.heatMapSize.w * this.scaleFactor * this.heatMapSize.h * this.scaleFactor;
			bound.w = this.heatMapSize.w * this.scaleFactor;
			bound.h = this.heatMapSize.h * this.scaleFactor;
		} else {
			if (p == this.root) {
				ra = this.heatMapSize.w * this.scaleFactor * this.heatMapSize.h * this.scaleFactor;
				bound.w = this.heatMapSize.w * this.scaleFactor;
				bound.h = this.heatMapSize.h * this.scaleFactor;
			} else {
				var pSize = p.size;
				ra = pSize.w * pSize.h;
				bound = copyRect(pSize);
			}
			if (r.t == 0)
				ra = 0;
			else {
				ra *= sum / r.t;
			}
		}

		var aw = c.w, 
		ah = c.h, 
		swapped = false;
		if (c.h < c.w) {
		} else {
			swapped = true;
			swapRect(c);
			swapRect(bound);
			var temp = aw;
			aw = ah;
			ah = temp;
		}
		
		if ((bound.x < c.x) || (bound.x + bound.w > c.x + c.w)) {
			if (gap > 1) {
				aw += (gap>>1);
			}
		}
		
		if ((bound.y < c.y) || (bound.y + bound.h > c.y + c.h)) {
			if (gap > 1) {
				ah += (gap>>1);
			}
		}
		var width = ah == 0 ? 0 : Math.min(c.w, Math.ceil(ra / ah));
		if (sum < r.t && sum > 0) {
			if (c.x + width < bound.x + bound.w) {
				if (gap > 1) {
					width -= (gap>>1);
				} else {
					width--;
				}
			}
		}

		layoutRow.call(this, r, c, width, sum, swapped);

		var newX = c.x + width, newWidth = c.w - width;
		if (sum < r.t && sum > 0) {
			if (c.x + width < bound.x + bound.w) {
				if (gap > 1) {
					newX += gap;
					newWidth -= gap;
				} else {
					newX++;
					newWidth--;
				}
			}
		}
		c.x = newX;
		c.w = Math.max(0, newWidth);
		if (swapped) {
			swapRect(c);
		}
	}

	function getVisibleEntities(a) {
		if (a == null)
			return [];
		var arr = a.slice(0), total = 0, l = arr.length;
		arr.t = [];
		for ( var i = 0; i < l; i++) {
			var e = arr[i], val = getSizeValue(e, this);
			if (e.deleted || isNaN(val) || val <= 0) {
				arr.splice(i, 1);
				i--;
				l--;
				continue;
			}
			total += val;
			arr.t[i] = total;
		}
		return arr;
	}

	function pivotByMiddle(t, l, r, c) {
		var e = t[0], gap = getRectangleGap.call(this, e), lc, rc, 
																	
																	
																	
																	
																	
		lv, rv, lp, swapped = false, n = r - l + 1, pivot = (n > 2 ? ((n - 1)>>1)
				: (n>>1))
				+ l, cc;
		cc = copyRect(c);
		if (cc.w > cc.h) {
		} else {
			swapRect(cc);
			swapped = true;
		}
		lc = copyRect(cc);
		rc = copyRect(cc);
		
		if (l == r) {
			e = t[l];
			layoutEntityByMiddle.call(this, e, cc, swapped);
			return;
		}
		
		if (l + 1 == r) {
			e = t[l];
			lv = getSizeValue(e, this);
			e = t[r];
			rv = getSizeValue(e, this);
		} else {
			if (l == 0) {
				lv = t.t[pivot - 1];
			} else {
				lv = t.t[pivot - 1] - t.t[l - 1];
			}
			if (pivot == 0) {
				rv = t.t[r];
			} else {
				rv = t.t[r] - t.t[pivot - 1];
			}
		}
		lp = lv / (lv + rv);
		lc.w = Math.ceil(lc.w * lp);
		if (lc.w < c.w) {
			if (gap > 1) {
				if (lc.w > (gap>>1)) {
					lc.w -= (gap>>1);
				}
			} else {
				if (lc.w > 1) {
					lc.w--;
				}
			}
		}
		
		if (l + 1 == r) {
			rc.w -= lc.w + gap;
			rc.x += lc.w + gap;
			e = t[l];
			layoutEntityByMiddle.call(this, e, lc, swapped);
			e = t[r];
			layoutEntityByMiddle.call(this, e, rc, swapped);
			return;
		}
		var mc = copyRect(cc), as, 
		pap, 
		cv = 0, 
		pi = -1, 
		la = 1, 
		pv;

		if (pivot > l) {
			var llc = copyRect(lc);
			if (swapped) {
				swapRect(llc);
			}
			pivotByMiddle.call(this, t, l, pivot - 1, llc);
		}

		mc.w -= lc.w + gap;
		mc.x += lc.w + gap;
		rc.w = mc.w;
		rc.x = mc.x;
		as = mc.w / mc.h;
		e = t[pivot];
		pv = getSizeValue(e, this);
		pap = pv / rv;

		for ( var i = pivot; i <= r; i++) {
			e = t[i];
			cv += getSizeValue(e, this);
			if (i == r - 1) {
				continue;
			}
			var pwp = cv / rv, php = pv / cv, a = pwp / php * as;
			if (a >= 1) {
				if (la < 1 && la * a > 1) {
					pi = (i == r) ? i - 2 : i - 1;
				} else {
					pi = i;
				}
				break;
			}
			la = a;
		}
		pi = pi < 0 ? r : pi;

		var mv, pw, ph;

		if (pivot == 0) {
			mv = t.t[pi];
		} else {
			mv = t.t[pi] - t.t[pivot - 1];
		}
		pw = Math.ceil(mc.w * (mv / rv));
		ph = Math.ceil(mc.h * (pv / mv));
		if (pw < mc.w) {
			if (gap > 1) {
				if (pw > (gap>>1)) {
					pw -= (gap>>1);
				}
			} else {
				if (pw > 1) {
					pw--;
				}
			}
		}
		if (ph < mc.h) {
			if (gap > 1) {
				if (ph > (gap>>1)) {
					ph -= (gap>>1);
				}
			} else {
				if (ph > 1) {
					ph--;
				}
			}
		}
		var pc = {
			x : mc.x,
			y : mc.y,
			w : pw,
			h : ph
		};
		e = t[pivot];
		layoutEntityByMiddle.call(this, e, pc, swapped);

		if (pivot < pi) {
			mc.y += ph + gap;
			mc.w = pw;
			mc.h -= ph + gap;
			if (swapped) {
				swapRect(mc);
			}
			pivotByMiddle.call(this, t, pivot + 1, pi, mc);
		}
		if (pi < r) {
			rc.x += pw + gap;
			rc.w -= pw + gap;
			if (swapped) {
				swapRect(rc);
			}
			pivotByMiddle.call(this, t, pi + 1, r, rc);
		}
	}

	function layoutEntityByMiddle(e, c, swapped) {
		var size = copyRect(c);
		if (swapped == true) {
			swapRect(size);
		}
		if(rectIsValid(size)){
			e.size = size;
		}
		else{
			e.size = {
				x : size.x,
				y : size.y,
				w : 0,
				h : 0
			};
		}
		var ch = e.entityChildren;
		if (ch !== undefined) {
			var arr = getVisibleEntities.call(this, ch), l = arr.length;
			if (l > 0) {
				pivotByMiddle.call(this, arr, 0, l - 1, size);
			}
		}
	}

	function sliceAndDice(r, c) {
		if (r == null || r.length == 0) {
			return;
		}
		var t = 0, e = r[0], val, gap = getRectangleGap.call(this, e), swapped = false, l = r.length, x, y, w, h;
		for ( var i = 0; i < l; i++) {
			e = r[i], val = getSizeValue(e, this);
			if (!e.deleted && val > 0) {
				t += val;
			}
		}
		if (c.w < c.h) {
		} else {
			swapped = true;
			swapRect(c);
		}
		w = c.w;
		h = c.h;
		x = c.x;
		y = c.y;
		for ( var i = 0; i < l; i++) {
			e = r[i], val = getSizeValue(e, this);
			if (!e.deleted && val > 0) {
				var width, height;
				height = t <= 0 ? 0 : Math.ceil(val / t * h);
				width = w;
				if (val < t) {
					if (i == 0 || i == l - 1) {
						if (gap > 1) {
							if (height > (gap>>1)) {
								height -= (gap>>1);
							}
						} else {
							if (height > 1) {
								height--;
							}
						}
					} else {
						if (height > gap) {
							height -= gap;
						}
					}
				}
				width = Math.max(0, width);
				height = Math.max(0, height);
				var nc = {
					x : x,
					y : y,
					w : width,
					h : height
				}, rect = rectIntersection(nc, c);
				y += height + gap;
				if (y >= c.y + h) {
					rect.h = c.y + h - rect.y;
				}
				if (swapped) {
					swapRect(rect);
				}
				if(rectIsValid(rect)){
					e.size = rect;
				}
				else{
					e.size = {
						x : rect.x,
						y : rect.y,
						w : 0,
						h : 0
					};
				}
				if (e.entityChildren !== undefined) {
					sliceAndDice.call(this, e.entityChildren, rect);
				}
			} else {
				e.size = {};
				if (swapped) {
					e.size = {
						x : y,
						y : x,
						w : 0,
						h : 0
					};
				} else {
					e.size = {
						x : x,
						y : y,
						w : 0,
						h : 0
					};
				}
				continue;
			}
		}
		if (swapped) {
			swapRect(c);
		}
	}

	
	
	
    function setShow(mf, s, fm, sfm, ec, w, ml) {
            
            if (ec.entityChildren !== undefined) {
                    
                    
                    var parent = ec.parentEntity, del = true, 
                    
                    cd = false, 
                    teAggValues = [], eChildren = ec.entityChildren, l = eChildren.length;
                    for ( var i = 0; i < ml; i++) {
                            teAggValues[i] = {
                                    count : 0,
                                    allChildrenCount : 0,
                                    positiveCount : 0
                            };
                    }

                    for ( var i = 0; i < l; i++) {
                            var child = eChildren[i];
                            setShow(mf, s, fm, sfm, child, w, ml);
                            if (!child.deleted) {
                                    del = false;
                            }
                            
                            if (child.entityChildren === undefined) {
                                    if (child.deleted) {
                                            cd = true;
                                    }
                            } else {
                                    if (child.hasChildDeleted) {
                                            cd = true;
                                    }
                            }
                            if (!child.deleted) {
                                    aggregateTotals(ec, child, teAggValues, w, ml);
                            }
                    }
                    ec.deleted = del;
                    ec.hasChildDeleted = cd;
                    for ( var i = 0; i < ml; i++) {
                            var ev = ec.aggValues[i];
                            if (ev == null) {
                                    ev = {};
                                    ec.aggValues[i] = ev;
                            }
                            
                            var temp = teAggValues[i];
                            ev.total = temp.total;
                            ev.avg = temp.count == 0 ? 0 : temp.avgTotal / temp.count;
                            ev.geomAvg = temp.positiveCount == 0 ? NaN : Math.pow(
                                    temp.geomProduct, 1 / temp.positiveCount);
                                    ev.min = temp.min;
                                    ev.max = temp.max;
                                    ev.count = temp.count;
                                    ev.positiveCount = temp.positiveCount;
                    }
            }
            
            else {
                    if(ec.deleted)
                            return ;
                    
                    var sv = getSizeValue(ec, w);
                    if(!isNaN(sv)){
                            if(isNaN(w.smax)){
                                    w.smax = w.smin = sv;
                            } else{
                                    if(sv > w.smax){
                                            w.smax = sv;
                                    }
                                    if(sv < w.smin){
                                            w.smin = sv;
                                    }
                            }
                    }
                    var cv = getColorValue(ec, w);
                    if(!isNaN(cv)){
                            if(isNaN(w.cmax)){
                                    w.cmax = w.cmin = cv;
                            } else{
                                    if(cv > w.cmax){
                                            w.cmax = cv;
                                    }
                                    if(cv < w.cmin){
                                            w.cmin = cv;
                                    }
                            }
                    }
            }
    }
	function aggregateTotals(ec, child, teAggValues, w, ml) {
		var ev, agg = child.aggValues;
		
		if (child.entityChildren !== undefined) {
			ev = getEntityValue(child, w.sizeMetricIndex);
			if (ev !== null) {
				var cnt = ev.count;
				if (cnt > 0) {
					for ( var i = 0; i < ml; i++) {
						ev = teAggValues[i];
						updateEntityContainerAggValue(ev, agg[i]);
					}
				}
			}
		}
		
		else {
			if (getSizeValue(child, w) > 0 && !child.deleted) {
				for ( var i = 0; i < ml; i++) {
					ev = teAggValues[i];
					updateEntityAggValue(ev, getAggValue(child, i, w));
				}
			}
		}
	}

	function getEntityValue(e, index) {
		var agg = e.aggValues;
		if (index >= agg.length)
			return NaN;
		return agg[index];
	}

	function getColorValue(e, w){
		var idx = w.colorMetricIndex;
		return getAggValue(e, idx, w);
	}

	function getSizeValue(e, w){
		var idx = w.sizeMetricIndex,
			val = getAggValue(e, idx, w);
		if(val < 0){
			w.hasNegativeSizeValue = true;
			return Math.abs(val);
		}
		return val;
	}

	function getSizeRawValue(e, w){
		var idx = w.sizeMetricIndex;
		return getAggValue(e, idx, w);
	}
	
	function getAggValue(e, i, w) {
		var agg = e.aggValues;
		if (i >= agg.length)
			return NaN;
		var ev = agg[i],
			t = w.aggFunctions[i]; 
		
		if (e.entityChildren !== undefined) {
			switch (t) {
				case AggregationType.Sum:
					return ev.total;
				case AggregationType.Avg:
					return ev.avg;
				case AggregationType.Cnt:
					return ev.count;
				case AggregationType.Max:
					return ev.max;
				case AggregationType.Min:
					return ev.min;
				case AggregationType.GeoAvg:
					return (ev.positiveCount > 0) ? ev.geomAvg : 0;
				default:
					return ev.total;
			}
		}
		
		else {
			if (ev.allChildrenCount == 1) {
				return ev.value;
			}
			switch (t) {
				case AggregationType.Sum:
					return ev.total;
				case AggregationType.Avg:
					return ev.count == 0 ? 0 : ev.avgTotal / ev.count;
				case AggregationType.Cnt:
					return ev.count;
				case AggregationType.Max:
					return ev.max;
				case AggregationType.Min:
					return ev.min;
				case AggregationType.GeoAvg:
					return ev.positiveCount > 0 ? NaN : Math.pow(ev.geomProduct,
							1.0 / ev.positiveCount);
				default:
					return ev.total;
			}
		}
	}
	function getLegendMaxMin() {






		if(!isNaN(this.mlmax) || !isNaN(this.mlmin)){
			if(!isNaN(this.mlmax)){
				this.cmax = this.mlmax;
				if(isNaN(this.mlmin) && (this.mlmax < this.cmin)){
					this.cmin = this.mlmax;
				}
			}
			if(!isNaN(this.mlmin)){
				this.cmin = this.mlmin;
				if(isNaN(this.mlmax) && (this.mlmin > this.cmax)){
					this.cmax = this.mlmin;
				}
			}

		}
		if (!isNaN(this.mlmax) && this.cmax > this.mlmax) {
			this.cmax = this.mlmax;
		}
		if (!isNaN(this.mlmin) && this.cmin < this.mlmin) {
			this.cmin = this.mlmin;
		}
		this.colorTheme.min = this.cmin;
		this.colorTheme.max = this.cmax;
		this.colorTheme.checkMinMax();
	}

	function getMetricID(idx){
		var str = "",
			m = this.model,
			col = m.ghs.chs.items,
			cnt = col.length,
			ml = col[0].items.length,
			coln = m.gts.col;
		if (idx < 0 || idx >= ml) return "";
		for(var i = 0; i < cnt; i++){
			var index = col[i].items[idx].idx;
			var temp = coln[i].es[index];
			var id = (temp.oid !== undefined) ? temp.oid : temp.id;
			str += id + " ";
		}
		return str.slice(0, str.length-1);
	}
	function getNumberForTick(i){
		var v;
		if(this.props.legendAsc){
			v = this.cmin + (this.cmax - this.cmin) * i/this.legendTickCount;
		}
		else{
			v = this.cmax + (this.cmin - this.cmax) * i/this.legendTickCount;
		}
		if(this.props.legendRounded){
			v = Math.floor(v);
		}
		return v;
	}

	function getTooltip(e, w){
		
		var level = e.level,
			index = (e.index === undefined) ? e.indices[0] : e.index,
			st = 0, 
			str = '',
			ret = '',
			ar = w.attSpan,
			rhs = w.model.ghs.rhs.items,
			rowHeaderData = rhs[index].items,
			attr = w.model.gts.row,
			mv = w.model.gvs.items, 
			ml = mv[0] ? mv[0].items.length:0,
			
			att, fs;

		for(var i = 0; i < level; i++){
			att = attr[i];
			
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-gray-bold">' + att.n + '</div>' + '<div class="heatmap-tooltip-gray-bold"><p>:&nbsp;</p></div>';
			str = '';
			for(var j = st; j < st + ar[i]; j++){
				var idx = rowHeaderData[j].idx;
				if(idx == -1)
					continue;
				str += att.es[idx].n + " ";
			}
			str = str.substring(0, str.length-1);
			ret += '<div class = "heatmap-tooltip-gray">' + str + '</div></div>';
			st += ar[i];
		}
		att = attr[level];
		ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-black-bold">' + att.n + '</div>' +  '<div class="heatmap-tooltip-black-bold"><p>:&nbsp;</p></div>';
		str = '';
		for(var i = st; i < st + ar[level]; i++){
			var idx = rowHeaderData[i].idx;
			if(idx == -1)
				continue;
			str += att.es[idx].n + " ";
		}
		str = str.substring(0, str.length-1);
		ret += '<div class = "heatmap-tooltip-black">' + str + '</div></div>';
		
		
		var si = w.sizeMetricIndex,
			ci = w.colorMetricIndex,
			n, v;
		if(si != ml){
			n = w.getMetricName(si);
			if(e.entityChildren !== undefined || w.aggregated){
				var tmp = w.aggFunctions[si];
				n = tooltipMacro(n, tmp);
				v = getSizeRawValue(e, w);
				if(isNaN(v)){
					v = '-';
				}
				else if(AggregationType.Cnt != tmp){
					fs = w.getFormatString(si);
					v = w.nf.formatByMask(fs, v);
				}
			}else{
				v = mv[index].items[si].v;
			}
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-black-bold">' + n + '</div>' + '<div class="heatmap-tooltip-black-bold"><p>:&nbsp;</p></div>';
			ret += '<div class = "heatmap-tooltip-black">' + v + '</div></div>';
		}
		if(e.entityChildren === undefined && ci != ml && si != ci){
			n = w.getMetricName(ci);
			if(e.entityChildren !== undefined || w.aggregated){
				var tmp = w.aggFunctions[ci];
				n = tooltipMacro(n, tmp);
				v = getColorValue(e, w);
				if(isNaN(v)){
					v = '-';
				}
				else if(AggregationType.Cnt != tmp){
					fs = w.getFormatString(ci);
					v = w.nf.formatByMask(fs, v);
				}
			}else{
				v = mv[index].items[ci].v;
			}
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-black-bold">' + n + '</div>' + '<div class="heatmap-tooltip-black-bold"><p>:&nbsp;</p></div>';
			ret += '<div class = "heatmap-tooltip-black">' + v + '</div></div>';
		}
		for(var i = 0; i < ml; i++){
			if(i == si) continue;
			if(i == ci && e.entityChildren === undefined && si != ci) continue;
			n = w.getMetricName(i);
			if(e.entityChildren !== undefined || w.aggregated){
				var tmp = w.aggFunctions[i];
				n = tooltipMacro(n, tmp);
				v = getAggValue(e, i, w);
				if(isNaN(v)){
					v = '-';
				}
				else if(AggregationType.Cnt != tmp){
					fs = w.getFormatString(i);
					v = w.nf.formatByMask(fs, v);
				}
			}else{
				v = mv[index].items[i].v;
			}
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-gray-bold">' + n + '</div>' + '<div class="heatmap-tooltip-gray-bold"><p>:&nbsp;</p></div>';
			ret += '<div class = "heatmap-tooltip-gray">' + v + '</div></div>';
		}
		return ret;
	}

	function tooltipMacro(n, t){
		var macro;
		switch(t){
			case AggregationType.Sum:
				macro = "Sum of {0}";
				break;
			case AggregationType.Avg:
				macro = "Average of {0}";
				break;
			case AggregationType.Cnt:
				macro = "Count of {0}";
				break;
			case AggregationType.Max:
				macro = "Maximum of {0}";
				break;
			case AggregationType.Min:
				macro = "Minimum of {0}";
				break;
			case AggregationType.GeoAvg:
				macro = "Geometry Average of {0}";
				break;
			default:
				macro = "Sum of {0}";
		}
		return macro.replace('{0}', n);
	};

    function bindTouchEvents(d, owner) {
            if(d.eventOwner == owner)
                    return;
            var $D = mstrmojo.dom,
                eventList = [$D.TOUCHSTART, $D.TOUCHMOVE, $D.TOUCHEND, $D.TOUCHCANCEL];
            for(var i = 0; i < eventList.length; i++){
                    if(eventList[i] == '')
                            continue;
                    if(document.createTouch){
                            d['on' + eventList[i]] = function (e) {
                                    var evt = document.createEvent("TouchEvent"),
                                        t = e.touches[0];
                                    
                                    if(!t){
                                            t = {};
                                    }
                                    
                                    evt.initTouchEvent(e.touches, e.targetTouches, e.changedTouches, e.type, e.view, t.screenX, t.screenY, t.clientX, t.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey);

                                    
                                    
                                    owner.dispatchEvent(evt);
                            };
                    }else{
                            d['on' + eventList[i]] = function (e) {
                                    var evt = document.createEvent('MouseEvent');
                                    evt.initMouseEvent(e.type, e.bubbles, e.cancelable, e.view, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);
                                    owner.dispatchEvent(evt);
                            };
                    }
                    
            }
            d.eventOwner = owner;
    };




	mstrmojo.VisHeatMap = mstrmojo.declare(

					mstrmojo.Vis,

					[ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

					{

						scriptClass : 'mstrmojo.VisHeatMap',

						scrollerConfig : {
							bounces : false,
							showScrollbars : false,
							useTranslate3d : true,
							vScroll: true,
							hScroll: true,
							offset : {
									y: {
										start: 0,
										end: 0
									},
									x: {
										start: 0,
										end: 0
									}
							},
							origin: {
								x: 0,
								y: 0
							}
						},

						selectedStyle : "background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #058CF5), color-stop(1, #015DE6));color:#FFFFFF;",

						selectedClass : "",

                        insertedStyles : [],

                        LayoutProperties: {},

						highlightBoxWidth: 3,

                        waitIconString: mstrmojo.desc("8445","Loading"),


						markupString :
						'<div id="{@id}" class="mstrmojo-{@cssClass}" style="background-color:#333333;width:{@width};height:{@height}; left:{@left}; top:{@top}; z-index: {@zIndex}; position:absolute;" mstrAttach:mousedown,mouseup,mousemove,click>'
                                
                                +'<div class="heatmap-canvas-outer-container" style="padding: {@LayoutProperties.Padding}px; height:{@heatMapSize.h}px; width:{@heatMapSize.w}px">'
                                        
                                        +'<div id ="{@id}-heatmap-canvas-container" class="heatmap-canvas-container" style="left: {@LayoutProperties.Padding}px; top: {@LayoutProperties.Padding}px; height:{@heatMapSize.h}px; width:{@heatMapSize.w}px">'
                                                
                                                +'<div>'
                                                        
                                                        + '<div></div>'
                                                        
                                                        +'<div class="heatmap-selection-highlight-box heatmap-round-corner" style="border: {@highlightBoxWidth}px solid white;"></div>'
                                                +'</div>'
                                        +'</div>'
                                +'</div>'
								
								+'<div class="heatmap-legend" style="left:{@legendSize.x}px; top:{@legendSize.y}px; height:{@legendSize.h}px; width:{@legendSize.w}px">'
											
											+ '<div  class="heatmap-size-legend">'
												
												+ '<div class="heatmap-size-legend-title">Rectangle Size:</div>'
												
												+ '<div id="{@id}-color-legend-ticker" class="heatmap-size-legend-label" ></div>'
											
											+ '</div>'
											+
											
											'<div  class="heatmap-color-legend">'
												
												+ '<div class="heatmap-color-legend-title">Rectangle Color:</div>'
												
												+ '<table cellpadding="4" class="heatmap-color-legend-label">'
													+ '<tbody><tr>'
														+ '<td class="heatmap-color-legend-label-td"></td>'
													+ '</tr></tbody>'
												+ '</table>'
												+ '<div style="position:relative;">'
													
													+ '<canvas id="{@id}-color-legend-band" class="heatmap-color-legend-band"></canvas>'
													
													+ '<div id="{@id}-legend-tooltip" class="heatmap-color-legend-tooltip"></div>'
												+ '</div>'
											
											+ '</div>'
											
											+ '<div id="{@id}-editor-div" class="heatmap-editor-button" style="width: {@LayoutProperties.EditButtonWidth}px; height:{@LayoutProperties.EditButtonHeight}px; right:{@LayoutProperties.EditButtonRight}px"></div>'
								
								+ '</div>'

								
								+'<span id="textSpan" class="heatmap-measure-text"></span>'

                                
                                +'<div class="mojo-overlay-wait" style="display: -webkit-box; -webkit-box-align:center; -webkit-box-pack:center; position: absolute; left: -100000px; top: -100000px">'
                                        +'<div class="overlay"></div>'
                                        +'<div style="width:{@LayoutProperties.WaitIconWidth}px; height:{@LayoutProperties.WaitIconHeight}px; background-color: black; opacity: 0.8; display: -webkit-box">'
                                            +'<div style="display: -webkit-box; -webkit-box-align: center; -webkit-box-pack: center; -webkit-box-flex:1;  margin: {@LayoutProperties.WaitIconMargin}px; border: 1px solid white; color: white; font-family: Helvetica; font-weight: bold; font-size:{@LayoutProperties.WaitIconFontSize}pt">'
                                                +'{@waitIconString}'
                                            +'</div>'
                                        +'</div>'
                                +'</div>'

                                
                                + '<div></div>'

                        + '</div>',

						markupSlots : {

							canvas: function() {
								return this.domNode.childNodes[0].childNodes[0].childNodes[0].childNodes[0];
							},

							canvasContainer: function() {
								return this.domNode.childNodes[0].childNodes[0];
							},

                            canvasOuterContainer: function() {
                               return this.domNode.childNodes[0];
                            },

                            scrollNode: function() {
                                return this.domNode.childNodes[0].childNodes[0].childNodes[0];
                            },

							selectionHighlightBox : function() {
								return this.domNode.childNodes[0].childNodes[0].childNodes[0].childNodes[1];
							},

							legend: function() {
								return this.domNode.childNodes[1];
							},

							sizeLegend : function(){
								return this.domNode.childNodes[1].childNodes[0];
							},
							sizeLegendTitle : function() {
								return this.domNode.childNodes[1].childNodes[0].firstChild;
							},
							sizeLegendLabel : function() {
								return this.domNode.childNodes[1].childNodes[0].lastChild;
							},

							colorLegend : function() {
								return this.domNode.childNodes[1].childNodes[1];
							},
							colorLegendTitle : function() {
								return this.domNode.childNodes[1].childNodes[1].firstChild;
							},
							colorLegendLabel : function() {
								return this.domNode.childNodes[1].childNodes[1].childNodes[1];
							},
							colorLegendBand : function() {
								return this.domNode.childNodes[1].childNodes[1].childNodes[2].firstChild;
							},
							legendTooltip : function() {
								return this.domNode.childNodes[1].childNodes[1].childNodes[2].childNodes[1];
							},
							editorButton : function() {
								return this.domNode.childNodes[1].lastChild;
							},
							textSpan : function() {
								return this.domNode.childNodes[2];
							},

                            waitIcon: function() {
                                    return this.domNode.childNodes[3];
                            },

                            infoBoxPuppet: function() {
                                    return this.domNode.childNodes[4];
                            }
						},

                        addCSSToHead: function(){
                                var cssString = {
                                        text:
                                                '.heatmap-popup-panel-title {'+
                                                '  font-size: ' + adjustPixel.call(this,22 , true) + 'pt !important;'+
                                                '  height: ' + adjustPixel.call(this,65 , true) + 'px !important;'+
                                                '}'+
                                                '.heatmap-gray-label {'+
                                                '        padding-bottom: ' + adjustPixel.call(this,7 , true) + 'px !important;'+
                                                '        font-size: ' + adjustPixel.call(this,14 , true) + 'pt !important;'+
                                                '  height: ' + adjustPixel.call(this,32 , true) + 'px !important;'+
                                                '  padding-left: ' + adjustPixel.call(this,22 , true) + 'px !important;'+
                                                '  line-height: ' + adjustPixel.call(this, 40 , true) + 'px !important;' +
                                                '}'+
                                                '.heatmap-tree-text {' +
                                                '  font-size: ' + adjustPixel.call(this, 18 , true) + 'pt !important;' +
                                                '  line-height: ' + adjustPixel.call(this, 65 , true) + 'px !important;'+
                                                '}' +
                                                '.heatmap-tree-div {'+
                                                '  font-size: ' + adjustPixel.call(this,18 , true) + 'pt !important;'+
                                                '  line-height: ' + adjustPixel.call(this, 40 , true) + 'px !important;'+
                                                '}'+
                                                '.heatmap-tree-button {'+
                                                '  font-size: ' + adjustPixel.call(this,16 , true) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-apply-button > .mstrmojo-Button-text {'+
                                                '  font-size: ' + adjustPixel.call(this,14 , true) + 'pt !important;'+
                                                '  line-height: ' + adjustPixel.call(this,24 , true) + 'px !important; '+
                                                '  height: ' + adjustPixel.call(this,24 , true) + 'px !important; '+
                                                '}'+
                                                '.heatmap-tree.root > .heatmap-tree-div > div {'+
                                                '  font-size: ' + adjustPixel.call(this,14 , true) + 'pt !important;'+
                                                '  line-height: ' + adjustPixel.call(this, 40 , true) + 'px !important;'+
                                                '  height: ' + adjustPixel.call(this, 40 , true) + 'px !important;'+
                                                '}'+
                                                '.heatmap-one-level-1 {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-multi-level-1 {'+
                                                '  font-size: ' + adjustPixel.call(this,24) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-two-level-2 {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-multi-level-2 {'+
                                                '  font-size: ' + adjustPixel.call(this,20) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-multi-level-3 {'+
                                                '  font-size: ' + adjustPixel.call(this,10) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-size-legend {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-color-legend {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-color-legend-label {'+
                                                '  font-size: ' + adjustPixel.call(this,10) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-color-legend-tooltip {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-legend {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-editor-button {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-gray-bold {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-gray {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-black-bold {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-black {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'
                                };

                                this.addAdjustedClassToDocument(cssString.text);

                        },

                        



						addAdjustedClassToDocument: function(classString){
							var beginIndex = classString.indexOf('.');
							if(beginIndex == -1)
								return;
                            var p = document.getElementsByTagName('head')[0];
                            this.CSSParent = p;
							for(var i = beginIndex; i < classString.length; ){
								var endIndex = i + classString.substring(i).indexOf('}');
								if(endIndex == -1)
									break;
								var style = document.createElement('style');
								style.type = 'text/css';
								style.innerHTML = classString.substring(i,endIndex+1);
                                this.insertedStyles.push(style);
								p.appendChild(style);
								i = endIndex + 1;
							}
						},

                        isMultipleDPIEnabled: function() {
                                var xtabModel = this.xtabModel,
                                    docModel = (xtabModel && xtabModel.docModel),
                                    fitToPage = false,
                                    microApp = false;
                                if (docModel) {
                                        fitToPage = docModel.zt && (docModel.zt==2);
                                        var layouts = (docModel && docModel.defn && docModel.defn.layouts),
                                            layout;
                                        var i;
                                        
                                        for(i in layouts) {
                                                if (layouts[i].loaded) {
                                                        layout = layouts[i];
                                                        break;
                                                }
                                        }
                                        if (layout && layout.hasOwnProperty("fch")) {
                                                microApp = layout.fch;
                                        }
                                }
                                if(fitToPage && microApp)
                                        return true;
                                else
                                        return false;
                                
                        },

                        init: function(e){

                                if(this._super)
                                        this._super(e);

                                
                                var canvas = document.createElement("canvas");
                                browserSupportsHtml5 = canvas.getContext;
                                if (!browserSupportsHtml5) {
                                        this.error = mstrmojo.desc(8126, 'Your browser does not support HTML5');
                                        return;
                                }



                        },
						preBuildRendering :function() {


                                delete this.error;
                                if(this._super){
                                        this._super();
                                }
                                
                                this.dpiAdjusted = true;
                                this.DPI = mstrMobileApp.getDeviceDPI();
                                if(mstrMobileApp.getDeviceDPIX)
                                        this.DPIX = mstrMobileApp.getDeviceDPIX();
                                else
                                        this.DPIX = 149;
                                if(this.isMultipleDPIEnabled()){
                                

                                        
                                        
                                        
                                                

                                        this.enableMultiDPI = true;
                                        
                                        
                                }else{
                                        
                                        this.enableMultiDPI = false;
                                        
                                        
                                        
                                                


                                        
                                        
                                        
                                }
                                
                                

                                this.adjustLocalDPI();
                                this.addCSSToHead();




                                this.zIndex = null;

                                this.loadDefinedFormat();


                                loadProps.call(this);
                                loadSession.call(this);


                                if (!this.model) {
                                        this.error = mstrmojo.desc(8426,'No model provided');

                                        return ;
                                }
                                
                                var err = this.model.err || this.model.eg;
                                if(err){
                                        this.error = err;
                                        return;
                                }

                                convertDataToModels.call(this);

                                var err = this.model.err || this.model.eg;
                                if(err){
                                        this.error = err;
                                        return;
                                }


                                setLayout.call(this);


                                this.calculateValuesInTree();

                                layoutEntities.call(this);


                                getLegendMaxMin.call(this);


                                this.nf = mstrmojo.num;

                                if (this.editorDialog) {
                                        this.editorDialog.destroy();
                                        this.editorDialog = null;
                                }

						},

                        
                        buildRendering: function () {


                                var that = this;
                                var backup = mstrmojo.string.apply;
                                mstrmojo.string.apply = function (tmpl, obj) {
                                        if (!tmpl) {
                                                return "";
                                        }
                                        return tmpl.replace(/\{([^\}]+)\}/gm,
                                                            function tokenRepl(token, prop) {
                                                                    var s = token.replace(/@/g, 'that.');
                                                                    var res;
                                                                    try{
                                                                            res = eval(s);
                                                                    }catch(e){
                                                                            res = undefined;
                                                                    }finally{
                                                                    }
                                                                    return res === undefined ? '' : res;
                                                            }
                                        );
                                };

                                if (this._super) {
                                        this._super();
                                }
                                mstrmojo.string.apply = backup;





                        },

                        createInfoBox: function(){
                                
                                
                                var html =
                                        
                                        '<div id="' + this.id + '-infobox" class="heatmap-infobox" style="position:absolute; left:0px; top:0px;">'  
                                            +'<div class="heatmap-highlight-box heatmap-round-corner" style="border: ' + this.highlightBoxWidth + 'px solid white;"></div>'  
                                            +'<div class="heatmap-shadow-box heatmap-round-corner"></div>'  
                                            +'<div class="heatmap-triangle"></div>'  
                                            +'<div class="heatmap-tooltip-box heatmap-round-corner" style="max-width: ' + document.body.offsetWidth + 'px; max-height: ' + document.body.offsetHeight + 'px; "></div>'  
                                            +'<div class="heatmap-delete-button"></div>'  
                                            +'<div class="heatmap-tooltip-shelter heatmap-round-corner"></div>'
                                        +'</div>';
                                
                            var div = document.createElement('div');
                            div.innerHTML = html;

							this.infoBox = div.childNodes[0];
                            this.highlightBox = this.infoBox.childNodes[0];
                            this.shadowBox = this.infoBox.childNodes[1];
                            this.triBox = this.infoBox.childNodes[2];
                            this.tooltipBox = this.infoBox.childNodes[3];
                            this.deleteButton = this.infoBox.childNodes[4];
                            this.shelter = this.infoBox.childNodes[5];

                            
                            

                            div.style.cssText = 'position: absolute; left: 0px; top: 0px';

                            
                            bindTouchEvents(div, this.infoBoxPuppet);

                            document.body.appendChild(div);
                        },

                        








						postBuildRendering : function postBR() {

                                if(this.error){

                                        this.renderErrorMessage(this.error);
                                        return ;
                                }
                            var heatMap = this;
                            
                            var tmpFunction = this.controller.onorientationChange;
                            this.controller.onorientationChange = function(){
                                    tmpFunction.call(heatMap.controller);
                                    heatMap.onorientationChange();
                            }

                            
                            
                            
                            this.enableGlobalDismiss();



                            this.setupScroller();
							if(this._super) {
			                	this._super();
                            }
                            var backup = this._tsCallback;
                            this._tsCallback = function(e){
                                    
                                    if(heatMap.isInfoWindowDisplayed())
                                            heatMap.infoWindowMode = true;
                                    else
                                            heatMap.infoWindowMode = false;


                                    backup.call(heatMap,e);
                            };

                            
                            

                            var $DAE = mstrmojo.dom.attachEvent,
                                $DDE = mstrmojo.dom.detachEvent,
                                TOUCHSTART = mstrmojo.dom.TOUCHSTART;
                            $DDE(this._tn, TOUCHSTART, backup);
                            $DAE(this._tn, TOUCHSTART, this._tsCallback);

                            
                            if(this.isUsingSavedColorTheme) {
                                this.useSavedColorTheme();
                            }

                            if(this.isUsingDefaultColorTheme) {
                                this.useDefaultColorTheme();
                            }

                            this.initCanvas();
							
							this.renderLegend();
                            
                            if(!this.infoBox)
                                    this.createInfoBox();

							
							if (this.props.delButtonEnabled) {
								this.deleteButton.style.display = "block";
							}

							if(this.previousSelected && this.previousSelected.parentEntity){
                                
								this.highlightEntity(this.selectionHighlightBox, this.previousSelected);
                                
                                
							}

							


                        },

                        unrender: function(){
                                

                                
                                
                                
                                
                                storeSession.call(this);


                                this.disableGlobalDismiss();
                                var $DAE = mstrmojo.dom.attachEvent,
                                    $DDE = mstrmojo.dom.detachEvent,
                                    TOUCHSTART = mstrmojo.dom.TOUCHSTART;
                                $DDE(this._tn, TOUCHSTART, this._tsCallback);
                                if(this.infoBox && this.infoBox.parentNode && this.infoBox.parentNode.parentNode)
                                        this.infoBox.parentNode.parentNode.removeChild(this.infoBox.parentNode);
                                delete this.infoBox;
                                
                                if(this._super)
                                        this._super();
                        },

                        getFirstInfowindow: function getFirstInfowindow() {
                                var me = this,
                                    model = me.model,
                                    xtabModel = me.xtabModel,
                                    docModel = (xtabModel && xtabModel.docModel),
                                    row = model && model.gts && model.gts.row,
                                    tks;
                                if (row && row.length>0) {
                                        tks = row[0] && row[0].sc && row[0].sc.tks;
                                }
                                if (docModel && tks) {
                                        ifws = docModel.getTargetInfoWin(tks);
                                        if (ifws && ifws.length) {
                                                var ifwunit = docModel.infoWinByKey[ifws[0]];
                                                var id = ifwunit && (ifwunit.id + "_ifw");
                                                return mstrmojo.all[id];
                                        }
                                }
                        },

                        isInfoWindowDisplayed: function() {
                                var ifw = this.getFirstInfowindow();
                                if(ifw)
                                        ifw = ifw.domNode;
                                if(!ifw)
                                        return false;

                                if(ifw.style.display == 'block')
                                        return true;
                                else
                                        return false;
                        },

                        globalListener: function (){
                                
                                var that = window.heatMap;
                                if(!that)
                                        return ;
                                that.hideInfoBox();
                                if(!that.selectAll)
                                        that.doSelection(that.previousSelected);
                        },


                        addGlobalListener: function() {
                                window.heatMap = this;
                                var p = document.getElementsByClassName('mstrmojo-DocLayoutViewer-layout')[0];
                                if(p)
                                        p.addEventListener(mstrmojo.dom.TOUCHSTART, window.heatMap.globalListener, false);
                        },

                        removeGlobalListener: function() {
                                var p = document.getElementsByClassName('mstrmojo-DocumentView')[0];
                                if(p)
                                        p.removeEventListener('click', this.globalListener, false);
                                delete window.heatMap;
                        },



                        addCurtain: function(){
                                var p = document.getElementsByClassName('mstrmojo-DocLayoutViewer-layout')[0];
                                var div = document.createElement('div'),
                                    
                                    that = this;
                                div.style.width = p.offsetWidth + 'px';
                                div.style.height = p.offsetHeight+ 'px';
                                div.style.position = 'absolute';
                                
                                div.style.zIndex = -1;
                                div.id = this.id + 'curtain';

                                div.onclick = this.globalListener;
                                p.appendChild(div);
                        },
                        removeCurtain: function(){
                                var div = document.getElementById(this.id+'curtain');
                                if(div)
                                        div.parentNode.removeChild(div);
                        },
                        renderErrorMessage: function renderErrorMessage(msg) {
                                var d = this.domNode,
                                    p = d.parentNode,
                                    div = document.createElement('div'),
                                    textDiv = document.createElement('div');

                                if(d){

                                        div.style.width = d.offsetWidth - 2 + 'px' ;
                                        div.style.height = d.offsetHeight - 2 + 'px';
                                        div.style.left = d.offsetLeft + 'px';
                                        div.style.top = d.offsetTop + 'px';
                                        div.style.zIndex = this.zIndex ;
                                }else{

                                        div.style.width = parseInt(this.width) - 2 + 'px';
                                        div.style.height = parseInt(this.height) - 2 + 'px';
                                        div.style.left = this.left;
                                        div.style.top  = this.top;
                                        div.style.zIndex = this.zIndex;
                                }

                                div.style.cssText += "background-color:#F5F5F2; position:absolute; display:-webkit-box; -webkit-box-pack:center; -webkit-box-align:center; -webkit-box-orient:vertical; border-style:solid; border-color:#A7A7A7; border-width:1px; ";
                                textDiv.className = "mstrmojo-message";
                                textDiv.innerText = msg;
                                div.appendChild(textDiv);
                                if(d)
                                        p.replaceChild(div, d);
                                else
                                        p.appendChild(div);
                        },

                        convertDPI: function(props) {
                                if(typeof props != 'object'){
                                        if(typeof props == 'number' && props%1 == 0)
                                                return adjustPixel.call(this, props);
                                        else
                                                return props;
                                }else{
                                        var ret = {};
                                        for(var key in props)
                                                ret[key] = this.convertDPI(props[key]);
                                        return ret;
                                }
                        },

						adjustLocalDPI: function(){
								
                                this.LayoutProperties = this.convertDPI(LayoutProperties);
                                this.LayoutProperties.LegendTickCount = 5;
                                this.LayoutProperties.LegendWidthPercent = 0.9;
                                this.LayoutProperties.LegendBandAspect = 10;
                                this.LayoutProperties.EditorDialogWidth = adjustPixel.call(this,565, true);
                                this.LayoutProperties.EditorDialogHeight = adjustPixel.call(this,574, true);
                                var h = document.body.offsetHeight,
                                    eh = this.LayoutProperties.EditorDialogHeight,
                                    sfh = h / eh,
                                    sf = 1;
                                if(sfh < 1){
                                        sf = sfh;
                                        sf *= 0.9;
                                        this.LayoutProperties.EditorDialogHeight = parseInt(eh * sf);
                                }

                                this.LayoutProperties.DeletedListHeight = adjustPixel.call(this,500*sf , true);
                                this.LayoutProperties.EditButtonWidth = adjustPixel.call(this,60);
                                this.LayoutProperties.EditButtonHeight = adjustPixel.call(this,40);
                                this.LayoutProperties.EditButtonRight = adjustPixel.call(this,10);
                                
						},

						onorientationChange: function(){
								if(this.editorDialog){
										var domNode = this.editorDialog.domNode;
                                        if(domNode && domNode.firstChild){
                                                var d = domNode.firstChild, 
                                                    t = d.firstChild.firstChild;
                                                d.style.marginTop = parseInt((document.body.offsetHeight - this.LayoutProperties.DeletedListHeight - t.offsetHeight)/2) + 'px';
                                        }
								}
						},


                        loadDefinedFormat: function() {
                                
                                if (this.defn && this.defn.fmts) {
                                        var fmts = this.defn.fmts,
                                            pWidgetHeight = fmts && fmts.p_fmts && fmts.p_fmts.height;

                                        if (fmts.height) {
                                                this.height = fmts.height;
                                        }
                                        if(!this.isFullScreenWidget) {
                                                if (fmts.width) {
                                                        this.width = fmts.width;
                                                }
                                        }

                                        if (fmts["z-index"]) {
                                                this.zIndex = fmts["z-index"];
                                        }
                                }
                        },

                        checkErrors: function() {
                                var err = this.error;
                                if(err){
                                        this.renderErrorMessage(err);
                                        return true;
                                }
                                if (!this.model) {
                                        this.renderErrorMessage(mstrmojo.desc(8426,'No model provided'));

                                        return true;
                                }
                                var err = this.model.err || this.model.eg;
                                if (err) {
                                        this.renderErrorMessage(err);

                                        return true;
                                }
                                return false;
                        },


                        setupScroller: function(){
                                
                                var sclConfig = this.scrollerConfig;
                                sclConfig.scrollEl = this.scrollNode;
                                sclConfig.offset.x.start = 0;
                                sclConfig.offset.x.end = this.heatMapSize.w * (this.scaleFactor - 1);
                                sclConfig.offset.y.start = 0;
                                sclConfig.offset.y.end = this.heatMapSize.h * (this.scaleFactor - 1);
                                if (sclConfig.origin.x > sclConfig.offset.x.end) {
                                        sclConfig.origin.x = sclConfig.offset.x.end;
                                }
                                if (sclConfig.origin.y > sclConfig.offset.y.end) {
                                        sclConfig.origin.y = sclConfig.offset.y.end;
                                }
                        },




                        refreshLabelInTree: function(){
                                var getLabel = function(e, idx){
                                        if(e == this.root)
                                                return;
                                        var text = this.getLabelForEntity(e);
                                        e.text = text;
                                        e.idx = idx;
                                };
                                this.dfs(this.root, getLabel, "");
                        },

						refreshColorInTree: function() {
							var paintColor = function(e) {
                                    if(e.EntityChildren || e == this.root)
                                            return;
                                    
                                    var color = getCSSColor(this.colorTheme.getColor(getColorValue(e,this)));
                                    e.color = color;
							};
							this.dfs(this.root,paintColor,"");
						},





























						dfs: function (root, f, indexString) {
							if(root.deleted) {
								return;
							}
							if(indexString === undefined){
								f.call(this,root);
							}else{
								f.call(this,root, indexString);
							}

							if(root.entityChildren === undefined){
								return;
							}
							var arr = root.entityChildren,
								l = arr.length;
							for(var i = 0; i < l; i++){
								var e = arr[i];
								if(indexString === undefined){
									this.dfs(e, f);
								}else{
									var param = indexString;
									if (!param) {
										param = i.toString();
									} else {
										param = param + ":" + i;
									}
									this.dfs(e, f, param);
								}
							}
						},

						
						traverseBFS: function traverse(){
							var heatMap = this,
								canvas = this.textCanvas,
								renderText = function(e, indexString) {

								},
								terminate = function(level){
									var lv = level - heatMap.levelToShowText;
									if(lv >= 3) return false;
									return true;
								};











						},

                        initCanvas: function() {
								this.refreshColorInTree();
                                this.refreshLabelInTree();
                                var props = {
                                        colorTheme: this.colorTheme,
                                        placeholder: this.canvas,
                                        root: this.root,
                                        width: this.heatMapSize.w,
                                        height: this.heatMapSize.h,
                                        scale: this.scaleFactor,
                                        attributes: this.levelAttributes,
                                        showMetric: this.props.showMetricValues,
                                        labelSetting: this.props.labelSize
                                };
                                this.canvasObject = new mstrmojo.VisHeatMapCanvas(props);
                                this.canvasObject.render();
                                this.canvasObject.updateOffsets(this._scroller.origin.x, this._scroller.origin.y);
                                this.canvas = this.canvasObject.domNode;
                        },


						renderRectangles: function(){
								this.refreshColorInTree();
                                this.refreshLabelInTree();
                                this.canvasObject.scale = this.scaleFactor;
                                this.canvasObject.offsetX =  this._scroller.origin.x;
                                this.canvasObject.offsetY =  this._scroller.origin.y;
                                this.canvasObject.draw();
						},

						renderLegend : function renderLegend() {
							if(this.props.showLegend == false) {
                                this.editorButton.style.height = '';
                                this.editorButton.style.width = '';
                                this.editorButton.style.right = '';
                                this.editorButton.style.bottom = '';

								this.editorButton.className = "heatmap-editor-legend-unshown";
								this.editorButton.innerHTML = "";
								this.editorButton.style.top = "";
								this.sizeLegend.style.display = "none";
								this.colorLegend.style.display = "none";
                                this.legend.style.left = '';
                                this.legend.style.top = '';
                                this.legend.style.right = '0px';
                                this.legend.style.bottom = '0px';
                                this.legend.style.zIndex = '100';
								return;
							}
                                var el = mstrmojo.desc(11158,'EDIT'),
                                rsl = mstrmojo.desc(10079,'Rectangle Size'),
                                rcl = mstrmojo.desc(10080,'Rectangle Color');

							this.editorButton.className = "heatmap-editor-button";
							this.editorButton.innerHTML = el;
							var w = parseInt(this.width), h = parseInt(this.height), canvasHeight = this.heatMapSize.h,
								computedStyle = window.getComputedStyle(this.editorButton,null),
								editorButtonHeight = parseInt(computedStyle['height']),
								editorButtonWidth = parseInt(computedStyle['width']),
                                legendHeight = this.legendSize.h,
                                legendWidth = this.legendSize.w - editorButtonWidth - parseInt(computedStyle['right']),
                                sfs = this.getFormatString(this.sizeMetricIndex);
							this.legend.style.top = this.heatMapSize.h  + 2*this.LayoutProperties.Padding + 'px';
							
							
							
								
							
							this.editorButton.style.top = ((legendHeight - editorButtonHeight)>>1) + "px" ;
							this.editorButton.style.bottom = "";
							if(this.props.showEditor){
								legendWidth -= this.LayoutProperties.LegendMenuEditorWidth;
							}
							var sizeT = {w:0, h:0}, sizeL = {w:0, h:0}, sizeSize = {w:0, h:0},
								tickCount, padding,
								bandWidth, bandHeight;
							if(this.props.sizeMetricEnabled){
								var sizeTitle = "<span style='font-weight: bold'>" + rsl + ":</span>";
								var vld = this.checkMetricValid(this.sizeMetricIndex),
									mn = this.getMetricName(this.sizeMetricIndex);
								if(this.hasNegativeSizeValue){
									mn = "Absolute value of " + mn;
								}
								if(isNaN(this.smin)){
									this.smin = 0;
									
								}
								
								if(isNaN(this.smax))
									this.smax = 0;
								
								
									


								var sizeLabel = "<div>" + (vld ? this.nf.formatByMask(sfs, this.smin) : "0")
												+ " < " + "</div>"
                                                + "<div class='heatmap-flex'>" + mn + "</div>"
                                                + "<div>" + " < "
												+ (vld ? this.nf.formatByMask(sfs, this.smax) : "0") + "</div>";
								
								
								
								this.sizeLegendTitle.innerHTML = sizeTitle;
								
								this.sizeLegendLabel.innerHTML = sizeLabel;
								
								
                                sizeSize = {w:Math.max(this.sizeLegendTitle.offsetWidth, this.sizeLegendLabel.offsetWidth), h: this.sizeLegendTitle.offsetHeight};
							}else{
								this.sizeLegend.style.display = "none";
							}
							if(this.props.colorMetricEnabled){
								var colorTitle;
								if( this.props.sizeMetricEnabled )
									colorTitle = rcl + ": " + "<span style='font-weight:normal;'>"
												 + this.getMetricName(this.colorMetricIndex)+ "</span>";
								else
									colorTitle = "<span style='font-weight:bold'>"
												 + this.getMetricName(this.colorMetricIndex)+ "</span>";
								tickCount = this.LayoutProperties.LegendTickCount;
								if(isNaN(this.cmin) || this.cmin >= this.cmax) {
									tickCount = 1;
								}
								this.legendTickCount = tickCount;
								
								bandWidth = Math.min(this.LayoutProperties.LegendMaxBandWidth, this.LayoutProperties.LegendWidthPercent*(legendWidth-sizeSize.w));
								padding = Math.floor((legendWidth - sizeSize.w - bandWidth)/3);
								var pd = this.renderTickLabels(bandWidth, tableHeight, tickCount);
								if(padding >= this.LayoutProperties.LegendMinPadding + pd.l + pd.r){
									bandWidth += pd.l + pd.r;
									padding -= ((pd.l + pd.r)>>1);
								}
								else if(padding < this.LayoutProperties.LegendMinPadding){
									padding = this.LayoutProperties.LegendMinPadding;
									var temp = ((legendWidth-3*padding)>>1);
									if(temp > sizeSize.w){
										bandWidth = legendWidth - 3*padding - sizeSize.w;
									}else{
										sizeSize.w = temp;
										bandWidth = sizeSize.w;
									}
								}
								bandHeight = Math.min(Math.floor(bandWidth/this.LayoutProperties.LegendBandAspect), Math.floor(legendHeight/3)) - this.LayoutProperties.LegendBottomPadding;
								this.colorLegend.style.display = "";
								
								this.colorLegendTitle.innerHTML = colorTitle;
							}else{
								padding = ((legendWidth - sizeSize.w)>>1);
								this.colorLegend.style.display = "none";
							}
							if(this.props.sizeMetricEnabled){
								this.sizeLegend.style.left = padding + 'px';
								this.sizeLegend.style.width = sizeSize.w + this.LayoutProperties.LegendGutter + 2*this.LayoutProperties.Padding + 'px';
								
								this.sizeLegend.style.height = legendHeight + 'px';
								
								
							}
							else{
								this.sizeLegend.style.left = '0px';
								this.sizeLegend.style.width = '0px';
								this.sizeLegend.top =  '0px';
								this.sizeLegend.style.height = '0px';
								this.sizeLegendLabel.style.marginTop = '0px';
								padding = ((legendWidth - bandWidth)>>1);
							}

							if(this.props.colorMetricEnabled){
								
								if (this.props.sizeMetricEnabled)
									this.colorLegend.style.left = sizeSize.w + 2*padding + 'px';
								else
									this.colorLegend.style.left = sizeSize.w + padding + 'px';
								this.colorLegend.style.width = bandWidth + 'px';
								this.colorLegend.style.height = legendHeight + 'px';


								
                                sizeT = {w:this.colorLegendTitle.offsetWidth, h:this.colorLegendTitle.offsetHeight};
								var tableHeight = legendHeight - bandHeight - sizeT.h - 2*this.LayoutProperties.LegendBottomPadding;
								
								this.colorLegendLabel.style.width = bandWidth + 'px';
								this.colorLegendLabel.style.height = tableHeight + 'px';

								this.colorLegendBand.width = bandWidth;
								this.colorLegendBand.height = bandHeight + 10;  
								var pd = this.renderTickLabels(bandWidth, tableHeight, tickCount);
                                
                                this.colorTheme.tooltipInfo = null;
								
									
								
								
								this.legendBand = {x:pd.l, y:0, w:bandWidth-pd.r-pd.l, h:bandHeight};
                                this.colorLegendBand.parentNode.style.width = bandWidth + 'px';
                                this.colorLegendBand.parentNode.style.height= bandHeight + 'px';

								this.renderGradientBand(this.legendBand);
							}
						},
						renderTickLabels: function renderLabel(w, h, t){
							var count = t + 1;
							var p = this.colorLegendLabel.firstChild.firstChild,
								nodes = p.childNodes,
								curCount = nodes.length,
								lastNode = p.lastChild,
								diff = curCount - count,
								cfs = this.getFormatString(this.colorMetricIndex);
							lastNode.style.display = "";
							lastNode.style.width = "";
							lastNode.style.textAlign = "center";
							if(diff < 0){
								for(var i = 0; i < Math.abs(diff); i++){
									var node = lastNode.cloneNode(true);
									p.insertBefore(node, lastNode.nextSibling);
									lastNode = node;
								}
							}
							else {
								for(var i = 0; i < diff; i++){
									if(t == 0 && i == diff-1){
										lastNode.style.display = "none";
										break;
									}
									
									p.removeChild(p.lastChild);
									
								}
							}
							p.firstChild.style.textAlign = "left";
							p.lastChild.style.textAlign = "right";
							var valid = true;
							if(isNaN(this.cmax) || isNaN(this.cmin)){
								valid = false;
							}
							for(var i = 0; i < count; i++){
								node = nodes[i];
								var v = "Null";
								if(valid){
									v = getNumberForTick.call(this, i);
								}
								node.innerHTML = '<div style="display: inline-block; overflow: hidden; text-overflow: ellipsis; max-width: 100%; white-space: nowrap;">' + this.nf.formatByMask(cfs, v) + '</div>';
								if(this.props.legendRounded){

								}
							}
							var firstV = p.firstChild.innerHTML,
								lastV = p.lastChild.innerHTML,
								
								
                                fSize = {w:p.firstChild.firstChild.offsetWidth, h:p.firstChild.firstChild.offsetHeight};
                                lSize = {w:p.lastChild.firstChild.offsetWidth, h: p.lastChild.firstChild.offsetHeight};
								left = Math.min(w/count, fSize.w)>>1,
								right = Math.min(w/count, lSize.w)>>1;

							return {l:left, r:right};

						},
						renderGradientBand: function renderBand(frame){
							var x = frame.x, y = frame.y, w = frame.w, h = frame.h,
								ctx = this.colorLegendBand.getContext("2d");
							ctx.clearRect(x, y, w+2, h);
							var lingrad = ctx.createLinearGradient(x,y,w+x,y);
							lingrad.addColorStop(0,"#333333");
							var gradientInfo = this.colorTheme.getGradientFillInfo(this.cmin, this.cmax);
							var c = gradientInfo.c,
								r = gradientInfo.r,
								l = c.length;
							for(var i = 0; i < l; i++){
								lingrad.addColorStop(roundNumber(r[i], 2), getCSSColor(c[i]));
							}
							ctx.fillStyle = lingrad;
							createPath(x, y, w, h, 0, ctx);
							ctx.fill();
						},
						renderHilightedBand: function renderHighlightedBand(i){
							var frame = this.legendBand,
								info = this.colorTheme.tooltipInfo[i],
								x = frame.x, y = frame.y, w = frame.w, h = frame.h,
								ctx = this.colorLegendBand.getContext("2d");
							this.renderGradientBand(frame);
							this.selectedBandIndex = i;
							
							ctx.strokeStyle = "#FFFFFF";
							ctx.lineWidth = 2;
							ctx.strokeRect(info.r.x+x+1, y+1, info.r.w-1, h-3);
						},

						getTextSize: function gts(str, fontName, fontSize, isBold, isItalic) {
							this.textSpan.style = "";
							this.textSpan.style.fontFamily = fontName;
							this.textSpan.style.fontSize = isNaN(fontSize) ? fontSize : fontSize + 'px';
							this.textSpan.style.fontWeight = isBold ? "bold" : "normal";
							this.textSpan.style.fontStyle = isItalic ? "italic" : "normal";
							this.textSpan.innerHTML = str;
							var w = this.textSpan.offsetWidth,
								h = this.textSpan.offsetHeight;
							return {w:w, h:h};
						},


						reRender : function reRender() {
							if (this.model.err || this.model.eg) {
								
								
								return;
							}
                            if(this._super) {
                                    this._super();
                            }
						},

						useDefaultColorTheme: function(callback){
							var colorTheme = this.colorTheme,
								needsRefresh = false;
							if(colorTheme.useDefault == false){
								needsRefresh = true;
								colorTheme.isBlend = true;
								colorTheme.setDefaultDataProvider();
							}
							if (this.scaleFactor != 1) {
								needsRefresh = true;
								this.scaleFactor = 1;
							}

							
							function markUndelete (delDict) {
								for (var key in delDict) {
									var childDict = delDict[key];
									if (typeof childDict === "object") {
										if (Object.keys(childDict).length === 0) { 
											delete delDict[key];
										} else { 
											markUndelete(childDict);
										}
									} else if (childDict === delStatus.dftDel) { 
										needsRefresh = true;
										delDict[key] = delStatus.dftUnDel;
									} else if (childDict === delStatus.usrDel) { 
										needsRefresh = true;
										delete delDict[key];
									}
								}
							};
							markUndelete(this.props.deletedList); 
							this.loadDeleteStatus(this.root, this.props.deletedList);

							if(needsRefresh){
								colorTheme.tooltipInfo = null;
								this.refreshWidget();
							}
							if (callback) {
								callback();
							}
						},

						loadDeleteStatus: function (node, delDict) {
							if (!node.entityChildren) { 
								if (delDict === delStatus.dftDel || delDict === delStatus.usrDel) {
									node.deleted = true;
								} else { 
									delete node.deleted;
								}
								return;
							}
							
							if ((!delDict || Object.keys(delDict).length === 0) && !node.hasChildDeleted) { 
								return;
							}
							
							var children = node.entityChildren;
							for (var i = 0; i < children.length; i++) {
								var child = children[i];
								var name = this.getEntityDisplayName(child);
								var thisDict = delDict && delDict[name];
								this.loadDeleteStatus(child, thisDict);
							}
						},

						useSavedColorTheme:function(callback){
							var colorTheme = this.colorTheme,
								needsRefresh = false;
							if(colorTheme.useDefault == true){
								needsRefresh = true;
								var propValue = this.model.vp;
								if(propValue){
									colorTheme.isBlend = ((propValue.blc === undefined || propValue.blc == "true") ? true:false);
								}
								if(propValue.gradientColors && propValue.bandColors){
									colorTheme.createDataProviderFromString(propValue.gradientColors, propValue.bandColors);
								}
								colorTheme.useDefault = false;
							}
							if (this.scaleFactor != 1) {
								needsRefresh = true;
								this.scaleFactor = 1;
							}

							
							function markDelete (delDict) {
								for (var key in delDict) {
									var childDict = delDict[key];
									if (typeof childDict === "object") {
										if (Object.keys(childDict).length === 0) { 
											delete delDict[key];
										} else { 
											markDelete(childDict);
										}
									} else if (childDict === delStatus.dftUnDel) { 
										needsRefresh = true;
										delDict[key] = delStatus.dftDel;
									} else if (childDict === delStatus.usrDel) { 
										needsRefresh = true;
										delete delDict[key];
									}
								}
							};
							markDelete(this.props.deletedList); 
							this.loadDeleteStatus(this.root, this.props.deletedList);

							if(needsRefresh){
								colorTheme.tooltipInfo = null;
								this.refreshWidget();
							}

							if (callback) {
								callback();
							}
						},

						getFormatString: function getFormatString(idx){
							var m = this.model,
								col = m.gvs.items[0] ? m.gvs.items[0].items:[],
								cnt = col.length;
							if(idx >= 0 && idx < cnt){
								var obj = col[idx];
								if(obj.formatstring !== undefined){
									return obj.formatstring.replace(/\'/g, '"');
								}
								return "";
							}
							return "";
						},

						checkMetricValid: function checkMetric(idx) {
							var str = "",
								m = this.model,
								col = m.ghs.chs.items,
								cnt = col.length,
								ml = col[0] ? col[0].items.length:0,
								coln = m.gts.col;
							if (idx < 0 || idx >= ml) return false;
							return true;
						},

						getMetricName: function getMetricName(idx){
							var str = "",
								m = this.model,
								col = m.ghs.chs.items,
								cnt = col.length,
								coln = m.gts.col;
							if(!this.checkMetricValid(idx)) return Fake_Metric_ID;
							for(var i = 0; i < cnt; i++){
								var index = col[i].items[idx].idx;
								var name = coln[i].es[index].n;
								str += name + " ";
							}
							return str.slice(0, str.length-1);
						},

						getEntityDisplayName: function getEntityDisplayName(e){
							var level = e.level,
								index = (e.index === undefined) ? e.indices[0] : e.index,
								st = 0, 
								str = "",
								ar = this.attSpan,
								rhs = this.model.ghs.rhs.items,
								rowHeaderData = rhs[index].items,
								att = this.model.gts.row[level];

							for(var i = 0; i < level; i++){
								st += ar[i];
							}
							str = "";
							for(var i = st; i < st + ar[level]; i++){
								var idx = rowHeaderData[i].idx;
								if(idx == -1)
									continue;
								str += att.es[idx].n + " ";
							}
							str = str.substring(0, str.length-1);
							return str;
						},

						previousTooltip: null,

                        previousSelected: null,


                        highlightEntity: function(box, entity) {
                                if(!entity || !box)
                                        return;
                                var w = this.canvasContainer.offsetWidth,
                                    h = this.canvasContainer.offsetHeight,
                                    size = entity.size,
                                    origin = this._scroller.origin,
                                    border = this.highlightBoxWidth,
                                    widgetRect = mstrmojo.dom.position(this.canvasContainer, true);

                                var container = {
                                        x: origin.x,
                                        y: origin.y,
                                        w: w,
                                        h: h
                                };

                                var canvasRect = {
                                        x: 0,
                                        y: 0,
                                        w: Math.ceil(this.heatMapSize.w * this.scaleFactor),
                                        h: Math.ceil(this.heatMapSize.h * this.scaleFactor)
                                };

                                
                                var rect = {
                                        x: size.x - border,
                                        y: size.y - border,
                                        w: size.w + 2*border,
                                        h: size.h + 2*border
                                };

                                var inters = rectIntersection(rect, canvasRect);

                                if(box == this.highlightBox){
                                        inters = rectIntersection(inters, container);
                                        this.previousHighlighted = entity;
                                }


                                if (isNaN(inters.x)) {
                                        return null;
                                }

                                
                                inters.x += (border - origin.x);
                                inters.y += (border - origin.y);
                                inters.w -= 2*border;
                                inters.h -= 2*border;


                                if(box == this.highlightBox){
                                        box.style.left = inters.x  - border + widgetRect.x + "px";
                                        box.style.top = inters.y - border  + widgetRect.y + "px";
                                        inters.x += widgetRect.x;
                                        inters.y += widgetRect.y;
                                }else {
                                        box.style.left = inters.x  - border + "px";
                                        box.style.top = inters.y - border + "px";
                                }
                                box.style.width = inters.w + "px";
                                box.style.height = inters.h + "px";
                                box.style.display = "block";


                                return inters;
                        },

						getLowestLevelRectangle: function(touch){
									target = document.elementFromPoint(touch.pageX, touch.pageY);
									var hiddenStack = [];
									
									while(!this.isLowestLevelRectangle(target)){
										target.style.display = "none";
										
										hiddenStack.push(target); 
										target = document.elementFromPoint(touch.pageX, touch.pageY);
									}
									while (hiddenStack.length) { 
										hiddenStack.pop().style.display = "block";
										
									}
									return target;
						},

						getEntityByTouch: function(touch,getLowest) {
                                
								var entity = null;
                                
                                var pageX = touch.pageX,
                                    pageY = touch.pageY;
console.log("#getEntityByTouch#" + "pageX:" + pageX + " " + "pageY:" + pageY);
								var target = document.elementFromPoint(pageX,pageY),
									backUps = [];

								if(!target) {
                                    console.log("target is null! at elementFromPoint.");
									return null;
                                }
                                
                                var lastLevel = target;
								while(!this.isRectangle(target) && target != this.domNode){
										backUps.push(target);
										target.style.visibility = 'hidden';
										target = document.elementFromPoint(pageX,pageY);
										if(!target || target == lastLevel)
											break ;
                                        lastLevel = target;
								}
                                
                                if(getLowest){
                                        lastLevel = target;
                                        while(target != this.domNode && target.tagName.toLowerCase() != 'img'){
                                                backUps.push(target);
                                                target.style.visibility = 'hidden';
                                                target = document.elementFromPoint(pageX,pageY);
                                                
                                                        
                                                if(!target || target == lastLevel)
                                                        break ;
                                                lastLevel = target;
                                        }
                                }

								var backLen = backUps.length;
								while(backUps.length > 0){
										var node = backUps.pop();
										node.style.visibility = 'visible';
								}
								if(!target) {
                                    console.log("target is null. At backups.");
									return null;
                                }
                                
								if(target != this.domNode){
										if (target.getAttribute('idx') && !getLowest) {
												var entity = this.getIdxObjectByTarget(target);
										}
										else{
                                                var rectPosition = mstrmojo.dom.position(this.canvas,true),
                                                offsetX = pageX - rectPosition.x,
                                                offsetY = pageY - rectPosition.y;
                                                var position = {x:offsetX,y:offsetY},
                                                    entity = this.canvasObject.getEntity(position);
                                                
                                                
                                                
										}
								} else {
                                        
                                }
                                
                                
								return entity;
						},
						getLabelForEntity : function(e) {
                            if(!this.props.showMetricValues || e.entityChildren !== undefined)
                                    return this.getEntityDisplayName(e);
							var	index = (e.index === undefined) ? e.indices[0] : e.index,
								st = '',
								si = this.sizeMetricIndex,
								ci = this.colorMetricIndex,
								mv = this.model.gvs.items,
								ml = mv[0].items.length,
								n, v,
                                dn = this.getEntityDisplayName(e);

							st = '<span style="font-weight:bold;">';
                            
                            if(dn !== '') {
                                st += dn + '<br>';
                            }
							if(si != ml){
								if(e.entityChildren !== undefined || this.aggregated){
									var tmp = this.aggFunctions[si];
									v = getSizeValue(e, this);
									if(isNaN(v)){
										v = '-';
									}
									else if(AggregationType.Cnt != tmp){
										fs = this.getFormatString(si);
										v = this.nf.formatByMask(fs, v);
									}
								}else{
									v = mv[index].items[si].v;
								}
                                if(v !== ''){
                                    st += v + '<br>';
                                }
							}
							if(e.entityChildren === undefined && ci != ml && si != ci){
								if(e.entityChildren !== undefined || this.aggregated){
									var tmp = this.aggFunctions[ci];
									v = getColorValue(e, this);
									if(isNaN(v)){
										v = '-';
									}
									else if(AggregationType.Cnt != tmp){
										fs = this.getFormatString(ci);
										v = this.nf.formatByMask(fs, v);
									}
								}else{
									v = mv[index].items[ci].v;
								}
                                if(v !== '') {
                                    st += v + '<br>';
                                }
							}
							st += '</span><span style="font-weight:normal;">';
							for(var i = 0; i < ml; i++){
								if(i == si) continue;
								if(i == ci && e.entityChildren === undefined && si != ci) continue;
								if(e.entityChildren !== undefined || this.aggregated){
									var tmp = this.aggFunctions[i];
									n = tooltipMacro(n, tmp);
									v = getAggValue(e, i, this);
									if(isNaN(v)){
										v = '-';
									}
									else if(AggregationType.Cnt != tmp){
										fs = this.getFormatString(i);
										v = this.nf.formatByMask(fs, v);
									}
								}else{
									v = mv[index].items[i].v;
								}
                                if(v !== '') {
                                    st += v;
                                    if(i !== ml-1){
                                        st += '<br>';
                                    }
                                }
							}
							st += '</span>';
							return st;
						},




						multiTap: true,
                        touchBegin: function(touch) {
                                
                                
                        },
						touchTap: function (touch) {
								if (touch.count >= 2) { 
										if (this.scaleFactor > 1) {
												this.scaleFactor = 1;
												this._scroller.offset.x.start = 0;
												this._scroller.offset.x.end = 0;
												this._scroller.offset.y.start = 0;
												this._scroller.offset.y.end = 0;
												this._scroller.scrollTo(0, 0, 0);
												this.refreshWidget();
										}
										return;
								}
								


								
								

								var target = touch.target;
                                
                                if(target == this.infoBoxPuppet){
                                    target = document.elementFromPoint(touch.pageX, touch.pageY);
                                }

								if(this.touchLegendTooltipValid(touch))
										this.showLegendTooltip(touch);
								else
										this.hideLegendTooltip();
								switch(target){
										case this.editorButton:{
												target.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
												var callback = function () {
														mstrmojo.VisHeatMapAnimation.animate(target, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
												};
												var that = this;
												setTimeout(function(){
														setTimeout(function(){
																try {
																		that.popupEditor(target);
																} catch (e) {
																} finally {
																		callback();
																}
														}, 0);
												}, 0);

												return; 
										}
										case this.deleteButton:{
                                                if (this.previousTooltip) {
                                                        var delDict = this.props.deletedList;
                                                        var delNode = this.previousTooltip;
                                                        
                                                        var keyStack = [];
                                                        var tempNode = delNode;
                                                        do { 
                                                                keyStack.push(this.getEntityDisplayName(tempNode));
                                                                tempNode = tempNode.parentEntity;
                                                        } while (tempNode.parentEntity);
                                                        var parentDict, key;
                                                        for (var i = keyStack.length - 1; i >= 0; i--) { 
                                                                parentDict = delDict;
                                                                key = keyStack.pop();
                                                                var tempDict = delDict[key];
                                                                if (!tempDict) {
                                                                        delDict[key] = {};
                                                                        tempDict = delDict[key];
                                                                }
                                                                delDict = tempDict;
                                                        }
                                                        this.deleteNode(delNode, delDict, parentDict, key);
                                                        this.hideInfoBox();
                                                        this.refreshWidget();
                                                        
                                                        var deleteTreeId = this.id + "-deleteTree";
                                                        var object = mstrmojo.all[deleteTreeId];
                                                        if (object) {
                                                                object.needRefresh = true;
                                                        }
                                                }
                                                this.previousTooltip = null;
                                                break;
										}

										case this.selectionHighlightBox: {
												this.doSelection(this.previousSelected);
												break;
										}

                                        case this.highlightBox: {
                                                this.hideInfoBox();
                                                var entity = this.previousHighlighted;
                                                if(this.hasSelector){
                                                        if(!this.previousHighlighted.entityChildren){
                                                                this.doSelection(entity);
                                                                
                                                        }
                                                }
                                                else if(this.hasLinkDrill){
                                                        this.doLinkDrill(entity);
                                                }
                                                break;
                                        }



										default:{
												
                                                if(this.isRectangle(target)){
                                                        if(this.hasSelector){
                                                                this.hideInfoBox();
                                                                var entity = this.getEntityByTouch(touch,true);
                                                                
                                                                this.doSelection(entity);
                                                                
                                                        }
                                                        else if(this.hasLinkDrill){
                                                                var entity = this.getEntityByTouch(touch);
                                                                this.doLinkDrill(entity);
                                                        }
                                                        else {
                                                                var entity = this.getEntityByTouch(touch);
                                                                this.showInfoBox(entity);
                                                                
                                                        }

														break;
												}
                                                
												else if(target.parentNode == this.infoBox){
                                                        this.hideInfoBox();
                                                }else{
														this.hideInfoBox();
                                                        if(!this.selectAll){
                                                                this.doSelection(this.previousSelected);
                                                        }
												}
										}
								}
						},

						isRectangle: function(target){
							if(this.canvasObject.domNode == target.parentNode || (target.parentNode && this.canvasObject.domNode == target.parentNode.parentNode) || target.tagName.toLowerCase() == 'img')
								return true;
							else
								return false;
						},
						isLowestLevelRectangle: function(target){
							if(target.getAttribute && target.getAttribute("idx") && !(target.innerHTML))
								return true;
							else
								return false;
						},

						doLinkDrill: function(entity){
								if(!entity)
									return;
								var actionObj = this.getActionObj({entity: entity, type:HYPERLINK_ACTION});
								if(actionObj){
										this.highlightEntity(this.selectionHighlightBox,entity);
										this.performAction([actionObj]);
								}
						},


						

						getActionObj: function(actionInfo) {
							if(!actionInfo)
								return null;
							var actionType = actionInfo.type,
								entity = actionInfo.entity,
								actionObj = null;

							switch(actionType){
									case HYPERLINK_ACTION: {
                                            
                                            var rowHeader = this.model.gts.row,
                                                rl = rowHeader.length,
                                                level = entity['level'],
                                                attrIndex;
                                            for(var i = 0; i <= level; i++){
                                                    var attr = rowHeader[i];
                                                    if(attr.lm){
                                                            for(var j = 0; j < attr.lm.length; j++)
                                                                if(attr.lm[j].links)break;
                                                            if(j != attr.lm.length){
                                                                    attrIndex = i;
                                                                    break;
                                                            }
                                                    }
                                            }
                                            var rowIndex = (entity.index === undefined) ? entity.indices[0] : entity.index,
                                                ghs = this.model.ghs;

											if(!isNaN(attrIndex)){
                                                    var attr = this.model.gts.row[attrIndex];
                                                        linkDrillNode = {};
                                                    linkDrillNode.titleInfo = attr;
                                                    linkDrillNode._e = attr.es[ghs.rhs.items[rowIndex].items[attrIndex].idx];
                                                    actionObj = {at:actionType, k: this.getModelKey(), node: linkDrillNode};
                                                    break;
                                            }

											
											index = this.firstColLinkDrillIndex;
											if(!isNaN(index)){
													var metricH = this.model.gts.col[0],
														metric = metricH.es[index],
														lm = metricH.lm[index];
													if(lm && lm.links){
														linkDrillNode = {};
														linkDrillNode.titleInfo = metricH;
														linkDrillNode.mix = index;
														actionObj = {at: actionType, k: this.getModelKey(), node: linkDrillNode};
													}
                                                    break;
											}

											break;
									}

							case SELECTOR_ACTION: {
                                    var entity = actionInfo.entity,
                                        anchor = actionInfo.anchor;
									if(!entity || !anchor){
											
											break;
									}

									if(entity){
											var m = this.model,
											rown = m.gts.row, 
											rl = rown.length,
											rhs = m.ghs.rhs.items,
											index = (entity.index === undefined) ? entity.indices[0] : entity.index,
											row = rhs[index].items,
											selectorObjects = [];
											for(var i = 0; i < rl; i++){
													var att = rown[i],
													sc = att.sc;
													if(att.otp != -1 && sc !== undefined){
															var ix = row[i].idx,
															elementId = att.es[ix].id,
															
															
															es = att.es[ix].n,
															eid;
															if (!elementId || elementId.substring(0, 1) === "D") {
																	
																	continue;
															};
															if(sc.all != 'false' && sc.all != false && actionInfo.needSelectAll)
																eid = EID_SELECTALL;
															else
																eid = att.es[ix].id;
															selectorObjects.push({ 
																	
																	
																	
																	sc: sc,
																	es: es,
																	eid: eid
															});
													}
                                            }
                                            actionObj = {at:actionType, k:this.getModelKey(), scObjList: selectorObjects,anchor:anchor};
									}


									break;
							}
                            
							case INFOWINDOW_ACTION: {
									var entity = actionInfo.entity,
									anchor = actionInfo.anchor;
									if(!entity || !anchor){

											break;
									}

									if(entity){
											var m = this.model,
											rown = m.gts.row, 
											rl = rown.length,
											rhs = m.ghs.rhs.items,
											index = (entity.index === undefined) ? entity.indices[0] : entity.index,
											row = rhs[index].items,
											selectorObjects = [];
											for(var i = 0; i < rl; i++){
													var att = rown[i],
													sc = att.sc;
													if(att.otp != -1 && sc !== undefined){
															var ix = row[i].idx,
															elementId = att.es[ix].id,
															
															
															es = att.es[ix].n,
															eid;
															if (!elementId || elementId.substring(0, 1) === "D") {
																	
																	continue;
															};
															if(sc.all != 'false' && sc.all != false && actionInfo.needSelectAll)
																eid = EID_SELECTALL;
															else
																eid = att.es[ix].id;
															selectorObjects.push({ 
																	
																	
																	
																	sc: sc,
																	es: es,
																	eid: eid
															});
													}
											}
													actionObj = {at:actionType, k:this.getModelKey(), scObjList: selectorObjects, anchor: anchor};
									}


									break;
							}
									default: {

											break;
									}

							}
							return actionObj;
						},
						getModelKey: function(){
							return this.model && this.model.k;
						},

						deleteNode: function (node, delDict, parentDict, key) { 
                            
                            if(!(node.size && node.size.w && node.size.h)){
                                return ;
                            }
							if (!node.entityChildren) { 
								node.deleted = true;
								if (parentDict && key) {
									if (delDict === delStatus.dftUnDel || delDict === delStatus.dftDel) { 
										parentDict[key] = delStatus.dftDel;
									} else { 
										parentDict[key] = delStatus.usrDel;
									}
								}
								return;
							} else {
								parentDict = delDict;
								for (var index in node.entityChildren) {
									var thisChild = node.entityChildren[index];
									key = this.getEntityDisplayName(thisChild);
									var thisDict = parentDict[key];
									if (!thisDict) {
										parentDict[key] = {};
										thisDict = parentDict[key];
									}
									this.deleteNode(thisChild, thisDict, parentDict, key);
								}
							}
						},

                        
						toggleSelectAll: function(entity){
                                var sc = this.model.gts.row[entity.level].sc;
                                if((sc && sc.all != 'false' && sc.all != false) || !this.hasGridTarget){
                                        if(this.selectAll)
                                                this.selectAll = false;
                                        else
                                                this.selectAll = true;
                                        return true;
                                }
                                return false;
						},
						doSelection: function(entity){
							if(!entity)
								return ;
							if(entity == this.previousSelected){
                                
                                if(!this.toggleSelectAll(entity))
                                        return;

                                
								var anchor = this.selectionHighlightBox,
                                    actionInfo = {entity: entity, type:SELECTOR_ACTION, needSelectAll:this.selectAll, anchor:anchor};
							        actionObject = this.getActionObj(actionInfo);
								if(this.selectAll){
									
									this.selectionHighlightBox.style.display = "none";
                                    delete actionObject.anchor;
                                }
								else
									this.highlightEntity(this.selectionHighlightBox,entity)
								this.performAction([actionObject]);
								
							}
							else{
								this.selectAll = false;
								var anchor = this.selectionHighlightBox,
                                    actionInfo = {entity: entity, type:SELECTOR_ACTION, needSelectAll:this.selectAll, anchor:anchor};
								this.previousSelected = entity;
								this.highlightEntity(this.selectionHighlightBox,entity);
							    var actionObject = this.getActionObj(actionInfo);
								this.performAction([actionObject]);
								
							}
						},

						getObjectByIdx: function (idx) {
							if (idx) {
								var indexArray = idx.split(":");
								var obj = this.root;
								for (var i = 0; i < indexArray.length; i++) {
									obj = obj.entityChildren[indexArray[i]];
								}
								return obj;
							}
							return null;
						},


						toggleDeleteButton: function () {
                            if(!this.infoBox)
                                    return;
							
								
								
							
								
								

							if (this.props.delButtonEnabled) {
								this.deleteButton.style.display = "none";
                                this.props.delButtonEnabled = false;
							} else {
								this.deleteButton.style.display = "block";
                                this.props.delButtonEnabled = true;
							}
						},


						editorDialog: null,  


						popupEditor: function (anchor) {
                                this.hideInfoBox();
                                var heatmapId = this.id;
                                var deleteTreeId = heatmapId + "-deleteTree";
                                var editorId = heatmapId + "-editor";
								var that = this;

								var defaultSelectionStatus = 0;
								if (this.props.delButtonEnabled) {
									defaultSelectionStatus = 1;
								}
                                var strSettings = mstrmojo.desc(7831, 'Settings'),
                                    strDeletedItems = mstrmojo.desc(10081, 'Deleted Items'),
                                    strRefresh = mstrmojo.desc(10378, 'REFRESH'),
                                    strRTSC = mstrmojo.desc(10082, 'Refresh to saved configuration'),
                                    strRTDC = mstrmojo.desc(10083, 'Refresh to default configuration'),
                                    strApply = mstrmojo.desc(10379, 'APPLY'),
                                    strDelete = mstrmojo.desc(10380, 'DELETE'),
                                    strEnableDelete = mstrmojo.desc(10085, 'Enable Delete'),
                                    strRestore = mstrmojo.desc(10084, 'Please select elements that you want to restore'),
                                    strButtonCancel = mstrmojo.desc(221, 'Cancel'),
                                    strButtonApply = mstrmojo.desc(134, 'Apply');


								var prop = {
									anchor: this.editorButton,
									title: "Heat Map",
									id: editorId,
									anchorOrientation: "h",
									width: this.LayoutProperties.EditorDialogWidth + 'px',
                                    
								    contentMaxHeight: this.LayoutProperties.DeletedListHeight,
									panels: [{
										
                                        title: strSettings,
										scriptClass: "mstrmojo.VisHeatMapPopupPanel",
                                        width: "100%",
									    height: "100%",
										children:[
										       {
										    	   scriptClass: 'mstrmojo.Label',
											       
                                                   text: strRefresh,
                                                   cssDisplay: "-webkit-box",
                                                   cssClass: "heatmap-gray-label"
                                                   
										       },
										       {
										    	   scriptClass: 'mstrmojo.VisHeatMapTree',
                                                   showIndicators: false,
										    	   isSelectable: false,
										    	   cssClass: "simple-tree",
										    	   cssText: "padding-left:15px;padding-right:15px;",
										    	   buttonNodeCss: "",
										    	   items: [
										    	           {
										    	        	   
                                                               n: strRTSC,
										    	        	   buttonNodeWidget: {
										    	        		   scriptClass: 'mstrmojo.Button',
																   
                                                                   text: strApply,
																   cssClass: "heatmap-apply-button",
										    	        		   onclick: function () {
                                                                       that.isUsingSavedColorTheme = true;
                                                                       that.isUsingDefaultColorTheme = false;
															    	   var node = this.domNode;
															    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
															    	   that.hideInfoBox();
															    	   that.hideLegendTooltip();

															    	   
															    	   
															    	   that._scroller.offset.x.start = 0;
															    	   that._scroller.offset.x.end = 0;
															    	   that._scroller.offset.y.start = 0;
															    	   that._scroller.offset.y.end = 0;
															    	   that._scroller.scrollTo(0, 0, 0);

															    	   var callback = function () {
															    		   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
															    	   };
															    	   setTimeout(function () {
														    		   		setTimeout(function () {
														    		   			that.useSavedColorTheme(callback);
														    		   			var object = mstrmojo.all[deleteTreeId];
																		    	if (object) {
																		    		object.needRefresh = true;
																		    	}
														    		   		}, 0);
														    		   },0); 
										    	        		   }
										    	        	   }
										    	           },
										    	           {
										    	        	   
                                                               n: strRTDC,
										    	        	   buttonNodeWidget: {
										    	        		   scriptClass: 'mstrmojo.Button',
																   
                                                                   text: strApply,
																   cssClass: "heatmap-apply-button",
										    	        		   onclick: function () {
                                                                       that.isUsingSavedColorTheme = false;
                                                                       that.isUsingDefaultColorTheme = true;
															    	   var node = this.domNode;
															    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
															    	   that.hideInfoBox();
															    	   that.hideLegendTooltip();

															    	   
															    	   
															    	   that._scroller.offset.x.start = 0;
															    	   that._scroller.offset.x.end = 0;
															    	   that._scroller.offset.y.start = 0;
															    	   that._scroller.offset.y.end = 0;
															    	   that._scroller.scrollTo(0, 0, 0);

															    	   var callback = function () {
															    		   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
															    	   };
															    	   setTimeout(function () {
														    		   		setTimeout(function () {
														    		   			that.useDefaultColorTheme(callback);
														    		   			var object = mstrmojo.all[deleteTreeId];
																		    	if (object) {
																		    		object.needRefresh = true;
																		    	}
														    		   		}, 0);
														    		   }, 0); 

															       }
										    	        	   }
										    	           }
										    	   ]
										       },
										       {
										    	   scriptClass: 'mstrmojo.Label',
											       
                                                   text: strDelete,
                                                   cssDisplay: "-webkit-box",
                                                   cssClass: "heatmap-gray-label"
                                                   
										       },
										       {
										    	   scriptClass: 'mstrmojo.VisHeatMapTree',
										    	   isSelectable: true,
										    	   cssClass: "simple-tree",
										    	   cssText: "margin-left:15px;margin-right:15px;",
                                                   showIndicators: false,
										    	   defaultSelectionStatus: defaultSelectionStatus,
										    	   items: [
										    	           {
										    	        	   
                                                               n: strEnableDelete,
										    	        	   itemFunction: function () {
																		that.toggleDeleteButton();
															   }
										    	           }
										    	   ]
										       },
										]
									}, {
										
                                        title: strDeletedItems,
										scriptClass: "mstrmojo.VisHeatMapPopupPanel",
                                        cssText: "position: relative",
										
										
                                        
                                        
                                        width: "100%",
                                        
										naviAction: function () {
											var object = mstrmojo.all[deleteTreeId];
									    	if (object) {
									    		object.refresh();
									    	}
										},
										children:[
										       {
										    	   scriptClass: "mstrmojo.Box",
										    	   cssText: "padding-left:16px;padding-right:16px; maxHeight:" + parseInt(this.LayoutProperties.DeletedListHeight * 0.89) + 'px',
										    	   children: [
															{
																scriptClass: "mstrmojo.VisHeatMapTree",
																height: "100%",
																heightLimit: parseInt(this.LayoutProperties.DeletedListHeight * 0.89),
                                                                showIndicators: true,
                                                                showScrollbars: true,
																id: deleteTreeId,
																itemDisplayField: "label",
																itemChildrenField: "entityChildren",
																draggable:  true,
																showRoot: true,
																
                                                                rootText: strRestore,
																itemIncludeFunction: function (item) {
																	if (item && (item.deleted || item.hasChildDeleted)) {
																		return true;
																	} else {
																		return false;
																	}
																},

													            apply: function (callback) {
													            	var itemFunction = function () {
																		if (this.selectionStatus === 1 && this.dataProvider && this.dataProvider.deleted) {
																			this.dataProvider.deleted = false;
																			
																			var tempNode = this.dataProvider;
																			if (!tempNode.entityChildren) {
																				var keyStack = [];
																				while (tempNode.parentEntity) {
																					keyStack.push(that.getEntityDisplayName(tempNode));
																					tempNode = tempNode.parentEntity;
																				}
																				var delDict = that.props.deletedList;
																				while (keyStack.length > 1) {
																					delDict = delDict[keyStack.pop()];
																				}
																				var key = keyStack.pop(); 
																				if (delDict[key] === delStatus.dftDel) {
																					delDict[key] = delStatus.dftUnDel;
																				} else {
																					delete delDict[key];
																				}
																			}
																		}
																	};
													            	var iterator = function (item, itemFunction) {
													            		itemFunction.apply(item);
													            		if (!item.childTree) {
													            			return;
													            		}
													            		for (var i = 0; i < item.childTree.length; i++) {
													            			var subItem = item.childTree[i];
													            			iterator(subItem, itemFunction);
													            		}
													            	};
													            	iterator(this, itemFunction);
													            	that.refreshWidget();
                                                                    var tree = this;
                                                                    window.setTimeout(function(){
                                                                                    
                                                                                    tree.needRefresh = true;
                                                                                    tree.refresh();

                                                                                    if (callback) {
                                                                                        callback();
                                                                                    }
                                                                    },50);
													            },

																dataProvider: that.root,

																owner: that
													    	}

										    	   ]
										       },{
										    		scriptClass: "mstrmojo.Box",
										    		cssText: "background-color:whiteSmoke; position:relative; bottom:0px;font:12pt Roboto,Regular;text-align:center;vertical-align:middle;line-height:55px;border-top: 1px solid rgba(34, 34, 34, 0.18);",
										    		height: parseInt(this.LayoutProperties.DeletedListHeight * 0.11) + 'px',
                                                    
										    		width: "100%",
										    		children: [
										    		           {
											    	        		   scriptClass: 'mstrmojo.Button',
																       
                                                                       text: strButtonCancel,
																       cssClass: "heatmap-tree-button",
																       cssDisplay: "inline-block",
																       cssText: "border-right: 1px solid rgba(34, 34, 34, 0.18); position: absolute; left:0px; top: 0px; height:100%;",
																       width: "49.5%",
																       onclick: function () {
																    	   var node = this.domNode;
																    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
																    	   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
																    	   setTimeout(function() { 
																    		   mstrmojo.all[editorId].close();
																    		   }, 100);
																       }
										    		           },
										    		           {
										    	        		   scriptClass: 'mstrmojo.Button',
															       
                                                                   text: strButtonApply,
															       cssClass: "heatmap-tree-button",
															       cssDisplay: "inline-block",
															       cssText: "position: absolute; right:0px; top:0px; height: 100%",
															       width: "50.5%",
															       postBuildRendering: function () {
															    	   mstrmojo.all[deleteTreeId].register(this);
															       },
															       notify: function (enabled) {
															    	   this.set("enabled", enabled);
															    	   
															       },
															       onclick: function () {
															    	   var node = this.domNode;
															    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
															    	   that.hideInfoBox();
															    	   var callback = function () {
															    		   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
															    	   };
															    	   setTimeout(function () {
															    		   setTimeout(function () {
															    			   mstrmojo.all[deleteTreeId].apply(callback);
															    		   }, 0);
															    	   }, 0); 
															    	   
															       }
										    		           }
										    		]
										    	}
										]
									}]
								};
								this.editorDialog = mstrApp.showDialog(prop,'HeatMapEditor'); 
						},

						showWaitIcon: function (delay){
							

                                var w = this.waitIcon;
                                w.style.display = '-webkit-box';
                                w.style.left = '0px';
                                w.style.top = '0px';
                        },
						hideWaitIcon: function (){
							
                                var w = this.waitIcon;
                                w.style.left = '-100000px';
                                w.style.top = '-100000px';

						},

						clearChildren: function(node) {
							var firstChild;
							if(!node)
								return;
							while(firstChild = node.firstChild)
								node.removeChild(firstChild);
						},

                        calculateValuesInTree: function() {
							var ml = this.model.gvs.items[0] ? this.model.gvs.items[0].items.length:0;
							clearMaxMinValues.call(this);
							setShow(false, false, true, true, this.root, this, ml+1);
                        },

						refreshWidget: function () {
							

                            this.showWaitIcon();
                            var that = this;
                            var refresh = function(){
                                    that.calculateValuesInTree();
                                    getLegendMaxMin.call(that);

                                    layoutEntities.call(that)
                                    that.renderRectangles()

                                    that.renderLegend()

                                    var ps = that.previousSelected;
                                    if(ps){
                                            if(ps.deleted){
                                                    that.selectionHighlightBox.style.display = 'none';
                                            }else if(!that.selectAll){
                                                    that.highlightEntity(that.selectionHighlightBox, that.previousSelected);
                                            }
                                    }
                                    that.hideWaitIcon();
                            };
                            
                            window.setTimeout(refresh,10);
                            
                                

                        },


						hideInfoBox: function () {
							
							
							
							
							
							
                            if(!this.infoBox)
                                    return;
                            this.infoBox.style.zIndex = "-50";
                            this.infoBox.style.opacity = 0;
                            
                                    
                                    
                            
                            
                            
							
							
									
							
									
							
									
							
							

							
							
							
							this.previousTooltip = null;
						},

						getIdxObjectByTarget: function (target) {
							var ancestor = mstrmojo.dom.findAncestorByAttr(target, "idx", true, this.domNode);
							var idx = ancestor && ancestor.value;
							if (!idx) {
								return null;
							}
							var idxObject = this.getObjectByIdx(idx);
							return idxObject;
						},

						showInfoBox: function (entity) {
                                
                            if(!entity)
                                    return;
                            if(!this.infoBox)
                                    this.createInfoBox();

							var idxObject = entity;

							if (idxObject === this.previousTooltip) {
								
								return;
							}
							this.previousTooltip = idxObject;
                            if(this.infoBox.style.display != "block")
                                    this.infoBox.style.display = "block";
                            this.infoBox.style.zIndex = "75";
                            this.infoBox.style.opacity = 1;
							
							
							
							

							var	hBoxWidth = this.highlightBoxWidth,
								
								
                                domRect = mstrmojo.dom.position(document.body, true),
                                
								interRect = this.highlightEntity(this.highlightBox, idxObject);

							if (!interRect || isNaN(interRect.x)) {
								return;
							}

							
							this.deleteButton.style.left = interRect.x + "px";
							this.deleteButton.style.top = interRect.y + "px";

							
							this.tooltipBox.style.width = "";
							this.tooltipBox.innerHTML = getTooltip(idxObject, this);





							
							var anchorBox = {
								x: interRect.x - hBoxWidth,
								y: interRect.y - hBoxWidth,
								w: interRect.w + hBoxWidth * 2,
								h: interRect.h + hBoxWidth * 2
							}; 
							
							this.triBox.style.display = "block";
							var anchorCenterX = anchorBox.x + (anchorBox.w>>1);
							var anchorCenterY = anchorBox.y + (anchorBox.h>>1);
							var triSize = this.triBox.offsetWidth * 0.717;


                            
                            var cNodes = this.tooltipBox.childNodes,
                                len = cNodes.length;
                            for(var i = 0; i < len; i++){
                                    var cInline = cNodes[i].childNodes;
                                    if(cInline[0].offsetWidth + cInline[1].offsetWidth + cInline[2].offsetWidth > cNodes[i].offsetWidth)
                                            cInline[0].className += ' heatmap-half-width';
                            }


							var tHeight = this.tooltipBox.offsetHeight;
							var tWidth = this.tooltipBox.offsetWidth;





							
							var matched = false;

							
							var xFit = ((anchorCenterX - (tWidth>>1)) > 0) && (anchorCenterX + (tWidth>>1)) < (domRect.w);
							var yFit = ((anchorCenterY - (tHeight>>1)) > 0) && (anchorCenterY + (tHeight>>1)) < (domRect.h);

							
							var canShiftPadding = 10; 
							function calcPosition (triBox, tooltipBox, deleteButton,  canShift) {
								if (canShift === undefined) {
									canShift = false; 
								}
								if (!matched && (canShift || yFit)) { 
									if (anchorBox.x - triSize - tWidth >= 0) { 
										matched = true;
										triBox.style.left = anchorBox.x - triSize + "px";
										tooltipBox.style.left = anchorBox.x - triSize - tWidth + "px";

										
										deleteButton.style.left = interRect.x + interRect.w + "px";
									} else if (anchorBox.x + anchorBox.w + triSize + tWidth <= domRect.w) { 
										matched = true;
										triBox.style.left = anchorBox.x + anchorBox.w + triSize + "px";
										tooltipBox.style.left = anchorBox.x + anchorBox.w + triSize + "px";
									}
									if (matched) { 
										var triTop = anchorCenterY;
										var tooltipTop = anchorCenterY - tHeight / 2;
										if (canShift) {
											if (tHeight + canShiftPadding * 2 > domRect.h) {
												matched = false; 
											} else {
												var upLimit = canShiftPadding;
												var downLimit = domRect.h - canShiftPadding - tHeight;
												if (tooltipTop < upLimit) { 
													tooltipTop = upLimit;
												} else if (tooltipTop > downLimit) { 
													tooltipTop = downLimit;
												}
											}
										}
										triBox.style.top = triTop + "px";
										tooltipBox.style.top = tooltipTop + "px";
									}
								}

								if (!matched && (canShift || xFit)) { 
									if (anchorBox.y - triSize - tHeight >= 0) { 
										matched = true;
										triBox.style.top = anchorBox.y - triSize + "px";
										tooltipBox.style.top = anchorBox.y - triSize - tHeight + "px";

										
										deleteButton.style.top = interRect.y + interRect.h + "px";
									} else if (anchorBox.y + anchorBox.h + triSize + tHeight <= domRect.h) { 
										matched = true;
										triBox.style.top = anchorBox.y + anchorBox.h + triSize + "px";
										tooltipBox.style.top = anchorBox.y + anchorBox.h + triSize + "px";
									}
									if (matched) { 
										var triLeft = anchorCenterX;
										var tooltipLeft = anchorCenterX - tWidth / 2;
										if (canShift) {
											if (tWidth + canShiftPadding * 2 > domRect.w) {
												matched = false; 
											} else {
												var leftLimit = canShiftPadding;
												var rightLimit = domRect.w - canShiftPadding - tWidth;
												if (tooltipLeft < leftLimit) { 
													tooltipLeft = leftLimit;
												} else if (tooltipLeft > rightLimit) { 
													tooltipLeft = rightLimit;
												}
											}
										}
										triBox.style.left = triLeft + "px";
										tooltipBox.style.left = tooltipLeft + "px";
									}
								}
							};

							
							
							calcPosition (this.triBox, this.tooltipBox, this.deleteButton, false);
							
							this.infoBox.style.display = 'block';
							if (!matched) { 
								anchorBox = {
										x: anchorCenterX,
										y: anchorCenterY,
										w: 0,
										h: 0
								};
								this.triBox.style.display = "none";
								triSize = 0;
								calcPosition (this.triBox, this.tooltipBox, this.deleteButton, true);
							}
							if (!matched) { 
								this.triBox.style.display = "none";
								this.tooltipBox.style.left = anchorCenterX - tWidth / 2 + "px";
								this.tooltipBox.style.top = anchorCenterY - tHeight / 2 + "px";
							}
							
							this.shadowBox.style.left = this.tooltipBox.style.left;
							this.shadowBox.style.top = this.tooltipBox.style.top;
							this.shadowBox.style.width = this.tooltipBox.offsetWidth + "px";
							this.shadowBox.style.height = this.tooltipBox.offsetHeight + "px";
							this.shelter.style.left = this.tooltipBox.style.left;
							this.shelter.style.top = this.tooltipBox.style.top;
							this.shelter.style.width = this.tooltipBox.offsetWidth + "px";
							this.shelter.style.height = this.tooltipBox.offsetHeight + "px";

                            
                            var span = this.tooltipBox.childNodes[0].childNodes[0];
                            var style = window.getComputedStyle(span,null);

                            

						},


						enableGlobalDismiss: function(){
								var touchManager = mstrmojo.touchManager;
								var heatMap = this;
								this._globalTouchListener = touchManager.attachEventListener("touchesBegin",
										this.id,
										function(evt){
                                                if(!evt || !evt.touch || !evt.touch.target)
                                                        return;
                                            var target = evt.touch.target,
                                                backgroundDiv1 = document.getElementsByClassName('mstrmojo-DocLayoutViewer-layout')[0],
                                                backgroundDiv2 = document.getElementsByClassName('mstrmojo-DocSubsection')[0];

                                            
											if(heatMap.infoBoxPuppet != target && !mstrmojo.dom.contains(heatMap.infoBox, target, true)){
                                                    heatMap.hideInfoBox();
                                            }
                                            
                                            if(target != backgroundDiv1 && target != backgroundDiv2)
                                                    return ;
                                            if(!this.selectAll)
                                                heatMap.doSelection(heatMap.previousSelected);
											
										}
								);
						},

						disableGlobalDismiss: function(){
								var touchManager = mstrmojo.touchManager;
								if(this._globalTouchListener){
										touchManager.detachEventListener(this._globalTouchListener);
										delete this._globalTouchListener;
								}
						},


						touchInfoBoxValid: function(touch) {
								var taget = touch.target;
								if(target.id == this.id+"-infobox") return true;
						},

						touchLegendTooltipValid: function touchValid(touch){
							var target = touch.target;
							if(target.id != this.id+'-color-legend-band') return false;
							var	frame = mstrmojo.dom.position(target, true),
								x = touch.clientX-frame.x,
								y = touch.clientY-frame.y,
								p = this.legendBand;
							if(x < p.x || x >= p.x + p.w - 1) {
								return false;
							}
							return true;
						},

						showLegendTooltip: function (touch) {
							var target = touch.target,
								frame = mstrmojo.dom.position(target, true),
								x = touch.clientX-frame.x,
								y = touch.clientY-frame.y,
								p = this.legendBand,
								idx;
							var ct = this.colorTheme;
							if(ct.tooltipInfo === undefined || ct.tooltipInfo === null){
								ct.createTooltipInfo(this.legendTickCount, p.w, this);
								this.selectedBandIndex = -1;
							}
							var i = ct.getTooltipInfo(x-p.x);
							if(i != this.selectedBandIndex){
								this.renderHilightedBand(i);
							}
							
							var t = this.colorTheme.tooltipInfo[i],
								cfs = this.getFormatString(this.colorMetricIndex),
								mn = this.getMetricName(this.colorMetricIndex),
								sign = (t.sign === undefined) ? " < " : " > ",
								str = "<div>" + this.nf.formatByMask(cfs, t.sv)
									  + sign + "</div>"
                                      + "<div class='heatmap-flex'>" + mn + "</div>"
                                      +"<div>" + sign
									  + this.nf.formatByMask(cfs, t.ev) + "</div>";
							
							
							this.legendTooltip.innerHTML = str;
							this.legendTooltip.style.borderColor = getCSSColor(t.c);
							
							
							this.legendTooltip.style.lineHeight = this.legendTooltip.style.height;
							this.legendTooltip.style.display = "-webkit-box";
                            var size = {w: this.legendTooltip.offsetWidth, h: this.legendTooltip.offsetHeight};
							var lc = mstrmojo.dom.position(this.colorLegend, true),
								cv = mstrmojo.dom.position(this.canvas, true), 
								tx = t.r.x+((t.r.w-size.w)>>1);
							if(tx < 0){
								tx = 0;
							}else if(tx > frame.w - size.w){
								tx = frame.w - size.w;
							}
							this.legendTooltip.style.left = tx + 'px';
							this.legendTooltip.style.top = -35 + 'px';
						},

						hideLegendTooltip: function () {
							if (this.selectedBandIndex === undefined || this.selectedBandIndex == -1) return;
							this.renderGradientBand(this.legendBand);
							this.selectedBandIndex = -1;
                            this.legendTooltip.style.left = '-100000px';
							
						},


						touchSelectBegin: function (touch) {
							if (touch.evt.ctrlKey) { 
								this.touchMultiBegin(touch);
								return;
							}
							var target = touch.target;
							if(!target) return;
                            this.lastTouchSelectTarget = target;
							if(this.touchLegendTooltipValid(touch)){
								this.showLegendTooltip(touch);
								this.hideInfoBox();
							}else{
								this.hideLegendTooltip();
								
                                var entity;
                                if(this.infoWindowMode){
                                        entity = this.getEntityByTouch(touch,true);
                                }else{
                                        entity = this.getEntityByTouch(touch);
                                }
								if(!entity)
									return;
								if (this.timer) {
									cleatTimeout(this.timer);
									this.timer = null;
								}
                                if(this.infoWindowMode){
                                        this.doSelection(entity);
                                }else{
                                        this.showInfoBox(entity);
                                        
                                }
							}
						},

						touchSelectMove: function (touch) {
							if (touch.evt.ctrlKey) {
								this.touchMultiMove(touch);
								return;
							}
							var target = touch.target;
							if(!target) return;
                            
                                    
							if(this.touchLegendTooltipValid(touch)){
								this.showLegendTooltip(touch);
								this.hideInfoBox();
							}else{
								this.hideLegendTooltip();
								
                                var entity;
                                if(this.infoWindowMode){
                                        entity = this.getEntityByTouch(touch,true);
                                }
                                else{
                                        entity = this.getEntityByTouch(touch);
                                }
								if(!entity)
									return;
								var that = this;
								if (this.timer) {
									clearTimeout(this.timer);
									this.timer = null;
								}
								
                                if(this.infoWindowMode){
                                        if(this.previousSelected != entity){
                                                this.doSelection(entity);
                                        }
                                }else{
                                        this.showInfoBox(entity);
                                        
                                }
							}
						},


						touchSelectEnd: function (touch) {
							if (touch.evt.ctrlKey) {
								this.touchMultiEnd(touch);
							}
							return;
						},


						initScroller: function (scroller) {
							scroller.attachEventListener('scrollMoved', this.id, function (evt) {
								this.hideInfoBox();
							});
                            scroller.attachEventListener('scrollDone', this.id, function (evt) {
                                    this.canvasObject.updateOffsets(scroller.origin.x, scroller.origin.y);
                            });
                        },


						multiTouch: true,

						touchMultiBegin: function (touch) {
							
							
							this.hideLegendTooltip();
							this.hideInfoBox();
                            
                            

							var touch1;
							var touch2;
							if (touch.evt.touches && touch.evt.touches.length == 2) {
								touch1 = touch.evt.touches[0];
								touch2 = touch.evt.touches[1];
							} else {
								touch1 = touch;
								touch2 = {pageX: 300, pageY:300};
							}
							var xDiff = touch1.pageX - touch2.pageX;
							var yDiff = touch1.pageY - touch2.pageY;
							this.initDiffDiff = xDiff * xDiff + yDiff * yDiff;
							this.initCenterX = ((touch1.pageX + touch2.pageX)>>1);
							this.initCenterY = ((touch1.pageY + touch2.pageY)>>1);
							this.initScrollX = this._scroller.origin.x;
							this.initScrollY = this._scroller.origin.y;

							this.relScaleFactor = 1;

							
							
						},

						touchMultiMove: function (touch) {
							
							var touch1;
							var touch2;
							if (touch.evt.touches && touch.evt.touches.length == 2) {
								touch1 = touch.evt.touches[0];
								touch2 = touch.evt.touches[1];
							} else {
								touch1 = touch;
								touch2 = {pageX: 300, pageY: 300};
							}
							var xDiff = touch1.pageX - touch2.pageX;
							var yDiff = touch1.pageY - touch2.pageY;
							var curDiffDiff = xDiff * xDiff + yDiff * yDiff;

							var curCenterX = ((touch1.pageX + touch2.pageX)>>1);
							var curCenterY = ((touch1.pageY + touch2.pageY)>>1);

							var scale = Math.sqrt(curDiffDiff / this.initDiffDiff);


							var offset = { 
								x: scale * (this.initCenterX + this.initScrollX) - curCenterX,
								y: scale * (this.initCenterY + this.initScrollY) - curCenterY
							};
							var transform = {scale: scale, offset: offset};

							this.relScaleFactor = scale;
                            if(this.relScaleFactor * this.scaleFactor >= this.maxScale && !this.oldTransform){
                                    this.oldTransform = transform;
                            }
							
							this.applyTransform(transform);
						},

						touchMultiEnd: function (touch) {
                                var finalScale = this.relScaleFactor * this.scaleFactor;
							if (finalScale < 1) {
								
                                var initTransform = {offset:{x:0,y:0}, scale: 1 / this.scaleFactor};
								this.relScaleFactor = initTransform.scale;
								this.applyTransform(initTransform, 500, this.postScale);
                            } else if(finalScale > this.maxScale){
                                    this.relScaleFactor = this.maxScale / this.scaleFactor;
                                    this.applyTransform(this.oldTransform, 500, this.postScale);
                                    delete this.oldTransform;
                            }else{
								this.postScale();
							}
						},

						relScaleFactor: 1,

						scaleFactor: 1,

                        applyTransform: function (transform, duration, callback) {
                                var scl = this._scroller;

                                if (duration === undefined) {
                                        duration = 0;
                                }
                                scl.scrollEl.style["webkitTransformOrigin"] = "left top";

                                scl.transform = "scale(" + transform.scale + "," + transform.scale + ")";
                                var scrollX = transform.offset.x,
                                    scrollY = transform.offset.y,
                                    scrollerOffsetScale = this.scaleFactor * this.relScaleFactor - 1,
                                    vOffsetEnd = this.heatMapSize.h * scrollerOffsetScale,
                                    hOffsetEnd = this.heatMapSize.w * scrollerOffsetScale;
                                scl.offset = {
                                        y: {
                                                start: 0,
                                                end: vOffsetEnd
                                        },
                                        x: {
                                                start: 0,
                                                end: hOffsetEnd
                                        }
                                };
                                this._scroller.scrollTo(scrollX, scrollY, duration);
                                if (callback) {
                                        var that = this;
                                        setTimeout(function () {callback.apply(that); that = null;}, duration);
                                }


                        },


						postScale: function () {
							delete this._scroller.transform;
							this._scroller.scrollTo(this._scroller.origin.x, this._scroller.origin.y, 0);
							this.scaleFactor *= this.relScaleFactor;
                            
                            if(this.scaleFactor > this.maxScale)
                                    this.scaleFactor = this.maxScale;
							this.refreshWidget();
						},


						destroy: function (skipCleanup) {
							this._super(skipCleanup);
							if (this.editorDialog) {
								
								this.editorDialog.destroy();
                                delete this.editorDialog;
							}
						}

					});
})();



(function () {

    mstrmojo.requiresCls("mstrmojo.MobileDocXtabGraph",
                         "mstrmojo.graph._CanvasGraph");

    
    mstrmojo.graph.MobileDocXtabCanvasGraph = mstrmojo.declare(
        mstrmojo.MobileDocXtabGraph,

        [ mstrmojo.graph._CanvasGraph ],

        
        {

            scriptClass: "mstrmojo.graph.MobileDocXtabCanvasGraph",
            update: function update(node) {
                delete this.graphData;

                this._super(node);
            },

            setModel: function setModel(model) {
                
                this.graphData = model.data;
            },

            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                if (!this.graphData) {
                    var id = this.id,
                        parentMethod = this._super,
                        md = this.model;

                    if (parseInt(h, 10) > 0 && parseInt(w, 10) > 0) {

                        this.model.getDataService().getRWGraphImage({
                            w: w,
                            h: h,
                            k: this.k,
                            sid: this.node.data.sid
                        }, md.newCallback({
                            success: function (res) {
                                var graph = mstrmojo.all[id];

                                if(!graph) { 
                                	return;
                                }
                                
                                graph.setModel({
                                    data: res
                                });

                                
                                parentMethod.call(graph, h, w);
                                
                                var parent = graph.parent;  
                                if(parent && parent.updateScroller) {
                                	parent.updateScroller();
                                }
                                
                            }
                        }));
                    }
                } else {
                    this._super(h, w);
                }
            }
        }
    );

}());




(function () {

    mstrmojo.requiresCls("mstrmojo.XtabBase",
                         "mstrmojo.XtabZone",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasXtabTouchScroll",
                         "mstrmojo._XtabSelections",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.css",
                         "mstrmojo._HasMagnifier",
                         "mstrmojo.XtabMagnifierHelper");

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom;

    
    var LOCK_OFF = 0;
    var LOCK_ROW = 1;
    var LOCK_COL = 2;
    var LOCK_BOTH = 3;











    
    function flagUnit(cellNode, isDirty) {
        $CSS.toggleClass(cellNode.firstChild, 'tx-active', isDirty);
    }

    
    function bringMagnifierToFront(magnifier) {
        if (magnifier) {
            magnifier.domNode.style.pointerEvents = 'auto';
        }
    }

    
    function checkLinks() {
        
        
        if (mstrMobileApp.isOnline()) {
            return;
        }

        
        var controller = this.controller,
            z,
            zone,
            nodes,
            node,
            cell,
            action,
            i,
            lnk,
            linkRequests = [],
            linkNodes = [],
            req;

        
        if ( ! controller.getLinkRequest) {
        	return;
        }
        for (z in this.zones) {
            if (z === '_BL' || z === '_BR') {
                zone = this.zones[z];
                nodes = zone.getNodesByPositions(zone.posMap);
                for (i = 0; i < nodes.length; i++) {
                    node = nodes[i];
                    cell = this.getCellForNode(node);
                    if (cell && cell.at && (cell.at & 4)) {
                        action = this.model.getAction(this.getActionCells(cell), null);

                        
                        if (action) {
                            lnk = action.a;
                            req = controller.getLinkRequest(lnk);
                            if (req) {
                                linkRequests.push(req);
                                linkNodes.push(node);
                            }
                        }
                    }
                }
            }
        }

        
        var count = linkRequests.length;
        if (count) {
            
            var fnSuccess = function (res) {
                var i,
                    node;
                for (i = 0; i < count; i++) {
                    node = linkNodes[i];
                    if (!res[i]) {
                    	node.setAttribute("hl_d", true);
                    	$CSS.addClass(node, "hl_d");
                    }
                }
            };

            if (mstrApp.isHosted()) {
                

            } else {
                this.model.getDataService().checkCachedLinkTargets(linkRequests, {
                    success: fnSuccess,
                    failure: mstrmojo.emptyFn
                });
            }
        }
    }

    
    function onConnectivityChange() {
        if (mstrMobileApp.isOnline()) {
            var z, zone,
                nodes,
                node,
                i;
            for (z in this.zones) {
                if (z === '_BL' || z === '_BR') {
                    zone = this.zones[z];
                    nodes = zone.getNodesByPositions(zone.posMap);
                    for (i = 0; i < nodes.length; i++) {
                        node = nodes[i];
                    	node.removeAttribute("hl_d");
                    	$CSS.removeClass(node, "hl_d");
                    }
                }
            }
        } else {
            checkLinks.call(this);
        }
    }

    
    mstrmojo.MobileXtab = mstrmojo.declare(
        
        mstrmojo.XtabBase,

        [ mstrmojo._TouchGestures, mstrmojo._HasXtabTouchScroll, mstrmojo._XtabSelections, mstrmojo._HasMagnifier ],

        
        {
            scriptClass: "mstrmojo.MobileXtab",

            
            frameRate: 30,

            
            enableMagnifier: true,

            useSeamlessIncFetch: false,
            
            
            allowToggleSelections: true,

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? 'block' : 'none'; },
                onheightChange: function () { this.domNode.style.height = this.height || ''; },
                onwidthChange: function () { this.domNode.style.width = this.width || ''; }
            },

            init: function init(props) {
                this._super(props);
                this.magnifierHelper = new mstrmojo.XtabMagnifierHelper({xtab: this});
                this.disposables.push(this.magnifierHelper);
            },

            gridPagesRendered: function gridPagesRendered() {
                this._super();
                
                checkLinks.call(this);
            },


            onRender: function onRender() {
                this._super();
                
                var interactiveCells = this.interactiveCellsArray;
                if (interactiveCells && interactiveCells.length > 0 && this.controller.getLinkRequest) {
                    
                    if (!this.subscr) {
                        var publisher = mstrmojo.publisher;
                        this.subscr = publisher.subscribe(publisher.NO_SRC, publisher.CONNECTIVITY_CHANGED_EVENT, onConnectivityChange, this.id);
                    }

                    
                    if ((mstrApp.useBinaryFormat || mstrApp.isHosted()) && !mstrMobileApp.isOnline()) {
                        var me = this;
                        window.setTimeout(function () {
                        	try{
                        	    checkLinks.call(me);
                        	} catch (ex) {
                                
                        	}
                        }, 100);
                    }
                }
            },

            unrender: function unrender() {
                if (this.subscr) {
                    mstrmojo.publisher.unsubscribe(this.subscr);
                    delete this.subscr;
                }
                
                this._super();
            },

            getDataService: function getDataService(options) {
                return this.model.getDataService();
            },

            setData: function setData(data) {
                this.set('gridData', data);
            },

            createZone: function createZone(cfg) {
                cfg = cfg || {};
                var ds = this.getDataService();
                cfg.imgCacheMap = (ds && ds.imgCache) || this.imgCacheMap;
                cfg.unCachedMap = {};

                return new mstrmojo.XtabZone(cfg);
            },

            showDownloadStatus: function showDownloadStatus() {
            },

            onclick: mstrmojo.emptyFn,

            
            setupTNs: function setupTNs() {

                
                var node = this.contentNode,
                    scrollBox = node.rows[1].cells[1].lastChild,
                    zIndex = 0;

                
                switch (this.lockHeadersCase) {
                case LOCK_OFF:
                    this._TSN.x = [ scrollBox.lastChild.lastChild ];
                    this._TSN.y = [ scrollBox.firstChild ];
                    break;

                case LOCK_COL:
                    this._TSN.x = [ node ];
                    this._TSN.y = [ scrollBox.firstChild ];
                    break;

                case LOCK_ROW:
                    this._TSN.x = [ scrollBox ];
                    this._TSN.y = [ node ];
                    zIndex = -1;
                    break;

                case LOCK_BOTH:
                    this._TSN.x = [
                        node.rows[0].cells[1].lastChild,    
                        scrollBox.firstChild                
                    ];
                    this._TSN.y = [ node.rows[1] ];
                    zIndex = 2;
                    break;
                }

                
                if (zIndex) {
                    this._TSN.x[0].style.zIndex = zIndex;
                }

                
                this.setOffsets();

                
                this.attachEventListener('scrolledOut', this.id, this.scrolledOut);
            },

            
            useDomToCalculateOffsets: function useDomToCalculateOffsets() {
                return (this.lockHeadersCase === LOCK_OFF || (this._super && this._super()));
            },

            setOffsets: function setOffsets() {
                var TW = 0,                                 
                    TH = 0;                                 

                
                var lockHeadersCase = this.lockHeadersCase;

                
                
                
                if (this.useDomToCalculateOffsets()) {
                    var touchNodes = this._TSN,
                        xScroll = touchNodes.x[0],
                        yScroll = touchNodes.y[0];

                    
                    TW = xScroll.offsetLeft + xScroll.offsetWidth + (!!(lockHeadersCase & LOCK_ROW) ? this._BL.offsetWidth : 0);
                    TH = yScroll.offsetTop + yScroll.offsetHeight + (!!(lockHeadersCase & LOCK_COL) ? this._TR.offsetHeight : 0);
                } else {
                    var zones = this.zones,
                        rh = (this.gridData.rh && parseInt(this.gridData.rh, 10)) || 0,           
                        cntTopRight = zones._TR ? zones._TR.cp.rc : 0,                 
                        cntBottomRight = zones._BR.cp.rc,              
                        widthBottomLeft = zones._BL ? zones._BL.totalColWidth : 0,     
                        widthBottomRight = zones._BR.totalColWidth;    

                    TH = ((lockHeadersCase === LOCK_ROW) ? cntBottomRight : cntTopRight + cntBottomRight) * rh;
                    TW = (lockHeadersCase === LOCK_COL) ? widthBottomRight :  widthBottomLeft + widthBottomRight;
                }

                
                var HEIGHT = 1,
                    WIDTH = 2,
                    scrollWidth = this.getGridDimension(WIDTH) || 0,
                    scrollHeight = this.getGridDimension(HEIGHT) || 0;

                
                
                this._TMAX = {
                    x: Math.min(scrollWidth - TW, 0),
                    y: Math.min(scrollHeight - TH, 0)
                };

                if (this._super) {
                    this._super();
                }
            },

            touchTap: function touchTap(touch) {
                
                if (!this.magnifier) {
                    if (this._super) {
                        this._super();
                    }

                    
                    if (this.performAction(touch) === false) {
                        
                        var ctrl = this.controller;
                        if (ctrl && ctrl.viewTap) {
                            
                            ctrl.viewTap();
                        }
                    }
                }
            },

            performAction: function performAction(touch) {
                
                this.deselectCell();

                
                var td = $DOM.findAncestorByAttr(touch.target, 'ei', true, this.domNode);

                
                if (!td || !td.value) {
                    
                    return false;
                }

                var node = td.node,
                    cell = this.getCellForNode(node),
                    actionType = cell.at;

                if (this._super && this._super(touch)) {
                    
                    return;
                }

                
                if (!actionType) {
                    
                    return false;
                }
                if ((actionType & 4) && ! node.getAttribute("hl_d")) {
                    var mask = document.createElement('div'),
                    	st = mask.style;
	                    id = this.id;
	
	                
	                mask.className = 'activeLink on';
	                st.left = node.offsetLeft + "px";
	                st.top = node.offsetTop + "px";
	                st.width = node.offsetWidth + "px";
	                st.height = node.offsetHeight + "px";
	                node.appendChild(mask);
	
	                
	                window.setTimeout(function () {
	                    
	                    var grid = mstrmojo.all[id];
	                    if (grid && grid.hasRendered) {
	                    	$DOM.attachOneTimeEvent(mask, 'webkitTransitionEnd', function () {
	                            
	                            node.removeChild(mask);
	                        });
	
	                        
	                    	$CSS.removeClass(mask, 'on');
	                    }
	                }, 200);
                }
                this.defaultAction(node);
            },


            
            selectCell: function selectCell(cell) {
                
                var highlight = document.createElement('div'),
                    highlightStyle = highlight.style;

                highlight.className = 'overlay';
                highlightStyle.top = cell.offsetTop + 'px';
                highlightStyle.left = (cell.offsetLeft + 1) + 'px';
                highlightStyle.height = (cell.clientHeight - 2) + 'px';
                highlightStyle.width = (cell.clientWidth - 1) + 'px';

                cell.appendChild(highlight);
            },

            flagDirtyUnit: function flagDirtyUnit(cellNode) {
                flagUnit(cellNode, true);
            },

            clearDirtyUnit: function clearDirtyUnit(cellNode) {
                flagUnit(cellNode, false);
            },

            
            deselectCell: function deselectCell() {
                
                var cell = this._selectedCell;
                if (cell) {
                    
                    cell.removeChild(cell.lastChild);

                    delete this._selectedCell;
                }
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                if (this.enableMagnifier) {
                	var controller = this.controller, magnifierConfig;
                	if (controller.getMagnifierConfig) {
                		magnifierConfig = controller.getMagnifierConfig();
                	}
                	
                    this.displayMagnifier(touch, magnifierConfig);
                }
            },

            touchSelectMove: function touchSelectMove(touch) {
                if (this.enableMagnifier) {
                    var me = this;
                    this.latestTouch = touch;
                    if (!this._moveMagnifierTimer) {
                        
                        
                        this._moveMagnifierTimer = setTimeout(function () {
                            me.displayMagnifier(me.latestTouch);
                            me._moveMagnifierTimer = null;
                        }, 50);
                    }
                }
            },

            touchSelectCancel: function touchSelectCancel(touch) {
                bringMagnifierToFront(this.magnifier);
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                bringMagnifierToFront(this.magnifier);
            },
            
            getCaptureDimensions: function getCaptureDimensions() {
            	var viewport = this.viewport,
            	    position = $DOM.position(this.domNode, true);
            	
            	position.w = Math.min(viewport.offsetWidth, position.w);
            	position.h = Math.min(viewport.offsetHeight, position.h)
            	
            	return position;
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._IsList",
                         "mstrmojo._HasSuggestion",
                         "mstrmojo.Enum_Keys",
                         "mstrmojo.hash",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom,
        $KEYS = mstrmojo.Enum_Keys,
        KEY_DELAY = 200,
        markup;

    var STATES = {
        DEFAULT: 1,
        ADDING: 2,
        EMPTY: 3,
        FULL: 4
    };

    var deleteCssCls = 'mstrmojo-SimpleObjectInputBox-del';

    
    function testInputText() {
        var inputBox = this.inputBox,
            text = inputBox.value;

        
        if (text !== this._lastPattern) {
            
            this.showSuggestion(text);
        }

        
        this._lastPattern = text;

        
        delete this._timerHandle;
    }

    
    function clearInputTextTimer() {
        
        var timerHandle = this._timerHandle;
        if (timerHandle) {
            
            window.clearTimeout(timerHandle);

            
            delete this._timerHandle;
        }
    }

    
    function setDefaultState() {
    	var mx = this.maxObjectCount,
			itsLen = (this.items && this.items.length) || 0,
			isFull = (mx != null && itsLen >= mx);
	
        this.set('state', !itsLen ? STATES.EMPTY : (isFull? STATES.FULL : STATES.DEFAULT) );
    }

    
    mstrmojo.SimpleObjectInputBox = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._IsList, mstrmojo._HasSuggestion ],

        
        {
            scriptClass: 'mstrmojo.SimpleObjectInputBox',

            markupString: '<div id="{@id}" class="mstrmojo-ListBase mstrmojo-SimpleObjectInputBox {@cssClass}" style="{@cssText}" mstrAttach:click>' +
                              '<div class="mstrmojo-SimpleObjectInputBox-container {@icnCss}" style="{@icnCssText}">{@itemsHtml}' +
                                  '<input type="text" mstrAttach:keydown,keyup,blur style="display: none;" />' +
                              '</div>' +
                              '<div class="mstrmojo-SimpleObjectInputBox-empty"><div>{@emptyText}</div></div>' +
                           '</div>',

            markupSlots: {
                itemsContainerNode: function () { return this.domNode.firstChild; },
                scrollboxNode: function () { return this.domNode; },
                emptyTextNode: function () { return this.domNode.childNodes[1]; },
                inputBox: function () { return this.domNode.firstChild.lastChild; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod,
                onmaxItemWidthChange: function onmaxItemWidthChange() {
                    
                    var w = this.maxItemWidth;
                    if (!isNaN(w)) {
                        
                        w += 'px';
                    }

                    
                    this.emptyTextNode.style.maxWidth = w;
                }
            },

            
            itemField: 'n',

            
            emptyText: '',

            state: 0,

            
            maxItemWidth: 'none',

            
            useKeyDelay: false,

            
            maxObjectCount: null,
            
            getItemMarkup: function (item) {
                
                if (!markup) {
                    var itemField = this.itemField;
                    markup = this._super(item).replace('>{@n}<', ' title="{@' + itemField + '}"><div class="elem">{@' + itemField + '}<div class="' + deleteCssCls + '"></div></div><');
                }

                
                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    itemField = this.itemField;

                
                props[itemField] = item[itemField];

                
                var maxWidth = this.maxItemWidth;
                if (!isNaN(maxWidth)) {
                    maxWidth = (maxWidth - 24) + 'px';
                }
                
                props.addStyle('max-width:' + maxWidth);

                return props;
            },

            getSuggestionPos: function getSuggestionPos() {
                var inputPosition = this._inputPos;

                return {
                    target: this.inputBox,
                    left: inputPosition.x,
                    top: inputPosition.y + inputPosition.h,
                    zIndex: 100
                };
            },

            getSearchPattern: function getSearchPattern() {
                return this.inputBox.value;
            },

            onSuggestionItemSelect: function onSuggestionItemSelect(item) {
                
                clearInputTextTimer.call(this);

                
                this.set('items', this.items.concat(item));

                this._super();

                
                var id = this.id;
                window.setTimeout(function () {
                	var obj = mstrmojo.all[id];
                	if (obj.state != STATES.FULL) {
                		obj.set('state', STATES.ADDING);
                	}
                }, 0);
            },

            onstateChange: function onstateChange(evt) {
                var state = evt.value;

                
                this.emptyTextNode.style.display = (state === STATES.EMPTY) ? 'block' : 'none';

                var inputBox = this.inputBox,
                    inputStyle = inputBox.style,
                    itemsContainer = this.itemsContainerNode;

                
                if (state === STATES.ADDING) {

                    
                    inputStyle.display = '';

                    
                    inputBox.focus();

                    
                    this._inputPos = $DOM.position(inputBox, true);

                } else {
                    
                    clearInputTextTimer.call(this);

                    
                    inputStyle.display = 'none';
                    inputBox.value = '';

                    
                    this._lastPattern = '';
                }
            },

            postBuildRendering: function postBuildRendering() {
                
                setDefaultState.call(this);
                return this._super();
            },

            preitemsChange: function preitemsChange() {
                
                setDefaultState.call(this);
            },

            onclick: function onclick(evt) {
                
                var target = $DOM.eventTarget(evt.hWin, evt.e);
                if (target && target.className === deleteCssCls) {
                    var item = $DOM.findAncestorByAttr(target, 'idx', true, this.domNode),
                        idx = item && parseInt(item.value, 10);

                    
                    if (idx !== null && !isNaN(idx)) {
                        
                        var items = this.items.concat();

                        
                        items.splice(idx, 1);

                        
                        this.set('items', items);
                    }

                    
                    return;
                }

                if (this.state != STATES.FULL) {
                	
                	this.set('state', STATES.ADDING);
                }
            },

            onblur: function onblur() {
                
                clearInputTextTimer.call(this);

                if (!this.suggestionShown) {
                    
                    setDefaultState.call(this);
                }
            },

            prekeydown: function prekeydown(evt) {
                
                var e = evt.e;
                switch (parseInt(e.keyCode || e.charCode, 10)) {
                case $KEYS.DOWN_ARROW:
                    this.nextHighlight();
                    break;

                case $KEYS.UP_ARROW:
                    this.preHighlight();
                    break;

                case $KEYS.TAB:
                case $KEYS.ENTER:
                    
                    $DOM.preventDefault(evt.hWin, e);

                    
                    var item = this.getSelected();
                    if (item) {
                        
                        this.handleSuggestionItemSelect(item);

                    } else {
                        
                        this.hideSuggestion();

                        setDefaultState.call(this);

                    }
                    break;

                case $KEYS.ESCAPE:
                    
                    clearInputTextTimer.call(this);

                    
                    this.hideSuggestion();

                    setDefaultState.call(this);
                    break;
                    
                case $KEYS.BACKSPACE:
                	
                	if (!this.getSearchPattern()) {
                		
                		$DOM.preventDefault(evt.hWin, e);

                		var items = this.items && this.items.concat();
                		if (items && items.length) {
                			
                			items.splice(items.length - 1, 1);
                			
                			
                			this.set('items', items);
                			
                			
                			var id = this.id;
                			window.setTimeout(function () {
                           		mstrmojo.all[id].set('state', STATES.ADDING);
                            }, 0);
                		}
                	}
                    
                    break;

                }
            },

            prekeyup: function prekeyup() {
                
                if (this.useKeyDelay) {
                    var id = this.id;

                    
                    if (!this._timerHandle) {
                        
                        this._timerHandle = window.setTimeout(function () {
                            testInputText.call(mstrmojo.all[id]);
                        }, KEY_DELAY);
                    }
                } else {
                    
                    testInputText.call(this);
                }
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo._HasSuggestion");

    var UNDETERMINED = -1,
        VALID = 0,
        INVALID = 1;
    
    
    mstrmojo._ValidateSuggestions = mstrmojo.provide(
        "mstrmojo._ValidateSuggestions",

        mstrmojo.hash.copy(mstrmojo._HasSuggestion, {
            _mixinName: 'mstrmojo._ValidateSuggestions',

            
            itemValidationField: 'did',
            
            
            verifyObject: function verifyObject(t, w) {
                
                var c = this.candidates,
                    state;

                if (c) {
                    var items = c.items,
                        idx = mstrmojo.array.find(items, this.itemValidationField, w.data[this.itemValidationField]);
                    
                    idx = idx > -1 ? idx : mstrmojo.array.find(items, this.itemField, t);

                    if (idx > -1) {
                        w.updateData(items[idx]);
                        state = VALID;

                    } else if (c.isComplete) {
                        state = INVALID;

                    }
                }

                if (state !== undefined) {
                    return state;
                }

                var q = this._vqueue = this._vqueue || [];
                q.push({
                    pattern: t,
                    id: w.data[this.itemIdField]
                });

                if (!this._vInProgress) {
                    this.verifyNextCandidate();
                }

                return UNDETERMINED;
            },

            verifyNextCandidate: function verifyNextCandidate() {
                var queue = this._vqueue;
                if (!queue || queue.length === 0) {
                    this._vInProgress = false;
                    return;
                }

                this.verifyCandidate(queue.shift());
            },

            verifyCandidate: function verifyCandidate(info) {
                var me = this;

                this._vInProgress = true;

                this.getCandidatesThroughTaskCall({
                    pattern: info.pattern,
                    blockBegin: 1,
                    blockCount: this.suggestCount,
                    isVerify: true
                }, {
                    success: function (res) {
                        var ws = me.ctxtBuilder.itemWidgets,
                            len = ws && ws.length,
                            target,
                            i;

                        for (i = 0; i < len; i++) {
                            if (ws[i].data[me.itemIdField] === info.id) {
                                target = ws[i];
                                break;
                            }
                        }

                        if (!target) {
                            return;
                        }

                        var its = res.items;
                        if (its && its.length === 1) {
                            target.updateData(its[0]);
                        } else if (its && its.length > 1) {
                            var idx = mstrmojo.array.find(its, 'did', target.data.did);
                            if (idx > -1) {
                                target.updateData(its[idx]);
                            } else {
                                target.set('state', INVALID);
                            }
                        } else {
                            target.set('state', INVALID);
                        }
                    },

                    failure: function (res) {
                        mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                    },

                    complete: function () {
                        me.verifyNextCandidate();
                    }
                });
            },

            
            ENUM_STATES: {
                UNDETERMINED: UNDETERMINED,
                VALID: VALID,
                INVALID: INVALID
            }
        })
    );
}());
(function(){
    mstrmojo.requiresCls("mstrmojo.android.Dialog", "mstrmojo.Button");
    
    mstrmojo.android.AndroidDICPopup = mstrmojo.declare(
            mstrmojo.android.Dialog,
            
            null,
            
            {
                scriptClass: 'mstrmojo.AndroidDICPopup',

                cssClass: 'mstrmojo-AndroidDICPopup',

                autoClose: false,
                
                fadeOnClose: false,
                
                init: function init(props) {
                    this._super(props);
                    
                    this.addChildren([this.widget]);
                },
                
                close: function close(){
                    
                    this.set('visible', false);
                    
                    
                    
                    if (this.widget.hasRendered){
                        this.widget.unrender();
                    }
                    
                    this.removeChildren(this.widget);
                    
                    this._super();
                },
                
                onpopupResized: function onpopupResized(e) {
                    if(this.widget.onpopupResized) {
                        this.widget.onpopupResized(e);
                    }
                },
                
                onkeyup: function onkeyup(evt) {
                    var hWin = evt.hWin,
                        e = evt.e || hWin.event;
                    
                    if(this.widget.applyOnEnter && e.keyCode === 13) {
                        
                        this.onApply();
                    } else if(e.keyCode === 27) {
                        this.onCancel();
                    }               
                },   
                              
                onApply: function() {
                    return this.widget.applyChanges();
                },
                
                onCancel: function() {
                    this.widget.cancelChanges();
                },
                
                enableApply: mstrmojo.emptyFn
            }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.css",
                         "mstrmojo.android.ui.CalendarMarkupBuilder",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.Dialog");

    var $CSS = mstrmojo.css,
        DIALOG_CSS = 'mstrmojo-CalDialog';

    
    mstrmojo.android.ui.CalendarDialog = mstrmojo.declare(

        
        mstrmojo.android.Dialog,

        
        null,

        
        {
            scriptClass: "mstrmojo.android.ui.CalendarDialog",

            
            markupBuilder: undefined,

            
            requiredOrientation: 0,

            
            init: function (props) {
                
                this._super(props);

                var calendar = this.calendar,
                    popDimensions = this.popDimensions = this.getPopupDimensions(),
                    requiredOr = this.requiredOrientation,
                    currentLockedOr = mstrMobileApp.getLockedOrientation();

                
                if (requiredOr !== 0 && requiredOr !== currentLockedOr) {
                    
                    mstrMobileApp.lockOrientation(requiredOr);

                    
                    this._prevOr = currentLockedOr;
                }

                
                calendar.markupBuilder = this.markupBuilder;

                
                calendar.width = popDimensions.w + 'px';
                calendar.height = popDimensions.h + 'px';
                calendar.layoutConfig = {
                    h: {
                        yearNode: '100px'
                    },
                    w: {
                        yearNode: '100%'
                    }
                };

                
                calendar.defaultCSS = this.cssClass;
                calendar.target = new mstrmojo.ui.MobileCheckList({
                    alias: 'contentList',
                    cssDisplay: ''
                });

                
                $CSS.addWidgetCssClass(this, [DIALOG_CSS]);
            },

            
            getPopupDimensions: function getPopupDimensions() {
                var screenDimensions = mstrApp.getScreenDimensions();

                return {
                    h: screenDimensions.h * 0.9,
                    w: Math.min(screenDimensions.w * 0.85, 720)
                };
            },

            
            getCancelBtnFn: function getCancelBtnFn() {
                var calList = this.calendar.target,
                    dialog = calList.parent,
                    items = calList.getSelectedItems(),
                    returnVal = true;

                
                if (items && items.length > 0) {
                    
                    calList.set('items', []);

                    
                    dialog.resizeDialog();

                    
                    returnVal = false;
                } else {
                    
                    dialog.close();
                }

                return returnVal;
            },

            
            close: function close() {
                
                this._super();

                var prevOrientation = this._prevOr;

                
                if (prevOrientation !== undefined) {
                    
                    if (prevOrientation === 0) {
                        
                        mstrMobileApp.releaseOrientation();
                    } else {
                        
                        mstrMobileApp.lockOrientation(prevOrientation);
                    }

                    
                    delete this._prevOr;
                }
            }
        }
    );

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.LikertScaleDIC",
                         "mstrmojo.css");

    
    mstrmojo.android.inputControls.LikertScaleDIC = mstrmojo.declare(
        
        mstrmojo.LikertScaleDIC,
        
        null,
        
        {
            scriptClass: 'mstrmojo.android.inputControls.LikertScaleDIC',

            lowestLabel: null,

            hightestLabel: null,

            

            markupString: '<div id="{@id}" class="mstrmojo-ListBase {@cssClass}" style="{@cssText}" mstrAttach:click>' +
                              '<div class="{@icnCss}" style="{@icnCssText}">' +
                                    '{@itemsHtml}' +
                                    '<div class="label {@lowestClass}">{@lowestLabel}</div>' +
                                    '<div class="label {@hightestClass}">{@hightestLabel}</div>' +
                              '</div>' +
                          '</div>',

            init: function init(props) {
                this._super(props);

                var len = this.titleItems && this.titleItems.length,
                    showMint = this.dic.mint && len,
                    showMaxt = this.dic.maxt && len;
                this.lowestLabel = showMint ? (this.titleItems[0] + ': ' + this.dic.mint) : '';
                this.lowestClass = showMint ? '' : 'hidden';
                this.hightestLabel = showMaxt ? (this.titleItems[len - 1] + ': ' + this.dic.maxt) : '';
                this.hightestClass = showMaxt ? '' : 'hidden';
            },

            
            getLeftEndTitle: function (idx) { return ''; },

            
            getRightEndTitle: function (idx) { return ''; },
            
            ontouchend: function (evt) {
                this.onclick(evt);
            },

            setDirtyFlag: function (c, d) {
                mstrmojo.css.addClass(this.itemsNode || d, 'tx-active');
            }
        }
    )
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.RatingDIC",
                         "mstrmojo._TouchGestures");

    var $D = mstrmojo.dom;

    
    mstrmojo.android.inputControls.RatingDIC = mstrmojo.declare(
        
        mstrmojo.RatingDIC,
        
        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: 'mstrmojo.android.inputControls.RatingDIC',

            touchTap: function touchTap(touch) {
                
                touch.e = touch.e || touch.evt;
                this.onclick(touch);
            },

            touchSwipeMove: function touchSwipeMove(touch) {
                var target = document.elementFromPoint(touch.pageX, touch.pageY),
                    idx;
                if ( $D.contains(this.domNode, target) ) {
                    idx = target && target.getAttribute('idx');
                    if ( idx != undefined ) {
                        this.setRating(idx);
                        this.ratingSelectedValue = this.items[idx].v;
                    }
                }
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                    if (this.ratingSelectedValue != undefined && this.ratingSelectedValue != this.value) {
                        this.set('value', this.ratingSelectedValue);
                    }
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                mstrmojo.css.addClass(this.itemsNode || d, 'tx-active');
            }
        }

    );
}());
(function(){
    
    mstrmojo.requiresCls(
            "mstrmojo.css",
            "mstrmojo.array",
            "mstrmojo.WidgetTree",
            "mstrmojo.TreeBrowserNode",
            "mstrmojo.TreeBrowserSelector"
    );
    
    mstrmojo.TreeBrowserEnum = {};
    var treeEnum = mstrmojo.TreeBrowserEnum;
    treeEnum.BRANCH_POLICY_TOGGLE = 'toggle';
    treeEnum.BRANCH_POLICY_SELECT = 'select';    
    
    
    mstrmojo.TreeBrowser = mstrmojo.declare(
        
        mstrmojo.WidgetTree,
        
        null,
        {   
            scriptClass:'mstrmojo.TreeBrowser',
            
            cssClass:'mstrmojo-TreeBrowser',
  
            
            blockCount: 30, 
            
            
            noCheckBox: false,
            
            
            selectionAcrossBranch: true,
            
            
            branchClickPolicy: treeEnum.BRANCH_POLICY_TOGGLE,
            
            
            contentRetrieved: false, 
            
            
            listSelector: mstrmojo.TreeBrowserSelector, 
                                                        
            
            
            handleNodeClicked: function(data){
                
            },

            
            getContentThroughTaskCall: function getContentThroughTaskCall(params, callbacks){

            }, 
            
            
            isBranch: function isBranch(data){

            },
            
            
            item2textCss: function item2textCss(data){
                return {
                    '-1': 'failed',
                    '-2': 'loading',
                    '-3': 'next',
                    '-4': 'prev'
                }[data.st];
            },
            
            failItemCreaterFunc: function(){
                return {n:'Loading Failed!',did:'-1',tp:'-1',st:'-1'};
            }, 
            
            loadingItemCreaterFunc: function(){
                return {
                    n:mstrmojo.desc(5674, "Loading..."),
                    did:'-2',
                    tp:'-2',
                    st:'-2'
                };                 
            }, 
            
            nextItemCreaterFunc: function(){
                return {
                    n: mstrmojo.desc(4507, 'Next ##  item(s)...').replace('##', this.blockCount),
                    did: '-3',
                    tp: '-3',
                    st: '-3'
                };                     
            },
            
            prevItemCreaterFunc: function(){
                return {
                    n: mstrmojo.desc(4508, 'Previous ##  item(s)...').replace('##', this.blockCount),
                    did: '-4',
                    tp: '-4',
                    st: '-4'
                };                     
            },
            
            updateTreeContent: function(w, res){
                w.contentRetrieved = true;
                var items = res[w.itemChildrenField],
                    tree = w.tree || w,
                    bc = res.bc,
                    sz = res.sz,
                    bb = res.bb;
                if(bc !== -1){
                    if(bb + bc < sz){
                        items.push(tree.nextItemCreaterFunc());
                    }
                    if((bb - bc) > -1){
                        items.unshift(tree.prevItemCreaterFunc());
                    }
                }
                w.blockBegin = bb;
                tree.initializing = true;
                w.clearSelect(false);
                w.set('items', items);
                
                
                w.setSelectedItems(tree.getTotalSelections(), true);
                
                tree.initializing = false;
            },
            
            getContent: function(w, blockBegin){
                var isRoot = (w === this),
                    tree = this,
                    success = function(res){
                        if(isRoot){
                            mstrmojo.css.removeClass(tree.domNode, ["loading"]);   
                        }
                        tree.updateTreeContent(w, res);
                    },
                    failure = function(res){                      
                        w.set('items',[tree.failItemCreaterFunc()]); 
                    },
                    callbacks = {success: success, failure: failure};
                
                if(isRoot){
                    mstrmojo.css.addClass(tree.domNode, ["loading"]);
                }
                
                this.getContentThroughTaskCall({
                        isRoot: isRoot,
                        data: w.data,
                        blockBegin: isRoot ? 0 : (blockBegin || w.blockBegin),
                        blockCount: tree.blockCount
                    }, callbacks);
            },
            
            postBuildRendering: function postBuildRendering(){
                this._super();
                if(!this.contentRetrieved){
                    this.getContent(this);
                }
            },

            
            itemFunction: function ifn(item, idx, w){
                var tree = w.tree || w,
                    iw = new mstrmojo.TreeBrowserNode({
                        data: item,
                        state: 0,
                        parent: w,
                        tree: tree,
                        multiSelect: w.multiSelect,
                        text: item[w.itemDisplayField],
                        textCssClass: tree.item2textCss(item),
                        items: item[w.itemChildrenField],
                        itemIdField: w.itemIdField,
                        itemDisplayField: w.itemDisplayField,
                        itemIconField: w.itemIconField,
                        itemChildrenField: w.itemChildrenField,
                        itemFunction: w.itemFunction,
                        listSelector: w.listSelector
                });
                return iw;
            },
            
            
            clearTreeSelect: function clearTreeSelect(){ 
                if(!this.selectionAcrossBranch){
                    this._super();
                } else {
                    var sp = this._selectionParentNode,
                        len = sp && sp.length,
                        i;
                    
                    for(i = 0; i < len; i++){
                        sp[i].clearSelect();
                    }
                    this._selectionParentNode = null;
                    this._totalSelections = null;
                }
            },
            
            
            onnodechange: function onnodechange(evt){
                if(this.initializing) {
                    return;
                }
                
                if(!this.selectionAcrossBranch){
                    this._super(evt);
                } else {
                    this._totalSelections = this._totalSelections || [];
                    this._selectionParentNode = this._selectionParentNode || [];
                    
                    var ts = this._totalSelections,
                        sp = this._selectionParentNode,
                        added = evt.added,
                        removed = evt.removed,
                        ais = [],
                        ris = [],
                        node = evt.src,
                        i, j, len, lenj;
                    
                    
                    sp.push(node);
                    
                    
                    for(i = 0, len = removed && removed.length;i<len;i++){
                        ris.push(node.items[removed[i]]);
                    }                
                    mstrmojo.array.removeItems(ts, 'did', ris);
                    
                    
                    for(j = 0, lenj = added && added.length;j<lenj;j++){
                        ais.push(node.items[added[j]]);
                    }
                    this._totalSelections = ts.concat(ais);
                }
            },
            
            
            getTotalSelections: function getTotalSelections(){
                if(this.selectionAcrossBranch){
                    return this._totalSelections || [];
                } else {
                    var sn = this.selectionParentNode;
                    return sn && sn.getSelectedItems();
                }
            }
   });
   
 
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo.android.controllers.SettingsController",
                         "mstrmojo.android._HasLingeringListSelections",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo.android.ui.TextInput",
                         "mstrmojo.android.ui.ValidationTextInput",
                         "mstrmojo.expr",
                         "mstrmojo.array",
                         "mstrmojo.css");

    mstrmojo.requiresDescs(221, 1442, 7883, 9454);

    var $STYLES = mstrmojo.android.controllers.SettingsController.STYLES,
        $BTN = mstrmojo.android.ui.Button.newButton,
        $ARR = mstrmojo.array,
        $VAL = mstrmojo.validation,
        $TRIG = $VAL.TRIGGER,
        $SC = $VAL.STATUSCODE,
        itemMarkup = {},
        $D = mstrmojo.dom,
        $TRANS_DURATION = $D.CSS3_TRANSITION_DURATION;

    
    mstrmojo.android.ui.SettingsView = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        [ mstrmojo.android._HasLingeringListSelections ],

        
        {
            scriptClass: "mstrmojo.android.ui.SettingsView",

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, 'mstrmojo-AndroidSettings');
            },

            
            allowTouchBubble: false,

            
            getList: function getList() {
                return this;
            },

            listHooks: {
                select: function (el, item, idx) {
                    
                    el.style[$TRANS_DURATION] = 0;

                    
                    if (item.disabled) {
                        
                        return true;
                    }

                    
                    if (item.style !== $STYLES.VIEW_BUTTON) {
                        
                        this.setClearHandler(200);
                    }
                },
                unselect: function (el, item, idx) {
                    
                    el.style[$TRANS_DURATION] = '300ms';
                }
            },

            getItemMarkup: function (item) {
                var s = item.style;
                
                if (!itemMarkup[s]) {
                    
                    var newMarkup = '<div><h3>{@ttl}</h3><h4>{@value}</h4></div>';

                    
                    if (s === $STYLES.TEXT_AREA) {
                        
                        newMarkup = '<div readonly="readonly">{@ttl}</div>';

                    
                    } else if (s === $STYLES.IMAGE) {
                        
                        newMarkup = '<h3></h3>';
                    }

                    
                    itemMarkup[s] = this._super(item).replace('{@n}', newMarkup);
                }

                return itemMarkup[s];
            },

            getItemProps: function getItemProps(item, idx) {
                var value = item.v,
                    props = this._super(item, idx);

                
                props.ttl = item.nm;
                props.value = value || '';

                
                var cls = item.cls;
                if (cls) {
                    
                    props.addCls(cls);
                }

                
                var fnTimeNumberText = function () {
                    
                    props.addCls('drop-down');

                    
                    if (item.pwd) {
                        props.value = '********';

                    
                    } else if (item.showHint && value === '') {
                        props.value = mstrmojo.desc(9454, '&lt;not set&gt;');

                    }
                };

                
                switch (item.style) {

                case $STYLES.TEXT_AREA:
                    props.addCls('textarea');
                    break;

                case $STYLES.HEADER:
                    
                    props.addCls('header');
                    break;

                    case $STYLES.TIME:
                    
                    props.value = new Date((item.v < 60000) ? item.v * 60000 : item.v).toJSON().replace(/.*T/, '').replace(/\.[0-9]{3}Z/, '');
                    fnTimeNumberText();
                    break;

                case $STYLES.NUMBER:
                case $STYLES.TEXT:
                    fnTimeNumberText();
                    break;

                case $STYLES.LIST:
                    
                    props.addCls('drop-down');

                    
                    var items = item.items;
                    props.value = items[$ARR.find(items, 'v', value)].n;
                    break;

                case $STYLES.CHECK:
                    
                    props.addCls('check');

                    
                    if (value === item.on) {
                        
                        props.addCls('on');
                    }

                    
                    props.value = item.desc;
                    break;
                }

                
                if (item.hidden) {
                    
                    props.addCls('hidden');

                
                } else if (item.disabled) {
                    
                    props.addCls('disabled');

                    
                    props.value = '';
                }

                
                if (props.value) {
                    
                    props.addCls('with-desc');
                }

                return props;
            },

            
            touchSelectBegin: function touchSelectBegin(touch) {
                
                var idx = this.getItemIdxTouch(touch);
                if (idx > -1) {
                    
                    var item = this.items[idx],
                        fnPress = item.fnPress;

                    
                    if (fnPress) {
                        
                        fnPress.call(this.controller, item);

                        
                        return false;
                    }
                }

                
                return true;
            },

            preselectionChange: function preselectionChange(evt) {
                
                var added = evt.added;
                if (!added) {
                    
                    return true;
                }

                
                var idx = added[0],
                    item = this.items[idx];

                
                if (item.disabled || item.noclick) {
                    
                    return false;
                }

                
                if (item.style === $STYLES.HEADER) {
                    
                    if (!this._listTarget.getAttribute('hidx')) {
                        
                        return false;
                    }
                }

                
                return true;
            },

            
            postselectionChange: function postselectionChange(evt) {
                var added = evt.added;
                if (!added) {
                    return;
                }

                
                var idx = added[0],
                    item = this.items[idx];

                
                var me = this,
                    dialogConfig = {
                        title: item.nm
                    },
                    dialogChildren = [],
                    fnOk,
                    dialog,
                    fnUpdateValue = function (item, value) {
                        
                        item.fn(value);

                        
                        me.updateItem(idx);
                    };

                
                switch (item.style) {
                case $STYLES.HEADER:
                    
                    var headerIdx = this._listTarget.getAttribute('hidx');
                    if (headerIdx) {
                        
                        this.controller.jumpTo(parseInt(headerIdx, 10), true);
                    }
                    break;

                case $STYLES.BUTTON:
                case $STYLES.VIEW_BUTTON:
                    
                    if (item.fn) {
                        
                        item.fn();
                    }
                    break;

                case $STYLES.NUMBER:
                case $STYLES.TEXT:
                    var isNum = (item.style === $STYLES.NUMBER),
                        tb = {
                            scriptClass: 'mstrmojo.android.ui.' + (isNum ? 'Validation' : '') + 'TextInput',
                            alias: 'textInput',
                            textValue: item.v,
                            textType: isNum ? 'number' : (item.pwd ? 'password' : 'text'),
                            onEnter: function (value) {
                                
                                fnUpdateValue(item, value);

                                
                                dialog.close();
                            }
                        };

                    
                    if (isNum) {
                        
                        tb.valProps = {
                            dtp: mstrmojo.expr.DTP.UNSIGNED,
                            min: item.limits.min,
                            max: item.limits.max,
                            constraints: {
                                trigger: $TRIG.ONKEYUP,
                                validator: function (v) {
                                    v = parseInt(v, 10);

                                    var min = this.min,
                                        max = this.max,
                                        msg = (v >= min && v <= max) ? '' : mstrmojo.desc(7883).replace('##', min).replace('###', max);

                                    return {
                                        code: msg ? $SC.INVALID : $SC.VALID,
                                        msg: msg
                                    };
                                }
                            }
                        };
                    }

                    
                    dialogChildren.push(tb);

                    
                    fnOk = function () {
                        
                        var eb = dialog.textInput;
                        if (eb.validate) {
                            
                            eb.validate();

                            
                            if (eb.isValid()) {

                                
                                fnUpdateValue(item, eb.getValue());
                                return true;
                            }

                            
                            return false;
                        }

                        
                        fnUpdateValue(item, eb.getValue());
                        return true;
                    };

                    break;

                case $STYLES.LIST:
                    var items = item.items;

                    
                    var optionList = new mstrmojo.ui.MobileCheckList({
                        items: items,
                        multiSelect: false,
                        isElastic: true,
                        selectedIndex: $ARR.find(items, 'v', item.v)
                    });

                    
                    dialogChildren.push(optionList);

                    
                    fnOk = function () {
                        
                        fnUpdateValue(item, items[optionList.selectedIndex].v);
                    };
                    break;

                case $STYLES.CHECK:
                    
                    fnUpdateValue(item, (item.v === item.on) ? item.off : item.on);
                    break;

                case $STYLES.TIME:
                    

                    
                    var v = (item.v < 60000) ? item.v * 60000 : item.v,
                        date = new Date(v),
                        timePicker = new mstrmojo.ui.MobileDateTimePicker({
                            value: {
                                time: {
                                    hour: date.getUTCHours(),
                                    min: date.getUTCMinutes(),
                                    sec: 0
                                }
                            },
                            is24HourMode: false,
                            dtp: mstrmojo.expr.DTP.TIME
                        });

                    dialogChildren.push(timePicker);

                    
                    fnOk = function () {
                        var time = timePicker.getTime();
                        
                        fnUpdateValue(item, time.hour * 60 + time.min);
                    };
                    break;
                }

                
                if (dialogChildren.length) {
                    
                    dialogConfig.children = dialogChildren;

                    
                    if (fnOk) {
                        
                        dialogConfig.buttons = [ $BTN(mstrmojo.desc(221, 'Cancel')), $BTN(mstrmojo.desc(1442, 'OK'), fnOk) ];
                    }

                    
                    dialog = mstrApp.showDialog(dialogConfig);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
        "mstrmojo._HasLayout",
        "mstrmojo.android.ui.PromptsList",
        "mstrmojo.android.ui.Button");

    mstrmojo.requiresDescs(2550, 3649, 3650);

    var $DESC = mstrmojo.desc,
        $100 = '100%';

    
    function passToParent(methodName, args) {
        
        var parent = this.parent;
        if (parent[methodName]) {
            
            parent[methodName].apply(parent, args);
            return true;
        }

        
        return false;
    }

    
    var $PV = mstrmojo.android.ui.PromptsView = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        
        {
            scriptClass: 'mstrmojo.android.ui.PromptsView',

            markupString: '<div id="{@id}" class="mstrmojo-Prompts {@cssClass}" style="{@cssText}">' +
                '<div class="summary"></div>' +
                '<div class="command"></div>' +
                '</div>',

            markupSlots: {
                summaryNode: function () {
                    return this.domNode.firstChild;
                },
                cmdNode: function () {
                    return this.domNode.lastChild;
                }
            },

            layoutConfig: {
                h: {
                    summaryNode: $100,
                    cmdNode: '90px'
                },
                w: {
                    summaryNode: $100,
                    cmdNode: $100
                }
            },

            init: function init(props) {
                this._super(props);

                var prompts = this.prompts,
                    supportedPrompts = this.supportedPrompts;

                
                if (prompts && supportedPrompts) {
                    
                    var cmdButton = mstrmojo.android.ui.Button.newButton((prompts.host.st === 14081) ? $DESC(3650, 'Run Document') : $DESC(3649, 'Run Report'), function () {
                        this.parent.controller.answerPrompts();
                    }, {
                        slot: 'cmdNode',
                        alias: 'cmdButton',
                        cssClass: 'mstrmojo-GlowButton',
                        ignoreLayout: true,
                        enabled: mstrMobileApp.isOnline(),                    
                        glowClass: 'glow'
                    });

                    
                    var publisher = mstrmojo.publisher;
                    publisher.subscribe(publisher.NO_SRC, publisher.CONNECTIVITY_CHANGED_EVENT, function (isOnline) {
                        
                        this.cmdButton.set('enabled', isOnline);
                    }, this.id);

                    
                    this.addChildren([ cmdButton ]);

                    
                    if (mstrApp.isTablet()) {
                        
                        supportedPrompts = [
                            {
                                title: $DESC(2550, 'FILTERS'),
                                isTtl: true
                            }
                        ].concat(supportedPrompts);
                    }

                    
                    this.promptList.set('items', supportedPrompts);
                }
            },

            
            rootOrientationChange: function rootOrientationChange() {
                
                if (!this.ignoreRotation) {
                    
                    mstrApp.closeDialog();
                }
            },

            children: [
                {
                    scriptClass: 'mstrmojo.android.ui.PromptsList',
                    slot: 'summaryNode',
                    alias: 'promptList',
                    canItemLinger: function canItemLinger(item) {
                        return !mstrApp.isTablet() || item.getStyle() === mstrmojo.prompt.WebPrompt.STYLES.SWITCH;
                    }
                }
            ],

            openPrompt: function openPrompt(fnOpen) {

                var controller = this.controller;

                
                if (!controller.prevController && !controller.nextController) {
                    return;
                }

                
                this.ignoreRotation = true;
                
                if (!passToParent.call(this, 'openPrompt', [ fnOpen ])) {
                    
                    fnOpen();
                }
                var me = this;
                window.setTimeout(function () {
                    delete me.ignoreRotation;
                }, 300);
            },

            closePrompt: function closePrompt() {
                passToParent.call(this, 'closePrompt');
            }
        }
    );

    
    mstrmojo.DPIManager.registerClass($PV, 'h', 'cmdNode', {
        160: 60,
        213: 60,
        240: 90,
        320: 120
    });

}());
(function(){
    
    mstrmojo.requiresCls(
            "mstrmojo.TreeBrowserNode",
            "mstrmojo.TreeBrowser",
            "mstrmojo.ACL.UserDataService"
    );
      

    
    mstrmojo.ACL.UserTreeBrowser = mstrmojo.declare(
        
        mstrmojo.TreeBrowser,
        
        null,
        {   
            scriptClass:'mstrmojo.ACL.UserTreeBrowser',
            
            itemIdField: 'did',

            branchClickPolicy: mstrmojo.TreeBrowserEnum.BRANCH_POLICY_SELECT,
            
            getContentThroughTaskCall: function getContentThroughTaskCall(params, callbacks){
                var DS = mstrmojo.ACL.UserDataService;
                if(params.isRoot){
                    DS.getTopLevelGroups(params, callbacks);
                } else {
                    DS.getMembers(params, callbacks);
                }
            }, 
            
            isBranch: function isBranch(data){
                return data.isGroup;
            },
            
            item2textCss: function item2textCss(data){
                return (this._super && this._super(data)) || 
                {
                    8704: 'u',
                    8705: 'ug'
                }[data.st];
            }
   });
 
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.android.AndroidDICPopup",
                         "mstrmojo.DefaultDIC",
                         "mstrmojo.android.inputControls.SliderDIC",
                         "mstrmojo.android.inputControls.TextFieldDIC",
                         "mstrmojo.android.inputControls.CheckBoxDIC",
                         "mstrmojo.android.inputControls.PullDownDIC",
                         "mstrmojo.android.inputControls.RadioListDIC",
                         "mstrmojo.android.inputControls.LikertScaleDIC",
                         "mstrmojo.android.inputControls.CalendarDIC",
                         "mstrmojo.android.inputControls.DateTimePickerDIC",
                         "mstrmojo.android.inputControls.TextAreaDIC",
                         "mstrmojo.android.inputControls.MarkRowDIC",
                         "mstrmojo.android.inputControls.ToggleDIC",
                         "mstrmojo.android.inputControls.SignatureDIC",
                         "mstrmojo.android.inputControls.StepperDIC",
                         "mstrmojo.android.inputControls.RatingDIC",
                         "mstrmojo.android.inputControls.BarcodeDIC",
                         "mstrmojo.android.ui.Button");

    mstrmojo.requiresDescs(221, 1442);

    var $BTN = mstrmojo.android.ui.Button.newButton,
        TEXTFIELD = 1,
        SWITCH = 2,
        LIST = 3,
        SLIDER = 4,
        CALENDAR = 5,
        TIMEPICKER = 6,
        TOGGLE = 7,
        TEXTAREA = 8,
        SIGNATURE = 9,
        RATING = 10,
        STEPPER = 12,
        BARCODE = 13,
        LIKERTSCALE = 14,
        MARKROW = 102;
        




    var $ADC = mstrmojo.android.AndroidDICConfig = mstrmojo.provide(

        "mstrmojo.android.AndroidDICConfig",

        {
            DICList: {
                1: mstrmojo.android.inputControls.TextFieldDIC,
                2: mstrmojo.android.inputControls.CheckBoxDIC,
                3: {
                    0: mstrmojo.android.inputControls.PullDownDIC,
                    1: mstrmojo.android.inputControls.RadioListDIC
                },
                4: mstrmojo.android.inputControls.SliderDIC,
                5: mstrmojo.android.inputControls.DateTimePickerDIC,
                6: mstrmojo.android.inputControls.DateTimePickerDIC,
                7: mstrmojo.android.inputControls.ToggleDIC,
                8: mstrmojo.android.inputControls.TextAreaDIC,
                9: mstrmojo.android.inputControls.SignatureDIC,
                10: mstrmojo.android.inputControls.RatingDIC,
                11: mstrmojo.DefaultDIC,
                12: mstrmojo.android.inputControls.StepperDIC,
                13: mstrmojo.android.inputControls.BarcodeDIC,
                14: mstrmojo.android.inputControls.LikertScaleDIC,
                102: mstrmojo.android.inputControls.MarkRowDIC
            },

            DICPopup: {
                getInstance: function (opener, dic) {
                    
                    return mstrApp.showPopup({
                        scriptClass: 'mstrmojo.android.AndroidDICPopup',
                        widget: dic,
                        buttons: [ $BTN(mstrmojo.desc(221, 'Cancel'), function () {
                            this.parent.parent.onCancel();
                        }), $BTN(mstrmojo.desc(1442, 'OK'), function () {
                            return this.parent.parent.onApply();
                        }) ],
                        title: dic.popupTitle || opener.parent.title        
                    });
                }
            },

            
            getDICClass: function getDICClass(dic) {
                if (dic.t === LIST) {
                    return this.DICList[dic.t][dic.st || 0];
                }
                return this.DICList[dic.t];
            },

            
            showDICByDefault: function showDICByDefault(dic, openerType) {
                if (dic.sbd === undefined) {
                    switch (dic.t) {
                    case LIST:
                        dic.sbd = (!!dic.st) ? true : false; 
                        break;
                    case CALENDAR:
                    case TIMEPICKER:
                    case TEXTFIELD:
                    case BARCODE:
                        dic.sbd = false;
                        break; 

                    case TOGGLE:
                    case SWITCH:
                    case MARKROW:
                    case RATING:
                    case STEPPER:
                    case LIKERTSCALE:
                        dic.sbd = true;
                        break;

                    default:
                        dic.sbd = (dic.dm === 1); 
                    }
                }

                return dic.sbd;
            },

            
            hasDICPreview: function hasDICPreview(dic, openerType) {
                
                return true;
            },

            isKeyNavigable: function isKeyNavigable(dic) {
                if (dic.ikn === undefined) {
                    dic.ikn = false;
                }
                return dic.ikn;
            }
        }
    );

    $ADC.TYPES = {
        TEXTFIELD: TEXTFIELD,
        SWITCH: SWITCH,
        LIST: LIST,
        SLIDER: SLIDER,
        CALENDAR: CALENDAR,
        TIMEPICKER: TIMEPICKER,
        TOGGLE: TOGGLE,
        TEXTAREA: TEXTAREA,
        SIGNATURE: SIGNATURE,
        RATING: RATING,
        STEPPER: STEPPER,
        LIKERTSCALE: LIKERTSCALE
    };

    mstrmojo.DICConfig = $ADC;
    mstrmojo.DICList = $ADC.DICList;
    mstrmojo.DICPopup = $ADC.DICPopup;
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.Button",
                         "mstrmojo.android.medium.ui.CalendarMarkupBuilder",
                         "mstrmojo.android.ui.CalendarDialog",
                         "mstrmojo.android.EnumOrientationTypes");

    var ENUM_MODE_CALENDAR = true,
        DPI = {
            160: {
                YEAR: 80,
                CELL: 40
            },

            240: {
                YEAR: 100,
                CELL: 60
            },

            320: {
                YEAR: 120,
                CELL: 80
            }
        },
        CLEAR_TEXT = mstrmojo.desc(2827, 'Clear');

    
    function cacheElasticHeight() {
        
        if (!this.elasticHeight) {
            
            this.contentList.elasticHeight = parseInt(this.calendar.domNode.offsetHeight, 10);
        }
    }

    
    mstrmojo.android.medium.ui.CalendarDialog = mstrmojo.declare(

        
        mstrmojo.android.ui.CalendarDialog,

        
        null,

        
        {
            scriptClass: "mstrmojo.android.medium.ui.CalendarDialog",

            
            markupBuilder: mstrmojo.android.medium.ui.CalendarMarkupBuilder,

            
            currentViewMode: ENUM_MODE_CALENDAR,

            
            requiredOrientation: mstrmojo.android.EnumOrientationTypes.PORTRAIT,

            
            init: function (props) {
                
                this._super(props);

                var $this = this,
                    calendar = this.calendar,
                    target = calendar.target,
                    dpi = mstrMobileApp.getDeviceDPI();

                
                calendar.layoutConfig.h = {
                    monthNode: (8 * DPI[dpi].CELL) + 'px',
                    yearNode: DPI[dpi].YEAR + 'px'
                };

                
                target.visible = this.currentViewMode !== ENUM_MODE_CALENDAR;
                this.addChildren([target]);
                this._elasticChild = target;

                var cancelButton = this.buttons[0],
                    selectedDates = calendar.selectedDates;

                
                cancelButton.onclick = function () {
                    return $this.getCancelBtnFn();
                };

                
                if (selectedDates && selectedDates.length > 0) {
                    cancelButton.text = CLEAR_TEXT;
                }
            },

            
            touchTap: function touchTap(touch) {
                if (this._super) {
                    this._super(touch);
                }

                var viewMode = !this.currentViewMode,
                    isCalCurrent = viewMode === ENUM_MODE_CALENDAR,
                    contentList = this.contentList,
                    calendar = this.calendar;

                
                this.currentViewMode = viewMode;

                
                if (mstrmojo.dom.contains(this.titleNode, touch.target, true, this.domNode) === true) {
                    
                    cacheElasticHeight.call(this);

                    
                    calendar.set('visible', isCalCurrent);
                    contentList.set('visible', !isCalCurrent);

                    
                    contentList.rowHeight = contentList.rowHeight || -1;

                    
                    calendar.syncListItemsWithSelections(contentList.getSelectedItems());
                }
            }
        }
    );

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo._ValidateSuggestions",
                         "mstrmojo.WidgetList",
                         "mstrmojo.Editor",
                         "mstrmojo.LegacySuggestionList");

    
    mstrmojo.Enum_OIB_States = mstrmojo.hash.copy(mstrmojo._ValidateSuggestions.ENUM_STATES, {
        EDITING: 2,
        ADDING: 3,
        EMPTY: 4
    });

    mstrmojo.Enum_OIB_States_CSS = (function () {
        var STATES = mstrmojo.Enum_OIB_States,
            CSS = {},
            s;

        for (s in STATES) {
            if (STATES.hasOwnProperty(s)) {
                CSS[String(STATES[s])] = s;
            }
        }

        return CSS;
    }());

    var $DOM = mstrmojo.dom,
        $HASH = mstrmojo.hash,
        STATES = mstrmojo.Enum_OIB_States,
        _freeIdCounter = 0,
        _ITEM_ID_FIELD = '_did_',
        KEYS = mstrmojo.Enum_Keys,
        MIN_TEXTINPUT_WIDTH = 80,
        KEY_DELAY = 200;

    function _nextId() {
        return _freeIdCounter++;
    }

    function _isAddingItem(item) {
        return (item && item.state === STATES.ADDING);
    }

    function _emptyItem(t) {
        var item = {
            n: t || '',
            state: STATES.EMPTY
        };

        item[_ITEM_ID_FIELD] = -2;

        return item;
    }

    function _isEmptyItem(it) {
        return (it && it.state === STATES.EMPTY);
    }

    function _isEmpty(w) {
        var items = w.items,
            len = items && items.length;

        if (!len) {
            return true;
        }

        return (len === 1 && _isAddingItem(items[0])) || (len === 2 && _isEmptyItem(items[0]) && _isAddingItem(items[1]));
    }

    function getAddingInput() {
        var ws = this.ctxtBuilder.itemWidgets,
            w = ws[ws.length - 1];

        if (w && w.isAdding) {
            return w;
        }

        return null;
    }

    function getActiveInput() {
        var idx = this.editingIdx;
        if (idx !== null) {
            return this.ctxtBuilder.itemWidgets[idx];
        }

        return getAddingInput.call(this);
    }

    function deactivate() {
        this.isActive = false;

        
        var tx = this.emptyText || '',
            its = this.items;

        
        if (_isEmpty(this) && !_isEmptyItem(its[0]) && (tx.length > 0)) {
            this.add([_emptyItem(tx)], 0);

            
            var ew = this.ctxtBuilder.itemWidgets[0];
            ew.set('shouldEllipsize', true);
            ew.doEllipsize();
        }

        
        var w = getActiveInput.call(this);
        if (w) {
            if (_isAddingItem(w)) {  
                w.domNode.style.display = 'none';
            }
            this.scrollTo(this.items[0]);
            w.blur();
        }
        $DOM.detachEvent(document.body, 'mousedown', this._mousedownHandler);
    }

    function activate() {
        this.isActive = true;

        
        if (_isEmptyItem(this.items[0])) {
            this.remove(0);
        }

        var w = getActiveInput.call(this);
        if (w) {
            
            if (_isAddingItem(w) && !this.isFull) {
                w.domNode.style.display = 'block';
            }

            this.scrollTo(w.data);

            w.focus();
        }

        $DOM.attachEvent(document.body, 'mousedown', this._mousedownHandler);
    }

    

    mstrmojo.ObjectInputBox = mstrmojo.declare(

        mstrmojo.WidgetList,

        [ mstrmojo._ValidateSuggestions ],

        
        {
            scriptClass: 'mstrmojo.ObjectInputBox',

            cssClass: 'mstrmojo-ObjectInputBox',

            
            emptyText: '',

            
            items: null,

            itemField: 'n',

            dynamicVerify: true,

            suggestCount: 10,

            candidates: null,

            makeObservable: true,

            renderOnScroll: false,

            editingIdx: null,

            isActive: false,

            maxObjectCount: null,

            isFull: false,
            
            suggestionListClass: 'mstrmojo.LegacySuggestionList',

            
            acptSugItemOnly: false,

            useKeyDelay: false,

            getSearchPattern: function() {
                var w = getActiveInput.call(this);
                if (w) {
                    return w.getSearchPattern();
                }
                return '';
            },
            
            getSuggestionTarget: function getSuggestionTarget() {
                return this.suggestTarget;
            },

            onsuggestTargetChanged: function onsuggestTargetChanged(evt) {
                this._request_pattern = null; 
            },

            getSuggestionPos: function getSuggestionPos() {
                return this._pop_cfg;
            },

            onSuggestionItemSelect: function onSuggestionItemSelect(it) {
                this.suggestTarget.setItem(it[this.itemField], it, false);
                this.hideSuggestion();
            },

            hideEditButton: function (d) {
                return !!this.noEditButton;
            },

            

            _set_items: function initItems(n, items) {
                items = items || [];

                var maxObjectCount = this.maxObjectCount;
                this.set('isFull', (maxObjectCount && items.length >= maxObjectCount));

                
                if (items.length === 0) {
                    var tx = this.emptyText || '';
                    if (tx.length > 0) {
                        items.push(_emptyItem(tx));
                    }
                }

                
                var addingItem = {
                    n: '',
                    state: STATES.ADDING
                };

                addingItem[_ITEM_ID_FIELD] = -1;

                
                items.push(addingItem);

                
                var w = items[items.length - 1];
                if (w && _isAddingItem(w) && this.maxObjectCount && (this.getSelectedObjects().length >= this.maxObjectCount)) {
                    this.set('isFull', true);
                    
                }

                
                this.itemIdField = _ITEM_ID_FIELD;


                return this._super(n, items);
            },

            add: function add(arr, at) {
                var w = getAddingInput.call(this);

                if (!this.maxObjectCount || this.getSelectedObjects().length < this.maxObjectCount) {
                    this._super(arr, at);
                }

                if (!_isEmpty(this) && _isEmptyItem(this.items[0])) {
                    this.remove(0);
                }

                if (w) {
                    w.adjustInputWidth();

                    if (this.maxObjectCount && (this.getSelectedObjects().length === this.maxObjectCount)) {
                        this.set('isFull', true);
                    }
                }

                
                w.domNode.style.display = 'none';
            },

            remove: function remove(arr) {
                this._super(arr);

                var w = getAddingInput.call(this);
                if (w) {
                    if (this.maxObjectCount && (this.getSelectedObjects().length < this.maxObjectCount)) {
                        this.set('isFull', false);
                    }

                    w.adjustInputWidth();
                }
            },
            preBuildRendering: function(){
                
                if (this.items == null || this.items.length == 0) {
                    this.set('items', []);
                }
                
                if (this._super) this._super();
            },
            postBuildRendering: function postBuildRendering() {
                this._super();

                var me = this,
                    w = getAddingInput.call(me);

                
                if (w) {
                    w.domNode.style.display = 'none';
                }

                this._clickHandler = function () {
                    activate.call(me);
                };

                this._mousedownHandler = function (evt) {
                    if (!me.isActive || me.browserShown) {
                        return;
                    }

                    
                    var s = $DOM.eventTarget(self, evt);
                    if (s && s.parentNode && !$DOM.contains(me.domNode, s, false, document.body) && !$DOM.contains(me.suggestionPopup.domNode, s, false, document.body)) {
                        deactivate.call(me);
                    }

                };

                $DOM.attachEvent(this.domNode, 'click', this._clickHandler);
            },

            nextId: _nextId,

            
            item2textCss: function item2textCss(data) {
                return data.cssClass || '';
            },
            
            
            itemFunction: function itemFunction(item, idx, w) {

                
                item[w.itemIdField] = _nextId();

                var c = new mstrmojo.ObjectItem({
                    parent: w,
                    itemField: w.itemField,
                    cssClass: w.item2textCss(item),
                    data: item
                });

                
                var evts = ['ItemEditBegin', 'ItemEditEnd', 'ItemDeletePrev', 'ItemDelete', 'ItemAdd', 'SuggestionOn', 'SuggestionOff', 'ItemEditing'],
                    len = evts.length,
                    i;

                for (i = 0; i < len; i++) {
                    c.attachEventListener(evts[i], w.id, '_itemChangeHandler');
                }

                return c;
            },

            getSelectedObjects: function getSelectedObjects() {
                if (_isEmpty(this)) {
                    return [];
                }

                var items = this.items,
                    last = items.length - 1;

                if ((last > -1) && _isAddingItem(items[last])) {
                    return items.slice(0, last);
                }

                return items.concat();
            },

            isValid: function isValid() {
                var ws = this.ctxtBuilder.itemWidgets,
                    len = ws && ws.length,
                    i;

                for (i = 0; i < len; i++) {
                    if (!ws[i].isValid()) {
                        return false;
                    }
                }
                return true;
            },

            
            _itemChangeHandler: function (evt) {
                var evtName = evt.name,
                    d = evt.d,
                    idx,
                    len = this.items.length,
                    w;

                switch (evtName) {
                case 'ItemEditBegin': 
                    if (this.editingIdx !== null) {
                        
                        w = getActiveInput.call(this);
                        if (w) {
                            w.blur();
                        }
                    }
                    idx = this.itemIndex(d);
                    this.editingIdx = idx;
                    activate.call(this);
                    break;

                case 'ItemEditEnd'://need to add the addingItem
                    this.editingIdx = null;

                    if (evt.deactivate) {
                        deactivate.call(this);
                    } else {
                        activate.call(this);
                    }

                    w = getAddingInput.call(this);
                    if (w) {
                        w.adjustInputWidth();
                    }
                    break;

                case 'ItemDelete'://need to remove the target item
                    if (this.editingIdx !== null) {
                        
                        w = getActiveInput.call(this);
                        if (w) {
                            w.blur();
                        }
                        this.editingIdx = null;
                    }

                    idx = this.itemIndex(d);
                    this.remove(idx);

                    if (!evt.deactivate) { 
                        this.editingIdx = null;
                        activate.call(this);

                    } else if (!this.isActive) {
                        deactivate.call(this);

                    } else {
                        activate.call(this);

                    }

                    break;
                case 'ItemDeletePrev':
                    if (len > 1) {
                        this.remove(len - 2);
                    }
                    break;

                case 'ItemAdd'://need to add a new item before the addingItem
                    var item = $HASH.copy(evt.d);
                    this.add([ item ], len - 1);
                    if (evt.deactivate) {
                        deactivate.call(this);
                    } else {
                        activate.call(this);
                    }
                    break;

                case 'SuggestionOn':
                    this.set('suggestTarget', evt.target);
                    this._pop_cfg = {
                        target: evt.target,
                        left: evt.l,
                        top: evt.t,
                        zIndex: this.zIndex? this.zIndex : 100
                    };
                    
                    this.showSuggestion(evt.pattern);
                    break;

                case 'SuggestionOff':
                    this.set('suggestTarget', null);
                    this.hideSuggestion();
                    break;
                }

                
                if (this.onitemchange && (evtName === 'ItemEditEnd' || evtName === 'ItemAdd' || evtName === 'ItemDelete' || evtName === 'ItemDeletePrev' || evtName === 'ItemEditing')) {
                    this.onitemchange();
                }
            },

            unrender: function unrender(ignoreDom) {
                var pop = this.suggestionPopup;
                if (pop.hasRendered) {
                    pop.unrender(false);
                }

                if (this._super) {
                    this._super(ignoreDom);
                }
            },

            destroy: function destroy(skipCleanup) {
                var pop = this.suggestionPopup;
                if (pop && pop.hasRendered) {
                    pop.destroy(false);
                }

                if (this._super) {
                    this._super(skipCleanup);
                }
            }
        }
    );

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._HasEllipsis");

    var objectItemCss = 'mstrmojo-ObjectItem-text';

    
    mstrmojo.ObjectItem = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        [mstrmojo._HasEllipsis],
        
        {
            scriptClass: 'mstrmojo.ObjectItem',

            markupString: '<div id={@id} class="mstrmojo-ObjectItem" style="{@cssText}">' +
                              '<div class="mstrmojo-ObjectItem-displayNode"><span class="' + objectItemCss + ' {@cssClass}"></span>' +
                                  '<img class="mstrmojo-ObjectItem-edit" src="../images/1ptrans.gif" title="' + mstrmojo.desc(1088, 'Edit') + '" onclick="mstrmojo.all[\'{@id}\'].edit()"/>' +
                                  '<img class="mstrmojo-ObjectItem-del" src="../images/1ptrans.gif" title="' + mstrmojo.desc(629, 'Delete') + '" onclick="mstrmojo.all[\'{@id}\'].del(arguments[0])"/>' +
                              '</div>' +
                              '<div class="mstrmojo-ObjectItem-editNode"><input type="text" class="mstrmojo-ObjectItem-input" mstrAttach:keyup,keydown/></div>' +
                          '</div>',

            markupSlots: {
                displayNode: function () { return this.domNode.firstChild; },
                editNode: function () { return this.domNode.childNodes[1]; },
                textNode: function () { return this.domNode.firstChild.firstChild; },
                editButtonNode: function () { return this.domNode.firstChild.childNodes[1]; },
                delButonNode: function () { return this.domNode.firstChild.lastChild; },
                inputNode: function () { return this.domNode.childNodes[1].firstChild; }
            },

            markupMethods: {
                oncssClassChange: function () {
                    this.textNode.className = objectItemCss + ' ' + this.cssClass;
                },
                onstateChange: function () {
                    var s = this.state,
                        css = mstrmojo.Enum_OIB_States_CSS[s],
                        dn = this.domNode;

                    if (s === STATES.EMPTY) {
                        dn.innerHTML = '<div class="mstrmojo-ObjectItem-emptyText">' + this.text + '</div>';
                    } else if (s === STATES.EDITING) {
                        var w = Math.round(this.displayNode.clientWidth);
                        this.editNode.style.width = w - 4 + 'px';   
                        this.inputNode.style.width = w - 9 + 'px';  
                    }

                    dn.className = "mstrmojo-ObjectItem " + css;

                    if (this.parent.hideEditButton(this.data)) {
                        this.editButtonNode.style.display = 'none';
                    }
                },
                ontextChange: function () {
                    
                    this.inputNode.value = this.text;
                    this.textNode.innerHTML = mstrmojo.string.encodeHtmlString(this.text);
                }
            },

            state: STATES.VALID,

            onstateChange: function onstateChange(evt) {
                this.data.state = this.state;
            },

            ontextChange: function ontextChange(evt) {
                this.data[this.itemField] = this.text;
            },

            updateData: function updateData(data) {
                $HASH.copy(data, this.data);
                this.set('state', STATES.VALID);
                this.set('text', this.data[this.itemField]);
                this.set('cssClass', this.parent.item2textCss(this.data));
            },

            init: function init(props) {
                this._super(props);

                var d = this.data,
                    s = d.state,
                    p = this.parent;

                if (typeof s === 'undefined') {  
                    s = p.dynamicVerify ? p.verifyObject(d[this.itemField], this) : STATES.UNDETERMINED;
                    d.state = s;
                }

                this.cssClass = p.item2textCss(d);
                this.text = d[this.itemField];
                this.state = s;
                this.isAdding = _isAddingItem(d);
                this.useRichTooltip = true;
            },

            isValid: function isValid() {
                var state = parseInt(this.state, 10);
                return (state !== STATES.INVALID && state !== STATES.UNDETERMINED);
            },

            
            adjustInputWidth: function adjustInputWidth() {
                if (this.isAdding) {
                    var inputNodeStyle = this.inputNode.style;
                    inputNodeStyle.width = MIN_TEXTINPUT_WIDTH + 'px';

                    var wn = this.domNode.parentNode,
                        cw = wn.parentNode.offsetWidth,
                        tw = Math.max(cw - wn.offsetLeft - 20, MIN_TEXTINPUT_WIDTH);  

                    if (!isNaN(tw)) {
                        inputNodeStyle.width = tw + 'px';
                    }
                }
            },

            blur: function blur() {

                this.hideSuggestion();

                
                if (!this.isActive) {
                    return;
                }

                this.isActive = false;

                var n = this.inputNode,
                    t = n.value,
                    p = this.parent;

                window.setTimeout(function () {
                    try {
                        n.blur();
                    } catch (e) { }
                }, 0);

                if (!t) {
                    return;
                }

                
                if (p.acptSugItemOnly) {
                    
                    this.set('text', t);
                    this.set('text', '');

                    this._tWas_ = null;

                    return;
                }

                this.setItem(t, null, true);
            },

            focus: function focus() {
                var ti = this.inputNode,
                    wasActive = this.isActive;

                window.setTimeout(function () {
                    try {
                        ti.focus();
                        if (ti.createTextRange && !wasActive) {  
                            var tr = ti.createTextRange(),
                                len = ti.value.length;

                            tr.move('character', len);
                            tr.select();
                        }
                    } catch (e) { }
                }, 0);

                this.isActive = true;
            },

            
            prekeydown: function prekeydown(evt) {
                var t = this.inputNode.value,
                    k = parseInt(evt.e.keyCode || evt.e.charCode, 10),
                    p = this.parent;

                if (!t) {
                    return;
                }

                if (k === KEYS.TAB || k === KEYS.ENTER) {
                    $DOM.preventDefault(evt.hWin, evt.e);

                    var it = p.getSelected();
                    if (it) {
                        p.handleSuggestionItemSelect(it);

                    } else {
                        this.hideSuggestion();

                        
                        if (!p.acptSugItemOnly) {
                            this.setItem(t, null, false);
                        } else {
                            
                            this.set('text', t);
                            this.set('text', '');
                        }
                    }

                } else if (k === KEYS.DOWN_ARROW) {
                    if (!p.noCache) { 
                        this.showSuggestion(t);
                    }

                    p.nextHighlight();

                } else if (k === KEYS.UP_ARROW) {
                    p.preHighlight();

                }
            },

            
            prekeyup: function prekeyup(evt) {
                var t = this.inputNode.value,
                    k = parseInt(evt.e.keyCode || evt.e.charCode, 10),
                    isAdding = this.isAdding,
                    p = this.parent;

                
                if (!t) {
                    if (isAdding) {
                        if (k === KEYS.BACKSPACE && !this._tWas_) {
                            this.raiseEvent({
                                name: 'ItemDeletePrev'
                            });

                            $DOM.preventDefault(evt.hWin, evt.e); 
                        }

                        this._tWas_ = null;

                    } else {
                        this.raiseEvent({
                            name: 'ItemDelete',
                            d: this.data
                        });
                    }

                    this.hideSuggestion();
                    return;
                }

                
                if (k === KEYS.ESCAPE) {
                    this.hideSuggestion();

                    if (p.acptSugItemOnly) {
                        
                        this.set('text', t);
                        this.set('text', '');
                        this._tWas_ = null;

                        return;

                    }
                } else {
                    if (this._tWas_ !== t) {
                       
                        
                        this.raiseEvent({
                            name: 'ItemEditing',
                            d: this.data
                        });
                        
                        if (p.useKeyDelay) {
                            if (!this._timerID) {
                                var me = this;
                                this._timerID = window.setTimeout(function () {
                                    var value = me.inputNode.value;
                                    if (value) {
                                        me.showSuggestion(value);
                                    }

                                    me._timerID = null;
                                }, KEY_DELAY);
                            }
                        } else {
                            this.showSuggestion(t);
                        }
                    }
                }

                this._tWas_ = t;
            },

            setItem: function (t, data, deactivate) {
                var isAdding = this.isAdding,
                    p = this.parent;

                deactivate = deactivate || false;

                this.set('text', t); 
                this._tWas_ = null;

                if (isAdding) {
                    this.set('text', ''); 

                    if (!data) {
                        data = {};
                        data[this.itemField] = t;
                    } else {
                        data.state = STATES.VALID;
                    }

                    this.raiseEvent({
                        name: 'ItemAdd',
                        d: data,
                        deactivate: deactivate
                    });

                } else {
                    this.set('text', t); 

                    if (data) {
                        this.updateData(data);
                    } else {
                        this.set('state', p.verifyObject(t, this));
                        this.set('cssClass', p.item2textCss(this.data));
                    }

                    this.isActive = false; 

                    this.raiseEvent({
                        name: 'ItemEditEnd',
                        d: data,
                        deactivate: deactivate
                    });
                }
            },

            getSearchPattern: function getSearchPattern() {
                return this.inputNode.value;
            },

            showSuggestion: function showSuggestion(text) {
                var pos = mstrmojo.dom.position(this.domNode, true);

                this.raiseEvent({
                    name: 'SuggestionOn',
                    l: Math.round(pos.x) + 'px',
                    t: Math.round(pos.y + pos.h) + 'px',
                    pattern: text,
                    target: this
                });
            },

            hideSuggestion: function hideSuggestion() {
                this.raiseEvent({
                    name: 'SuggestionOff'
                });
            },

            del: function del(e) {
                e = e || self.event;

                $DOM.stopPropogation(self, e);

                this.raiseEvent({
                    name: 'ItemDelete',
                    d: this.data,
                    deactivate: true
                });

                if (this.useRichTooltip && this.hideTooltip) {
                    this.hideTooltip();
                }
            },

            edit: function edit() {
                this.showSuggestion(this.text);
                this.set('state', STATES.EDITING); 
                this.raiseEvent({
                    name: 'ItemEditBegin',
                    d: this.data
                });
            },

            doEllipsize: function doEllipsize() {
                if (!this.shouldEllipsize) {
                    return;
                }

                var maxItemWidth = this.maxItemWidth,
                    truncatedNode;

                
                if (maxItemWidth) {
                    
                    this.domNode.style.maxWidth = maxItemWidth;

                    
                    switch (parseInt(this.state, 10)) {
                    case STATES.VALID:
                    case STATES.UNDETERMINED:
                    case STATES.INVALID:
                        truncatedNode = this.textNode;
                        break;

                    case STATES.EMPTY:
                        truncatedNode = this.domNode.firstChild;
                        break;
                    }

                    
                    if (truncatedNode) {
                        
                        this.set('richTooltip', {
                            content: this.text,
                            contentNodeCssClass: 'sp-tooltip',
                            posType: mstrmojo.tooltip.POS_TOPLEFT,
                            left: 0,
                            top: 30,
                            refNode: this.domNode
                        });

                        
                        mstrmojo.css.addClass(truncatedNode, 'truncated');
                    }
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.array",
                         "mstrmojo.string",
                         "mstrmojo.elementHelper",
                         "mstrmojo.SimpleObjectInputBox");

    var $ARR = mstrmojo.array,
        $DOM = mstrmojo.dom,
        thousandsSeperator = mstrConfig.thousandsSep;

    
    if (thousandsSeperator === undefined) {
        
        thousandsSeperator = ',';
    }

    var ERR_SDK_E_INVALID = 0x80044033,
        ERR_SDK_E_PROMPT_NUMERICAL_VALUES = 0x80044056,
        ERR_SDK_E_PROMPT_DATE_TIME = 0x8004405D,
        MAX_SUGGESTION_POPUP_HEIGHT = 140;

    var markup;

    mstrmojo.SearchBoxSelectorList = mstrmojo.declare(

        mstrmojo.SuggestionList,

        null,

        {
            getItemMarkup: function (item, idx) {
                
                if (!markup) {
                    
                    markup = this._super(item, idx).replace('>{@' + this.itemField + '}<', '>{@' + this.itemField + '}{@weight}<');
                }

                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    weight = item.wt;

                
                props.weight = (weight) ? '<em>(' + mstrmojo.num.addSeparators(weight, thousandsSeperator) + ' likes)</em>' : '';

                return props;
            }
        }
    );

    
    mstrmojo.SearchBoxSelector = mstrmojo.declare(

        mstrmojo.SimpleObjectInputBox,

        null,

        
        {
            cssClass: 'mstrmojo-SearchBoxSelector',

            srcid: null,

            dataSourcesXML: null,

            maxItemWidth: '',

            suggestionListClass: 'mstrmojo.SearchBoxSelectorList',

            postCreate: function postCreate() {
                var suggestionPopup = this.suggestionPopup;

                
                suggestionPopup.cssClass = 'mstrmojo-SearchBoxSelector-suggest';

                
                suggestionPopup.nudge = function () {
                    
                    var editorNode = this.editorNode;
                    if (!editorNode) {
                        
                        return;
                    }

                    var height = Math.min(editorNode.offsetHeight, MAX_SUGGESTION_POPUP_HEIGHT),
                        width = editorNode.offsetWidth,
                        windowDimensions = $DOM.windowDim(),
                        left = this.left,
                        top = this.top;

                    
                    if (top + height >= windowDimensions.h) {
                        
                        top -= height;
                    }

                    
                    if (left + width >= windowDimensions.w) {
                        
                        left -= width;
                    }

                    
                    var editorNodeStyle = editorNode.style;
                    editorNodeStyle.top = top + 'px';
                    editorNodeStyle.left = left + 'px';
                };
            },

            preBuildRendering: function preBuildRendering() {
                
                
                
                
                this.set('maxItemWidth', this.parent.contentNode.offsetWidth);

                this._super();
            },
            
            postBuildRendering: function postBuildRendering() {
            	var fmts = this.parent.defn.fmts;
            	
            	
            	
            	if (!fmts.height) {
            		this.domNode.style.height = "auto";
            	}
            	return this._super();
            },
            
            
            filterCandidates: function filterCandidates(items, t, max) {
                var filteredCandidates = items,
                    suggestCnt = this.suggestCount;

                if (!this.noCache) {
                    
                    max = max || suggestCnt;
                    t = mstrmojo.string.regEscape(t);

                    var itemField = this.itemField,
                        testExp = new RegExp('^' + t, 'i');

                    filteredCandidates = $ARR.filter(items, function (item) {
                        return testExp.test(item[itemField]);
                    }, {
                        max: max
                    });
                }

                
                if (filteredCandidates.length) {
                    $ARR.forEach(this.items, function (item) {
                        var idx = $ARR.find(filteredCandidates, 'v', item.v);
                        if (idx > -1) {
                            filteredCandidates.splice(idx, 1);
                        }
                    });
                }

                if (filteredCandidates.length >= suggestCnt) {
                    filteredCandidates = filteredCandidates.slice(0, suggestCnt);
                }

                return filteredCandidates;
            },

            getCandidatesThroughTaskCall: function getCandidatesThroughTaskCall(params, callbacks) {
                var id = this.id,
                    targetWas = this.getSuggestionTarget(),
                    searchPattern = params.pattern || '',
                    parent = this.parent,
                    attributeId = this.srcid;

                
                searchPattern = searchPattern.replace(/"/, '');

                
                if (attributeId) {
                    
                    var taskParams = {
                        taskId: 'browseElements',
                        styleName: 'MojoAttributeStyle',
                        attributeID: attributeId,
                        dataSourcesXML: this.dsrc || '',
                        blockCount: this.REQUEST_THRESHOLD,
                        searchPattern: searchPattern,
                        browseFlags: 1
                    };

                    
                    var defn = parent.defn;
                    if (defn.dsid) {
                        taskParams.datasetID = defn.dsid;
                        taskParams.messageID = parent.model.mid;
                        taskParams.ctlKey = parent.ckey;
                    }

                    
                    if (defn.sfid) {
                        
                        taskParams.searchForms = defn.sfid;

                        
                        if (parseInt(defn.sfdt, 10) === 8) {
                            
                            taskParams.searchPattern += '*';
                        }
                    }

                    callbacks.success = function (res) {
                        if (res && res.es) {
                            var box = mstrmojo.all[id],
                                target = box.getSuggestionTarget(),
                                len = res.es.length;

                            if (!res || !target || (targetWas !== target)) {
                                return;
                            }

                            
                            if (len && (len > box.suggestCount)) {
                                return;
                            }

                            var newPattern = target.getSearchPattern(),
                                items = res.es;

                            
                            if (attributeId) {
                                items = mstrmojo.elementHelper.buildElemsTerseID(items, attributeId, true);
                            }

                            var srcPattern = params.pattern;

                            
                            box._last_hit = {
                                items: items,
                                pattern: srcPattern
                            };

                            if (newPattern && newPattern.indexOf(srcPattern) > -1) {
                                box.updateSuggestion(box.filterCandidates(items, newPattern));
                            }
                        }
                    };

                    
                    
                    
                    
                    
                    
                    callbacks.failure = function (res) {
                        var ec = parseInt(res.getResponseHeader('X-MSTR-TaskErrorCode'), 10) + 0x100000000;
                        if (ec !== ERR_SDK_E_INVALID && ec !== ERR_SDK_E_PROMPT_NUMERICAL_VALUES && ec !== ERR_SDK_E_PROMPT_DATE_TIME) {
                            mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                        }
                    };

                    mstrmojo.xhr.request('POST', mstrConfig.taskURL, callbacks, taskParams, false, null, true); 
                }
            },

            onsuggestionItemsChange: function onsuggestionItemsChange() {
                var suggestionItems = this.suggestionItems,
                    popup = this.suggestionPopup,
                    editorNode = popup.editorNode,
                    hasScrollBar = suggestionItems && (suggestionItems.length > 8),
                    height = '',            
                    px = '';                

                
                if (hasScrollBar) {
                    
                    height = MAX_SUGGESTION_POPUP_HEIGHT;
                    px = 'px';
                }

                
                if (editorNode) {
                    
                    editorNode.style.height = height + px;

                } else if (hasScrollBar) {
                    
                    px += ';';

                    
                    popup.cssText = (popup.cssText || '') + 'height:' + height + px;
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.MobileXtab",
                         "mstrmojo.array",
                         "mstrmojo.hash");

    
    function removeStyleSheet() {
        var xtabStyleSheet = this.xtabStyleSheet,
            parentNode =  xtabStyleSheet && xtabStyleSheet.parentNode;

        
        if (parentNode) {
            parentNode.removeChild(xtabStyleSheet);

            
            delete this.xtabStyleSheet;
        }
    }

    
    mstrmojo.AndroidXtab = mstrmojo.declare(
        
        mstrmojo.MobileXtab,

        null,

        
        {
            scriptClass: "mstrmojo.AndroidXtab",

            
            scrollerFriction: 0.0015,

            preBuildRendering: function preBuildRendering() {
                
                removeStyleSheet.call(this);

                
                this.updateXtabStyles(this.model.data.cssString);

                
                this._super();
            },

            
            onwidthChange: function onwidthChange() {
                
                if (this.gridData.afw) {
                    var sbn = this.scrollboxNode,
                        width = this.width;

                    
                    if (sbn) {
                        sbn.style.width = width;
                    } else {
                        this.scrollboxNodeCssText = 'width: ' + width;
                    }
                }

                
                if (this._super) {
                    this._super();
                }
            },

            
            updateXtabStyles: function updateXtabStyles(css) {
                
                if (!this.xtabStyleSheet) {
                    this.xtabStyleSheet = document.getElementsByTagName('head')[0].appendChild(document.createElement('style'));
                }

                
                this.xtabStyleSheet.appendChild(document.createTextNode(css));
            },

            
            unrender: function unrender(ignoreDom) {
                this._super(ignoreDom);

                
                removeStyleSheet.call(this);
            },
            
            getMaskNode: function getMaskNode() {
                var div = document.createElement('div');
                div.appendChild(this.xtabStyleSheet.cloneNode(true));
                div.appendChild(this.domNode.cloneNode(true));
                
                return div;
            },

            
            updateActionMenu: function updateActionMenu(cell, actions) {
                
                this._selectionActions = actions;

                
                return true;
            },

            setModel: function setModel(model) {
                this._super(model);

                
                this.controller.getPageByTree(false);
            },

            deselectCell: function deselectCell() {
                this._super();

                
                delete this._selectionActions;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.maps.androidmap.AndroidMap");

    
    mstrmojo.maps.androidmap.AndroidRptMap = mstrmojo.declare(
        mstrmojo.maps.androidmap.AndroidMap,

        null,

        
        {
            scriptClass: 'mstrmojo.maps.androidmap.AndroidRptMap',

            setModel: function setModel(model) {
                this._super(model);

                
                this.controller.getPageByTree(false);
            }
        }
    );
}());


(function () {
    mstrmojo.requiresCls("mstrmojo.maps.androidmap.AndroidMap",
                         "mstrmojo.maps.androidmap.AndroidDocMapInfoWindow",
                         "mstrmojo.Image",
                         "mstrmojo.DynamicClassFactory",
                         "mstrmojo.Box",
                         "mstrmojo._HasLayout",
                         "mstrmojo.DocPanel",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    var REGULAR_SIZE = 0,
        FULL_SCREEN = 1,
        $H = mstrmojo.hash;
   
    function adjustFormat(fmt) {
    	if (!fmt || !fmt.p_fmts) return fmt;
    	var panel_fmt = fmt.p_fmts;
    	var panel_top = parseInt(panel_fmt.top)||0;
    	var panel_height = parseInt(panel_fmt.height)||0;
    	var height = parseInt(fmt.height)||0;
    	return { top:(panel_top+panel_height-height)+"px",
    		left:panel_fmt.left,
    		width:fmt.width,
    		height:fmt.height,
    		'z-index':panel_fmt['z-index']
    	};
    }
    
    function compareFormats(fmt1, fmt2) {
        if (fmt1 && fmt2) {
        	if (fmt1['z-index']>fmt2['z-index']) return false;
            var x1 = parseInt(fmt1.left),
                y1 = parseInt(fmt1.top),
                w1 = parseInt(fmt1.width),
                h1 = parseInt(fmt1.height),
                x2 = parseInt(fmt2.left),
                y2 = parseInt(fmt2.top),
                w2 = parseInt(fmt2.width)||0,
                h2 = parseInt(fmt2.height)||0;
            return ((((x1 <= x2) && (x2 < x1+w1)) || ((x2 < x1) && (x1 < x2 + w2))) &&
                    (((y1 <= y2) && (y2 < y1+h1)) || ((y2 < y1) && (y1 < y2 + h2))));
        }
        return false;
    }
    
   
      
    
    function registerMapRendering() {
        if( !mstrApp.renderingMap || (mstrApp.renderingMap === this.id) ) {
            mstrApp.renderingMap = this.id;
            return true;
        } else {
            return false;
        }
    }
    
    
    function deregisterMapRendering() {
        if(mstrApp.renderingMap === this.id) {
            delete mstrApp.renderingMap;
            return true;
        }
        return false;
    }
    
    
    mstrmojo.maps.androidmap.AndroidDocMap = mstrmojo.declare(
        mstrmojo.maps.androidmap.AndroidMap,

        [ mstrmojo._Formattable ],

        {
            scriptClass: "mstrmojo.maps.androidmap.AndroidDocMap",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@domNodeCssText}" mstrAttach:touchstart>' +
            			  '</div>',

            formatHandlers: {
                domNode: ['left', 'top', 'z-index', 'height', 'width', 'border', 'border-color', 'border-style', 'border-width' ]
            },

            sc: null,
            
            domNodeCssText:'position:relative;',
            
            lastSelectedRow: null,
            
            hasTarget: function hasTarget() {
                var sc = this.getInfoWindowSelectorControl(this.gridData);
                return !!(sc && sc.tks);
            },

            
            postBuildRendering: function postBuildRendering() {
                
                this._touchListener = mstrmojo.touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                    
                    var openInfoWindow = this.openedInfoWindow;
                    if (openInfoWindow) {
                        
                        if (!$DOM.contains(this.domNode, evt.touch.target, true, document.body)) {
                            
                            openInfoWindow.close();
                        }
                    }
                });

                return this._super();
            },
            
            destroy: function destroy(ignoreDom) {
                
                var listener = this._touchListener;
                if (listener) {
                    
                    mstrmojo.touchManager.detachEventListener(listener);
                    delete this._touchListener;
                }
                if(this.mapRendered) {
                    this.removeMap();
                }
                this._super(ignoreDom);
            },

            setModel: function setModel(d) {
                
                this.doc = d.controller.view;
                this._super(d);
            },
            
            initFromVisProps: function initFromVisProps(vp) {
                this._super(vp);

                if (!vp) {
                    return;
                }

                this.iwDocLayout = (parseInt(vp.dl, 10) === 1);

                
                if (vp.lyt) {
                    this.iwLayoutKey = vp.lyt;
                }
            },

            
            findSelectorTarget: function findSelectorTarget(sc) {
                if (sc && sc.tks) {
                    var dm = this.xtabModel.docModel,
                        targets = sc.tks.split('\u001E'),
                        i = 0,
                        len = targets.length;

                    for (i = 0; i < len; ++i) {
                        var d = dm.getTargetDefn(targets[i]);
                        if (d[targets[i]].ifw) {
                            return targets[i];
                        }
                    }
                }
                return null;
            },

            findIntersectingComponents: function findIntersectingComponents() {
            	var container = this,
            	    skipNode,
            	    fmt = this.getFormats();
            	while (container.scriptClass != "mstrmojo.DocSubsection" || container.scriptClass != "mstrmojo.DocInfoWindow") {
            		skipNode = container;
            		container = container.parent;            		
            		if(!container) {
            		    break;
            		}
            		var children = container.children,
            		    numChild = (children && children.length) || 0,
            		    comp = null,
            		    idx;
            		for (idx = 0; idx < numChild; idx++) {
            			comp = children[idx];
            			
            			
            			if (comp != skipNode && comp.getFormats && compareFormats(adjustFormat(fmt), adjustFormat(comp.getFormats()))) {
            				return true;
            			}
            		}
            		
            	}
            	return false;
            },
            
            getGridModel: function() {
            	var gridModel = this._super();
            	
            	
            	delete gridModel.layoutModel;
            	delete gridModel.layoutNode;
            	return gridModel;
            },
            
            dispatchMapData: function dispatchMapData() {
                
                if(!registerMapRendering.call(this)) {
                    this.domNode.innerHTML = mstrmojo.desc(9480, 'Only one map visualization is supported at a time');
                    mstrmojo.css.addClass(this.domNode, 'noMapVis');
                    return ;
                }
                
                var doc = this.doc,
                	m = doc.model,
                    viewTree = this.getViewHierarchy(),
                    mapModel = this.getMapModel(),
                    gridModel = this.simplifyGridData(),
                    layouts = (doc.getSupportedLayouts && doc.getSupportedLayouts()) || doc.getLayouts(),
                    fullScreen = !!this.isFullScreenWidget? FULL_SCREEN : REGULAR_SIZE,
                    isActive = false,
                    curLyt = doc.getCurrentLayout(),
                    docData;
                
                    docData = JSON.stringify({
                        did: doc.did,
                        ttl: doc.ttl,
                        st: doc.st,
                        mid: m.mid,
                        ci: m.ci,
                        bs: m.bs,
                        zt: m.zt,
                        defn: m.defn,
                        currlaykey: m.currlaykey
                    });
                    
                    
                
                delete mapModel.model;
                
                
                if (curLyt.setMapID){
                    curLyt.setMapID(this.id);
                }
                
                
                if(!fullScreen) {
                	isActive = this.findIntersectingComponents();
                }
                               
                mstrMobileApp.loadMap(JSON.stringify($H.copy({
                	fullScreen: fullScreen,
                	infoWindow: this.getInfoWindowConfig(),
                	viewTree: viewTree,
                	mapPath: this.mapPath,
                	active: isActive,
                	docModelId: this.xtabModel.docModel.id,
                	hasTarget:this.hasTarget(),
                	zt: m.zt,
                	gdProp: gridModel.prop
                }, mapModel)), gridModel.es, gridModel.data, docData);       
                
                
                this.mapRendered = true;
            },
            
            getViewHierarchy: function () {
                
                var mapPath = [];
                
                
                
                
                
                var p = this.parent, w = [], c = $H.copy(this.fmts, {}), me = this;
                w.push(c);
                while(p) {
                    c = $H.copy(p.fmts, {});
                    c.id = p.id;                    
                    mapPath.push(c.id);
                    
                    if(p.scriptClass === "mstrmojo.MobileDocLayoutViewer") {
                        
                        delete c.width;
                        delete c.height;
                    } else if(p instanceof mstrmojo.DocPanel) {
                        
                        
                        var left = parseInt(p.domNode.style.left, 10); 
                        if(left > 0) {
                            p.parent._scrollOffsetLeft = left;
                        }
                    } else if(p.scriptClass === "mstrmojo.DocSection") {
                        
                        
                        
                        if(p.domNode.offsetTop) {
                            c.top = p.domNode.offsetTop + 'px';
                        }
                    } else if(p.scriptClass === "mstrmojo.DocInfoWindow") {
                        
                        
                        if(p.containerNode) {
                            c.top = p.containerNode.offsetTop + 'px';
                            c.left = p.containerNode.offsetLeft + 'px';
                        }
                        
                        p.onClose = function() {
                            mstrMobileApp.hideMapView(1);
                        };
                    }

                    if(p._scroller) {
                        if(!p._scroller.scrollMoveListener) {
                            var scrollerUpdate = function(e) {
                                mstrMobileApp.scrollerUpdated(JSON.stringify({id: this.id,  x: e.x - (this._scrollOffsetLeft || 0) , y: e.y}));
                            };
                            p._scroller.attachEventListener('scrollMoved', p.id, scrollerUpdate);
                            p._scroller.attachEventListener('scrollDone', p.id, scrollerUpdate);
                            p._scroller.attachEventListener('transformAnim', p.id, scrollerUpdate);
                            p._scroller.scrollMoveListener = true;
                        }
                        c.scroller = true;
                    }
                    w.splice(0, 0, c);
                    p = p.parent;
                }
                
                this.mapPath = mapPath.join('') + ':' + JSON.stringify(w);
                return w;
            },            
            
            getInfoWindowConfig: function useDefaultInfoWindow() {
                
                if(!this.iwConfig) {
                    if(this.iwDocLayout) {
                        this.iwConfig = {dft: false};
                    } else {
                        var d = this.gridData,
                            sc = this.getInfoWindowSelectorControl(d);
                        if(sc) {
                            var dm = this.xtabModel.docModel,
                            tgtDefs = dm.getTargetDefn(sc.tks);

                            if(this.findSelectorTarget(sc)) {
                                this.iwConfig = {dft: false};
                                if(tgtDefs && tgtDefs[sc.tks]) {
                                    var fmt = tgtDefs[sc.tks].fmts;
                                    this.iwConfig.size = {
                                        w: parseInt(fmt.width, 10), 
                                        h: parseInt(fmt.height, 10)
                                    };
                                    return this.iwConfig;
                                }
                            }
                        } 
                        this.iwConfig = {dft: true};
                    }
                } 
                
                return this.iwConfig;
            },
           
            
            resetLayout: function resetLayout() {
                
                if (this.iwDocLayout && this.preIWLayout) {
                    this.doc.selectLayout(this.preIWLayout, true, null, true);
                    this.preIWLayout = null;
                }
            },
            
            closeInfoWindow: function closeInfoWindow() {
                
                do{
                    mstrApp.closeDialog();
                } while(mstrmojo.all.mstrMapInfoWindow);
            },
            
            removeMarkerAnchor: function removeMarkerAnchor() {
                var anchor = mstrmojo.all.mstrMapMarkerAnchor;
                if(anchor) {
                    anchor.destroy();
                }
            },
            beforeViewHidden: function beforeViewHidden(isBackOperation) {
            	
            	this.unrender();
            },
            
            handleMarkerSelection: function handleMarkerSelection(ri, ancherX, ancherY) {
                
                this.removeMarkerAnchor();
                
                
                var anchor = mstrmojo.insert({
                    id: 'mstrMapMarkerAnchor',
                    scriptClass: 'mstrmojo.Box',
                    cssText: 'left:' + ancherX + 'px;top:' + ancherY + 'px;position:absolute;z-index:100',
                    width: '1px',
                    height: '1px'
                });
                anchor.render();
                document.body.appendChild(anchor.domNode);
                this.handleMarkerTargetSelection(ri,anchor);
                this.handleMarkerInfoWindowLayoutSelection(ri,anchor);
            },
                
            handleMarkerInfoWindowLayoutSelection: function handleMarkerInfoWindowLayoutSelection(ri,anchor) {
                
                var d = this.gridData,
                    att = d.gts.row[0],
                    attrid = att.id,
                    r = d.ghs.rhs.items[ri],
                    c = r && r.items[0].idx,
                    ths = this,
                    eid = (c >= 0) ? att.es[c].id : -1;
                
              
                if (this.iwDocLayout) {
                    
                    var doc = this.doc,
                        layouts = doc.getLayouts(),
                        lyt = this.iwLayoutKey,
                        layout = layouts[mstrmojo.array.find(layouts, 'k', lyt)],
                        sep = "\x1F",
                        dssXmlTypeAttribute = "12",
                        gbIDs = attrid + sep + dssXmlTypeAttribute + sep + eid;

                    var taskParams = {
                            layoutKey: lyt,
                            groupByIDs: gbIDs,
                            reload: true
                        };
                    
                        
                        if(!this.preIWLayout) {
                            this.preIWLayout = layouts[mstrmojo.array.find(layouts, 'k', this.defn._lkz)];
                        }

                    (function (params, layouts) {
                        var me = doc,
                            model = me.model,
                            dataService = model.getDataService(),
                            key = params.layoutKey,
                            layout = layouts[mstrmojo.array.find(layouts, 'k', key)];  

                        
                        if (layout.defn && (params.reload || layout.defn.loaded === false)) {
                            
                            
                            dataService.loadDocLayout(params, {
                            success: function (res) {
                                var model = ths.xtabModel.docModel,
                                    key = lyt,
                                    newLayout;
                                
                                
                                res.key = key;
                                res.isSelected = false;
                                
                                
                                model.replaceLayout(key, res);
                                
                                newLayout = doc.rebuildLayout(key, layouts);
                                
                                ths.lastSelectedRow = ri;
                                
                                var node = newLayout.node, 
                                    overlay,
                                    dimensions = mstrApp.getScreenDimensions(),
                                    mw = dimensions.w * 0.85,
                                    mh = dimensions.h * 0.9,
                                    dw = dimensions.w * 0.6, 
                                    dh = dimensions.h * 0.5, 
                                    w = node.defn.fmts.width || (dw + 'px'),
                                    h = node.defn.fmts.height || node.data.mh || (dh + 'px'); 
    
                                ths.closeInfoWindow();
                                
                                overlay = new mstrmojo.Overlay({
                                    cssClass: 'iwOverlay',
                                    children: [newLayout]
                                });

                                
                                overlay.set('width', w);
                                overlay.set('height', h);
                                mstrApp.showPopup({
                                    id: 'mstrMapInfoWindow',
                                    cssClass: 'mapInfoWindow',
                                    scriptClass: 'mstrmojo.android.Popup',
                                    anchorOffset: 1,
                                    onClose: function() {
                                        window.setTimeout(function(){
                                            ths.resetLayout();
                                        }, 0);
                                    },
                                    
                                    resizeDialog: function() {
                                        var editorNode = this.editorNode; 
                                        
                                        
                                        if (mstrApp.isTablet()) {
                                            
                                            var popDimensions = this.popDimensions;
                                            if (popDimensions) {
                                                mh = popDimensions.h;
                                                mw = popDimensions.w;
                                            } else {
                                                
                                                mh = Math.min(488, mh);
                                                mw = Math.min(550, parseInt(w, 10));
                                            }
                                        }
                                        
                                        
                                        this.set('width', Math.min(parseInt(w, 10), mw) + 'px');
                                        
                                        
                                        if(editorNode) {
                                            editorNode.style.height = Math.min(parseInt(h, 10), mh) + 'px';
                                        }
                                        
                                        mstrmojo.Dialog.prototype.resizeDialog.call(this);
                                    },
                                    children: [overlay]
                                }, anchor.domNode);
                                
                                var INTERVAL = 300,
                                    t = 0,
                                    ti = window.setInterval(function () {
                                        var n = overlay.parent.editorNode;
                                        if (n) {
                                            var ow = n.clientWidth,
                                                oh = n.clientHeight;
                                            if (ow !== parseInt(w, 10) || oh !== parseInt(h, 10)) {
                                                overlay.setDimensions(oh + 'px', ow + 'px');
                                                window.clearTimeout(ti);
                                            }
                                        }
                                        t += INTERVAL;
                                        
                                        
                                        if (t > 10 * INTERVAL) {
                                            window.clearTimeout(ti);
                                        }
                                    }, INTERVAL); 
                                
                                doc.selectLayout(layout, true);
                                }
                            });
                        } else {
                            
                            me.selectLayout(layout, true);
                        }
                    })(taskParams, layouts);
                }
            },
            handleMarkerTargetSelection:function handleMarkerTargetSelection(ri,anchor){
            	var d = this.gridData,
                    att = d.gts.row[0],
                    attrid = att.id,
                    r = d.ghs.rhs.items[ri],
                    c = r && r.items[0].idx,
                    ths = this,
                    eid = (c >= 0) ? att.es[c].id : -1;
                
                
                var sc = this.getInfoWindowSelectorControl(d),
                    firstInfoWinKey = this.findSelectorTarget(sc);
    
                if (sc && sc.tks) {
                    var dataCacheUpdate = null,
                        dm = ths.xtabModel.docModel;

                    
                    dm.getDataService().setDocSelectorElements(sc.ck, eid, sc.ckey, sc.include, {
                        success: function (res) {

                            
                            var tgtDefs = dm.getTargetDefn(sc.tks);

                            
                            if (res.pukeys) {
                                tgtDefs = dm.getTargetDefn(res.pukeys);
                            }

                            
                            
                            
                            dataCacheUpdate = dm.updateDataCache(res.data, tgtDefs);

                            var firstInfoWinKey = ths.findSelectorTarget(sc);
                            
                            
                            if(firstInfoWinKey) {
                                var targetDef = dm.getTargetDefn(firstInfoWinKey),
                                    id = firstInfoWinKey + "_ifw",
                                    w = mstrmojo.all[id],
                                    psId = "*l" + res.currlaykey + "*k" + firstInfoWinKey + "*x1*t" + dm.buildTime;
    
                                
                                if (w) {
                                    w.destroy();
                                }
    
                                var ifw = new mstrmojo.maps.androidmap.AndroidDocMapInfoWindow({
                                    id: id,
                                    builder: ths.doc.builder,
                                    model: dm,
                                    psKey: firstInfoWinKey,
                                    psId: psId
                                });
                            
                             
                                var fmts = targetDef[firstInfoWinKey].fmts,
                                    iw = parseInt(fmts.width, 10) || width,
                                    ih = parseInt((fmts.p_fmts && fmts.p_fmts.height) || fmts.height, 10) || height;
    
                                ifw.set('width', iw + 'px');
                                ifw.set('height', ih + 'px');
                                
                                mstrApp.showPopup({
                                    id: 'mstrMapInfoWindow',
                                    scriptClass: 'mstrmojo.android.Popup',
                                    cssClass: 'mapInfoWindow',
                                    anchorOffset: 1,
                                    children: [ifw],
                                    resizeDialog: function() {
                                        var editorNode = this.editorNode;
                                        
                                        this.set('width', iw + 'px');
                                        
                                        
                                        if(editorNode) {
                                            editorNode.style.height = ih + 'px';
                                        }
                                        
                                        mstrmojo.Dialog.prototype.resizeDialog.call(this);
                                    }
                                }, anchor.domNode);
                            }
                            
                            
                            
                            var ue = {
                                name: 'partialUpdate',
                                tree: res.data,   
                                ids: dataCacheUpdate,
                                anchor: anchor.domNode
                            };

                            
                            if (!mstrmojo.hash.isEmpty(ue.ids.ifws)) {
                                
                                delete ue.ids.ifws[firstInfoWinKey];
                            }
                            
                            
                            dm.raiseEvent(ue);
                        }
                    }, dm.zf, true);
                } 
            },
            
            getInfoWindowSelectorControl: function getInfoWindowSelectorControl(d) {
                if (!this.sc && !d.eg) {
                    
                    this.sc = d.gts.row[0].sc;
                }
                return this.sc;
            },
            
            afterViewVisible: function afterViewVisible() {
                window.setTimeout(function() {mstrMobileApp.showMapView(1);},300);
            },
            
            removeMap:function removeMap() {
            	 
                this.closeInfoWindow();
                
                this.removeMarkerAnchor();
                
                
                
                
                
                
                
                
                
                
                
                
                this.resetLayout();
                
                
                if(deregisterMapRendering.call(this)) {
                    
                    mstrMobileApp.hideMapView(1);
                } 
            },
            
            unrender: function() {
                this.lastSelectedRow = null;
                this._super();
            }
        }
    );
}());
(function() {

	mstrmojo.requiresCls(
						"mstrmojo.VisChart",
						"mstrmojo.locales"
						);

	
	
	
	var ROTATE_X_ADJUST = 20;
	var ROTATE_Y_ADJUST = -20;

	
	var PLAIN_Y_ADJUST = 25;

	var $H = mstrmojo.hash;
	
	var prevDate = null; 

	
	mstrmojo.VisChartLine = mstrmojo.declare(
			
			mstrmojo.VisChart,

			
			null,

			
			{
				 
				scriptClass: 'mstrmojo.VisChartLine',

				
				fillinColor: null,

				
				rotateXLabels: false,

				
				isFillLinesArea: null,

				
				isAnimateLines: true,

				
				isDrawStartEndPoints: 0,

				
				startEndPointRadius: 5,

				
				startPointColor: null,

				
				endPointColor: null,

				
				prevLines: null,

				
				chartLineColors: ['#0099FF', '#FFB03C', '#F26AE1', '#888BF4', '#93CA20', '#FE2F68'],

				
				maxXLabels: 6,
				
				
				DSS_XML_BASE_FORM_DATE : "8",
				
				            
				drawChart: function drwchrt() {
					
					var model = this.model;
					if(model.err) {
						return;
					}

					
					var context = this.animationContext,
					mvalues = model.mvalues,
					values = model.series,
					margin = this.margin,lines = [],linesFrom = [],
					height = this.getHeight(),
					width = this.getWidth(),
					me = this,
					utils = this.utils;

					if (!values) return; 

					var vl = values.length;

					if(this.isDrawAxis && this.drawYAxisLabels) {
						margin.l = utils.getLabelWidthForMargin(this,model.mls);
					}

					
					me.RTY = (height - margin.t - margin.b - 5) / (mvalues[mvalues.length - 1] - mvalues[0]);
					me.RTX = (width - margin.l - margin.r - 1) / (me.windowSize - 1);

					var mn = (mvalues[0] + mvalues[mvalues.length - 1]) / 2;
					var mnY = utils.getYValue(me, mn); 
					
					for(var j = 0; j < vl; j++) {
						lines = [];
						var k = 0;
						for (var i = 0; i < me.windowSize; i++) {
							var val = values[j].rv[i];
							if(val.length === 0) continue;

							lines[k] = {x:(i * me.RTX) + margin.l, y:utils.getYValue(me, val)};

							if (!this.prevLines) {
								
								linesFrom[k] = {x:lines[k].x, y:mnY};
							}
							k++;
						}

						this.drawChartLine(lines, linesFrom, vl, j, context);

						if(!this.multiLine) break; 
					}

					this.prevLines = lines;

			},

			drawChartLine: function drwcl(lines, linesFrom, vl, si, context, lw) {

				var me = this, 
					height = me.getHeight(),
					utils = me.utils;

				
				var cfg = {
						rate: 6
				};

				context.strokeStyle = utils.getColor(me);
				context.lineCap = 'round';
				context.lineWidth = lw || 2;
				context.lineJoin = 'round';

				if(me.isAnimateLines && (!me.multiLine || vl === 1 )) {
					if (me.prevLines) {
						linesFrom = me.prevLines;
						
						if (linesFrom.length < lines.length) {
							for (var i = linesFrom.length; i < lines.length; i++) {
								linesFrom.push(lines[linesFrom.length-1]);
							}
						}
					}

					
					utils.animateLineSet(me, me.prevLines || linesFrom, lines, cfg);
				} else {

					if(me.multiLine && vl > 1) {
						context.strokeStyle = me.chartLineColors[si % 6];
					}

					
					utils.drawLineSet(me, lines, false, context);

					if(me.isFillLinesArea) {
						utils.fillLinesArea(me,lines.slice(0));
					}

					if(me.isDrawStartEndPoints ) {
						utils.drawStartEndPoints(me, lines, context, me.isDrawStartEndPoints);
					}
				}

			},

			
			setMicroChartProperties: function setMicroChartProperties() {
				this.isDrawAxis = false;
				this.margin = {t:0, r:5, b:0, l:5};
				this.showHighlightLine = false;
				this.isDrawStartEndPoints = 3;
			},
			
			initFromVisProps: function initFromVisProps(vp) {
				if(!vp) return;
				
				if(vp.thc) {
					this.themeColor = "#" + vp.thc;
				}
				
				if(vp.shl === "0") {
					this.showHighlightLine = false;
				}
				
				if(vp.mc === "1") {
					this.setMicroChartProperties();
				}
			},
			
			 
			postCreate: function pstCrt() {
				if (this._super) {
					this._super();
				}

				if (this.rotateXLabels) {
					this.margin.b = 75;
				}

				
				if(typeof(this.isFillLinesArea) === 'undefined' && !this.multiLine) {
					this.isFillLinesArea = true;
				}
			},
			
			
			drawLabels: function drwlbls(needNotDrawVerticalGridLine) {					
				
				if (!this.isDrawAxis) return;            	

				if (this._super) {
					
					this._super();
				}

				if(!this.drawXAxisLabels) return;
				
				
				var me = this,
					cat = me.model.categories,
					labels = cat.items,
					tp = cat.tp,
					utils = me.utils,
					mg = me.margin,
					l = labels.length,
					li = null,
					x = null,
					y = 0,
					lbl = null,
					ts = me.isTimeSeries,
					ctx = me.animationContext,
					dgl = me.drawGridLines;

				
				var pxl = me.prevXLabel;
				pxl.x = 0;
				pxl.y = 0;
				pxl.w = 0;

				ctx.save();
				
				ctx.globalAlpha = 1;
				ctx.strokeStyle = utils.rgb2rgbStr(me.formatProp.textClr, 0.35);
				ctx.lineWidth = 1;
				ctx.lineCap = 'round';

				
				var totalLabels = l > me.maxXLabels ? me.maxXLabels : l;
				
				var xlblDiv = null;
				
				
				if(ts) {
					xlblDiv = document.createElement("div");
					me.xdiv = xlblDiv;

					
					totalLabels *= (me.totalChartWidth/(me.chartWidth));
				} 

				
				if(me.rotateXLabels) {
					y = me.canvas.height + ROTATE_Y_ADJUST;
				} else {
					if(ts){
						
						y =  me.canvas.height - this.margin.b + 5;
					}else{
						y =  me.canvas.height - PLAIN_Y_ADJUST;
					}

				}
				
				var labInterval = Math.round(l / totalLabels);
				
				if(labInterval === 0) {
					labInterval = 1;
				}
				
				var lw = Math.round(labInterval * me.RTX) - me.xLabelPadding;
					
				prevDate = null;
				var curPrevDate = {mn:0,dt:0,yr:0};
				if(ts){
					
					var labelDisplayStatus = -1;
					this.needRedrawVerticalLine = false;
					for(var i = me.ACrns; i < me.ACrne; i+=labInterval) {
						x = ((i - me.ACrns) * me.RTX);
						var dtlbl = labels[i];
						if(labelDisplayStatus < 0 && i >= me.model.rns){
							
							labelDisplayStatus = 0;
						}
						if(ts && (tp.toString() === me.DSS_XML_BASE_FORM_DATE)) {
							
							if(labelDisplayStatus == 0){
								prevDate = null;
								labelDisplayStatus = 1;
							}
							dtlbl = me.getFormattedDateLabel(dtlbl, curPrevDate);
							
						}
						
						if (me.rotatXLabels) {
							lbl = utils.addLabel(me, dtlbl, x - ROTATE_X_ADJUST, y, null, true, pxl);
						} else {
							lbl = utils.addLabel(me, dtlbl, x , y, null, false, pxl);
						}
						
						if(lbl) {
							if(dgl & me.drawVerticalGridLines) {
								prevDate = $H.clone(curPrevDate);
								if(!needNotDrawVerticalGridLine){
									var xPos = Math.floor(x) + 0.5;
									utils.drawLineSet(me,[{x:xPos,y:me.canvas.height - mg.b},{x:xPos, y:mg.t}], false, ctx);
								}
							}
						}

					}
					
				}else{
				
					for(var i = 0; i < l; i+=labInterval) {
						x = (i * me.RTX) + mg.l;
						var dtlbl = labels[i];
						if(ts && (tp.toString() === me.DSS_XML_BASE_FORM_DATE)) {
							dtlbl = me.getFormattedDateLabel(dtlbl, curPrevDate);
						}
						
						if (me.rotateXLabels) {
							lbl = utils.addLabel(me, dtlbl, x - ROTATE_X_ADJUST, y, null, true, pxl);
						} else {
							lbl = utils.addLabel(me, dtlbl, x, y, lw, false, pxl);
						}
						
						if(lbl) {
							if(dgl & me.drawVerticalGridLines) {
								prevDate = $H.clone(curPrevDate);
								utils.drawLineSet(me,[{x:x,y:me.canvas.height - mg.b},{x:x, y:mg.t}], false, ctx);
							}
						}
					}
				}
				
				
				
				if(xlblDiv) {
					if(this.isTimeSeries){
						
						me.xLabelsDiv.innerHTML = xlblDiv.innerHTML;
						
						me.xdiv = null;
						
					}else{
						var tc = me.animationCanvas;
						me.itemsContainerNode.innerHTML = xlblDiv.innerHTML;
						me.itemsContainerNode.insertBefore(tc, me.itemsContainerNode.firstChild);
						me.xdiv = null;
						
					}
					
				}
				
				ctx.restore();
			},

			
			getFormattedDateLabel: function getFormattedDateLabel( val, cpv) {
				if(isNaN(val)) {
					return val;
				}
				
				var fVal = val;
				try {
					val = this.utils.convertRawValueToMilliseconds(val);
					var dt = new Date(Number(val));
					var mn = cpv.mn = mstrmojo.locales.datetime.MONTHNAME_SHORT[dt.getMonth()];
					var yr = cpv.yr = dt.getFullYear().toString().substring(2);
					cpv.dt = dt.getDate();
					
					if(!prevDate || (mn !== prevDate.mn && yr !== prevDate.yr)) {
						fVal = mn + " " + cpv.dt + " " + yr;
					} else if(mn !== prevDate.mn) {
						fVal = mn + " " + cpv.dt;
					} else {
						fVal = cpv.dt;
					}
				} catch(e) {
				}
				return fVal;
			},

			removeLabels: function rmvlbls() {
				
				var todel = this.domNode.getElementsByClassName('mstrmojo-Chart-lbl');
				for (var i = todel.length - 1; todel && i >= 0; i--) {
					todel[i].parentElement.removeChild(todel[i]);
				}
				
			},

			
			highlightPoint: function hghlghtpnt(x, touchY) {

				
				var me = this,
				ctx = me.highlightContext,
				height = me.getHeight(),
				margin = me.margin,
				model = me.model,
				utils = me.utils,
				si = me.seriesIndex;

				
				var xcoord = (x * me.RTX) + margin.l;
				if (this.prevHighlight >= 0) {
					var prevXCoord = (this.prevHighlight * me.RTX) + margin.l;
					var PADDING = 10;
					var TOP_PADDING = 8;
					var y = margin.t-TOP_PADDING > 0 ?  margin.t-TOP_PADDING : 0; 
					ctx.clearRect(prevXCoord-PADDING, y , prevXCoord + PADDING, height - margin.b);					
				}		

				if (x < 0) return;

				var xcoord = (x * me.RTX) + margin.l;

				ctx.shadowBlur    = 5;
				ctx.shadowColor   = '#000';
				ctx.globalAlpha = 1;

				if(me.showHighlightLine) {
					
					ctx.strokeStyle = this.highlightColor;
					ctx.fillStyle = this.highlightColor;
					ctx.lineWidth = 2;
					ctx.lineCap = "round";				

					
					utils.drawLineSet(me, 
							[ {x:xcoord, y:margin.t},
							  {x:xcoord, y:height - margin.b}
							], false, ctx);
				} else {
					ctx.strokeStyle = utils.getColor(me);
					ctx.fillStyle = ctx.strokeStyle;
				}

				var s = model.series,
				l = s.length,
				y = utils.getYValue(me, s[si].rv[x]);

				
				if(!me.multiLine) {
					utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);
				} else {
					if(me.showHighlightLine) {
						if(l > 1) {
							ctx.strokeStyle = this.chartLineColors[0];
							ctx.fillStyle = ctx.strokeStyle;
						}
						for(var i = 0; i < l; i++) {
							ctx.strokeStyle = this.chartLineColors[i % 6];
							if(i > 0) {
								ctx.fillStyle = ctx.strokeStyle;
							}
							y = utils.getYValue(me, s[i].rv[x]);
							utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);
						}
					} else {
						if(l > 1) {
							ctx.strokeStyle = this.chartLineColors[si];
							ctx.fillStyle = ctx.strokeStyle;
						}
						utils.drawArc(me, xcoord, utils.getYValue(me, s[si].rv[x]), 5, 0, Math.PI * 2, true, true, ctx);
					}
				}
			},

			refreshChart: function refreshChart() {
				
				var height = this.getHeight(),
					width = this.getWidth();
				this.highlightContext.clearRect(0, 0, width, height);    
				this.animationContext.clearRect(0, 0, width, height);

				
				this.removeLabels();

				
				this.drawChart();

				
				this.drawLabels();
			}
		}
	);

})();
(function() {

	mstrmojo.requiresCls("mstrmojo.VisChart");

	var DEFAULT_DARK_THEME = 1;
	var DEFAULT_LIGHT_THEME = 2;
	var CUSTOM_DARK_THEME = 3;
	var CUSTOM_LIGHT_THEME = 4;


	mstrmojo.VisMicroChartBar = mstrmojo.declare(

			mstrmojo.VisChart,

			null,

			{

				scriptClass: 'mstrmojo.VisMicroChartBar',


				isDrawAxis: false,


				margin:{t:0, r:1, b:0, l:1},


				showHighlightLine: false,


				themeColor: '#FFFFFF',


				noBackground: true, 


				isAnimateLines: false,


				toolTipMain: null,

				labelLen: 0,

				mainWidth: 0,


				mainLeftPos: 0,

				markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};position:relative;" ' +
				' mstrAttach:mousedown,mouseup,mousemove,click ' +
				'><canvas width="{@width}" height="{@height}"></canvas>' +
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
				'<div style="position:absolute;left:0px;top:0px;padding-left:1px;padding-top:1px;text-align:left;-webkit-text-size-adjust: none"></div>' +
				'<div style="position:absolute;left:0px;bottom:0px;padding-left:1px;padding-bottom:1px;text-align:left;-webkit-text-size-adjust: none"></div>' +
				'</div>',

				
				markupSlots: {
					
					canvas: function(){ return this.domNode.firstChild; },
					animationCanvas: function(){ return this.domNode.childNodes[1]; },
					highlightCanvas: function(){ return this.domNode.childNodes[2]; },
					minLabel: function(){ return this.domNode.childNodes[3];},
					maxLabel: function(){ return this.domNode.childNodes[4];}
				},

				postBuildRendering: function postBR() {
					if (this._super) {
						this._super();
					}
					
					this.windowSize = this.model.series[0].rv.length;
	                if (this.windowSize === 1) {
	                	this.plot();
	                }

				},


                
                 getTouchValue: function gtvlindx(touchX) {
                    var series = this.model.series[0];
                    var ind = 0;
                    for (var i = 0; i < series.v.length; i++) { 
                        if (touchX < this.hightLightPos[i].x) {
                            if (i === 0) {
                                ind = i;
                            } else {
                                ind = (this.hightLightPos[i].x + this.hightLightPos[i - 1].x)/2 > touchX? (i - 1): i;
                            }
                            break;
                        }
                    }
                    if (i !== series.v.length) {
                    } else {
                        ind = i - 1;
                    }
                    return ind;
				},


                
                isTouchPointInGraphRange: function tpInGR(touchX, touchY){
                    if (touchX <= this.labelLen + 1 || touchX >= this.getWidth() - 1 ) {
                        return false;
                    }
                    return true;
                },

                
				showTooltip: function rndrttp(pageX, pageY) {
					if(!this.config.mbShowTooltip || this.noDataToShowTtp) {
						return false;
					}

                    var m = this.model,
                        series = m.series[0];

                    if(series.rv.length <= 1){
                        return false;
                    }

					var pos = mstrmojo.dom.position(this.domNode, true);
					var touchX = pageX - pos.x;
					var touchY = pageY - pos.y;

                    if(!this.isTouchPointInGraphRange(touchX, touchY)){
                        return false;
                    }


                    var touchVal = this.getTouchValue(touchX, touchY);



                    var x =  this.hightLightPos[touchVal].x;
                    
                    if(this.widget.enableSmoothScroll){
                        if(this.domNode.offsetLeft + x < this.widget._scroller.origin.x){
                            return false;
                        }
                    }

                    this.prevHighlight = this.currentHighlight;
                    this.currentHighlight = touchVal;

                    
                    
                    if(!this.widget.tooltipShow || this.prevHighlight != this.currentHighlight){

                        touchX = Math.round(this.hightLightPos[touchVal].x);
                        touchY = Math.round(this.hightLightPos[touchVal].y);

                        var vl = series.rv[touchVal] * 1.0;
                        var tColor = this.posBarColor;
                        if(vl < 0) {
                            tColor = this.negBarColor;
                        }
                        if(series.thClr && series.thClr[touchVal]){
                            
                            tColor = series.thClr[touchVal];
                        }

                        this.renderTooltip(touchVal, x, touchY, tColor);
                        this.highlightPoint(touchX, touchY, tColor);
                    }
                    return true;
                },

                renderTooltip: function rndrttp(valIndex, touchX, touchY, tColor) {
                    var model = this.model;
                    var barProps = this.config;
                    var series = model.series[0],
                        categories = model.categories.items,
                        width = this.getWidth();
                    var metrics = model.mtrcs;
                    metrics = metrics.items;
                    var ttp = this.toolTipMain;

					var line1 = model.categories.tn + ": " + categories[valIndex];
					if(isNaN(this.kpiOffset)) {
						this.kpiOffset = 0;
					}

					if(this.widget.sparklineProps.mstrAssMetric)
						line2 = this.widget.sparklineProps.mstrAssMetric + ": " + series.v[valIndex];
					else
						line2 = metrics[this.kpiOffset] + ": " + series.v[valIndex];

					var maxLength = this.widget.getTextWidthByCanvas(line1, ttp);
					var leng2 = this.widget.getTextWidthByCanvas(line2, ttp);
					if(leng2 > maxLength) {
						maxLength = leng2;
					}
					var domHtml =  line1 + '<br/>' + line2;

					if(this.refv && this.refv.length > 1 && this.config.mbRefLine) {
						domHtml += "<br/>";

						var line3 = metrics[this.kpiOffset + 1] + ": " + this.refv[1].v;
						var leng3 = this.widget.getTextWidthByCanvas(line3, ttp);
						if(leng3 > maxLength) {
							maxLength = leng3;
						}
						domHtml += line3;
					}
					ttp.innerHTML = '<div style="margin-left:5px;margin-bottom:4px;margin-top:5px;">' + domHtml + "</div>";

					

                    var pos = mstrmojo.dom.position(this.domNode, true);
					var posWdt = mstrmojo.dom.position(this.widget.domNode, true);
					var oft =  {
							left: pos.x - posWdt.x,
							top: pos.y - posWdt.y
					};

					var maxWidth = maxLength + 10;
					ttp.style.display = 'block';
					ttp.style.borderColor = tColor;
					ttp.style.width = maxWidth + "px";

					var topOff = (touchY + pos.y - posWdt.y - ttp.offsetHeight - 29);
					if(topOff < 0) {
						topOff = 0;
					}
					var leftOff = (oft.left + touchX + maxWidth + 20);
					if(leftOff > this.widget.getWidth()) {
						leftOff = (touchX + oft.left  - maxWidth - 20);
						if(leftOff < 0) {
							leftOff = 0;
						}
					} else {
						leftOff -= maxWidth;
					}
					ttp.style.display = 'none';
					ttp.style.top = (topOff) + "px";
					ttp.style.left = (leftOff) + "px";
					ttp.style.display = 'block';

				},

				highlightPoint: function highlightPoint(touchX, touchY, tColor){







                    var ctx = this.highlightContext,
                        width = this.getWidth(),
                        height = this.getHeight(),
                        utils = this.utils;


                    ctx.clearRect(0, 0, width, height);
                    ctx.globalAlpha = 1;

                    touchX = touchX > 5 ? touchX : 5;
                    if(touchX > width - 5) {
                        touchX = width - 5;
                    }
                    touchY = touchY > 5 ? touchY : 5;
                    if(touchY > height - 5) {
                        touchY = height - 5;
                    }
                    ctx.globalAlpha = 0.8;
                    ctx.strokeStyle = "FFFFFF";
                    ctx.fillStyle = ctx.strokeStyle;
                    utils.drawArc(this, touchX, touchY, 5, 0, Math.PI * 2, true, true, ctx);

                    ctx.strokeStyle = tColor;
                    ctx.fillStyle = ctx.strokeStyle;

                    ctx.globalAlpha = 1.0;
                    utils.drawArc(this, touchX, touchY, 5, 0, Math.PI * 2, true, false, ctx);
                    utils.drawArc(this, touchX, touchY, 2.5, 0, Math.PI * 2, true, true, ctx);
                    this.highlightCanvas.id = "highLightCav" + this.widget.domNode.id;
				},

				textLen: function txtLn(str) {
					
					var len = 0;
				    for (var i = 0; i < str.length; i++) {
				        if (str.charCodeAt(i) > 255 || str.charCodeAt(i<0)) len += 2; else len ++;
				    }
				    return len;
				},

				handleTouchMove: function () {
					
				},

				reDrawChart: function reDrwchart(){
					var context = this.context,
						canvas = this.canvas,
						wd = canvas.width,
						ht = canvas.height;
					context.clearRect(0,0, wd, ht);
					this.data.processLinearData(this);
					 
	                this.windowSize = this.model.series[0].rv.length;
	              
					this.utils.fillBackground(this);

					if(this.windowSize < 1) {
						return; 
					}
					this.drawChart();
				},

				setColorByTheme: function setColorByTheme(){
					var barProps = this.config;
					if(this.theme == DEFAULT_DARK_THEME || this.theme == DEFAULT_LIGHT_THEME){
						this.posBarColor = "#598200";
						this.negBarColor = "#CC3A06";

						this.xAxisLineWidth = 1;
						this.xAxisLineColor = "#7F7F7F";
						this.refLineWidth = 1;
						this.refLineColor = "#00A6EF";
					}else{
						this.posBarColor = barProps.mwPosCol;
						this.negBarColor = barProps.mwNegCol;

						this.xAxisLineWidth = 1;
						this.xAxisLineColor = "#000000";
						this.refLineWidth = 1;
						this.refLineColor = barProps.mwRefLineCol;
					}
				},

				drawChart: function drwchrt() {

					var model = this.model;
					var barProps = this.config;
					if(model.err) {
						this.noDataToShowTtp = true;
						return;
					}

					this.setColorByTheme();

					var context = this.context,
					values = model.series,
					height = this.getHeight(),
					width = this.getWidth(),
					me = this,
					utils = this.utils;
					var barOffset = 0;
					var barPadLeft = this.margin.l;
					var barPadRight = this.margin.r;

					var min = 0,
						max = 0,
						minLabel = maxLabel = "",
						series = model.series[0];

					for (var i = 0; i < series.v.length; i ++) {
						var vl = parseFloat(series.rv[i]);
						if (i === 0) {
							max = min = vl;
							minLabel = maxLabel = series.v[i];
						} else if(vl > max) {
							max = vl;
							maxLabel = series.v[i];
						} else if(vl < min) {
							min = vl;
							minLabel = series.v[i];
						}
					}

					if(isNaN(min) && isNaN(max)){
						
						this.minLabel.innerHTML = "";
						this.maxLabel.innerHTML = "";
						this.noDataToShowTtp = true;
						return;
					}

					this.noDataToShowTtp = false;

					if (barProps.mbShowLegend) { 
						var fontSize = Math.ceil(Math.min(12, (height / 2) * 0.7));  
						var mintxt = "Min:" + minLabel.replace(/[ ]/g, "");
						var maxtxt = "Max:" + maxLabel.replace(/[ ]/g, "");

						this.minLabel.innerHTML = mintxt;
						this.maxLabel.innerHTML = maxtxt;

						
						var maxBarOffset = width - 10;
						if(maxBarOffset > width * 0.5){
							maxBarOffset = Math.floor(width*0.5);
						}
						do {
							this.minLabel.style.fontSize = fontSize + "px";
							this.maxLabel.style.fontSize = fontSize + "px";
							var fontFamily = "Arial";
							var minTxtLen = this.widget.getTextWidth(mintxt, "", fontFamily, fontSize, "px", this.isTextBold);
							var maxTxtLen = this.widget.getTextWidth(maxtxt, "", fontFamily, fontSize, "px", this.isTextBold);
							var txtLen = minTxtLen > maxTxtLen? minTxtLen: maxTxtLen; 
							barOffset = txtLen + barPadLeft;
							fontSize -= 1;
						} while ( barOffset > maxBarOffset && fontSize > 5); 
						fontSize += 1;
					} else {
						barOffset = barPadLeft;
					}

					this.labelLen = barOffset;

					
					if(this.refv && this.refv.length > 1 && barProps.mbRefLine) {
						var refValue = this.refv[1].rv * 1.0;
						if(refValue < min) {
							min = refValue;
						}
						if(refValue > max) {
							max = refValue;
						}
					}
					
					var ts = max - min;
					var baseY = 0;
					var barPadTop = 5;
					var barPadBottom = 5;
					var rangeRatio = height - barPadTop - barPadBottom; 
					if (ts == 0) { 
						if (min == 0) {
							baseY = height / 2;
							rangeRatio = 0;
						} else {
							rangeRatio /= Math.abs(max);
							if (max < 0) {
								baseY = barPadTop;
							} else {
								baseY = height - barPadBottom;
							}
						}
					} else if(max < 0) {
						baseY = barPadTop;
						rangeRatio /= Math.abs(min);
					} else if (min < 0) {
						baseY = max / ts * rangeRatio + barPadTop;
						rangeRatio /= ts;
					} else { 
						baseY = height - barPadBottom;
						rangeRatio /= max;
					}


					
					
					var barTotalWidth = width - barOffset - barPadRight;
					var barCount = series.v.length;
					var barSpaceWidth = barTotalWidth * 0.4 / barCount; 
					barSpaceWidth = barSpaceWidth >= 1? barSpaceWidth: 1; 
					var barWidth = barTotalWidth / barCount - barSpaceWidth;
					this.hightLightPos = [];
					for(var i = 0; i < barCount; i ++) {
						this.hightLightPos[i] = {};
						var vl = series.rv[i] * 1.0;
						var direct = true;
						if(vl < 0) {
							vl = 0 - vl;
							direct = false;
						}
						
						var hgt = vl * rangeRatio;
						
						var cw = (width - barOffset) / series.v.length;
						this.drawBar(barOffset + (barWidth + barSpaceWidth) * i + barSpaceWidth / 2, baseY, barWidth, hgt, context, series.thClr && series.thClr[i],direct, this.hightLightPos[i]);
					}

					
					context.strokeStyle = this.xAxisLineColor;
					context.lineWidth = this.xAxisLineWidth;
					if (context.lineWidth % 2 === 1) {
						baseY = Math.round(baseY + 0.5) - 0.5; 
					}

					context.beginPath();
					context.moveTo(barOffset, baseY);
					context.lineTo(width - barPadRight, baseY);
					context.stroke();

					
					if(this.refv && this.refv.length > 1 && barProps.mbRefLine) {
						var refValue = this.refv[1].rv * 1.0;
						var refH = baseY - refValue * rangeRatio;
						
						
						if (context.lineWidth % 2 === 1) {
							refH = Math.round(refH + 0.5) - 0.5; 
						}
						context.beginPath();
						context.moveTo(barOffset, refH);
						context.lineTo(width - barPadRight, refH);
						context.strokeStyle = this.refLineColor;
						context.stroke();
					}
				},

				drawBar: function drwBr(x, y, width, height, context, color, direct, posStore) {
					

					
					if (width >= 3) { 
						x = Math.round(x);
						y = Math.round(y);
						width = Math.round(width);
					}
					if (height != 0) {
						height = Math.round(height);
						if (height < 1) { 
							height = 1;
						}
					}

				    if(direct) {
				    	context.fillStyle = color ? color : this.posBarColor;
				    	context.fillRect(x,y - height,width,height);
				    	posStore.x = x + Math.round(width / 2.0);
				    	posStore.y = y - height;
				    } else {
				    	context.fillStyle = color ? color : this.negBarColor;
				    	context.fillRect(x,y,width,height);
				    	posStore.x = x + Math.round(width / 2.0);
				    	posStore.y = y + height;
				    }
				}
			}
	);

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.VisChart");

    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    mstrmojo.VisMicroChartLine = mstrmojo.declare(

        mstrmojo.VisChart,

        null,

        {

            scriptClass: 'mstrmojo.VisMicroChartLine',

            isDrawAxis: false,

            
            margin: {t: 5, r: 2, b: 1, l: 2},

            showHighlightLine: false,

            themeColor: '#FFFFFF',

            isDrawRefArea: true,

            noBackground: true, 

            isAnimateLines: false,

            toolTipMain: null,

            mainWidth: 0,

            mainLeftPos: 0,

            reDrawChart: function reDrwchart() {
                var context = this.context,
                    canvas = this.canvas,
                    wd = canvas.width,
                    ht = canvas.height;
                context.clearRect(0, 0, wd, ht);

                this.data.processLinearData(this);
                
                this.windowSize = this.model.series[0].rv.length;
                
                this.utils.fillBackground(this);

                if (this.windowSize <= 1) {
                    return; 
                }
                this.drawChart();
            },

            setColorByTheme: function setColorByTheme() {
                var lineProps = this.config;
                if (this.theme === DEFAULT_DARK_THEME || this.theme === DEFAULT_LIGHT_THEME) {
                    this.startPointColor = '#50B5D8';
                    this.endPointColor = '#50B5D8';
                    this.otherPointColor = '#50B5D8';
                    this.isDrawRefArea = false;
                    this.sparkLineColor = "#50B5D8";
                    this.refLineColor = "#FF781D";
                } else {
                    
                    this.startPointColor = '#000000';
                    
                    this.endPointColor = '#FF0000';
                    
                    this.otherPointColor = '#663300';
                    this.isDrawRefArea = lineProps.mbRefArea;
                    this.sparkLineColor = lineProps.mwSeriesLineCol;
                    this.refLineColor = lineProps.mwRefLineCol;
                }
                var dpi = mstrMobileApp.getDeviceDPI();
                this.sparkLineWidth = dpi > 160 ? 2 : 1;
                this.refLineWidth = 1;
                
                this.startEndPointRadius = dpi >= 320 ? 4 : dpi >= 240 ? 3 : 2;
            },

            drawChart: function drwchrt() {
                this.setColorByTheme();
                var lineProps = this.config;
                var context = this.context;
                var model = this.model;
                var values = model.series;
                var mvalues = model.mvalues;
                var margin = this.margin;
                var height = this.getHeight();
                var width = this.getWidth();
                var utils = this.utils;
                var maxVR = mvalues[mvalues.length - 1]; 
                var minVR = mvalues[0]; 
                var maxYValue = mvalues[mvalues.length - 1];
                var minYValue = mvalues[0];

                

                
                if (this.refv && this.refv.length > 1 && lineProps.mbRefLine) {
                    var refValue = parseFloat(this.refv[1].rv);
                    if (isNaN(refValue)) {
                        
                    } else {
                        
                        if (refValue > maxVR) {
                            maxVR = refValue;
                            if (mvalues.length === 1) {
                                mvalues[1] = maxVR;
                            } else {
                                mvalues[mvalues.length - 1] = maxVR;
                            }
                        }
                        if (refValue < minVR) {
                            minVR = refValue;
                            if (mvalues.length === 1) {
                                mvalues[1] = mvalues[0];
                                mvalues[0] = maxVR;
                            } else {
                                mvalues[0] = minVR;
                            }
                        }
                    }

                }
                this.themeColor = lineProps.mwRefAreaCol;
                
                this.isDrawStartEndPoints = lineProps.mbAllPoints ? 7 : (lineProps.mbEndPoints ? 3 : 0);
                if (this.isDrawStartEndPoints & 1 && margin.l < this.startEndPointRadius) {
                    margin.l = this.startEndPointRadius;
                }
                if (this.isDrawStartEndPoints & 2 && margin.r < this.startEndPointRadius) {
                    margin.r = this.startEndPointRadius - 1; 
                }

                if (model.err) {
                    return;
                }

                if (!values) {
                    return;
                }

                
                if (maxVR !== minVR) {
                    this.RTY = (height - margin.t - margin.b - 4) / (maxVR - minVR);
                } else {
                    this.RTY = 0;
                }
                if (this.windowSize !== 1) {
                    this.RTX = (width - margin.l - margin.r - 1) / (this.windowSize - 1);
                } else {
                    this.RTX = 0;
                }
                
                var lines = [];
                var k = 0;
                
                
                for (var i = 0; i < this.windowSize; i++) {
                    var val = values[0].rv[i];
                    if (val.length === 0) {
                        continue;
                    }
                    var x = (i * this.RTX) + margin.l;
                    var y = utils.getYValue(this, val);
                    lines[k] = {x: x, y: y};
                    
                    k++;
                }
                if (lines.length === 0) {
                    
                    return;
                }
                maxYValue = utils.getYValue(this, maxYValue);
                minYValue = utils.getYValue(this, minYValue);
                
                if (maxYValue === undefined || minYValue === undefined) { 
                    maxYValue = height - 4 - margin.b;
                    minYValue = margin.t;
                }
                
                if (this.isDrawRefArea) {
                    context.fillStyle = this.themeColor;
                    context.fillRect(margin.l, minYValue, width - margin.r - margin.l, (maxYValue - minYValue));
                }
                
                context.lineCap = 'round';
                context.lineWidth = this.sparkLineWidth;
                context.lineJoin = 'round';
                context.strokeStyle = this.sparkLineColor;

                utils.drawLineSet(this, lines, false, context);

                
                if (this.isDrawStartEndPoints) {
                    utils.drawStartEndPoints(this, lines, context, this.isDrawStartEndPoints);
                }

                
                if (this.refv && this.refv.length > 1 && lineProps.mbRefLine) {
                    var refValue = this.refv[1].rv * 1.0;
                    var y = this.utils.getYValue(this, refValue);
                    if (isNaN(y)) {
                        y = height - 5;
                    }
                    if (context.lineWidth % 2 === 1) {
                        y = Math.round(y + 0.5) - 0.5; 
                    }
                    context.beginPath();
                    context.moveTo(margin.l, y);
                    context.lineTo(width - margin.r, y);
                    context.lineWidth = this.refLineWidth;
                    context.strokeStyle = this.refLineColor;
                    context.stroke();
                }
            },

            
            highlightPoint: function hghlghtpnt(x, touchY) {

                var me = this,
                    ctx = me.highlightContext,
                    height = me.getHeight(),
                    width = me.getWidth(),
                    margin = me.margin,
                    model = me.model,
                    utils = me.utils;

                ctx.clearRect(0, 0, width, height);

                if (x < 0) {
                    return;
                }

                var xcoord = (x * me.RTX) + margin.l;

                ctx.globalAlpha = 1;

                ctx.strokeStyle = this.sparkLineColor;
                ctx.fillStyle = ctx.strokeStyle;

                var y = utils.getYValue(me, model.series[0].rv[x]);

                if (xcoord < 5) {
                    xcoord = 5;
                }
                if (xcoord > width - 5) {
                    xcoord = width - 5;
                }
                if (y < 5) {
                    y = 5;
                }
                if (y > height - 5) {
                    y = height - 5;
                }
                ctx.strokeStyle = "FFFFFF";
                ctx.fillStyle = ctx.strokeStyle;
                ctx.globalAlpha = 0.8;
                utils.drawArc(this, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);

                ctx.strokeStyle = this.sparkLineColor;
                ctx.fillStyle = ctx.strokeStyle;
                ctx.globalAlpha = 1.0;
                utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, false, ctx);
                utils.drawArc(me, xcoord, y, 2.5, 0, Math.PI * 2, true, true, ctx);
                this.highlightCanvas.id = "highLightCav" + this.widget.domNode.id;
            },

            renderTooltip: function rndrttp(valIndex, touchX, touchY) {
                if (valIndex < 0) {
                    this.toolTipMain.style.display = 'none';
                    return;
                }

                var highLightCav = document.getElementById("highLightCav" + this.widget.domNode.id);
                if (highLightCav) {
                    var highlightCt = highLightCav.getContext('2d');
                    highLightCav.id = "";
                    highlightCt.clearRect(0, 0, 1000, 1000);
                }

                var m = this.model,
                    s = m.series,
                    utils = this.utils,
                    l = s.length,
                    si = this.seriesIndex,
                    ch = m.colHeaders,
                    rh = this.baseModel.rowHeaders,
                    ttp = this.toolTipMain;

                var me = this,
                    ctx = me.highlightContext,
                    height = me.getHeight(),
                    width = me.getWidth(),
                    margin = me.margin,
                    utils = me.utils;

                var metrics = m.mtrcs;
                metrics = metrics.items;
                if (isNaN(this.kpiOffset)) {
                    this.kpiOffset = 0;
                }
                var sn = '';

                var line1 = m.categories.tn + ': ' + m.categories.items[valIndex];
                var line2;
                if ( this.widget.sparklineProps.mstrAssMetric) {
                    line2 = this.widget.sparklineProps.mstrAssMetric + ": " + s[0].v[valIndex];
                }
                else {
                    line2 = metrics[this.kpiOffset] + ": " + s[0].v[valIndex];
                }
                var relx = (valIndex * me.RTX) + margin.l;
                var rely = utils.getYValue(me, s[0].rv[valIndex]);

                var leng1 = this.widget.getTextWidthByCanvas(line1, ttp);
                var leng2 = this.widget.getTextWidthByCanvas(line2, ttp);

                var domHtml = line1 + '<br/>' + line2;

                var leng3 = 0;
                if (this.refv && this.refv.length > 1 && this.config.mbRefLine) {
                    domHtml += "<br/>";
                    var line3 = metrics[this.kpiOffset + 1] + ": " + this.refv[1].v;
                    leng3 = this.widget.getTextWidthByCanvas(line3, ttp);
                    domHtml += line3;
                }
                ttp.innerHTML = '<div style="margin-left:5px;margin-bottom:4px;margin-top:5px;">' + domHtml + "</div>";

                var maxLength = Math.max(leng1, leng2, leng3);

                var oft = mstrmojo.boxmodel.offset(this.domNode, this.widget.domNode);
                var pos = mstrmojo.dom.position(this.domNode, true);
                var posWdt = mstrmojo.dom.position(this.widget.domNode, true);
                var maxWidth = maxLength + 10;
                ttp.style.display = 'block';
                ttp.style.borderColor = this.sparkLineColor;
                ttp.style.width = maxWidth + "px";

                var topOff = (rely + pos.y - posWdt.y - ttp.offsetHeight - 29);
                if (topOff < 0) {
                    topOff = 0;
                }
                var leftOff = (oft.left + relx + maxWidth + 20);
                if (leftOff > this.widget.getWidth()) {
                    leftOff = (relx + oft.left - maxWidth - 20);
                    if (leftOff < 0) {
                        leftOff = 0;
                    }
                } else {
                    leftOff -= maxWidth;
                }

                ttp.style.top = topOff + "px";
                ttp.style.left = leftOff + "px";

                var yadjust = this.mainOffsetTop === 0 ? ttp.offsetHeight + 20 : (2 * ttp.offsetHeight) + 30;
                var yPos = utils.getYValue(this, s[si].rv[valIndex]) - yadjust + this.offsetTop;
                if (yPos < 0) {
                    yPos = 0;
                }

                if (this.mainWidth > 0) {
                    var xposr = touchX + ttp.offsetWidth + this.offsetLeft - this.mainLeftPos;
                    if (xposr > this.mainWidth) {
                        touchX -= (xposr - this.mainWidth);
                    }
                }

            },

            
            isTouchPointInGraphRange: function tpInGR(touchX, touchY) {
                var margin = this.margin;
                if (touchX < margin.l || touchY < margin.t || touchY > this.canvas.height - margin.b) {
                    return false;
                }

                return true;
            },

            showTooltip: function handleTouchMove(touchX, touchY) {
                if (!this.config.mbShowTooltip) {
                    return false;
                }
                var me = this,
                    m = me.model;

                if (m.series[0].rv.length <= 1) {
                    return false;
                }

                
                var pos = mstrmojo.dom.position(this.domNode, true);
                touchX = touchX - pos.x;
                touchY = touchY - pos.y;

                if (!this.isTouchPointInGraphRange(touchX, touchY)) {
                    return false;
                }

                var touchVal = me.getTouchValue(touchX, touchY);

                var margin = this.margin;

                if (touchVal !== null) {

                    var x = (touchVal * me.RTX) + margin.l;

                    

                    if (me.widget.enableSmoothScroll) {
                        if (this.domNode.offsetLeft + x < this.widget._scroller.origin.x) {
                            return false;
                        }
                    }

                    var rns = (m.rne - m.rns > 1) ? m.rns : m.rns - 1;

                    if (me.seriesIndex === -1 || me.switchSeriesOnTouch) {
                        me.seriesIndex = me.utils.getSeriesIndexAndYValue(me, rns + touchVal, touchY).si;
                    }

                    if (m.series[me.seriesIndex].rv[rns + touchVal] === "") {
                        return false;
                    }

                    me.prevHighlight = me.currentHighlight;
                    me.currentHighlight = touchVal;

                    
                    
                    if (!me.widget.tooltipShow || me.prevHighlight != me.currentHighlight) {
                        me.renderTooltip(touchVal, x, touchY);
                        me.highlightPoint(touchVal, touchY);
                    }

                    return true;

                }
            }

        }
    );

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidMap");

    
    mstrmojo.maps.jsmap.AndroidRptMap = mstrmojo.declare(
        
        mstrmojo.maps.jsmap.AndroidMap,

        
        null,

        {
            scriptClass: 'mstrmojo.maps.jsmap.AndroidRptMap',

            setModel: function setModel(model) {
                this._super(model);

                
                this.controller.getPageByTree(false);
            }
        }
    );
}());


(function () {
    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidMap",
                         "mstrmojo.maps.jsmap.AndroidDocMapInfoWindow",
                         "mstrmojo.Overlay",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    
    mstrmojo.maps.jsmap.AndroidDocMap = mstrmojo.declare(
        mstrmojo.maps.jsmap.AndroidMap,

        [ mstrmojo._Formattable ],

        {
            scriptClass: "mstrmojo.maps.jsmap.AndroidDocMap",

            cssClass: "mstr-googleMapView",

            formatHandlers: {
                domNode: ['left', 'top', 'z-index', 'height', 'width', 'border', 'border-color', 'border-style', 'border-width' ]
            },

            sc: null,

            getMapModel: function getMapModel() {
                var d = this.doc,
                    m = d.model,
                    pid = mstrApp.getCurrentProjectId(),
                    sessions = mstrApp.serverProxy.getSessions();

                return {
                    pid: pid,
                    sessions: sessions,
                    model: this.model,
                    docData: {
                        did: d.did,
                        ttl: d.ttl,
                        st: d.st,
                        mid: m.mid,
                        bs: m.bs,
                        data: m.data,
                        defn: m.defn
                    },
                    cfg: mstrApp.getConfiguration().getConfiguration()
                };
            },

            
            postBuildRendering: function postBuildRendering() {
                
                this._touchListener = mstrmojo.touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                    
                    var openInfoWindow = this.openedInfoWindow;
                    if (openInfoWindow) {
                        
                        if (!$DOM.contains(this.domNode, evt.touch.target, true, document.body) && !mstrApp.isDialogUp()) {
                            
                            openInfoWindow.close();
                        }
                    }
                });

                return this._super();
            },

            destroy: function destroy(ignoreDom) {
                
                var listener = this._touchListener;
                if (listener) {
                    
                    mstrmojo.touchManager.detachEventListener(listener);
                    delete this._touchListener;
                }

                this._super(ignoreDom);
            },

            setModel: function setModel(d) {
                
                this.doc = d.controller.view;
                this._super(d);
            },

            initFromVisProps: function initFromVisProps(vp) {
                this._super(vp);

                if (!vp) {
                    return;
                }

                this.iwDocLayout = (parseInt(vp.dl, 10) === 1);

                
                if (vp.lyt) {
                    this.iwLayoutKey = vp.lyt;
                }
            },

            
            findSelectorTarget: function findSelectorTarget(sc) {
                if (sc && sc.tks) {
                    var dm = this.model.docModel,
                        targets = sc.tks.split('\u001E'),
                        i = 0,
                        len = targets.length;

                    for (i = 0; i < len; ++i) {
                        var d = dm.getTargetDefn(targets[i]);
                        if (d[targets[i]].ifw) {
                            return targets[i];
                        }
                    }
                }
            },

            showInfoWindow: function showInfoWindow(mp, mkr, w) {
                this.openedInfoWindow = w;
                w.open(mp, mkr);
            },

            
            getInfoWindow: function getInfoWindow(map, marker) {
                var gd = this.gridData;

                
                if (this.iwDocLayout) {

                    
                    this.getInfoWindowFromLayout(gd, map, marker, this.showInfoWindow);

                } else {

                    var sc = this.getInfoWindowSelectorControl(gd),
                        firstInfoWinKey = this.findSelectorTarget(sc);

                    
                    if (!(!!sc && firstInfoWinKey)) {
                        
                        return this.getDefaultInfoWindow(gd, marker);
                    }

                    
                }
            },

            getInfoWindowFromLayout: function getInfoWindowFromLayout(d, map, marker, callback) {
                
                var ths = this,
                    doc = this.doc,
                    layouts = doc.getLayouts(),
                    lyt = this.iwLayoutKey,
                    layout = layouts[mstrmojo.array.find(layouts, 'k', lyt)],
                    sep = "\x1F",
                    dssXmlTypeAttribute = "12",
                    
                    
                    gbIDs = marker.attrid + sep + dssXmlTypeAttribute + sep + marker.eid;

                var taskParams = {
                    layoutKey: lyt,
                    groupByIDs: gbIDs
                };

                doc.selectLayout(layout, (lyt !== doc.model.currlaykey), {
                    complete: function () {

                        layout.defn.loaded = false;

                        doc.getNewLayout(taskParams, layouts, false, {
                            complete: function () {
                                mstrApp.hideMessage();
                            },
                            submisson: function () {
                                mstrApp.showMessage();
                            },
                            success: function (res) {
                                var node = res.node, overlay,
                                    content = document.createElement('div'),
                                    contentStyle = content.style,
                                    w = node.defn.fmts.width,
                                    h = node.defn.fmts.height || node.data.mh; 

                                overlay = new mstrmojo.Overlay({
                                    children: [res]
                                });
                                
                                overlay.set('width', w);
                                overlay.set('height', h);

                                
                                var cn = document.createElement('div');
                                overlay.placeholder = cn;
                                overlay.render();

                                contentStyle.overflow = "hidden";
                                content.appendChild(overlay.domNode);

                                var win = new google.maps.InfoWindow({
                                    content: content
                                });

                                
                                ths.openedInfoWindow = win;
                                win.open(map, marker);

                                var INTERVAL = 300,
                                    t = 0,
                                    ti = window.setInterval(function () {
                                        var n = content.parentNode;
                                        if (n) {
                                            var ow = n.offsetWidth,
                                                oh = n.offsetHeight;
                                            if (ow !== parseInt(w, 10) || oh !== parseInt(h, 10)) {
                                                overlay.setDimensions(oh + 'px', ow + 'px');
                                                window.clearTimeout(ti);
                                            }
                                        }
                                        t += INTERVAL;
                                        
                                        
                                        if (t > 10 * INTERVAL) {
                                            window.clearTimeout(ti);
                                        }
                                    }, INTERVAL); 
                            }
                        }, true);
                    }
                });
            },

            getInfoWindowSelectorControl: function getInfoWindowSelectorControl(d) {
                if (!this.sc) {
                    
                    this.sc = d.gts.row[0].sc;
                }
                return this.sc;
            },

            
            postHandleMarkerClick: function postHandleMarkerClick(map, marker) {

                var d = this.gridData,
                    sc = this.getInfoWindowSelectorControl(d);

                if (sc && sc.tks) {
                    var ths = this,
                        dataCacheUpdate = null,
                        dm = ths.model.docModel;

                    dm.getDataService().setDocSelectorElements(sc.ck, marker.eid, sc.ckey, sc.include, {
                        success: function (res) {

                            
                            var tgtDefs = dm.getTargetDefn(sc.tks);

                            
                            if (res.pukeys) {
                                tgtDefs = dm.getTargetDefn(res.pukeys);
                            }

                            
                            
                            
                            dataCacheUpdate = dm.updateDataCache(res.data, tgtDefs);

                            var firstInfoWinKey = ths.findSelectorTarget(sc);

                            
                            if (firstInfoWinKey) {
                                
                                

                                var targetDef = dm.getTargetDefn(firstInfoWinKey),
                                    psId = "*l" + res.currlaykey + "*k" + firstInfoWinKey + "*x1*t" + dm.buildTime,
                                    id = psId + "_ifw",
                                    widget = mstrmojo.all[id];

                                
                                if (widget) {
                                    widget.destroy();
                                }

                                
                                
                                var ifw = new mstrmojo.maps.jsmap.AndroidDocMapInfoWindow({
                                    id: id,
                                    parent: ths,
                                    builder: ths.builder,
                                    model: dm,
                                    psKey: firstInfoWinKey,
                                    psId: psId
                                });

                                
                                var fmts = targetDef[firstInfoWinKey].fmts,
                                    content = document.createElement('div'),
                                    contentStyle = content.style,
                                    w = fmts.width,
                                    h = fmts.height;

                                
                                ifw.set('width', w);
                                ifw.set('height', h);

                                
                                var cn = document.createElement('div');
                                ifw.placeholder = cn;
                                ifw.render();

                                contentStyle.height = h;
                                contentStyle.width = w;
                                contentStyle.overflow = "hidden";
                                content.appendChild(ifw.domNode);

                                
                                var iw = new google.maps.InfoWindow({
                                    content: content
                                    
                                    
                                });

                                
                                var fnClose = iw.close;
                                iw.close = function () {
                                    
                                    fnClose.call(iw);

                                    
                                    ifw.destroy();

                                    
                                    delete ths.openedInfoWindow;
                                };

                                
                                

                                ths.openedInfoWindow = iw;
                                iw.open(map, marker);

                                var INTERVAL = 300,
                                    t = 0,
                                    ti = window.setInterval(function () {
                                        var n = content.parentNode;
                                        if (n) {
                                            var ow = n.offsetWidth,
                                                oh = n.offsetHeight;
                                            if (ow !== parseInt(w, 10) || oh !== parseInt(h, 10)) {
                                                ifw.setDimensions(oh + 'px', ow + 'px');
                                                window.clearTimeout(ti);
                                            }
                                        }
                                        t += INTERVAL;
                                        
                                        
                                        if (t > 10 * INTERVAL) {
                                            window.clearTimeout(ti);
                                        }
                                    }, INTERVAL); 






                            }

                            
                            
                            var ue = {
                                name: 'partialUpdate',
                                tree: res.data,   
                                ids: dataCacheUpdate
                            };

                            
                            if (!mstrmojo.hash.isEmpty(ue.ids.ifws)) {
                                
                                delete ue.ids.ifws[firstInfoWinKey];
                            }

                            
                            dm.raiseEvent(ue);
                        }
                    }, dm.zf, true);
                }
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ResultSetController",
                         "mstrmojo._IsDocController",
                         "mstrmojo.android.controllers._SupportsQueuedTransactions",
                         "mstrmojo.android.controllers._HasPageBy",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.string",
                         "mstrmojo.array",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(1089, 1917, 2941, 6189, 9233, 9254, 9255, 9256, 9257);

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        MENUS = mstrmojo.android.EnumMenuOptions,
        MNU_LAYOUTS = MENUS.DOC_LAYOUTS,
        MNU_GROUPBY = MENUS.GROUP_BY,
        MNU_REPROMPT = MENUS.REPROMPT,
        MNU_SHARE = MENUS.SHARE,
        MNU_ANNOTATION = MENUS.ANNOTATION,
        UNIT_SEPARATOR = '\u001F',
        MARK_ROW = 1;                   


    function getCurLayout(me) {
        var model = me.model,
	        lyts = model.data.layouts,
	        i = $ARR.find(lyts, 'k',  model.currlaykey);
    	return i >= 0 ? lyts[i] : null;
    }

    function getDrillGB(me, view) {
        var elements = me.getGroupByElements(view),
        	res = [],
	        lyt = getCurLayout(me),
	        gbys = lyt && lyt.gbys && lyt.gbys.groupbys,
	        elemSize = elements && elements.length;

	    if (elemSize && gbys) {
	        for (i = 0; i < elemSize; i++) {
	            var gb = gbys[i].unit.target;
	            res.push(gb.did);
	            res.push(gb.t);
	            res.push(elements[i]);
	        }
	    }
	    return res.join(UNIT_SEPARATOR);
    }

    function getDesiredUnits(me, elements) {
        var res = me.desiredUnits || {},                
            lyt = getCurLayout(me),
            elemSize = elements && elements.length;

        if (lyt && lyt.gbys) {
            var gbys = lyt.gbys.groupbys,
                size = gbys.length;

            for (i = 0; i < size; i++) {
                var gb = gbys[i].unit,
                    elem;
                if (elements) {
                    if (i < elemSize) {
                        elem = elements[i];
                    } else {
                        
                        
                        break;
                    }
                } else {
                    elem = gb.elms[gb.idx].v;
                }
                res[gb.target.did] = elem;
            }
        }
        return res;
    }

    function toDesiredElements(units) {
        var res = '',
            i = 0,
            u;

        for (u in units) {
            if (i > 0) {
                res += UNIT_SEPARATOR;
            }
            res += u + UNIT_SEPARATOR + units[u];
            i++;
        }

        return res;
    }

    
    function clearRefreshTimer() {
        if (this.refreshTimer) {
            clearInterval(this.refreshTimer);
            delete this.refreshTimer;
        }
    }

    
    function startRefreshTimer() {
        var rf = this.model.rf;
        if (rf && rf > 0) {
            var ths = this;
            this.refreshTimer = self.setInterval(function () {

                ths.checkCache( null, null, null, 2);

            }, rf * 1000);
        }
    }

    
    function clearOrientation() {
        
        var previousOrientation = this._previousOr;

        
        if (previousOrientation === -1) {
            
            return;
        }

        
        if (previousOrientation === 0) {
            
            window.setTimeout(function () {
                mstrMobileApp.releaseOrientation();
            });

        
        } else if (previousOrientation > 0) {
            
            mstrMobileApp.lockOrientation(previousOrientation);
        }

        
        this._previousOr = -1;
    }

    
    function getTxController() {
        return mstrApp.getTransactionNotificationController();
    }

    
    function createLinkParams(queryKeys, linkSrc) {
        
        var params = {
            srcMsgId: this.model.mid,
            desiredUnits: getDesiredUnits(this, this.getGroupByElements(linkSrc))
        };

        
        $HASH.forEach(queryKeys, function (v, k) {
            
            v = v.replace(/\+/g, ' ');
            params[k] = decodeURIComponent(v);
        });

        
        return params;
    }

    

    function fillTxData(params) {
        var txds = params.txData.split(';'),
            i,
            size = txds.length;

        for (i = 0; i < size; i++) {
            var t = txds[i],

                
                kvp = t.split(','),

                
                v = decodeURIComponent(kvp[1]),

                
                
                w = this.model.getFirstUnitInstanceByName(kvp[0]);

            
            if (w) {

                
                w.dataChanged(0, w.v, {
                    dv: v,
                    v: v
                }, w.valueNode);
            }
        }
    }

    
    mstrmojo.android.controllers.DocumentController = mstrmojo.declare(

        mstrmojo.android.controllers.ResultSetController,

        [ mstrmojo.android.controllers._SupportsQueuedTransactions, mstrmojo._IsDocController, mstrmojo.android.controllers._HasPageBy ],

        
        {
            scriptClass: "mstrmojo.android.controllers.DocumentController",

            initModel: function initModel(params) {
                return mstrApp.modelFactory.newModel('Document', $HASH.copy(params, {
                    controller: this
                }));
            },

            
            hasTxChanges: false,

            start: function start(params, callback) {
                
                var du = this.desiredUnits = params.desiredUnits;
                if (du) {
                    var desired = toDesiredElements(du);
                    if (desired) {
                        params.desiredElements = desired;
                    }
                    delete params.desiredUnits;
                }

                
                this.sub_id = params.sub_id;

                this.hasTxChanges = !!params.hasTxChanges;

                this._super(params, callback);
            },

            
            createView: function createView(res, params) {
                var layouts = res.defn.layouts,
                    currentLockedOrientation = mstrMobileApp.getLockedOrientation(),        
                    lastLayoutOrientation = -1,                                             
                    newOrientation = -1,                                                    
                    shouldLock = true,                                                      
                    cnt = layouts.length,
                    i;

                
                for (i = 0; i < cnt; i++) {

                    
                    if (layouts[i].iw) {
                    	continue;
                    }

                    
                    var layoutOrientation = layouts[i].or;

                    
                    if (lastLayoutOrientation === -1) {
                        
                        lastLayoutOrientation = layoutOrientation;
                    }

                    
                    if (layoutOrientation !== lastLayoutOrientation || layoutOrientation === 3) {
                        
                        shouldLock = false;

                        
                        break;
                    }
                }

                
                if (currentLockedOrientation > 0) {
                    
                    if (shouldLock) {
                        
                        if (lastLayoutOrientation !== currentLockedOrientation) {
                            
                            newOrientation = lastLayoutOrientation;
                        }

                    } else {
                        
                        newOrientation = 0;
                    }

                } else {
                    
                    if (shouldLock) {
                        
                        newOrientation = lastLayoutOrientation;
                    }
                }

                
                if (newOrientation > -1) {
                    
                    if (newOrientation === 0) {
                        
                        mstrMobileApp.releaseOrientation();
                    } else {
                        
                        mstrMobileApp.lockOrientation(newOrientation);
                    }

                    
                    this._previousOr = currentLockedOrientation;
                }

                
                var doc = this.view = this.newView('Document', params);
                doc.set('model', this.model);

                
                doc.buildChildren();

                
                return doc;
            },

            afterReprompt: function afterReprompt(response) {
                
                var view = this.view;
                view.unloadLayouts(null, false);
                view.model.loadLayout(response, true);
                this._super(response);
            },

            onPageBy: function onPageBy(pageByKeys) {

                var gbUnits = '';
                $ARR.forEach(pageByKeys, function (item, idx) {
                    if (idx) {
                        gbUnits += UNIT_SEPARATOR;
                    }

                    gbUnits += item.id + UNIT_SEPARATOR + item.v;
                });

                this.onGroupBy({
                    gbUnits: gbUnits
                });
            },

            hasPageBy: function hasPageBy() {
                var view = this.view,
                    layout = view && view.getLayouts() && view.getCurrentLayout();

                return !!(layout && layout.gb && layout.defn.dpb);
            },

            onGroupBy: function onGroupBy(params, callback, config) {
                var view = this.view,
                    model = this.model;

                config = config || {};
                config.showWait = true;
                config.hideWait = true;
                config.delay = true;

                
                callback = mstrmojo.func.wrapMethods(callback, {
                    success: function (res) {
                        
                        view.unloadLayouts(null, true);
                        model.loadLayout(res);
                    }
                });

                model.getDataService().changeDocGroupBy(params, callback, config);
            },

            setData: function setData(res, isNewData) {
                
                
                var view = this.view;

                if (isNewData && view) {
                    
                    view.unloadLayouts(null, false);
                }

                this.model.loadLayout(res);

                if ( res.rf != this.old_rf ) {
                    
                    clearRefreshTimer.call(this);

                    
                    startRefreshTimer.call(this);
                }

                
                this.rootCtrl.updateContent( null , this.model.n, false  );
            },

            onDrill: function onDrill(view, action) {
                
                if (!this.isInRequest()) {
                    
                    if (action.isWithin) {
                        
                        view.model.drillGrid(this._addNodeKeyToAction(view, action), this._getXtabCallback(view));
                    } else {
                    	
                        action.rwGroupByElements = getDrillGB(this, view);
                        
                        this._super(this._addNodeKeyToAction(view, action));
                    }
                }
            },

            onDownloadGridData: function onDownloadGridData(view, action) {
                this.model.downloadGridData(this._addNodeKeyToAction(view, action));
            },

            onExecuteNewObject: function onExecuteNewObject(view, action) {
                this._super(action);
            },

            onReExecute: function onReExecute(view) {
                this.reExecute(view);
            },

            
            refresh: function refresh(params, callback) {

                var id = this.id;
                
                this.model.getDataService().refresh( params, mstrmojo.func.wrapMethods({
                    success: function (res) {
                        mstrmojo.all[id].setData(res, true);
                    }
                }, callback) );
            },

            invalidClientCache: function () {
                if (mstrApp.useBinaryFormat) {
                    mstrMobileApp.removeLiveCache(mstrApp.getCurrentProjectId(), this.model.ci.cid);
                }
            },

            
            onTransactionUpdates: function onTransactionUpdates(view, updateObject, autoRefresh) {
                var md = this.model,
                    callback;

                if (mstrApp.useBinaryFormat) {
                    callback = md.newCallback({
                        success: function () {
                            
                            view.clear();

                            md.clearTxDeltaUpdate();

                            if (autoRefresh) {
                                
                                
                                setTimeout(function () {
                                    view.autoRefresh();
                                }, 250); 

                            }
                        }
                    });

                    var dataService = md.getDataService();
                    if (updateObject.manipulation === MARK_ROW) {
                        dataService.txMarkRows(updateObject, callback);
                    } else {
                        dataService.txChangeData(updateObject, callback);
                    }

                } else {
                    
                    if (autoRefresh) {
                        
                        view.autoRefresh();
                    }
                }

                
                this.hasTxChanges = true;
            },

            onLink: function onLink(view, action) {

                
                if (!action.url) {
                    return this._super(view, action);
                }

                
                var uri = mstrmojo.string.parseUri(action.url),
                    authority = uri.authority,
                    path = uri.path;

                if (uri.protocol === 'mstr') {
                    this.handleSpecialLink(uri, action);

                } else if (authority === 'mstrWeb' || authority === 'Main.aspx' || (/mstrWeb$/.test(path)) || (/Main\.aspx$/.test(path))) {
                    
                    this._super(view, createLinkParams.call(this, uri.queryKey, action.src));

                } else {
                    
                    var err = mstrMobileApp.openLink(uri.source, action.target);
                    if (err) {
                        mstrApp.onerror({
                            message: err
                        });
                    }
                }
            },

            
            getLinkRequest: function getLinkRequest(link) {
                var res;

                
                if (!link.url) {
                    res = this.buildLinkParams(link);

                } else {

                    
                    var uri = mstrmojo.string.parseUri(link.url),
                        uriParams = uri.queryKey,
                        authority = uri.authority,
                        path = uri.path;

                    if (uri.protocol !== 'mstr' && (authority === 'mstrWeb' || authority === 'Main.aspx' || (/mstrWeb$/.test(path)) || (/Main.aspx$/.test(path)))) {
                        res = this.buildLinkParams(createLinkParams.call(this, uriParams, link.src));

                        if (res) {
                            switch (parseInt(uriParams.evt, 10)) {
                            case 4001:
                                res.taskID = "reportExecute";
                                res.styleName = "AndroidMessageResultStyle"; 
                                break;

                            case 2048001:
                                res.taskID = "RWExecute";
                                res.objType = 55;
                                var du = res.desiredUnits;
                                if (du) {
                                    var desired = toDesiredElements(du);
                                    if (desired) {
                                        res.desiredElements = desired;
                                    }
                                    delete res.desiredUnits;
                                }
                                break;
                            }
                        }

                    }
                }
                if (res && res.link) {
                    res.linkAnswers = res.link.toXml();
                    delete res.link;
                }
                
                return res;
            },

            getDesiredElements: function getDesiredElements(elements) {
                var gbElements = this.model.gbElements,
                    res = '';

                
                
                if (gbElements) {
                    var gbs = gbElements.split(';'),
                        size = gbs.length,
                        i;

                    for (i = 0; i < size; i += 3) {
                        if (i > 0) {
                            res += UNIT_SEPARATOR;
                        }
                        res += gbs[i] + UNIT_SEPARATOR + gbs[i + 2];
                    }
                } else {
                    res = toDesiredElements(getDesiredUnits(this, elements));
                }
                return res;
            },

            
            confirmMsgBeforeSubmit: function confirmMsgBeforeSubmit() {
                var md = this.model,
                    txNtfCtl = getTxController(),
                    msg;

                if (this.hasTxChanges && txNtfCtl && txNtfCtl.hasPendingTransactions(this.did)) {
                    
                    
                    if (md.txrcd) {
                        msg = mstrmojo.desc(9254, 'Pending transaction exists') + '. ' + mstrmojo.desc(9255, 'You are about to replace a pending transaction.');
                    } else {
                        msg = mstrmojo.desc(9256, 'There are one or more pending submissions in the transaction queue for this document.') + ' ' + mstrmojo.desc(9257, 'Continuing will submit a new transaction.');
                    }
                }
                return msg;
            },

            offlineTransactionsSubmitted: function offlineTransactionsSubmitted(ck) {
                var txNtfCtl = getTxController();
                if (txNtfCtl) {
                    txNtfCtl.setOfflineRecords(this.did);
                }
                
                
                this.hasTxChanges = false;
            },

            openOfflineTransactions: function openOfflineTransactions() {
                var txNtfCtl = getTxController();
                if (txNtfCtl) {
                    txNtfCtl.showNotificationBoard(this, this.did, this.ttl);
                }
            },

            transactionDiscarded: function transactionDiscarded(ck) {
                this.hasTxChanges = false;
            },

            destroy: function destroy() {
                
                clearOrientation.call(this);

                
                this._super();
            },

            nudgeWidget: function nudgeWidget(id, update) {
                if (mstrMobileApp !== undefined && mstrMobileApp.nudgeWidget) {
                    mstrMobileApp.nudgeWidget(id, JSON.stringify(update));
                }
            },

            
            resetOrientation: function resetOrientation() {
                clearOrientation.call(this);
            },

            checkCache: function checkCache(res, params, cacheIsGoodCallback, option, config) {

                
                this.old_rf = this.model.rf;

                
                this._super(res || {
                    ifc: true,
                    ci: this.model.ci
                }, params, cacheIsGoodCallback, option, config);
            },

            beforeViewHidden: function beforeViewHidden(isBack) {
                this._super(isBack);

                
                if (isBack) {
                    
                    mstrmojo.GraphBase.hideTooltips();

                    
                    this.resetOrientation();
                }

                
                clearRefreshTimer.call(this);
            },

            afterViewVisible: function afterViewVisible() {
                this._super();

                
                var view = this.view;
                if (view && view.afterViewVisible) {
                    
                    view.afterViewVisible();
                }

                
                
                if ( !this.isSubscription ) {
                    startRefreshTimer.call(this);
                }
            },

            hasFullScreenInfoWindow: function hasFullScreenInfoWindow(){

            	var view = this.view;

            	return view && view.fullScreenInfoWindow;
            },

            updateActionToolbar: function updateActionToolbar(tbCfg) {
                
                if (!this.hasFullScreenInfoWindow()) {
                    
                    this.getTxnToolbarButton(tbCfg);

                    
                    this.addFullScreenButton(tbCfg);

                    
                    if (mstrMobileApp.isOnline()) {
                        
                        var model = this.model,
                            docModel = model.docModel || model,
                            prompts = docModel.prompts,
                            
                            currentLayoutDef = docModel.getCurrentLayoutDef && docModel.getCurrentLayoutDef(),
                            dri = (currentLayoutDef && currentLayoutDef.dri);

                        
                        if (prompts && prompts.hasSupported() && (dri === undefined || dri)) {
                            
                            tbCfg.addToolbarBtn(MNU_REPROMPT, mstrmojo.desc(6189, 'Filter'), MNU_REPROMPT, true, 3);
                        }
                    }

                    
                    if (this.hasPageBy()) {
                        
                        tbCfg.addToolbarBtn(MNU_GROUPBY, mstrmojo.desc(2941, 'Grouping'), MNU_GROUPBY, true, 2);
                    }

                    
                    var layouts = this.view && this.view.getSupportedLayouts();
                    if (layouts && (layouts.length > 1)) {
                        
                        tbCfg.addToolbarBtn(MNU_LAYOUTS, mstrmojo.desc(4174, 'Layouts'), MNU_LAYOUTS, false, 8);
                    }
                }

                return this._super(tbCfg);
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                
                if (group !== MNU_SHARE && group !== MNU_ANNOTATION) {
                	
                	mstrmojo.GraphBase.hideTooltips();

                	
                	if (mstrApp.isTablet()) {
                		this.view.closeInfoWindowsOnTablet();
                	}
                }

                switch (group) {
                case MNU_LAYOUTS:
                    var view = this.view,
                        fnLayouts = function () {
                            var layouts = view.getSupportedLayouts();

                            
                            return {
                                l: layouts,
                                idx: $ARR.indexOf(layouts, view.getCurrentLayout())
                            };
                        },
                        info = fnLayouts();

                    
                    mstrApp.showDialog({
                        title: mstrmojo.desc(4174, 'Layouts'),
                        children: [{
                            scriptClass: 'mstrmojo.ui.MobileCheckList',
                            isElastic: true,
                            multiSelect: false,
                            items: info.l,
                            selectedIndex: info.idx,
                            postselectionChange: function (evt) {
                                
                                var added = evt.added;
                                if (added) {
                                    
                                    if (view.showLayout(this.items[added[0]])) {
                                        
                                        mstrApp.closeDialog();
                                    }
                                }
                            },
                            postCreate: function () {
                                
                                mstrApp.rootController.attachEventListener('rootOrientationChange', this.id, function () {
                                    
                                    var info = fnLayouts();

                                    
                                    this.set('items', info.l);
                                    this.select(info.idx);

                                    
                                    this.parent.resizeDialog();
                                });
                            }
                        }]
                    });

                    return;

                case MNU_GROUPBY:
                    this.showGroupByDialog();
                    return;

                case MNU_REPROMPT:
                    this.reprompt();
                    return;

                }

                return this._super(group, cmdId);
            },

            makeCurrent: function makeCurrent(isBack) {
            	this.isBack = true;
            	this._super(isBack);
            	delete this.isBack;
            },

            handleSpecialLink: function handleSpecialLink(uri, action) {
                var param = uri.queryKey,
                    view = this.view,
                    eventId = param.evt;

                if (eventId === "2048500") {
                    
                    var name = param.panelName,
                        model = view.model,
                        unit = model.getInfoWindow(name);
                    if (unit) {
                        view.showInfoWindow(unit.id, unit.k, action.src.domNode);
                    }
                } else if (eventId === "2048030") {
                    

                	
                	var	fresh = !!param.useCache && param.useCache === "0",
                		rparams = {
                			fresh: fresh,
                			useRefreshProgress: mstrApp.isTablet()
                		};

                    this.refresh( rparams );

                
                } else if (eventId === "2048258") {   
                    fillTxData.call(this, param);

                
                } else if (eventId === "3037") {
                	this.share(param.emailSubject, true);

                } else if (eventId === "3175") {
                	
                	this.startAnnotate();
                } else if (uri.authority === 'gb') {
                    
                    var me = this,
                        curLayout = view.getSelectedLayoutWidget(),
                        gpby = curLayout.gb,
                        attId = param.a,
                        eId = param.e,
                        $forEach = $ARR.forEach;


                    
                    $forEach(gpby.groupbys, function (gb) {
                        var unit = gb.unit,
                            target = unit.target;

                        if (target.did === attId) {
                            var showDialog = function () {
                                var options = unit.elms,
                                    items = [];

                                
                                $forEach(options, function (opt, idx) {
                                    items.push($HASH.copy(opt, {
                                        k: gb.k,
                                        on: (idx === unit.idx)
                                    }));
                                });

                                mstrApp.showDialog({
                                    title: target.n,
                                    children: [{
                                        scriptClass: 'mstrmojo.ui.MobileCheckList',

                                        
                                        selectionPolicy: 'reselect',
                                        items: items,
                                        multiSelect: false,
                                        isElastic: true,
                                        selectedIndex: unit.idx,

                                        
                                        preselectionChange: function (evt) {
                                            
                                            if (evt.added[0] === evt.removed[0]) {
                                                
                                                mstrApp.closeDialog();

                                                
                                                return false;
                                            }

                                            
                                            if (this._super) {
                                                return this._super(evt);
                                            }
                                        },

                                        postselectionChange: function (evt) {
                                            mstrApp.closeDialog();

                                            var item = items[evt.added[0]];
                                            me.onGroupBy({
                                                groupbyKey: item.k,
                                                elementId: item.v
                                            });
                                        }
                                    }]
                                });
                            };

                            if (eId && parseInt(eId, 10) !== 0) {
                                this.onGroupBy({ 
                                    groupbyKey: gb.k,
                                    elementId: eId
                                }, {   
                                    
                                    failure: showDialog
                                }, {   
                                    
                                    noErrorMessage: true
                                });

                            } else {
                                showDialog();

                            }

                            
                            return false;
                        }
                    });
                } else {
                    this._super(uri, action);

                }
            },

            
            
            getContentDimensions: function getContentDimensions() {

                var dim = mstrApp.getContentDimensions();

                return {
                	w: dim.w,
                	h: dim.h
                };
            },

            
            canDelegateToolBar: function canDelegateToolBar () {
            	if (this.hasFullScreenInfoWindow()) {
            		return false;
            	}

            	return this._super();
            }
        }
    );
}());


(function () {
    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidDocMap",
                         "mstrmojo.maps.androidmap.AndroidDocMap");
    mstrmojo.maps.AndroidDocMap =  mstrmojo.declare(
            mstrmojo.Obj ,

            null,

            {
            	scriptClass: 'mstrmojo.maps.AndroidDocMap'
            }
    );
    if ((typeof(mstrMobileApp) != 'undefined') && (typeof(mstrMobileApp.useNativeMap) != 'undefined') && mstrMobileApp.useNativeMap()) {
		mstrmojo.maps.AndroidDocMap = mstrmojo.maps.androidmap.AndroidDocMap;
	} else {
		mstrmojo.maps.AndroidDocMap = mstrmojo.maps.jsmap.AndroidDocMap;
	}
}());


(function () {
    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidRptMap",
                         "mstrmojo.maps.androidmap.AndroidRptMap",
                         "mstrmojo.Obj");

    mstrmojo.maps.AndroidRptMap =  mstrmojo.declare(
            mstrmojo.Obj ,

            null,

            {
            	scriptClass: 'mstrmojo.maps.AndroidRptMap'
            }
    );
    
    if ((typeof(mstrMobileApp) != 'undefined') && (typeof(mstrMobileApp.useNativeMap) != 'undefined') && mstrMobileApp.useNativeMap()) {
		mstrmojo.maps.AndroidRptMap = mstrmojo.maps.androidmap.AndroidRptMap;
	} else {
		mstrmojo.maps.AndroidRptMap = mstrmojo.maps.jsmap.AndroidRptMap;
	}
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.Vis", "mstrmojo.dom", "mstrmojo._TouchGestures", "mstrmojo.VisChartUtils",
        "mstrmojo._HasTouchScroller", "mstrmojo.color", "mstrmojo.css", "mstrmojo.VisMicroChartLine", "mstrmojo.VisMicroChartBar", "mstrmojo.VisMicroChartBullet", "mstrmojo._NeedSyncScroller");

    
    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    
    var ATTR_NAME = 0,
        METRIC_NAME = 1,
        METRIC_VALUE = 2,
        CHART = 3,
        TREE_TRIANGLE = 4,
        DROP_SHADOW = 5;

    var TRIANGLE_NONE = 0;
    var TRIANGLE_OPEN = 1;
    var TRIANGLE_CLOSE = 2;
    var TRIANGLE_CLOSE_STYLE = "width:0px;height:0px;border-left:10px solid black;border-top:5px solid transparent;border-bottom:5px solid transparent;margin-left:auto;margin-right:auto;-webkit-transform:scale(0.8,0.9)";
    var TRIANGLE_OPEN_STYLE = "width:0px;height:0px;border-left:5px solid transparent;border-top:10px solid black;border-right:5px solid transparent;margin-left:auto;margin-right:auto;-webkit-transform:scale(0.9,0.8)";

    var DOCKED_HEADER = 0,
        OTHER_ROW = 1;

    var zf = 1;

    var $CLR = mstrmojo.color,
        $CSS = mstrmojo.css;

    var MC_TABLE_TEXT = "microchart-table-text";

    var ROW_HEIGHT = 0;
    var ROW_HEIGHT_FOR_CHART = 0;

    function removeChildren(container) {
        container.innerHTML = '';
    }

    function setDHBackGroundColor() {
        var backgroundColor = this.backgroundColor;
        if (!backgroundColor) {
            return;
        }
        this.dockedHeaderTable.style.backgroundColor = backgroundColor;
        this.dockedHeaderTable.style.opacity = '1';
        this.dockedHeaderReplaceDiv.firstChild.style.backgroundColor = backgroundColor;
        this.dockedHeaderReplaceDiv.firstChild.style.opacity = '1';
    }

    
    
    function setNodeCssText(node, cssText) {
        var height = node.style.height;
        var width = node.style.width;
        var textDecoration = node.style.textDecoration;
        var display = node.style.display;
        var fontSize = node.style.fontSize;
        var paddingLeft = node.style.paddingLeft;
        var paddingRight = node.style.paddingRight;
        var boxShadow = node.style.boxShadow;
        node.style.cssText = cssText;
        node.style.height = height;
        node.style.width = width;
        node.style.textDecoration = textDecoration;
        if (display) {
            node.style.display = display;
        }
        if (fontSize) {
            node.style.fontSize = fontSize;
        }
        if (paddingLeft) {
            node.style.paddingLeft = paddingLeft;
        }
        if (paddingRight) {
            node.style.paddingRight = paddingRight;
        }
        if (boxShadow) {
            node.style.boxShadow = boxShadow;
        }

    }

    function setTreeTriangle(arrowDiv, treeNode, color) {
        var level = treeNode.level;

        var state = "";
        if (treeNode.isLeaf) {
            
            state = TRIANGLE_NONE;
        } else {
            if (treeNode.needExpand) {
                state = TRIANGLE_OPEN;
            } else {
                state = TRIANGLE_CLOSE;
            }
        }

        var whichBorderColor = null;
        var bodyFontColorRGB = this.bodyFontColorRGB;
        var theme = this.theme;

        if (state == TRIANGLE_CLOSE) {
            arrowDiv.className = "microchart-tree-arrow-close";
            whichBorderColor = "border-left-color";
        } else if (state == TRIANGLE_OPEN) {
            arrowDiv.className = "microchart-tree-arrow-open";
            whichBorderColor = "border-top-color";
        } else {
            
            arrowDiv.className = "";
            arrowDiv.setAttribute("style", "");
            return;
        }

        var styleContent = "";

        if (color) {
            
            styleContent = whichBorderColor + ':' + color;
        } else if (theme == DEFAULT_LIGHT_THEME) {
            if (level == 0) {
                
                styleContent = whichBorderColor + ':' + '#4c4c4c';
            } else if (level == 1) {
                
                styleContent = whichBorderColor + ':' + 'rgba(76,76,76,0.8)';
            } else if (level > 1) {
                styleContent = whichBorderColor + ':' + 'rgba(76,76,76,0.6)';
            }
        } else if (theme == DEFAULT_DARK_THEME) {
            if (level == 0) {
                
                styleContent = whichBorderColor + ':' + 'white';
            } else if (level == 1) {
                
                styleContent = whichBorderColor + ':' + "rgba(255,255,255,0.8)";
            } else if (level > 1) {
                styleContent = whichBorderColor + ':' + "rgba(255,255,255,0.6)";
            }

        } else if (bodyFontColorRGB && bodyFontColorRGB.length > 2 && (theme == CUSTOM_LIGHT_THEME || theme == CUSTOM_DARK_THEME)) {
            if (level == 0) {
                
                styleContent = whichBorderColor + ':' + 'rgba(' + bodyFontColorRGB[0] + ',' + bodyFontColorRGB[1] + ',' + bodyFontColorRGB[2] + ',0.8)';
            } else if (level > 0) {
                
                styleContent = whichBorderColor + ':' + 'rgba(' + bodyFontColorRGB[0] + ',' + bodyFontColorRGB[1] + ',' + bodyFontColorRGB[2] + ',0.7)';
            }

        }

        arrowDiv.setAttribute("style", styleContent);
    }

    function renderOneRow(rowIdx, dockedHeaderRowInfo) {
        var widget = this.widget,
            rowInfo = widget.rows[rowIdx],
            curM = rowInfo.model,
            elms = curM.elms,
            rowTmpl = this.rowTemplate,
            treeNode = rowInfo.treeNode,
            colInfos = this.colInfos,
            rowIdx = rowInfo.rowIdx,
            rowRef = null,
            colCount = colInfos.length;
        var bodyFontColorRGB = this.bodyFontColorRGB;

        var ths = this.headerTable.firstChild.firstChild.childNodes;

        rowRef = dockedHeaderRowInfo ? dockedHeaderRowInfo.rowRef : rowInfo.rowRef;

        var tr = null;
        var tds = null;
        if (rowRef[this.domRefName]) {
            
            tr = rowRef[this.domRefName];
        } else {
            
            tr = rowTmpl.cloneNode(true);
            rowRef[this.domRefName] = tr;
        }
        tr.style.display = '';

        fillThemeColor.call(this, dockedHeaderRowInfo ? dockedHeaderRowInfo : rowInfo);

        
        if (!this.isAndroidTab) {
            
            tr.style.fontSize = 14 * zf + "px";
        }

        tr.setAttribute("rowType", dockedHeaderRowInfo ? DOCKED_HEADER : OTHER_ROW);

        var tds = tr.childNodes;

        var attr = null;

        for (var j = 0, tdsIdx = 0; j < colCount; j++, tdsIdx++) {
            var colInfo = colInfos[j];
            var colIdx = colInfo.colIdx;

            tds[j].setAttribute("mrow", rowInfo.rowIdx);

            if (colIdx == this.treeColumnIdx && treeNode) {
                
                var arrowDiv = tds[j].firstChild;

                setTreeTriangle.call(this, arrowDiv, treeNode);

                if (!treeNode.isLeaf) {

                    arrowDiv.parentNode.setAttribute("CLK", "T");
                }
                continue;
            }

            
            if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME) {
                if (this.isTreeMode) {
                    var attrName = "";
                    for (var k = 0; k < treeNode.es.length; k++) {
                        attrName += treeNode.es[k].n;
                    }
                    
                    if (attrName.indexOf("&lt;") >= 0) {
                        attrName = attrName.replace(/&lt;/g, "<");
                        attrName = attrName.replace(/&gt;/g, ">");
                    }

                    tds[j].innerHTML = attrName;

                    if (treeNode.level == 0) {
                        tds[j].style.fontWeight = 'bold';
                    } else {
                        tds[j].style.fontWeight = '';
                    }
                    if (treeNode.level > 0 && (this.theme == CUSTOM_DARK_THEME || this.theme == CUSTOM_LIGHT_THEME)) {
                        
                        
                        if (bodyFontColorRGB && bodyFontColorRGB.length > 2) {
                            tds[j].style.color = 'rgba(' + bodyFontColorRGB[0] + ',' + bodyFontColorRGB[1] + ',' + bodyFontColorRGB[2] + ',0.8)';
                        }
                    } else {

                    }
                } else {
                    attr = elms[colInfo.order];
                    var attrName = attr ? attr.n : "";
                    
                    if (attrName.indexOf("&lt;") >= 0) {
                        attrName = attrName.replace(/&lt;/g, "<");
                        attrName = attrName.replace(/&gt;/g, ">");
                    }
                    tds[j].innerHTML = attrName;

                }

                continue;
            }

            if (colInfo.order == "LineChart") {

                if (rowRef[colIdx]) {
                    var w = rowRef[colIdx];
                    if (curM.isTotal && !this.isTreeMode) {
                        w.domNode.style.display = 'none';
                    } else {
                        
                        w.domNode.style.display = '';
                        w.model = curM.model;
                        w.refv = curM.refv;
                        w.kpiOffset = this.kpiOff * rowIdx;
                        w.reDrawChart();
                        
                    }

                } else {
                    if (curM.isTotal && !this.isTreeMode) {
                        continue;
                    }
                    var placeholder = document.createElement("div");
                    var props = {
                        placeholder: placeholder,
                        model: curM.model,
                        refv: curM.refv,
                        config: widget.sparklineProps,
                        widget: widget,
                        kpiOffset: this.kpiOff * rowIdx,
                        width: colInfo.contentWidth,
                        height: ROW_HEIGHT_FOR_CHART,
                        toolTipMain: widget.tooltip,
                        mainOffsetTop: this.offsetTop,
                        mainLeftPos: parseInt(this.domNode.style.left, 0) || 0,
                        mainWidth: this.getWidth(),
                        isTreeMode: this.isTreeMode,
                        theme: this.theme
                    };
                    tds[j].appendChild(placeholder);
                    var w = new mstrmojo.VisMicroChartLine(props);
                    w.render();
                    tds[j].removeAttribute("class");
                    rowRef[colIdx] = w;
                }

            } else if (colInfo.order == "BarChart") {

                if (rowRef[colIdx]) {
                    var w = rowRef[colIdx];
                    if (curM.isTotal && !this.isTreeMode) {
                        w.domNode.style.display = 'none';
                    } else {
                        
                        w.model = curM.model;
                        w.refv = curM.refv;
                        w.kpiOffset = this.kpiOff * rowIdx;
                        w.isTextBold = this.isTreeMode ? treeNode.level == 0 : false;
                        w.reDrawChart();
                        
                    }
                } else {
                    if (curM.isTotal && !this.isTreeMode) {
                        continue;
                    }
                    var placeholder = document.createElement("div");
                    var props = {
                        placeholder: placeholder,
                        model: curM.model,
                        refv: curM.refv,
                        widget: widget,
                        kpiOffset: this.kpiOff * rowIdx,
                        config: widget.barProps,
                        width: colInfo.contentWidth,
                        height: ROW_HEIGHT_FOR_CHART,
                        toolTipMain: widget.tooltip,
                        mainOffsetTop: this.offsetTop,
                        mainLeftPos: parseInt(this.domNode.style.left, 0) || 0,
                        mainWidth: this.getWidth(),
                        isTreeMode: this.isTreeMode,
                        theme: this.theme,
                        isTextBold: this.isTreeMode ? treeNode.level == 0 : false
                    };

                    tds[j].appendChild(placeholder);
                    var w = new mstrmojo.VisMicroChartBar(props);
                    w.render();
                    
                    tds[j].className = this.valueCssClass;
                    rowRef[colIdx] = w;
                }

            } else if (colInfo.order == "GaugeChart") {
                
                if (rowRef[colIdx]) {
                    
                    var w = rowRef[colIdx];
                    w.model = curM.model;
                    w.refv = curM.refv;
                    w.kpiOffset = this.kpiOff * rowIdx;
                    w.labelColorRGB = this.bodyFontColorRGB;
                    w.reDrawChart();
                } else {
                    var placeholder = document.createElement("div");
                    var props = {
                        placeholder: placeholder,
                        model: curM.model,
                        refv: curM.refv,
                        widget: widget,
                        config: widget.bulletProps,
                        width: colInfo.contentWidth,
                        height: ROW_HEIGHT_FOR_CHART,
                        toolTipMain: widget.tooltip,
                        mainOffsetTop: this.offsetTop,
                        mainLeftPos: parseInt(this.domNode.style.left, 0) || 0,
                        mainWidth: this.getWidth(),
                        labelColorRGB: this.bodyFontColorRGB,
                        showMinLabel: this.showMinLabel,
                        isTreeMode: this.isTreeMode,
                        theme: this.theme

                    };
                    tds[j].appendChild(placeholder);
                    var w = new mstrmojo.VisMicroChartBullet(props);
                    w.render();
                    tds[j].removeAttribute("class");
                    rowRef[colIdx] = w;
                }

            } else {
                var metricIdx = -1;
                var idx = -1;

                if (this.widget.isKPI) {
                    
                    idx = parseInt(colInfo.order) % this.kpiOff;

                    
                    var metricIdx = rowInfo.model.metricIdx + idx;
                } else {
                    if (colInfo.type == METRIC_VALUE) {
                        metricIdx = parseInt(colInfo.order);
                        idx = metricIdx;
                    }
                }

                var innerHTML = "";
                var cssClass = "";

                if (!curM.refv[idx]) {
                    continue;
                }

                if (curM.refv[idx].ti === undefined) { 
                    if (curM.refv[idx].ts === 4) { 
                        innerHTML = "<img src='" + curM.refv[idx].v + "'/>";
                    } else {
                        innerHTML = curM.refv[idx].v;
                    }
                } else { 
                    try { 
                        
                        var model = this.widget.model;
                        var th = model.th['' + metricIdx];
                        var ti = curM.refv[idx].ti;

                        if (curM.refv[idx].ty === 4) { 
                            var path;
                            if (th[ti] && th[ti].n) {
                                path = th[ti].n;
                            } else {
                                path = curM.refv[idx].v;
                            }
                            if (path.indexOf(":") >= 0) { 
                                
                            } else { 
                                var baseURL;
                                try {
                                    baseURL = mstrApp.getConfiguration().getHostUrlByProject(mstrApp.getCurrentProjectId());
                                } catch (err) {
                                    baseURL = "";
                                }
                                path = baseURL + path;
                            }
                            innerHTML = "<img src='" + path + "'/>";
                        } else {
                            if (th[ti] && th[ti].n && th[ti].cni !== undefined) { 
                                innerHTML = th[ti].n;
                            } else {
                                innerHTML = curM.refv[idx].v;
                            }
                            tds[j].style.fontSize = this.widget.fontSize; 
                            
                        }
                        cssClass = model.css[th[ti].cni].n;
                    } catch (err) {
                        if (!innerHTML) { 
                            innerHTML = curM.refv[idx].v;
                        }
                    }
                }

                if (cssClass) {
                    tds[j].className = colInfo.valueCssClass + " " + cssClass;
                } else if (this.valueCssClass) {
                    tds[j].className = colInfo.valueCssClass + " " + this.valueCssClass;
                } else {
                    tds[j].className = colInfo.valueCssClass;
                }

                tds[j].innerHTML = innerHTML;
            }

            
            if (this.isTreeMode) {
                if (treeNode.level == 0) {
                    tds[j].style.fontWeight = 'bold';
                } else {
                    tds[j].style.fontWeight = '';
                }
            }
        }

        if (this.isTreeMode) {
            
            var preRowInfo = widget.rows[rowIdx - 1];
            var preRowExpanded = preRowInfo && preRowInfo.treeNode.level < rowInfo.treeNode.level;
            var isDockedHeader = dockedHeaderRowInfo != undefined;
            var isFirstRow = rowIdx == 0;

            if (preRowExpanded || ( isDockedHeader && treeNode.level > 0)) {
                
                var tdCount = tds.length;
                for (var i = 0; i < tdCount; i++) {
                    if (this.theme == DEFAULT_LIGHT_THEME || this.theme == CUSTOM_LIGHT_THEME) {
                        tds[i].style.boxShadow = '0px 5px 3px -3px rgba(0,0,0,0.2) inset';
                    } else if (this.theme == DEFAULT_DARK_THEME || this.theme == CUSTOM_DARK_THEME) {
                        tds[i].style.boxShadow = '0px 6px 3px -3px rgba(0,0,0,0.5) inset';
                    }

                }

                
                
                tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0)';

            } else if ((isDockedHeader && treeNode.level == 0 || isFirstRow) && (this.theme == DEFAULT_LIGHT_THEME || this.theme == DEFAULT_DARK_THEME)) {
                
                tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0)';
            } else {
                var tdCount = tds.length;
                for (var i = 0; i < tdCount; i++) {
                    tds[i].style.boxShadow = '';
                }
            }
        }

        var rowInfoToHighlight = dockedHeaderRowInfo ? dockedHeaderRowInfo : rowInfo;
        if (this.isTreeMode) {
            
            if (treeNode.selected) {
                this.widget.highlightRowByRowInfo(rowInfoToHighlight);
            } else {
                this.widget.unHighlightRowByRowInfo(rowInfoToHighlight);
            }

        } else {
            
            if (this.widget.isAllAttrSelectable) {
                if (rowInfo.selected[-1]) {
                    
                    this.widget.highlightRowByRowInfo(rowInfo);
                } else {
                    this.widget.unHighlightRowByRowInfo(rowInfo);
                }
            } else {
                
                this.widget.highlightCellsByRowInfo(rowInfo);
            }
        }

        return tr;
    }

    function fillThemeColor(rowInfo) {
        var tr = rowInfo.rowRef[this.domRefName];
        
        if (this.isTreeMode) {

            var treeNode = rowInfo.treeNode
            var level = treeNode.level;

            if (level == 0) {
                
                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#f9f9f9';
                    tr.style.color = '#191919';
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.3)';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#333333';
                    tr.style.color = 'white';
                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.3)';

                } else if (this.theme == CUSTOM_DARK_THEME) {
                    tr.style.backgroundColor = '';

                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.3)';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {
                    tr.style.backgroundColor = '';
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.3)';

                }

                tr.style.font = 'bold 12pt Helvetica';

            } else if (level == 1) {
                
                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#e5e5e5';
                    tr.style.color = '#4c4c4c';
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.2)';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#232323';
                    tr.style.color = '#cccccc';
                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.2)';

                } else if (this.theme == CUSTOM_DARK_THEME) {

                    tr.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.2)';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {

                    tr.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.2)';

                }

                tr.style.font = '12pt Helvetica';

            } else if (level == 2) {
                
                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#d1d1d1';
                    tr.style.color = '#333333';
                    
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.1)';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#0F0F0F';
                    tr.style.color = '#cccccc';
                    
                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.1)';

                } else if (this.theme == CUSTOM_DARK_THEME) {

                    tr.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.1)';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {

                    tr.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.1)';

                }
                tr.style.font = '12pt Helvetica';
            } else if (level > 2) {
                
                var opc = level > 9 ? 1 : level / 10;

                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#BDBDBD';
                    tr.style.color = '#333333';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#000000';
                    tr.style.color = '#cccccc';

                } else if (this.theme == CUSTOM_DARK_THEME) {

                    tr.style.backgroundColor = 'rgba(255, 255, 255, ' + opc + ')';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {

                    tr.style.backgroundColor = 'rgba(0, 0, 0, ' + opc + ')';

                }

                tr.style.font = '12pt Helvetica';
                
                tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.1)';
            }

        } else {
            
            if (this.theme == DEFAULT_LIGHT_THEME) {
                tr.style.backgroundColor = '#f9f9f9';
                tr.style.font = '12pt Helvetica';
                tr.style.color = '#191919';
            } else if (this.theme == DEFAULT_DARK_THEME) {
                tr.style.backgroundColor = '#333333';
                tr.style.font = '12pt Helvetica';
                tr.style.color = 'white';
            }
        }
    }

    function setScrollerPosition(scrollTo) {
        var scl = this._scroller,
            icn = this.chartTable,
        
            offsetEnd = Math.max(this.chartTableOffsetHeight + this.headerTableOffsetHeight - this.getHeight(), 0);

        scl.origin = {
            x: scrollTo && scrollTo.x || 0,
            y: scrollTo && scrollTo.y || 0
        };

        scl.showScrollbars = this.showScrollbars;
        scl.vScroll = (offsetEnd !== 0 && scl.noVScroll !== true) || this.scrollPast;

        if (scl.vScroll) {

            scl.offset = {
                y: {
                    start: 0,
                    end: offsetEnd
                },
                scrollPast: this.scrollPast

            };
        }

        this.utils.translateCSS(-scl.origin.x, -scl.origin.y, false, icn);
    }

    mstrmojo.VisMicroChartTable = mstrmojo.declare(

        mstrmojo.Vis,

        
        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo._NeedSyncScroller ],

        {
            scriptClass: 'mstrmojo.VisMicroChartTable',

            utils: mstrmojo.VisChartUtils,

            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                useTranslate3d: false,
                hScroll: false,
                vScroll: true
            },

            scrollPast: false,

            
            colInfos: null,

            rowTemplate: null,

            theme: -1,

            isTreeMode: false,

            showMinLabel: false,

            bodyFontColorRGB: null,

            markupString: '<div id="{@id}-microchart-table" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};z-index:{@zIndex};position:absolute;background-color:{@backgroundColor}">'
                +
                '<div id="{@id}-header-bar" class="microchart-header-div" style="width:{@width};">'
                + '<table id="{@id}-header-table" style="width:{@width};table-layout:fixed;">'
                + '<tr class="microchart-table-row" >'
                + '<th style="border:none;text-decoration:none;"></th>'
                + '</tr>'
                + '</table>'
                + '</div>'
                +
                '<div id="{@id}-chart-table-container" class="microchart-canvas-div" style="position:absolute;overflow:hidden;width:{@width};">'
                + '<table id="{@id}-charts-body" style="width:{@width};table-layout:fixed">'
                + '<tr class="microchart-table-row">'
                + '<td style="border:none;background:transparent;text-decoration:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-top:0px;padding-bottom:0px"></td>'
                + '</tr>'
                + '</table>'
                + '</div>'
                +
                '<div style="position:absolute;z-index:2;">'
                + '<table id="{@id}-docked-header" style="width:{@width};table-layout:fixed;position:relative;background-color:white;">'
                + '<tbody></tody>'
                + '</table>'
                + '<div id="{@id}-docked-header-replace-div" style="width:{@width};position:relative;overflow:hidden">'
                + '<table id="{@id}-docked-header-replace" style="width:{@width};table-layout:fixed;background-color:white;">'
                + '<tbody></tody>'
                + '</table>'
                + '</div>'
                + '</div>'
                +
                '</div>',

            markupSlots: {

                headerTable: function () {
                    return this.domNode.childNodes[0].firstChild;
                },

                itemsContainerNode: function () {
                    return this.domNode.childNodes[1];
                },

                chartTable: function () {
                    return this.domNode.childNodes[1].firstChild;
                },

                dockedHeaderTable: function () {
                    return this.domNode.childNodes[2].firstChild;
                },

                dockedHeaderReplaceDiv: function () {
                    return this.domNode.childNodes[2].lastChild;
                }
            },

            postBuildRendering: function postBR() {

                
                ROW_HEIGHT = (this.widget.otherProps.mRowHeight - 1) + 'px';
                ROW_HEIGHT_FOR_CHART = (this.widget.otherProps.mRowHeight - 2) + 'px';
                zf = this.utils.getScreenZoomFactor();
                this.scrollerConfig.scrollEl = this.chartTable;
                this.scrollerConfig.indicatorEl = this.widget.indicatorEl;
                this.scrollerConfig.showScrollbars = this.showScrollbars;
                this._super();
                this.renderMicroChart();
                this.updateRowOffsetHeight();
                this.updateHeaderTableOffsetH();
                this.updateChartTableOffsetH();
                setScrollerPosition.call(this, this.widget.mcStatus && this.widget.mcStatus.scrollTo);

                setDHBackGroundColor.call(this);

                
                
                var widget = this.widget;
                if (this._tn) {
                    var backup = this._tsCallback;
                    this._tsCallback = function (e) {
                        widget.closedIfwAttr = null;
                        backup.call(this, e);
                    };
                    mstrmojo.dom.detachEvent(this._tn, mstrmojo.dom.TOUCHSTART, backup);
                    mstrmojo.dom.attachEvent(this._tn, mstrmojo.dom.TOUCHSTART, this._tsCallback);
                }
            },

            renderMicroChart: function rmc() {

                var colLen = this.colInfos.length;

                var ht = this.headerTable;
                
                ht.style.font = 'bold 13pt Helvetica';
                if (this.theme == DEFAULT_LIGHT_THEME) {
                    ht.style.backgroundColor = '#B5BDC4';
                    ht.style.color = 'black';
                } else if (this.theme == DEFAULT_DARK_THEME) {
                    ht.style.backgroundColor = '#1C273A';
                    ht.style.color = 'white';
                }
                if (!this.isAndroidTab) {
                    
                    ht.style.height = zf * 32 + 'px';
                    ht.style.fontSize = 14 * zf + "px";
                }

                
                var htr = ht.firstChild.firstChild;

                
                var tbody = this.chartTable.firstChild;
                var rowTmpl = tbody.firstChild;

                var th0 = htr.firstChild;
                var td0 = rowTmpl.firstChild;
                
                for (var i = ht.childNodes.length; i < colLen; i++) {
                    htr.appendChild(th0.cloneNode(true));
                    rowTmpl.appendChild(td0.cloneNode(true));
                }
                this.rowTemplate = rowTmpl;

                var fnSD = function (e, width, noSetHeight) {
                    var paddingWidth = 0;

                    var compStyle = mstrmojo.css.getComputedStyle(e);
                    if (compStyle.paddingLeft) {
                        paddingWidth += parseFloat(compStyle.paddingLeft);
                    }
                    if (compStyle.paddingRight) {
                        paddingWidth += parseFloat(compStyle.paddingRight);
                    }

                    e.style.width = (width - paddingWidth) + 'px';

                    if (!noSetHeight) {
                        e.style.height = ROW_HEIGHT;
                    }

                };

                
                var ths = htr.childNodes;
                
                var tds = rowTmpl.childNodes;

                if (this.isTreeMode) {
                    
                    $CSS.removeClass(rowTmpl, "microchart-table-row");
                    $CSS.removeClass(htr, "microchart-table-row");
                }

                for (var i = 0; i < colLen; i++) {

                    var colInfo = this.colInfos[i];

                    ths[i].innerHTML = colInfo.title ? colInfo.title : '';

                    if (colInfo.padding.l != undefined) {
                        tds[i].style.paddingLeft = colInfo.padding.l + "px";
                    }
                    if (colInfo.padding.r != undefined) {
                        tds[i].style.paddingRight = colInfo.padding.r + "px";
                    }

                    ths[i].className = colInfo.headerCssClass;
                    if (this.treeColumnIdx == colInfo.colIdx) {
                        
                        var arrowDiv = document.createElement('div');
                        tds[i].appendChild(arrowDiv);
                        arrowDiv.style.display = "";
                    } else {
                        
                        tds[i].className = colInfo.valueCssClass + " " + this.valueCssClass;
                    }

                    if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME) {
                        this.bodyFontColorRGB = this.valueCssClass && $CLR.rgbStr2rgb(mstrmojo.css.getStyleValue(tds[i], 'color'));
                    }

                    fnSD(ths[i], colInfo.colWidth);
                    fnSD(tds[i], colInfo.colWidth);

                    ths[i].style.wordBreak = "break-word";
                    ths[i].style.whiteSpace = "normal";

                    tds[i].setAttribute("mcol", colInfo.colIdx);
                    ths[i].setAttribute("mcol", colInfo.colIdx);
                    ths[i].setAttribute("mrow", -1);

                }

                for (var i = 0; i < colLen; i++) {
                    var colInfo = this.colInfos[i];
                    colInfo.titleOverflow = this.utils.truncateTextToLineWithWordWrap2(ths[i], this.textCanvas, 2);

                    if (colInfo.type == CHART) {
                        colInfo.contentWidth = tds[i].offsetWidth - colInfo.padding.l - colInfo.padding.r;
                    }

                }

                var otherProps = this.widget.otherProps;
                this.kpiOff = otherProps.mnMetricsPerKPI;
                if (!this.widget.isKPI) {
                    this.kpiOff = 0;
                }

                var w = this.widget;

                var fragment = document.createDocumentFragment();
                for (var i = w.startCnt; i < w.endCnt; i++) {
                    var newTR = renderOneRow.call(this, i);
                    fragment.appendChild(newTR);

                }
                tbody.appendChild(fragment);

                rowTmpl.style.display = "none";

                
                if (otherProps.mbHideColHeaders) {
                    this.headerTable.style.display = "none";
                }

                this.itemsContainerNode.style.top = this.headerTableOffsetHeight + 'px';
            },

            reRenderRows: function reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender) {
                var tbody = this.chartTable.firstChild;
                tbody.innerHTML = "";
                var w = this.widget;

                var fragment = document.createDocumentFragment();

                if (firstRowRemain == undefined) {
                    firstRowRemain = 0;
                    lastRowRemain = 0;
                    firstRowToRender = w.startCnt;
                    lastRowToRender = w.endCnt;
                }

                var rows = w.rows;
                if (firstRowRemain < firstRowToRender) {
                    for (var i = firstRowRemain; i < lastRowRemain; i++) {
                        var newTR = rows[i].rowRef[this.domRefName];
                        fragment.appendChild(newTR);
                    }

                    for (var i = firstRowToRender; i < lastRowToRender; i++) {
                        var newTR = renderOneRow.call(this, i);
                        fragment.appendChild(newTR);

                    }
                } else {
                    for (var i = firstRowToRender; i < lastRowToRender; i++) {
                        var newTR = renderOneRow.call(this, i);
                        fragment.appendChild(newTR);

                    }
                    for (var i = firstRowRemain; i < lastRowRemain; i++) {
                        var newTR = rows[i].rowRef[this.domRefName];
                        fragment.appendChild(newTR);
                    }
                }

                tbody.appendChild(fragment);

                this.updateChartTableOffsetH();
                setScrollerPosition.call(this, scrollTo);
            },

            updateHeaderTableOffsetH: function updateHeaderTableOffsetH() {
                if (this.widget.otherProps.mbHideColHeaders) {
                    this.headerTableOffsetHeight = 0;
                } else {
                    this.headerTableOffsetHeight = this.headerTable.offsetHeight;
                }
            },

            updateRowOffsetHeight: function updateRowOffsetHeight() {
                this.rowOffsetHeight = this.chartTable.firstChild.lastChild.offsetHeight;

            },

            updateChartTableOffsetH: function updateChartTableOffsetH() {
                this.chartTableOffsetHeight = this.chartTable.firstChild.offsetHeight;
            },

            onScrollDone: function onScrollDone(evt) {
                if (this._super) {
                    this._super(evt);
                }
                this.widget.onScrollDone(evt);
            },

            onScrollMoved: function onScrollMoved(evt) {
                if (this._super) {
                    this._super(evt);
                }
                this.widget.onScrollMoved(evt);
            },

            initScroller: function initScroller(scroller) {

                if (!scroller.offset && this.scrollPast) {
                    scroller.offset = {scrollPast: this.scrollPast};
                }

                scroller.vScroll = true;

                if (this._super) {
                    this._super(scroller);
                }

                var me = this;
            },

            initDHs: function initDHs() {
                var dockedHeaderTable = this.dockedHeaderTable;
                dockedHeaderTable.parentNode.style.top = this.headerTableOffsetHeight + 'px';
            },

            
            addRowsToDH: function addRowsToDH(rowCount, toDHReplacingTable) {
                var w = this.widget;
                var rows = null;
                if (toDHReplacingTable) {
                    rows = w.dockedHeaderReplaceRows;
                } else {
                    rows = w.dockedHeaderRows;
                }

                var fragment = document.createDocumentFragment();
                for (var i = rows.length - rowCount; i < rows.length; i++) {
                    var newTR = renderOneRow.call(this, rows[i].rowIdx, rows[i]);
                    rows[i].rowRef[this.domRefName] = newTR;
                    fragment.appendChild(newTR);
                }
                if (toDHReplacingTable) {
                    this.dockedHeaderReplaceDiv.firstChild.firstChild.appendChild(fragment);
                } else {
                    this.dockedHeaderTable.firstChild.appendChild(fragment);
                }

            },

            removeRowsFromDH: function removeRowsFromDH(rowCount, moveToReplacingTable) {
                var dockedHeaderTable = this.dockedHeaderTable,
                    dockedHeaderTbody = dockedHeaderTable.firstChild;
                var dockedHeaderReplaceTbody = this.dockedHeaderReplaceDiv.firstChild.firstChild;

                if (rowCount > dockedHeaderTbody.childNodes.length) {
                    
                    rowCount = dockedHeaderTbody.childNodes.length;
                }

                if (rowCount > 1) {
                    
                    dockedHeaderTable.removeChild(dockedHeaderTbody);
                    for (var i = 0; i < rowCount; i++) {
                        dockedHeaderTbody.removeChild(dockedHeaderTbody.lastChild);
                    }
                    dockedHeaderTable.appendChild(dockedHeaderTbody);

                } else if (rowCount == 1) {
                    var dockedHeaderTR = dockedHeaderTbody.lastChild;
                    dockedHeaderTbody.removeChild(dockedHeaderTR);
                    if (moveToReplacingTable) {
                        dockedHeaderReplaceTbody.appendChild(dockedHeaderTR);
                    }

                }
            },

            moveRowFromDHRplcTableToDH: function moveRowFromDHRplcTableToDH() {
                var dockedHeaderTable = this.dockedHeaderTable,
                    dockedHeaderTbody = dockedHeaderTable.firstChild;
                var dockedHeaderReplaceTbody = this.dockedHeaderReplaceDiv.firstChild.firstChild;

                var replacingTR = dockedHeaderReplaceTbody.firstChild;
                if (replacingTR) {
                    removeChildren(dockedHeaderReplaceTbody);
                    dockedHeaderTbody.appendChild(replacingTR);
                }

            },

            removeChildrenForDHReplaceTable: function removeChildrenForDHReplaceTable() {
                var dockedHeaderReplaceTbody = this.dockedHeaderReplaceDiv.firstChild.firstChild;

                removeChildren(dockedHeaderReplaceTbody);
            },

            showDockedHeader: function showDockedHeader() {
                this.dockedHeaderTable.parentNode.style.display = 'block';
            },

            hideDockedHeader: function hideDockedHeader() {
                this.dockedHeaderTable.parentNode.style.display = 'none';
            },

            setTreeArrow: function setTreeArrow(rowInfo, color) {
                var tr = rowInfo.rowRef[this.domRefName];
                var tds = tr.childNodes;
                var arrowDiv = tds[this.treeColumnIdx].firstChild;
                setTreeTriangle.call(this, arrowDiv, rowInfo.treeNode, color);
            },

            scrollTo: function (origin) {
                var icn = this.chartTable;
                this.utils.translateCSS(-origin.x, -origin.y, false, icn);
            },

            shouldTouchBubble: function shouldTouchBubble(touch) {
                var scroller = this._scroller,
                    isVertical = touch.isVertical;

                var vScrollable = !!scroller.offset && scroller.offset['y'].end !== 0;

                return isVertical ? !vScrollable : this._super(touch);
            },

            multiTap: true,

            touchTap: function (touch) {
                this.widget.touchTap(touch);
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                this.bubbleTouchEvent(touch);
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                this.bubbleTouchEvent(touch);
            },

            touchSelectMove: function touchSelectMove(touch) {
                this.bubbleTouchEvent(touch);
            },

            multiTouch: true,

            touchMultiBegin: function (touch) {
                this.bubbleTouchEvent(touch);
            },

            touchMultiMove: function (touch) {
                this.bubbleTouchEvent(touch);
            },

            touchMultiEnd: function (touch) {
                this.bubbleTouchEvent(touch);
            },

            destroy: function destroy() {
                delete this.widget;
                delete this.parent;
                delete this.rowTemplate;

                this._super();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.VisChartLine", "mstrmojo.EnumRWUnitType",
        "mstrmojo.VisTooltip",
        
        "mstrmojo.dom", "mstrmojo._TouchGestures", "mstrmojo.TouchScroller", "mstrmojo._HasTouchScroller", "mstrmojo.css", "mstrmojo.color",
        "mstrmojo.VisTimeSeriesLegend", "mstrmojo.VisTimeSeriesTimeSelector");

    mstrmojo.requiresDescs(5674, 8475, 8626);

    
    var $CSS = mstrmojo.css,
        $CLR = mstrmojo.color;

    var DRILLING_ACTION = 1,
        SELECTOR_ACTION = 2,
        HYPERLINK_ACTION = 4;
    var ROW_AXIS = 1,
        COL_AXIS = 2;
    var chartStatus = {},
        widgetCount = 0,
        tooltipShown = false,
        itemClicked = false,
        isDataSetChanged = false,
        chartSizeChanged = false,
        originalTouchPosition = 0,
        masterSliderClicked = null,
    
        rangeToSeriesMaxRatio = 5;

    var MCHW = 20; 
    var MCHH = 20; 
    var MAXPOINTS_PER_DRAW = 80; 
    
    var SWidthChanged = false;

    var masterMargin = {
        t: 5,
        r: MCHW / 2,
        b: 5,
        l: MCHW / 2
    }; 

    
    var PADDING = 10,
        TOP_PADDING = 8;

    var canvasReseted = false;

    var $_DT = mstrmojo.locales.datetime;

    
    function resetLocalVars() {
        tooltipShown = false;
        itemClicked = false;
        isDataSetChanged = false;
        chartSizeChanged = false;
        originalTouchPosition = 0;
        masterSliderClicked = null;
    }

    function getParentBkgColor() {
        var parentNode = this.domNode.parentNode;
        while (parentNode) {
            var compStyle = mstrmojo.css.getComputedStyle(parentNode);
            var bkgColor = compStyle.backgroundColor;
            if (bkgColor) {
                if (bkgColor.indexOf('rgba') >= 0) {
                    var rgba = this.utils.rgbaStr2rgba(bkgColor);
                    if (rgba && rgba[4]) {
                        return rgba;
                    }
                } else if (bkgColor.indexOf('rgb') >= 0) {
                    var rgb = $CLR.rgbStr2rgb(bkgColor);
                    return rgb;
                }

            }
            parentNode = parentNode.parentNode;
        }

        
        return [255, 255, 255];
    }

    var LIGHT_THEME = 0;
    var DARK_THEME = 1;

    function getUITheme() {
        var utils = this.utils;

        
        

        var rgb = getParentBkgColor.call(this);

        var opacity = this.formatProp.backgroundAlpha;

        rgb = utils.getRGBWithOpacity(rgb, opacity, this.formatProp.backgroundClr);

        var brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        if (brightness > 150) {
            this.theme = LIGHT_THEME;
        } else {
            this.theme = DARK_THEME;
        }

    }

    
    function addChartStatus(id) {
        chartStatus[id] = {isLegendBarOpen: false,
            legendBarWidth: 30,
            isLegendSelected: false,
            legendSelectedIndex: -1,
            timeSelectedIntervalPosition: {},
            currSelectionIdx: -1,
            usingCustomInterval: false};
    }

    
    function isScrollableElementTouched(touch) {

        
        var me = this,
            m = me.margin,
            chartWidth = me.getChartWidthOnScreen();

        var touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me);

        var x = touchPointOnWidget.touchX,
            y = touchPointOnWidget.touchY;

        if (x < m.l || x > (chartWidth + m.l) || y < m.t || y > this.canvas.height - m.b) {
            return false;
        }
        return true;
    }

    function isTouchedOnWidget(touch) {

        if (!touch) {
            return false;
        }
        var me = this;

        var touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me);

        var x = touchPointOnWidget.touchX,
            y = touchPointOnWidget.touchY;

        if ((x > 0 && x < me.getWidth()) && (y > 0 && y < me.getHeight())) {
            return true;
        }
        return false;
    }

    function getTouchedElement(touch) {
        var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode);
        return item || null;
    }

    
    function getMinYPosition(lines) {
        var l = lines.length;
        var i = 0, min;
        while (i < l) {
            if (lines[i]) {
                min = lines[i].y;
                break;
            }
            i++;
        }
        for (i = 0; i < l; i++) {
            if (lines[i]) {
                min = Math.min(min, lines[i].y);
            }
        }
        return min;
    }

    function resetBaseAndDerivedData(tsl) {
        var obm = this.baseModel;
        var currStatus = chartStatus[this.chartID];
        this.baseModel = this.getModel(tsl.ds) || this.baseModel;
        var bm = this.baseModel;

        this.checkData(bm);
        
        var err = bm.err || bm.eg;

        if (err) {
            this.renderErrorMessage(err);
            return false;
        }

        var bms = bm.series,
            m = this.model,
            cs = m.series,
        
        
            sl = bms.length,
            s = [],
            j = 0;

        for (j = 0; j < sl; j++) {
            s[j] = bms[j];
            
        }
        this.model.categories = bm.categories;
        this.model.series = s;
        this.model.colHeaders = bm.colHeaders;

        var currWindowSize = this.model.series[0].rv.length;
        if (this.windowSize !== currWindowSize) {
            
            currStatus.rns = 0;
            currStatus.rne = currWindowSize;
        }
        this.windowSize = currWindowSize;

        
        if (!bm.vp || !bm.vp.rl || bm.vp.rl.length < obm.vp.rl.length) {
            bm.vp = obm.vp;
        }
        isDataSetChanged = true;
        return true;
    }

    
    function localUpdateScrollerConfig() {
        var scl = this._scroller,
            m = this.model,
            margin = this.margin,
            currStatus = chartStatus[this.chartID],
            animationCanvas = this.animationCanvas,
            chartWidth = this.getChartWidthOnScreen(),
            offsetEnd = Math.max(this.acContentWidth - chartWidth, 0);
        var rns = (currStatus.rns !== 0 && currStatus.rns + 1 === currStatus.rne) ? currStatus.rns - 1 : currStatus.rns; 
        
        scl.origin = {
            x: parseInt(((rns - this.ACrns) * this.RTX), 10),
            y: 0
        };

        
        scl.hScroll = (offsetEnd !== 0 && scl.noHScroll !== true) || this.scrollPast;

        if (scl.hScroll) {
            
            scl.offset = {
                x: {
                    start: 0,
                    end: offsetEnd
                },
                scrollPast: this.scrollPast

            };
        }
        
        
        this.utils.translateCSS(-(scl.origin.x), scl.origin.y, false, this.animationCanvasDiv);
        this.utils.translateCSS(-(scl.origin.x) + this.maxYLblWidth, scl.origin.y, false, this.xLabelsDiv);

    }

    
    function getCurrencySymbolForMetric(m) {
        var s = m.series,
            ch = m.colHeaders,
            chl = ch[0].items.length;

        
        var hi0 = s[0].hi,
            fInfo = ch[ch.length - 1].items[hi0[hi0.length - 1]],
            f = fInfo.f;
        var cs = (fInfo && f && f.indexOf(fInfo.cs) >= 0) ? "," + fInfo.cs : "";

        if (cs === "" && f) {
            cs = f.indexOf("%") >= 0 ? ",%" : "";
        }

        if (cs === "" && f) {
            var q = null;
            if (f.indexOf('\'') >= 0) {
                q = '\'';
            } else if (f.indexOf("\"") >= 0) {
                q = "\"";
            }
            if (q) {
                var temp = f.substring(f.indexOf(q) + 1);
                cs = "," + temp.substring(0, temp.indexOf(q));
            }
        }

        return cs;
    }

    function hideMasterSliderTooltip() {
        var ms = this.masterSlider,
            stt = this.sliderTooltip,
            sttF = stt.firstChild,
            sttP = stt.lastChild,
            fc = ms.firstChild,
            lc = ms.lastChild;

        
        $CSS.removeClass(fc, 'mstrmojo-timeseries-span-shadow');
        $CSS.removeClass(lc, 'mstrmojo-timeseries-span-shadow');

        
        sttF.innerHTML = '';
        sttF.style.display = 'none';
        sttP.style.display = 'none';
    }

    
    function resizeMasterSliderDone() {
        var me = this,
            currStatus = chartStatus[this.chartID];

        
        if (currStatus.usingCustomInterval && me.currSelection) {
            me._timeSelector.toggleSelected(me.currSelection, false);
            me._timeSelector.toggleGlowEffect(me.currSelection, false);

            this.updateIntervalPosition();
            me.currSelection = null;
            currStatus.currSelectionIdx = -1;
        }
        if (chartSizeChanged && masterSliderClicked !== 'MS') {
            me.showMessage(); 

            this.makeSureMasterSliderNotBeyondTheMargin();
            this.makeSureSliderOnPoint();
            this.makeSureSelectedIntervalMoreThanTwo();
            this.makeSureMasterSliderNoOverlap();
            this.setMasterSliderLayout();
            window.setTimeout(function () {
                me.reDrawSlaveChart();
            }, 10);

        } else {
            
            masterSliderClicked = null;
        }
        
        hideMasterSliderTooltip.call(this);
    }

    function getFormattedDateForSliderTooltip(sliderTooltipXPosition) {
        var me = this,
            cat = me.model.categories,
            tp = cat.tp;

        var pos = Math.round((sliderTooltipXPosition - masterMargin.l) / me.MRTX),
            rVal = cat.items[pos];

        if (tp.toString() === me.DSS_XML_BASE_FORM_DATE) {
            rVal = me.getFormattedDateForTooltip(rVal, true);
        }

        return rVal;
    }

    function getPointDistanceSquare(p1, p2) {
        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
    }

    function getACRnsRne(rns, rne) {
        var me = this,
            currStatus = chartStatus[me.chartID],
            model = me.model,
            windowSize = me.windowSize,
            needRedraw = true,
            ACrns,
            ACrne;

        if ((!rns && rns !== 0) || !rne) {
            rns = currStatus.rns;
            rne = currStatus.rne;
        }

        var diff = rne - rns;

        model.currentRatio = Math.round(windowSize / ((diff - 1) || 1));
        if (model.currentRatio > rangeToSeriesMaxRatio) {
            var ACRation = (rangeToSeriesMaxRatio - 1) / 2;
            
            ACrns = Math.max(0, rns - ACRation * (diff - 1));
            ACrne = Math.min(windowSize, rne + ACRation * (diff - 1));
            if (ACrns === 0) {
                ACrne = rangeToSeriesMaxRatio * (diff - 1) + 1;
            } else if (ACrne === windowSize) {
                ACrns = ACrne - rangeToSeriesMaxRatio * (diff - 1) - 1;
            }
        } else {
            ACrns = 0;
            ACrne = windowSize;
            var ACdiff = ACrne - ACrns;
        }
        if (me.ACrns === ACrns && me.ACrne === ACrne) {
            needRedraw = false;
        } else {
            me.ACrns = ACrns;
            me.ACrne = ACrne;
        }

        return needRedraw;
    }

    function removeChildren(container) {
        var count = container && container.childNodes && container.childNodes.length,
            i;
        for (i = 0; i < count; ++i) {
            container.removeChild(container.firstChild);
        }

    }

    function removeLegendAndTimeSelectorChildren() {
        
        
        
        if (this._legend) {
            this._legend.destroy();
        }

        
        
        
        if (this._timeSelector) {
            this._timeSelector.destroy();
        }
    }

    
    mstrmojo.VisTimeSeries = mstrmojo.declare(

        
        mstrmojo.VisChartLine,

        
        [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

        {
            
            scriptClass: 'mstrmojo.VisTimeSeries',

            
            isLinearChart: true,

            
            highlightColor: '#ffffff',

            chartLineColors: ['#16b0ff', '#ff3729', '#04ba22', '#ff960e',
                '#ae79de', '#cccd25', '#19cee0', '#a9a9a9',
                '#b3cdef', '#ffa796', '#98df8a', '#ffbf80',
                '#dac3ec', '#dac3ec', '#a1dfea', '#d6d6d6'],

            
            switchSeriesOnTouch: false,

            
            multiTouch: true,

            
            margin: {
                t: 70,
                r: 1,
                b: 50,
                l: 5
            },

            SLXP: 0,
            
            SRXP: 0,
            

            
            isTimeSeries: true,

            
            maxXLabels: 4,

            
            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                useTranslate3d: true
            },
            
            scrollPast: true,
            
            isAndroidTab: false,

            
            masterContext: null,

            
            selectionOrLinkdrillOnRow: false,

            
            lastSelectedPoint: null,

            
            markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};left:{@left};top:{@top};z-index:{@zIndex};position:absolute;-webkit-transition: 0ms; transition: 0ms; -webkit-transform: translate3d(0px, 0px, 0px);" ' +
                ' mstrAttach:mousedown,mouseup,mousemove,click >' +
                '<canvas width="{@width}" height="{@slaveChartHeight}"></canvas>' +
                '<div style="overflow:hidden;position:absolute;left:0px;top:0px;">' +
                '<div id="{@id}-animation-canvas-div" class="mstrmojo-timeseries-animation-canvas" style="position:absolute;left:0px;top:0px;width:{@width};height:{@slaveChartHeight+"px"};">' +
                '<canvas style="position:absolute;left:0px;top:0px;" width="{@width}" height="{@slaveChartHeight}"></canvas>' +
                '</div>' +
                '</div>' +
                '<div style="overflow:hidden;position:absolute;left:0px;top:0px;">' +
                '<div id="{@id}-x-labels-div" class="mstrmojo-timeseries-animation-canvas" style="position:absolute;left:0px;top:0px;width:{@width};height={@slaveChartHeight+"px"}">' +
                '</div>' +
                '</div>' +
                '<canvas id="{@id}-highlight-canvas" style="position:absolute;left:0px;top:0px;" width="{@width}" height="{@slaveChartHeight}"></canvas>' +
                '<div id="{@id}-tooltip"></div>' +
                '<div id="{@id}-time-selector-div"></div>' +
                '<div id="{@id}-legend-bar-div" ></div>' +
                '<div id="{@id}-loading-msg" class="mstrmojo-loading-msg" style="display:none"></div>' +
                '<canvas id="{@id}-master-canvas" style=" position:absolute;left:0px;bottom:0px;" width="{@width}" height="{@masterChartHeight}"></canvas>' +
                '<div id="{@id}-master-div" class="mstrmojo-master-parent-div" width="{@width}" style="position:absolute;bottom:5px" >' +
                '<div id="{@id}-master-cover-span" style="position:absolute;left:0px;" class="mstrmojo-master-cover-span"></div>' +
                '<div id="{@id}-master-slider" class="mstrmojo-master-slider-div" clk="MS">' +
                '<canvas id="{@id}-master-img-L" width="20" height="20" style="position:absolute;left:0px" class="mstrmojo-timeseries-master-span" clk="L" ></canvas>' +
                '<canvas id="{@id}-master-slider" width="{@width}" height="{@masterChartHeight}" style="top:0px;left:0px" class="mstrmojo-master-slider-div-top"></canvas>' +
                '<canvas id="{@id}-master-img-R" width="20" height="20" style="position:absolute;right:0px" class="mstrmojo-timeseries-master-span" clk="R" ></canvas>' +
                '</div>' +
                '<div id="{@id}-master-cover-span" style="position:absolute;right:0px;" class="mstrmojo-master-cover-span"></div>' +
                '</div>' +
                '<div id="{@id}-slider-tooltip" style="position:absolute;left:0;top:0;z-index:150;width:{@width};">' +
                '<div class="timeseries-slider-tooltip"></div>' +
                '<canvas style="position:absolute;left:0px;top:20px;display: none;" width="6px" height="5px"></canvas>' +
                '</div>' +
                '<div id="{@id}-legend-tooltip" class="mstrmojo-Chart-tooltip timeseries-legend-tooltip"></div>' +
                '<span id="textSpan" style="z-index:-10;visibility:hidden;"></span>' +
                '<div id="{@id}-infowindow-anchor" style="position:absolute;width:18px;height:18px;display:block"></div>' +
                '<div id="{@id}-errMsg" class="mstrmojo-message" style="width:{@width};height:{@height};top:0px;left:0px;position:absolute;display:none; z-index:20;"></div>' +
                '</div>',
            
            markupSlots: {
                
                canvas: function () {
                    return this.domNode.firstChild;
                },

                
                animationCanvasDiv: function () {
                    return this.domNode.childNodes[1].firstChild;
                },

                
                animationCanvas: function () {
                    return this.domNode.childNodes[1].firstChild.firstChild;
                },

                
                itemsContainerNode: function () {
                    return this.domNode.childNodes[1];
                },

                
                xLabelsDiv: function () {
                    return this.domNode.childNodes[2].firstChild;
                },

                
                xLabelsDivContainer: function () {
                    return this.domNode.childNodes[2];
                },

                
                highlightCanvas: function () {
                    return this.domNode.childNodes[3];
                },

                
                tooltip: function () {
                    return this.domNode.childNodes[4];
                },

                timeSelectorDiv: function () {
                    return this.domNode.childNodes[5];
                },

                
                legendBarDiv: function () {
                    return this.domNode.childNodes[6];
                },

                loadingMsg: function () {
                    return this.domNode.childNodes[7];
                },

                masterCanvas: function () {
                    return this.domNode.childNodes[8];
                },

                masterSlider: function () {
                    return this.domNode.childNodes[9].childNodes[1];
                },

                sliderTooltip: function () {
                    return this.domNode.childNodes[10];
                },

                legendTooltip: function () {
                    return this.domNode.childNodes[11];
                },

                textSpan: function () {
                    return this.domNode.childNodes[12];
                },

                infoWindowAnchor: function () {
                    return this.domNode.childNodes[13];
                },

                errorMsg: function () {
                    return this.domNode.childNodes[14];
                }
            },

            
            getTextWidth: function gtw(str, fontStyle, zf) {
                this.textSpan.style.font = fontStyle;
                this.textSpan.innerHTML = str;
                if (zf) {
                    this.utils.changeElementSize(this.textSpan, 'font', zf);
                }
                var ret = this.textSpan.offsetWidth;

                return ret;
            },

            
            getTextWidthByElem: function gtwCvs(text, elem) {

                var computedStyle = mstrmojo.css.getComputedStyle(elem);
                var fontStyle = computedStyle.fontStyle + " "
                    + computedStyle.fontWeight + " "
                    + computedStyle.fontSize + "/"
                    + computedStyle.fontVariant
                    + " " + computedStyle.fontFamily;

                return this.getTextWidth(text, fontStyle);
            },

            
            getTextHeight: function gtw(str, fontStyle, zf) {
                this.textSpan.style.font = fontStyle;
                this.textSpan.innerHTML = str;
                if (zf) {
                    this.utils.changeElementSize(this.textSpan, 'font', zf);
                }
                var ret = this.textSpan.offsetHeight;

                return ret;
            },

            getMaxTextWidth: function (textArray, fontStyle) {
                var me = this,
                    l = textArray.length,
                    maxWidth = 0,
                    currWidth = 0,
                    i;
                for (i = 1; i < l; i++) {
                    currWidth = me.getTextWidth(textArray[i], fontStyle);
                    maxWidth = currWidth > maxWidth ? currWidth : maxWidth;
                }

                return maxWidth;
            },

            
            getChartWidthOnScreen: function getChartWidthOnScreen() {
                var m = this.margin;
                return this.getWidth() - m.r - m.l - chartStatus[this.chartID].legendBarWidth;
            },

            
            drawChartXYAxis: function drawChartXYAxis() {
                var utils = this.utils,
                    m = this.margin,
                    w = this.getWidth() - chartStatus[this.chartID].legendBarWidth,
                    h = this.canvas.height,
                    c = this.context;

                c.save();

                
                c.strokeStyle = utils.rgb2rgbStr(this.formatProp.textClr);
                c.lineWidth = 1;
                c.globalAlpha = 0.8;

                
                var xPos = Math.floor(m.l) - 0.5;
                utils.drawLineSet(this, [
                    {
                        x: xPos,
                        y: m.t
                    },
                    {
                        x: xPos,
                        y: h - m.b
                    }
                ], false, c);
                
                var yPos = Math.floor(h - m.b) + 0.5;
                utils.drawLineSet(this, [
                    {
                        x: m.l - this.maxYLblWidth,
                        y: yPos
                    },
                    {
                        x: w - m.r,
                        y: yPos
                    }
                ], false, c);

                c.restore();

            },

            
            setMasterSlider: function setMasterSlider() {
                var width = this.getWidth(),
                    h = this.masterCanvas.height - masterMargin.t - masterMargin.b,
                    utils = this.utils,
                    msl = this.masterSlider,
                    msStyle = msl.style,
                    mslp = msl.parentNode,
                
                    lcStyle = mslp.firstChild.style,
                
                    rcStyle = mslp.childNodes[2].style,
                    m = this.model,
                    mrtx = this.MRTX,
                    currStatus = chartStatus[this.chartID];

                
                mslp.style.display = 'block';
                mslp.style.height = h + 'px';
                mslp.style.width = width + 'px';
                

                msStyle.height = h + 'px';

                
                lcStyle.height = h - 2 + 'px';
                rcStyle.height = h - 2 + 'px';
                lcStyle.backgroundColor = rcStyle.backgroundColor = utils.rgb2rgbStr(this.formatProp.backgroundClr, this.formatProp.backgroundAlpha * 0.5);

                
                this.drawMasterChartHandler(msl.firstChild, MCHW, MCHH, true);
                
                this.drawMasterChartHandler(msl.lastChild, MCHW, MCHH, false);
                
                msl.firstChild.style.marginTop = msl.lastChild.style.marginTop = Math.round((h - MCHH) / 2) + 'px';

                
                this.calculateSXP(currStatus.rns, currStatus.rne, true);
                this.makeSureMasterSliderNotBeyondTheMargin();
                this.makeSureMasterSliderNoOverlap();
                this.setMasterSliderLayout();
            },

            drawMasterChartHandler: function drwMCH(canvas, w, h, isLeft) {
                var utils = this.utils,
                    ctx = canvas.getContext('2d');

                
                canvas.width = w;
                canvas.height = h;

                ctx.save();
                
                ctx.fillStyle = utils.rgb2rgbStr(this.formatProp.backgroundClr, 0.76);
                utils.drawRoundRect(ctx, 0.5, 0.5, w - 1, h - 1, 1, true);
                
                ctx.strokeStyle = utils.rgb2rgbStr(this.formatProp.textClr);
                ctx.lineWidth = 1;
                utils.drawRoundRect(ctx, 0.5, 0.5, w - 1, h - 1, 1);
                
                ctx.beginPath();
                ctx.lineWidth = 2;
                if (isLeft) {
                    ctx.moveTo(11, 6);
                    ctx.lineTo(7, 10);
                    ctx.lineTo(11, 14);
                } else {
                    ctx.moveTo(9, 6);
                    ctx.lineTo(13, 10);
                    ctx.lineTo(9, 14);
                }
                ctx.stroke();

                ctx.restore();
            },

            drawMasterChartDiv: function drwMCD(x, w) {
                var canvas = this.masterSlider.childNodes[1],
                    width = this.SRXP - this.SLXP + MCHW;

                
                if (canvas.width == width) {
                    
                } else {
                    var margin = masterMargin,
                        mcHeight = this.masterChartHeight,
                        divHeight = mcHeight - margin.t - margin.b,
                        h = (divHeight - MCHH) / 2;

                    
                    canvas.height = divHeight
                    canvas.width = width;

                    var ctx = canvas.getContext('2d');
                    ctx.save();
                    ctx.strokeStyle = this.utils.rgb2rgbStr(this.formatProp.textClr);
                    ctx.lineWidth = 1;
                    ctx.beginPath();

                    var leftX = 0.5 + MCHW / 2;
                    var rightX = width - 0.5 - MCHW / 2;
                    ctx.moveTo(leftX, h);
                    ctx.lineTo(leftX, 0);
                    ctx.lineTo(rightX, 0);
                    ctx.lineTo(rightX, h);

                    ctx.moveTo(leftX, h + MCHH);
                    ctx.lineTo(leftX, divHeight);
                    ctx.lineTo(rightX, divHeight);
                    ctx.lineTo(rightX, h + MCHH);

                    ctx.stroke();
                    ctx.restore();
                }

            },

            
            setMasterSliderLayout: function setMasterSliderLayout() {
                var width = this.getWidth(),
                    utils = this.utils,
                    msl = this.masterSlider,
                    msStyle = msl.style,
                    mslp = msl.parentNode,
                
                    lcStyle = mslp.firstChild.style,
                
                    rcStyle = mslp.childNodes[2].style;

                lcStyle.width = (this.SLXP) + 'px';
                rcStyle.width = (width - this.SRXP) + 'px';

                
                var slWidth = (this.SRXP - this.SLXP);

                msStyle.width = (slWidth + MCHW) + 'px';
                
                utils.translateCSS(this.SLXP - MCHW / 2, 0, false, msl);

                this.drawMasterChartDiv();

            },

            makeSureMasterSliderNoOverlap: function makeSureMasterSliderNoOverlap(fixWhich) {
                var slWidth = this.SRXP - this.SLXP;

                
                if (slWidth < MCHW) {
                    slWidth = MCHW;
                    var width = this.getWidth();

                    if (!fixWhich) {
                        fixWhich = this.SRXP + MCHW / 2 === width - 1 ? "R" : "L";
                    }

                    if (fixWhich == "L") {
                        this.SRXP = this.SLXP + MCHW;
                    } else {
                        this.SLXP = this.SRXP - MCHW;
                    }

                }
            },

            
            calculateSXP: function calculateSXP(rns, rne, intervalChanged) {
                if (intervalChanged) {
                    this.SLXP = Math.round((this.MRTX * rns) + masterMargin.l);
                    this.SRXP = Math.round((this.MRTX * (rne - 1)) + masterMargin.l);
                } else {
                    var width = this.SRXP - this.SLXP;
                    this.SLXP = Math.round((this.MRTX * rns) + masterMargin.l);
                    this.SRXP = this.SLXP + width;
                }

            },

            makeSureMasterSliderNotBeyondTheMargin: function makeSureMasterSliderNotBeyondTheMargin(keepWidth) {
                var SWidth = this.SRXP - this.SLXP;
                var width = this.getWidth();
                if (this.SLXP < masterMargin.l) {
                    this.SLXP = masterMargin.l; 
                    if (keepWidth) {
                        this.SRXP = this.SLXP + SWidth;
                    }
                }
                if (this.SRXP > width - masterMargin.r - 1) {
                    this.SRXP = width - masterMargin.r - 1; 
                    if (keepWidth) {
                        this.SLXP = this.SRXP - SWidth;
                    }
                }
            },

            makeSureSelectedIntervalMoreThanTwo: function makeSureSelectedIntervalMoreThanTwo() {
                var mrtx = this.MRTX,
                    width = this.getWidth();
                if (this.SRXP - this.SLXP < mrtx) {
                    if (masterSliderClicked) {
                        if (masterSliderClicked === 'L') {
                            this.SLXP = this.SRXP - mrtx;
                        } else {
                            this.SRXP = this.SLXP + mrtx;
                        }
                    } else if (this.SLXP + mrtx <= width - masterMargin.r) {
                        this.SRXP = this.SLXP + mrtx;
                    } else {
                        this.SLXP = this.SRXP - mrtx;
                    }
                }
            },

            makeSureSXPNotEqual: function makeSureSXPNotEqual() {
                var mrtx = this.MRTX,
                    width = this.getWidth();
                if (this.SLXP === this.SRXP) {
                    if (masterSliderClicked) {
                        if (masterSliderClicked === 'L') {
                            this.SLXP -= mrtx;
                        } else {
                            this.SRXP += mrtx;
                        }
                    } else if (this.SRXP + mrtx <= width - masterMargin.r) {
                        this.SRXP += mrtx;
                    } else {
                        this.SLXP -= mrtx;
                    }
                }
            },

            makeSureSliderOnPoint: function makeSureSliderOnPoint() {
                var mrtx = this.MRTX,
                    diff = 0,
                    currStatus = chartStatus[this.chartID];
                ;
                if (masterSliderClicked) {
                    diff = Math.round((this.SRXP - this.SLXP) / mrtx);
                    if (masterSliderClicked === 'L') {
                        this.SLXP = this.SRXP - diff * mrtx;
                    } else if (masterSliderClicked === 'R') {

                        this.SRXP = this.SLXP + diff * mrtx;
                    } else {
                        this.calculateSXP(currStatus.rns, currStatus.rne, true);
                    }
                }
            },

            
            initScroller: function initScroller(scroller) {

                if (!scroller.offset && this.scrollPast) {
                    scroller.offset = {
                        scrollPast: this.scrollPast
                    };
                }

                this._super(scroller);

                var me = this;

                
                this._scrollDoneListener = this._scroller.attachEventListener('scrollDone', me.id, function (evt) {
                    
                    var m = me.model,
                        currStatus = chartStatus[me.chartID],
                        r = currStatus.rne - currStatus.rns,
                        rns = me.ACrns + parseInt(Math.round(me._scroller.origin.x / me.RTX), 10);
                    if (r === 1) { 
                        rns++;
                    }

                    var rne = rns + r;

                    
                    if (rns < 0) {
                        currStatus.rns = 0;
                        currStatus.rne = currStatus.rns + r;
                    } else if (rne > m.series[0].rv.length) {
                        currStatus.rne = m.series[0].rv.length;
                        currStatus.rns = currStatus.rne - r;
                    } else {
                        currStatus.rns = rns;
                        currStatus.rne = rne;
                    }
                    me.updateRnsRne();
                    SWidthChanged = false;

                    
                    me.incFetchChart();
                    
                });

                
                this._scrollMovedListener = this._scroller.attachEventListener('scrollMoved', me.id, function (evt) {
                    if (tooltipShown) {
                        me.hiddenTooltipAndShowTimeSelector();
                    }

                    
                    var m = me.model,
                        currStatus = chartStatus[me.chartID],
                        sl = m.series[0].rv.length,
                        r = currStatus.rne - currStatus.rns,
                        rns = me.ACrns + Math.round(evt.x / me.RTX),
                        rne = Math.min(rns + r, sl);

                    if (rns < 0) {
                        rns = 0;
                    }

                    if (rne - rns != r) {
                        SWidthChanged = true;
                    }

                    
                    me.utils.translateCSS(-evt.x + me.maxYLblWidth, -evt.y, false, me.xLabelsDiv);

                    me.calculateSXP(rns, rne, SWidthChanged);

                    me.makeSureSXPNotEqual();
                    me.makeSureMasterSliderNoOverlap();
                    me.setMasterSliderLayout();

                });

            },

            initFromVisProps: function (vp) {
                var propValue = vp ? vp : {};

                this.formatProp = {};

                this.formatProp.backgroundClr = propValue.fbg ? $CLR.hex2rgb(propValue.fbg) : [0, 0, 0];

                this.formatProp.textClr = propValue.flt ? $CLR.hex2rgb(propValue.flt) : [255, 255, 255];

                this.formatProp.tooltipClr = propValue.ftt ? $CLR.hex2rgb(propValue.ftt) : [255, 255, 255];

                this.formatProp.backgroundAlpha = propValue.fbt != undefined ? ( 1 - parseInt(propValue.fbt) / 100) : 1;

                var getBool = function (v) {
                    if (v == true || v == "1" || v == 1 || v == "true") {
                        return true;
                    }

                    return false;
                }

                this.formatProp.useCustomAxisScale = propValue.fcas ? getBool(propValue.fcas) : false;

                var numCheck = function (num) {
                    if (num > Number.MAX_VALUE) {
                        num = Number.MAX_VALUE;
                    }
                    if (num < -1 * Number.MAX_VALUE) {
                        num = -1 * Number.MAX_VALUE;
                    }
                    return num;

                }

                this.formatProp.minValue = propValue.fmiav ? numCheck(parseFloat(propValue.fmiav)) : "";

                this.formatProp.maxValue = propValue.fmaav ? numCheck(parseFloat(propValue.fmaav)) : "";

                this.formatProp.condenseLabels = propValue.fcl ? getBool(propValue.fcl) : true;

                this.chartLineColors = ['#16b0ff', '#ff3729', '#04ba22', '#ff960e',
                    '#ae79de', '#cccd25', '#19cee0', '#a9a9a9',
                    '#b3cdef', '#ffa796', '#98df8a', '#ffbf80',
                    '#dac3ec', '#dac3ec', '#a1dfea', '#d6d6d6'];

                for (var i = 0; i < this.chartLineColors.length; i++) {
                    var propName = '' + Math.floor(i / 4) + i % 4;
                    propName = "fs" + propName;

                    var color = propValue[propName];
                    if (color) {
                        this.chartLineColors[i] = "#" + color;
                    }
                }

                
                this.glowColor = this.utils.rgb2rgbStr(this.formatProp.tooltipClr);
                
            },

            
            getMaxValue: function getMaxV() {
                if (typeof this.formatProp.maxValue == "number") {
                    return this.formatProp.maxValue;
                } else {
                    return this._super();
                }

            },

            
            getMinValue: function getMinV() {
                if (typeof this.formatProp.minValue == "number") {
                    return this.formatProp.minValue;
                } else {
                    return this._super();
                }
            },

            preBuildRendering: function preBR() {
                if (this._super) {
                    this._super();
                }
                this.masterChartHeight = 90;
                this.slaveChartHeight = this.getHeight() - this.masterChartHeight;
            },

            buildRendering: function () {
                var that = this;
                var backup = mstrmojo.string.apply;
                mstrmojo.string.apply = function (tmpl, obj) {
                    if (!tmpl) {
                        return "";
                    }
                    return tmpl.replace(/\{([^\}]+)\}/gm,
                        function tokenRepl(token, prop) {
                            var s = token.replace(/@/g, 'that.');
                            var res = eval(s);
                            return res === undefined ? '' : res;
                        }
                    );
                };

                if (this._super) {
                    this._super();
                }

                mstrmojo.string.apply = backup;
            },

            
            postBuildRendering: function postBR() {
                var model = this.model;

                this.checkData(model);

                
                var err = model.err || model.eg;

                
                var xtabModel = this.xtabModel,
                    docModel = (xtabModel && xtabModel.docModel);

                if (err) {
                    
                    if (docModel && docModel.prompts) {
                        this.model.docModel = docModel;
                    }
                    this.renderErrorMessage(err);
                    return;
                } else {
                    this.errorMsg.style.display = 'none';
                }

                resetLocalVars();
                getUITheme.call(this);

                this.updateSelectionLinkdrillInfo(model);
                
                
                if (this.baseModel && !model.vp) {
                    this.model = this.baseModel;
                }

                this.chartID = this.getChartID(docModel);

                if (!chartStatus[this.chartID]) {
                    addChartStatus(this.chartID);
                }
                
                this.scrollerConfig.scrollEl = this.animationCanvasDiv;

                
                this.isAndroidTab = !!mstrApp.isTablet(); 
                this.masterContext = this.masterCanvas.getContext('2d');

                this.renderVisTooltip();
                
                this.setMarginTopByTooltipHeight();

                this.renderLegend();

                if (this._super) {
                    this._super();
                }

                this.renderTimeSelector();
                this.setAnimationCanvasContainer();

                
                localUpdateScrollerConfig.call(this);

                
                if (docModel && docModel.prompts) {
                    this.model.docModel = docModel;
                }

                this.drawSliderTooltipPointer();

                
                var me = this;
                if (docModel) {
                    this._infoWClosedListener = this.xtabModel.docModel.attachEventListener('infoWindowClosed', this.id, function (evt) {
                        var infoWindowK = evt.psKey;
                        
                        if (!me.hasNonifwTarget && me.selectorTargets && me.selectorTargets[infoWindowK]) {
                            

                            
                            
                            
                            
                            
                            
                            
                            
                            me.lastSelectedPoint = null;
                            me.incFetchChart(true);
                            
                            return;
                        }

                    });
                }

                this.fullScreenListener = mstrmojo.touchManager.attachEventListener('fullScreenStateChange', this.id, function (evt) {
                    this.adjustWidgetOffsets();
                });

                this.renderLegendTooltip();

                
                
                

                
                

            },

            
            ongridDataChange: function onGridDataChange(evt) {
                this.model = this.gridData;
            },

            getChartID: function getChartID(docModel) {
                var chartID = "";

                var layoutModel = docModel ? docModel : (this.layoutModel ? this.layoutModel : ( this.model.layoutModel ? this.model.layoutModel : null ));

                if (layoutModel) {
                    chartID = layoutModel.oid + "_" + layoutModel.currlayKey + "_" + this.model.k;
                    
                    

                } else if (this.model.mid) {
                    chartID = this.model.mid;
                } else {
                    chartID = widgetCount++;
                }
                
                return chartID;

            },

            checkData: function checkData(model) {
                var colHeaders = model.colHeaders,
                    categories = model.categories;

                if (!colHeaders || (colHeaders && colHeaders.length < 1)) {
                    this.model.err = mstrmojo.desc(8626, "The Time Series widget requires at least one attribute on the row axis and at least one metric on the column axis; optionally, one attribute can be placed above the metrics.");
                }
                if (colHeaders && colHeaders.length >= 1 && !this.isMetric(colHeaders[colHeaders.length - 1].items)) {
                    this.model.err = mstrmojo.desc(8626, "The Time Series widget requires at least one attribute on the row axis and at least one metric on the column axis; optionally, one attribute can be placed above the metrics.");
                }

                if ((categories && (!categories.items || categories.items.length < 2))) {
                    this.model.err = mstrmojo.desc(8475, 'There is not enough data to plot the graph.');
                }

            },

            renderErrorMessage: function renderErrorMessage(msg) {
                this.errorMsg.innerHTML = msg; 
                this.errorMsg.style.display = 'block';
            },

            isMetric: function isMetric(items) {
                if (items && items.length > 0 && items[0].cs != null) {
                    return true;
                }
                return false;
            },

            updateSelectionLinkdrillInfo: function uscld(model) {
                
                var rowHeaders = model.rowHeaders,
                    rowHL = rowHeaders.length;
                for (var i = 0; i < rowHL; i++) {
                    var rowH = rowHeaders[i];
                    if (rowH.sc && rowH.sc.tks) {
                        this.selectionOrLinkdrillOnRow = true;
                        return;
                    }
                    if (rowH.lm && rowH.lm[0] && rowH.lm[0].links) {
                        this.selectionOrLinkdrillOnRow = true;
                        return;
                    }
                }
            },

            
            hasPageBy: function hasPageBy() {
                if (this.baseModel && this.baseModel.phs && this.baseModel.phs.show) {
                    return true;
                }
                return false;
            },




            setlegendStatus: function setlegendStatus(ilo, lbw) {
                chartStatus[this.chartID].legendBarWidth = lbw;
                chartStatus[this.chartID].isLegendBarOpen = ilo;
            },

            setLegendSelected: function setLegendSelected(ils, lsi) {
                chartStatus[this.chartID].isLegendSelected = ils;
                chartStatus[this.chartID].legendSelectedIndex = lsi;

            },

            getLegendBarDiv: function getLegendBarDiv() {
                return this.domNode.childNodes[6];
            },

            getTimeSelectorDiv: function getTimeSelectorDiv() {
                return this.domNode.childNodes[5];
            },

            renderLegend: function renderLegend() {
                var placeholder = this.legendBarDiv;
                var m = this.margin;
                var chartID = this.chartID;
                var props = {
                    placeholder: placeholder,
                    model: this.model,
                    utils: this.utils,
                    widget: this,
                    isLegendBarOpen: chartStatus[chartID].isLegendBarOpen,
                    isAndroidTab: this.isAndroidTab,
                    isLegendSelected: chartStatus[chartID].isLegendSelected,
                    legendSelectedIndex: chartStatus[chartID].legendSelectedIndex,
                    top: m.t + "px",
                    right: "0px",
                    zIndex: 1
                };

                var w = new mstrmojo.VisTimeSeriesLegend(props);
                w.render();
                this._legend = w;
            },

            renderTimeSelector: function renderTimeSelector() {
                var placeholder = this.timeSelectorDiv;
                var m = this.margin;
                var chartID = this.chartID;
                var props = {
                    placeholder: placeholder,
                    offsetx: this.margin.l,
                    widget: this,
                    chartStatus: chartStatus[this.chartID]
                };

                var w = new mstrmojo.VisTimeSeriesTimeSelector(props);
                w.render();
                this._timeSelector = w;
            },

            renderVisTooltip: function renderVisTooltip() {
                
                var props = {
                    placeholder: this.tooltip,
                    cssClass: 'timeseries-tooltip'
                };
                this._tooltip = new mstrmojo.VisTooltip(props);
                this._tooltip.render();

                this._tooltip.toggle(false);
            },

            renderLegendTooltip: function renderLegendTooltip() {
                var props = {
                    placeholder: this.legendTooltip,
                    boundary: this.domNode
                };
                this._legendTooltip = new mstrmojo.VisTextTooltip(props);
                this._legendTooltip.render();

                this._legendTooltip.toggle(false);
            },

            setAnimationCanvasContainer: function setAnimationCanvasContainer() {
                var currStatus = chartStatus[this.chartID],
                    m = this.margin;
                
                this.itemsContainerNode.style.left = m.l + 'px';
                this.xLabelsDivContainer.style.left = (m.l - this.maxYLblWidth) + 'px';
            },

            
            updateRnsRne: function updateRnsRne(rns, rne) {
                var currStatus = chartStatus[this.chartID],
                    m = this.model;

                if ((rns == 0 || rns) && rne) {
                    currStatus.rns = rns;
                    currStatus.rne = rne;
                }
                m.rns = currStatus.rns;
                m.rne = currStatus.rne;
            },

            
            drawPreparation: function drawPreparation(windowSize, rns, rne) {
                var me = this,
                    margin = this.margin,
                    model = me.model,
                    diff = rne - rns,
                    height = me.getHeight() - me.masterChartHeight,
                    ctx = me.animationContext;

                
                var chartWidth = me.getChartWidthOnScreen();
                
                this.chartWidth = chartWidth;

                getACRnsRne.call(this, rns, rne);
                var ACdiff = me.ACrne - me.ACrns;

                
                if (diff < windowSize) {
                    if (diff > 1) {
                        diff--;
                    }
                    if (ACdiff > 1) {
                        ACdiff--;
                    }
                    windowSize--;
                }

                this.itemsContainerNode.style.width = chartWidth + 'px';
                this.itemsContainerNode.style.height = height + 'px';

                this.xLabelsDivContainer.style.width = me.maxYLblWidth + chartWidth + 'px';
                this.xLabelsDivContainer.style.height = height + 'px';

                
                totalChartWidth = (windowSize / diff) * chartWidth;

                me.totalChartWidth = totalChartWidth;
                var acContentWidth = 0;
                if (model.currentRatio > rangeToSeriesMaxRatio) {
                    acContentWidth = (ACdiff / diff) * chartWidth;
                } else {
                    acContentWidth = totalChartWidth;
                }
                this.acContentWidth = acContentWidth;

                var acWidth = rangeToSeriesMaxRatio * this.getWidth();
                if (me.animationCanvas.width !== acWidth) {
                    canvasReseted = true;
                }
                me.animationCanvas.width = acWidth;

                
                me.RTX = (totalChartWidth - 1) / (this.windowSize - 1);

            },

            
            drawChart: function drwchrt() {
                var model = this.model;
                if (model.err) {
                    return;
                }

                var me = this,

                    mvalues = model.mvalues,
                    width = me.getWidth(),
                    margin = me.margin,
                    utils = me.utils,
                    values = model.series,
                    ylbls = model.ylbls,
                    windowSize = me.windowSize,
                    currStatus = chartStatus[this.chartID];

                
                if ((!currStatus.rns && currStatus.rns != 0) || !currStatus.rne || currStatus.rns < 0 || currStatus.rne > windowSize) {
                    currStatus.rns = model.rns;
                    currStatus.rne = model.rne;

                    
                    if ((currStatus.rne - currStatus.rns) < 2) {
                        if (currStatus.rns > 0) {
                            currStatus.rns = currStatus.rne - 2;
                        } else {
                            currStatus.rne = currStatus.rns + 2;
                        }
                    }
                }
                this.updateRnsRne();
                
                var mch = me.masterChartHeight;

                var height = me.slaveChartHeight;

                if (!values) {
                    return;
                }

                if (me.isDrawAxis && me.drawYAxisLabels) {
                    margin.l = utils.getLabelWidthForMargin(me, model.mls);
                }

                
                me.masterCanvas.height = mch;
                me.masterCanvas.width = width;
                
                utils.fillMasterChartBackground(me, 0, masterMargin.t, width, mch - masterMargin.t - masterMargin.b, masterMargin.b, me.masterContext);

                me.MRTY = (mch - masterMargin.t - masterMargin.b - 1 - 3 ) / (mvalues[mvalues.length - 1] - mvalues[0]);
                me.MRTX = (width - masterMargin.l - masterMargin.r - 1) / (windowSize - 1);

                
                me.drawSeries(0, windowSize, currStatus.rns, currStatus.rne, values, me.masterContext, true);

                me.setMasterSlider();

                this.calculateRnsRneFromSXP();

                if (me.canvas.height != height || me.animationCanvas.height != height || me.highlightCanvas.height != height || me.canvas.width != width) {
                    me.canvas.height = me.animationCanvas.height = me.highlightCanvas.height = height;
                    me.canvas.width = me.highlightCanvas.width = width;
                    canvasReseted = true

                    
                    utils.fillBackground(me);
                }

                
                this.maxYLblWidth = this.getMaxTextWidth(ylbls, this.mstrmojo_Chart_lbl_font) + 5;

                this.drawPreparation(windowSize, currStatus.rns, currStatus.rne);
                
                me.RTY = (height - margin.t - margin.b - 1 - 4) / (mvalues[mvalues.length - 1] - mvalues[0]);

                
                

                me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, me.animationContext, false);

            },

            calculateRnsRneFromSXP: function calrns() {
                var me = this;

                var rne = Math.round((me.SRXP - masterMargin.l) / me.MRTX) + 1; 
                rne = Math.min(rne, me.windowSize); 
                var rns = Math.round((me.SLXP - masterMargin.l) / me.MRTX);

                this.updateRnsRne(rns, rne);
            },

            
            reDrawSlaveChartImpl: function reDrawSlaveChartImpl() {
                var me = this,
                    model = me.model,
                    currStatus = chartStatus[this.chartID],
                    values = model.series,
                    context = me.animationContext;



                this.drawPreparation(me.windowSize, currStatus.rns, currStatus.rne);

                me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, context, false);

                
                localUpdateScrollerConfig.call(me);
                this.removeLabels();
                itemClicked = true;
                this.drawLabels();
                itemClicked = false;
            },

            
            redrawSeries: function redrawSeries() {
                var me = this,
                    model = me.model,
                    values = model.series,
                    context = me.animationContext,
                    windowSize = me.windowSize,
                    ht = me.getHeight(),
                    currStatus = chartStatus[this.chartID];

                
                me.animationCanvas.width = me.animationCanvas.width;

                me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, context, false);

                localUpdateScrollerConfig.call(me);

                this.removeLabels();
                itemClicked = true;
                this.drawLabels();
                itemClicked = false;
            },

            
            incFetchChart: function incFetchChart(mustRedraw) {
                var me = this,
                    model = me.model,
                    currStatus = chartStatus[this.chartID],
                    values = model.series,
                    context = me.animationContext,
                    m = me.margin,
                    utils = me.utils,
                    lines = [],
                    width = me.getWidth(),
                    chartWidth = me.getChartWidthOnScreen(),
                
                    h = me.canvas.height,
                
                    windowSize = me.windowSize;

                var v0l = values[0].rv.length;
                var diff = currStatus.rne - currStatus.rns;
                var needRedraw = getACRnsRne.call(this);
                
                var redrawChart = mustRedraw || needRedraw || currStatus.isLegendSelected || me.needRedrawVerticalLine;
                if (redrawChart) {
                    var ACdiff = me.ACrne - me.ACrns;
                    
                    if (diff < v0l) {
                        if (diff > 1) {
                            diff--;
                        }
                        if (ACdiff > 1) {
                            ACdiff--;
                        }
                        v0l--;
                    }

                    
                    totalChartWidth = (v0l / diff) * chartWidth;

                    me.totalChartWidth = totalChartWidth;
                    var acContentWidth = 0;
                    if (model.currentRatio > rangeToSeriesMaxRatio) {
                        acContentWidth = (ACdiff / diff) * chartWidth;
                    } else {
                        acContentWidth = totalChartWidth;
                    }
                    this.acContentWidth = acContentWidth;

                    
                    me.animationCanvas.width = me.animationCanvas.width;

                    me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, context, false);

                    
                    localUpdateScrollerConfig.call(me);
                }

                this.removeLabels();
                itemClicked = true;
                this.drawLabels(!redrawChart);
                itemClicked = false;
            },

            
            reDrawSlaveChart: function reDrawSlaveChart() {
                var me = this;

                this.calculateRnsRneFromSXP();
                this.reDrawSlaveChartImpl();

                chartSizeChanged = false;
                masterSliderClicked = null;
                this.hideMessage();
            },

            drawSeries: function drawSeries(start, end, rns, rne, values, context, isMasterChart) {
                var me = this,
                    utils = me.utils,
                    lines = [],
                    k = 0,
                    vl = values.length;

                var lineWidth = isMasterChart ? 1 : (rne - rns > 180 ? 1 : 2);
                
                for (var j = vl - 1; j >= 0; j--) {
                    lines = [];
                    k = 0;
                    for (var i = start; i < end; i++) {
                        var val = values[j].rv[i];
                        if (val.length === 0) {
                            lines[k++] = null;
                            continue;
                        }

                        lines[k] = {
                            x: isMasterChart ? ((i * me.MRTX) + masterMargin.l + 1) : ((i - start) * me.RTX ),
                            y: isMasterChart ? utils.getMasterYValue(me, val, masterMargin) : utils.getYValue(me, val)
                        };
                        k++;
                    }

                    me.drawChartLine(lines, rns - start, rne - start, j, context, isMasterChart, lineWidth);

                }

                if (!isMasterChart && me.lastSelectedPoint) {
                    me.highlightSelectedPoint();
                }
            },

            getSerieColor: function getSerieColor(serieIndex) {
                var clrLength = this.chartLineColors.length;
                
                return this.chartLineColors[serieIndex % clrLength];
            },

            
            drawChartLine: function drwcl(lines, rns, rne, si, context, isMasterChart, lw) {

                var me = this,
                    m = me.model,
                    s = m.series[si],
                    utils = this.utils,
                    currStatus = chartStatus[this.chartID];

                context.save();
                context.lineCap = 'round';
                context.lineWidth = lw || 2;
                context.lineJoin = 'round';

                context.beginPath();


                if (this.formatProp && this.formatProp.useCustomAxisScale) {
                    var margin;
                    if (!isMasterChart) {
                        margin = me.margin;
                        context.rect(0, margin.t, me.animationCanvas.width, me.slaveChartHeight - margin.b - margin.t);
                    } else {
                        margin = masterMargin;
                        context.rect(0, margin.t, me.getWidth(), me.masterChartHeight - margin.b - margin.t);
                    }
                    context.clip();
                }


                var clr = this.getSerieColor(si),
                    rgbClr = $CLR.hex2rgb(clr),
                    l = lines.length,
                    dataPointPerScreen = rne - rns;

                context.strokeStyle = clr;

                if (currStatus.isLegendSelected && !isMasterChart) {
                    if (currStatus.legendSelectedIndex === si) {
                        var MaxY = this.canvas.height - this.margin.b;
                        var start = rns, end = rne - 1;
                        for (var i = 0; i < Math.ceil((l - 1 - rns) / (dataPointPerScreen - 1)); i++) {
                            if (mstrmojo.dom.isIE10) {
                                utils.drawLineAreaWithSplit(me, lines, start, end, MaxY, rgbClr, context, MAXPOINTS_PER_DRAW);
                            } else {
                                utils.drawLineArea(me, lines, start, end, MaxY, rgbClr, context);
                            }
                            start = end;
                            end = Math.min(start + dataPointPerScreen - 1, l - 1);
                        }
                        start = Math.max(rns - dataPointPerScreen + 1, 0), end = rns;
                        for (var i = Math.ceil((rns) / (dataPointPerScreen - 1)); i > 0; i--) {
                            if (mstrmojo.dom.isIE10) {
                                utils.drawLineAreaWithSplit(me, lines, start, end, MaxY, rgbClr, context, MAXPOINTS_PER_DRAW);
                            } else {
                                utils.drawLineArea(me, lines, start, end, MaxY, rgbClr, context);
                            }

                            end = start;
                            start = Math.max(start - dataPointPerScreen + 1, 0);
                        }
                        if (mstrmojo.dom.isIE10) {
                            utils.drawLineAreaWithSplit(me, lines, start, end, MaxY, rgbClr, context, MAXPOINTS_PER_DRAW);
                        } else {
                            utils.drawLineArea(me, lines, start, end, MaxY, rgbClr, context);
                        }
                        context.strokeStyle = this.highlightColor;
                        context.globalAlpha = 1;
                        context.lineWidth = 2;
                    } else {
                        context.globalAlpha = 0.3;
                        context.lineWidth = 1;
                    }
                }

                if (mstrmojo.dom.isIE10) {
                    utils.drawLineSetWithSplit(me, lines, false, context, MAXPOINTS_PER_DRAW);
                } else {
                    utils.drawLineSet(me, lines, false, context);
                }

                
                

                context.restore();

            },

            
            drawLabels: function drwlbls(needNotDrawVerticalGridLine) {
                
                this.drawChartXYAxis();
                if (this._super) {
                    this._super(needNotDrawVerticalGridLine);
                }
            },

            drawSelector: function drwsl(lbl, rl, intervalChanged) {
                var m = this.model,
                    sl = m.series[0].rv.length,
                    rng = sl,
                    bm = this.baseModel,
                    row = bm.rowHeaders,
                    currStatus = chartStatus[this.chartID],
                    rns = currStatus.rns,
                    rne = currStatus.rne;

                if (intervalChanged) {

                    
                    var rs = parseInt(rl.rs, 10);
                    var sr = rl.sr;

                    for (var i = 0; i < row.length; i++) {
                        
                        if (row[i].id === sr) {
                            rng = row[i].l * rs;
                            break;
                        }
                    }

                    
                    if (rng < 2) {
                        rng = 2;
                    }

                    var index = mstrmojo.dom.findAncestorByAttr(lbl, "value", true, this.domNode);

                    
                    
                    
                    
                    
                    
                    
                    
                    
                    var right = rne;
                    if (right - rng >= 0) {
                        currStatus.rns = right - rng;
                        currStatus.rne = right;
                    } else {
                        currStatus.rns = 0;
                        currStatus.rne = rng < sl ? rng : sl;
                    }
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    

                    this.updateIntervalPosition();
                    
                    this.updateRnsRne();
                }
                this.refreshChart(true, isDataSetChanged);

                itemClicked = false;
                this.hideMessage();
            },

            
            getTouchValue: function gtvlindx(x, y) {
                var md = this.model,
                    m = this.margin,
                    currStatus = chartStatus[this.chartID];

                
                var sz = currStatus.rne - currStatus.rns > 0 ? currStatus.rne - currStatus.rns > 1 ? currStatus.rne - currStatus.rns : 2 : this.windowSize;
                var touchVal = Math.round(((x - m.l) * (sz - 1)) / (this.getChartWidthOnScreen() ));
                return (touchVal < sz) ? touchVal : null;
            },

            
            getNearestPoint: function getNP(touchX, touchY) {
                var me = this,
                    currStatus = chartStatus[this.chartID],
                    margin = me.margin;

                var touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);
                touchX = touchPointOnWidget.touchX;
                touchY = touchPointOnWidget.touchY;

                
                if (touchX < margin.l || touchY < margin.t || touchY > me.canvas.height - margin.b) {
                    return;
                }

                var xIndexOnScreen = this.getTouchValue(touchX, touchY);

                var rowIdx = xIndexOnScreen + currStatus.rns;
                var pointX = (xIndexOnScreen * me.RTX) + me.margin.l;
                var pointY, serieIdx;

                if (currStatus.isLegendSelected) {
                    serieIdx = currStatus.legendSelectedIndex;
                    pointY = me.utils.getYValue(me, me.model.series[serieIdx].rv[rowIdx]);
                } else {
                    var nearestPoint = me.utils.getSeriesIndexAndYValue(me, rowIdx, touchY);
                    serieIdx = nearestPoint.si;
                    pointY = nearestPoint.y;
                }

                return { rowIdx: rowIdx, serieIdx: serieIdx, point: {x: pointX, y: pointY} };
            },

            
            highlightPoint: function hghlghtpnt(x, touchX, touchY) {

                
                var me = this,
                    ctx = me.highlightContext,
                    height = me.highlightCanvas.height,
                    mg = me.margin,
                    m = me.model,
                    utils = me.utils,
                    currStatus = chartStatus[this.chartID],
                    si = currStatus.isLegendSelected ? currStatus.legendSelectedIndex : me.seriesIndex;

                
                
                
                this.highlightCanvas.width = this.highlightCanvas.width;
                if (x < 0) {
                    return;
                }

                var xcoord = (x * me.RTX) + mg.l;

                
                
                ctx.strokeStyle = this.utils.rgb2rgbStr(this.formatProp.textClr);

                ctx.lineCap = "round";

                
                ctx.lineWidth = 2;
                ctx.globalAlpha = 1;
                utils.drawLineSet(me, [
                    {
                        x: touchX,
                        y: this._tooltip.domNode.offsetHeight
                    },
                    {
                        x: touchX,
                        y: height - mg.b
                    }
                ], false, ctx);

                ctx.strokeStyle = me.highlightColor;
                ctx.fillStyle = ctx.strokeStyle;
                
                var s = m.series,
                    l = s.length,
                    rns = (currStatus.rns === 0 || currStatus.rne - currStatus.rns > 1) ? currStatus.rns : currStatus.rns - 1,
                    rowIdx = rns + x,
                    y = utils.getYValue(me, s[si].rv[rowIdx]); 
                
                if (!chartStatus[this.chartID].isLegendSelected) {
                    ctx.strokeStyle = me.getSerieColor(si);
                }
                ctx.fillStyle = ctx.strokeStyle;

                if (y >= mg.t && y <= this.canvas.height - mg.b) {
                    
                    utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);
                }

                
                this.lastHighlightPoint = {rowIdx: rowIdx, serieIdx: si, point: {x: xcoord, y: y}};

            },

            hideTimeSelectorLabels: function htsl() {
                var lbls = this.domNode.getElementsByClassName('timeseries-intervals');
                for (var i = 0; i < lbls.length; i++) {
                    lbls[i].style.display = 'none';
                }
            },

            showTimeSelectorLabels: function stsl() {
                var lbls = this.domNode.getElementsByClassName('timeseries-intervals');
                for (var i = 0; i < lbls.length; i++) {
                    lbls[i].style.display = 'block';
                }
            },

            
            getFormattedDateForTooltip: function getFormattedDateForTooltip( val, isLongFormat) {
                if (isNaN(val)) {
                    return val;
                }
                var fVal = val;
                try {
                    val = this.utils.convertRawValueToMilliseconds(val);
                    var dt = new Date(Number(val)),
                        $_DT = mstrmojo.locales.datetime;
                    var mn = isLongFormat ? $_DT.MONTHNAME_FULL[dt.getMonth()] : $_DT.MONTHNAME_SHORT[dt.getMonth()];
                    var yr = dt.getFullYear().toString();
                    if (isLongFormat) {
                        fVal = mn + " " + dt.getDate() + ", " + yr;
                    } else {
                        fVal = mn + "-" + dt.getDate() + "-" + yr.substring(2);
                    }
                } catch (e) {
                    
                }
                return fVal;
            },

            showLegendTooltip: function showLegendTooltip(e) {
                 this._legendTooltip.updateContent(e);
            },

            hiddenLegendTooltip: function hiddenLegendTooltip() {
                this._legendTooltip && this._legendTooltip.toggle(false);
            },

            getLegendName: function getLegendName(colHeaders, series, i) {
                var colHLength = colHeaders.length;
                var hiLength = series[i].hi.length;

                if (colHLength < 1) {
                    return "null";
                }

                if (hiLength == colHLength) {

                    var legendName = "";

                    for (var j = 0; j < hiLength; j++) {
                        var colHeader = colHeaders[j];
                        var colName = "";

                        if (colHeader.es) {
                            colName = colHeader.es[series[i].hi[j]];
                        } else {
                            colName = colHeader.items[series[i].hi[j]].n;
                        }

                        if (j > 0) {
                            legendName += " ";
                        }
                        if (colName != "") {
                            legendName += colName;
                        }
                    }
                    return legendName;
                } else {
                    var items = colHeaders[0].items
                    legendName = items[i % items.length].n;
                    return legendName;
                }
                return "null";
            },

            
            getRowHeader: function getrh(idx) {
                var me = this,
                    m = me.model,
                    riArray = m.ri,
                    s = m.series,
                    cat = m.categories,
                    tp = cat.tp,
                    currStatus = chartStatus[this.chartID],
                    rowHs = m.rowHeaders,
                    rowHLength = rowHs.length,
                    rowHeader = [];

                
                var rVal = cat.items[idx];

                var ri = riArray && riArray[idx];

                if (!ri) {
                    return rowHeader;
                }

                
                if (tp.toString() === me.DSS_XML_BASE_FORM_DATE) {
                    rVal = me.getFormattedDateForTooltip(rVal, true);
                    var rowHeaderObj = {};
                    rowHeaderObj.n = rowHs[rowHLength - 1].n;
                    rowHeaderObj.v = rVal;
                    rowHeader.push(rowHeaderObj);
                } else {
                    

                    for (var i = 0; i < rowHLength; i++) {
                        var rowHeaderObj = {}

                        var rowH = rowHs[i];
                        rowHeaderObj.n = rowH.n;
                        rowHeaderObj.v = rowH.es[ri[i]] || "";
                        rowHeader.push(rowHeaderObj);
                    }
                }

                return rowHeader;

            },

            setMarginTopByTooltipHeight: function setMarginTopByTooltipHeight() {
                var me = this,
                    m = me.model,
                    mg = me.margin,
                    s = m.series,
                    colH = m.colHeaders;

                if (this._tooltip) {
                    this._tooltip.displayInfo([
                        {n: 'legendName', v: 'val'},
                        {n: 'rowHeaderName', v: 'rowHeaderValue'}
                    ]);
                    this._tooltip.toggle(true);
                    var height = this._tooltip.domNode.offsetHeight + 10;
                    this._tooltip.toggle(false);

                    if (me.margin.t < height) {
                        me.margin.t = height;
                    }
                }

                
                var stt = me.sliderTooltip,
                    sttF = stt.firstChild,
                    sttP = stt.lastChild;

                sttF.innerHTML = "name: value";
                sttF.style.display = 'block';

                var sliderTooltipHeight = sttF.offsetHeight;

                
                me.sliderTooltipYPosition = me.getHeight() - me.masterChartHeight - sliderTooltipHeight - 7 + masterMargin.t;
                sttP.style.top = sliderTooltipHeight + 'px';

                sttF.style.display = 'none';

            },

            
            renderTooltip: function rndrttp(valIndex, touchX, touchY) {
                if (valIndex < 0) {
                    this._tooltip.toggle(false);
                    return;
                }

                var me = this,
                    m = me.model,
                    mg = me.margin,
                    s = m.series,
                    currStatus = chartStatus[this.chartID],
                    si = currStatus.isLegendSelected ? currStatus.legendSelectedIndex : me.seriesIndex,
                    rns = (currStatus.rns === 0 || currStatus.rne - currStatus.rns > 1) ? currStatus.rns : currStatus.rns - 1,
                    colH = m.colHeaders;
                var width = me.getWidth();

                if (!tooltipShown) {
                    me.hideTimeSelectorLabels();
                    tooltipShown = true;

                    var touchManager = mstrmojo.touchManager;
                    this._touchListener = touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                        if (!isTouchedOnWidget.call(me, evt.touch)) {
                            me.hiddenTooltipAndShowTimeSelector();   
                        }
                    });
                }
                var vIdx = rns + valIndex;
                var val = s[si].v[vIdx] ? s[si].v[vIdx] : "null";
                var legendName = this.getLegendName(colH, s, si);
                
                var rowHeaders = this.getRowHeader(vIdx),
                    rowHeaderName = "",
                    rowHeaderValue = "";
                for (var i = 0; i < rowHeaders.length; i++) {
                    rowHeaderName += rowHeaders[i].n;
                    rowHeaderValue += rowHeaders[i].v;
                    if (i < rowHeaders.length - 1) {
                        rowHeaderName += " ";
                        rowHeaderValue += " ";
                    }
                }

                this._tooltip.displayInfo([
                    {n: legendName, v: val},
                    {n: rowHeaderName, v: rowHeaderValue}
                ]);
                this._tooltip.toggle(true);

                this._tooltip.doLayout(width - 10);

                
                
                var ttw = this._tooltip.domNode.offsetWidth,
                    x = touchX - ttw / 2;

                
                if (x < 5) {
                    x = 5;
                } else if (x > width - 5 - ttw) {
                    x = width - 5 - ttw;
                }

                this._tooltip.posTo({x: x, y: 5});

            },

            
            handleTouchEnd: function handleTouchEnd() {
                this._super();
                this._tooltip && this._tooltip.toggle(false);
            },

            showMessage: function shmsg(text) {
                var msg = this.loadingMsg,
                    mns = msg.style;

                
                msg.innerHTML = text || mstrmojo.desc(5674, 'Loading...');
                mns.display = 'block';
                mns.opacity = 1;

                
                var x = Math.round(this.getWidth() / 2 - msg.offsetWidth / 2);
                var y = Math.round(this.getHeight() / 2 - msg.offsetHeight / 2);

                this.utils.translateCSS(x, y, false, msg);

            },

            hideMessage: function hmsg() {
                this.loadingMsg.style.opacity = 0;
            },

            showMasterSliderTooltip: function showMasterSliderTooltip(item) {
                $CSS.addClass(item.node, 'mstrmojo-timeseries-span-shadow');

                var stt = this.sliderTooltip;
                stt.firstChild.style.display = 'block';
                stt.lastChild.style.display = 'block';
                
                this.renderSliderTooltip(item.value === 'L' ? this.SLXP : this.SRXP);

            },

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            


            unrender: function unrender(ignoreDom) {

                if (this._tooltip) {
                    this._tooltip.destroy();
                    delete this._tooltip;
                }
                if (this._legend) {
                    this._legend.destroy();
                    delete this._legend;
                }
                if (this._timeSelector) {
                    this._timeSelector.destroy();
                    delete this._timeSelector;
                }

                if (this._legendTooltip) {
                    this._legendTooltip.destroy();
                    delete this._legendTooltip;
                }

                if (this._super) {
                    this._super(ignoreDom);
                }
            },

            
            refresh: function refresh() {
                var me = this;

                removeLegendAndTimeSelectorChildren.call(this);

                
                me.removeLabels();

                me.lastSelectedPoint = null;

                me.render();
            },

            
            removeLabels: function rmvlbls() {
                var me = this;

                
                me.canvas.width = me.canvas.width;
                
                me.utils.fillBackground(me);

                
                me.xLabelsDiv.innerHTML = '';
                
                var lbls = me.domNode.getElementsByClassName('mstrmojo-chart-ylbl-div')[0];
                if (lbls) {
                    lbls.innerHTML = '';
                }

            },

            refreshChart: function refcht(isMetric, pld) {
                var me = this,
                    wd = me.getWidth(),
                    ht = me.getHeight();
                if (me.model.err) {
                    return;
                }
                
                
                me.highlightCanvas.width = wd;
                
                me.animationCanvas.width = me.animationCanvas.width;

                if (isMetric) {
                    me.context.clearRect(0, 0, wd, ht);

                    
                    me.removeLabels();

                    if (pld) { 
                        me.data.processLinearData(me);
                    }

                }

                
                me.drawChart();
                this.setAnimationCanvasContainer();
                me.drawLabels();

                
                localUpdateScrollerConfig.call(me);

                
                
            },

            
            timeSelectorOnClick: function hoc(item) {
                var currStatus = chartStatus[this.chartID];
                if (!itemClicked) {
                    itemClicked = true;

                    var me = this,
                        v = item.value,
                        node = item.node,
                        intervalChanged = true;

                    
                    if (node === me.currSelection && !currStatus.usingCustomInterval) {
                        itemClicked = false;
                        return;
                    }

                    if (v === 'S') {
                        if (currStatus.usingCustomInterval) {
                            currStatus.usingCustomInterval = false;
                        } else {
                            me.updateIntervalPosition();
                        }

                        if (me.currSelection) {
                            me._timeSelector.toggleSelected(me.currSelection, false);
                            me._timeSelector.toggleGlowEffect(me.currSelection, false);
                        }

                        me._timeSelector.toggleSelected(node, true);
                        me._timeSelector.toggleGlowEffect(node, true);

                        var bm = me.baseModel, tslIndex = parseInt(node.getAttribute("value"));
                        var tsl = bm.vp.rl[tslIndex];

                        
                        if ((bm.k && bm.k !== tsl.ds) && me.layoutModel) { 
                            var getData = resetBaseAndDerivedData.call(this, tsl);
                            if (!getData) {
                                return;
                            }
                        } else {
                            isDataSetChanged = false;
                        }

                        intervalChanged = node !== me.currSelection;
                        me.currSelection = node;
                        currStatus.currSelectionIdx = me.currSelection.getAttribute('value');
                        me.showMessage();

                        window.setTimeout(function () {
                            me.drawSelector(node, tsl, intervalChanged);
                        }, 10);

                    }
                }

            },

            moveMasterSlider: function moveMasterSlider(x ) {
                var me = this,
                    m = me.model,
                    width = me.getWidth(),
                    delta = Math.round(x - originalTouchPosition),
                    currStatus = chartStatus[this.chartID];

                
                
                
                
                
                
                
                
                

                
                
                this.SLXP += delta;
                this.SRXP += delta;

                this.SLXP = Math.round(this.SLXP);
                this.SRXP = Math.round(this.SRXP);

                this.makeSureMasterSliderNotBeyondTheMargin(true);
                this.setMasterSliderLayout();

                this.calculateRnsRneFromSXP();

                
                
                
                
                
                
                
                
                
                
                
                
                
                
                

                
                localUpdateScrollerConfig.call(me);
                
                if (!currStatus.usingCustomInterval && this.currSelection) {
                    this.updateIntervalPosition();
                }
            },

            updateIntervalPosition: function updateIntervalPosition() {
                var me = this,
                    m = me.model,
                    currStatus = chartStatus[this.chartID];
                
                if(me.currSelection){
                    var index = me.currSelection.getAttribute("value");
                    currStatus.timeSelectedIntervalPosition[index] = {rns: currStatus.rns, rne: currStatus.rne};
                }

            },

            drawSliderTooltipPointer: function drawSliderTooltipPointer() {
                var canvas = this.sliderTooltip.lastChild,
                    cntx = canvas.getContext('2d'),
                    width = canvas.width,
                    height = canvas.height;
                cntx.fillStyle = '#ffffff';
                cntx.beginPath();
                cntx.moveTo(0, 0);
                cntx.lineTo(width, 0);
                cntx.lineTo(width / 2, height);
                cntx.lineTo(0, 0);
                cntx.closePath();
                cntx.fill();

            },

            renderSliderTooltip: function renderSliderTooltip(sliderTooltipXPosition) {
                var me = this,
                    stt = me.sliderTooltip,
                    sttF = stt.firstChild,
                    sttP = stt.lastChild,
                    width = me.getWidth();

                var pointerPos = sliderTooltipXPosition;

                var content = getFormattedDateForSliderTooltip.call(this, sliderTooltipXPosition);
                if (content == "") {
                    content = "--";
                }

                sttF.innerHTML = content;

                var stWidth = sttF.offsetWidth,
                    stHalfWidth = stWidth / 2;

                if (sliderTooltipXPosition !== this.SLXP) {
                    
                    sliderTooltipXPosition = this.SRXP - stHalfWidth;
                } else {
                    
                    sliderTooltipXPosition -= stHalfWidth;
                }

                
                if (sliderTooltipXPosition < 0) {
                    sliderTooltipXPosition = 0;
                } else if (sliderTooltipXPosition + stWidth > width) {
                    sliderTooltipXPosition = width - stWidth;
                }

                
                sttP.style.left = (pointerPos - sliderTooltipXPosition - 3) + 'px';
                
                me.utils.translateCSS(sliderTooltipXPosition, me.sliderTooltipYPosition, false, stt);
            },

            resizeMasterSlider: function resizeMasterSlider(x ) {
                var me = this,
                    width = me.getWidth(),
                    msl = me.masterSlider,
                    msls = msl.style,
                
                    lcs = msl.parentNode.firstChild.style,
                
                    rcs = msl.parentNode.childNodes[2].style;

                var touchPoint = me.utils.getTouchXYOnWidget(x, 0, me);
                x = touchPoint.touchX;
                var fixWhich;
                if (masterSliderClicked === 'L') {
                    this.SLXP = x;
                    fixWhich = "R";
                } else {
                    this.SRXP = x;
                    fixWhich = "L";
                }

                me.makeSureMasterSliderNotBeyondTheMargin();
                me.makeSureMasterSliderNoOverlap(fixWhich);
                this.setMasterSliderLayout();

                if (masterSliderClicked === 'L') {
                    me.renderSliderTooltip(this.SLXP);
                } else {
                    me.renderSliderTooltip(this.SRXP);
                }

                chartStatus[this.chartID].usingCustomInterval = true;
                chartSizeChanged = true;
            },

            shouldTouchBubble: function shouldTouchBubble(touch) {
                
                return false;
            },

            hiddenTooltipAndShowTimeSelector: function hsctooltip() {
                if (tooltipShown) {	
                    
                    this.handleTouchEnd();
                    tooltipShown = false;
                    this.showTimeSelectorLabels();

                    var touchManager = mstrmojo.touchManager;
                    touchManager.detachEventListener(this._touchListener);
                    delete this._touchListener;
                }
            },

            
            onCrossWidgetMultitouch: function onCrossWidgetMultitouch() {
                this.hiddenTooltipAndShowTimeSelector();
            },

            touchBegin: function touchBegin(touch) {
                
                this.adjustWidgetOffsets();
                var item = this.isMasterSliderTouched(touch);
                if (item) {
                    this.hiddenTooltipAndShowTimeSelector();
                    var value = item.value;
                    if (value === 'L' || value === 'R' || value === 'MS') {
                        
                        masterSliderClicked = item.value;
                        originalTouchPosition = touch.pageX; 
                        if (item.value !== 'MS') {
                            
                            this.showMasterSliderTooltip(item);
                        }

                    } else {
                        return false;
                    }
                    
                } else if (!isScrollableElementTouched.call(this, touch)) {
                    this.hiddenTooltipAndShowTimeSelector();
                    if (this.shouldTouchBubble(touch)) {
                        
                        return this.bubbleTouchEvent(touch);
                    }
                    return false;
                }
            },

            isMasterSliderTouched: function isMasterSliderTouched(touch) {
                var item = getTouchedElement.call(this, touch);
                if (item && (item.value === 'L' || item.value === 'R')) {
                    return item;
                }

                
                var touchRadius = 45 * this.utils.getScreenZoomFactor();
                var position = this.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, this);
                var touchX = position.touchX,
                    touchY = position.touchY;

                
                var height = this.getHeight();
                if (touchY > height || touchY < height - this.masterChartHeight) {
                    return null;
                }

                if (touchX < this.SRXP && touchX > this.SLXP) {
                    return {node: this.masterSlider.childNodes[1], value: "MS"};
                }

                var LDistance = Math.abs(touchX - this.SLXP);
                var RDistance = Math.abs(this.SRXP - touchX);
                var minDistance = Math.min(LDistance, RDistance);

                if (minDistance < touchRadius) {
                    if (LDistance == minDistance) {
                        return {node: this.masterSlider.firstChild, value: "L"};
                    } else if (RDistance == minDistance) {
                        return {node: this.masterSlider.lastChild, value: "R"};
                    }
                } else {
                    return null;
                }

                return null;
            },

            touchSelectBegin: function touchSelectBegin(touch) {

                this.hiddenTooltipAndShowTimeSelector();
                var item = this.isMasterSliderTouched(touch);
                if (item) {
                    if (item.value === 'L' || item.value === 'R' || item.value === 'MS') {
                        
                        masterSliderClicked = item.value;
                        originalTouchPosition = touch.pageX; 
                    }
                } else {
                    
                    this.handleTouchBegin(touch.pageX, touch.pageY);
                }
            },

            touchSelectMove: function touchSelectMove(touch) {
                if (masterSliderClicked) {
                    if (masterSliderClicked === 'MS') {
                        
                        this.moveMasterSlider(touch.pageX);
                    } else {
                        this.resizeMasterSlider(touch.pageX);
                    }
                    originalTouchPosition = touch.pageX; 
                    return false;
                }
                
                this.handleTouchMove(touch.pageX, touch.pageY);
            },

            handleTouchSelectEnd: function handleTouchSelectEnd(touch) {
                if (masterSliderClicked) {
                    if (masterSliderClicked === 'MS') {
                        this.makeSureSliderOnPoint();
                        this.setMasterSliderLayout();
                        this.incFetchChart();
                    } else {
                        resizeMasterSliderDone.call(this);
                    }
                    return false;
                }
                
                var canBeSelected = false;
                if (touch) {
                    var nearestPoint = this.getLastHighlightPoint();
                    canBeSelected = nearestPoint && this.pointCanBeSelected(nearestPoint.rowIdx, nearestPoint.serieIdx);
                }
                if (!canBeSelected) {
                    
                    this.handleTouchEnd();

                    if (tooltipShown) {
                        tooltipShown = false;
                        this.showTimeSelectorLabels();
                    }
                } else {
                    this.seriesIndex = -1;
                }

                this.hiddenLegendTooltip();
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                this.handleTouchSelectEnd(touch);
            },

            touchMultiBegin: function touchMultiBegin(touch) {
                this.handleTouchSelectEnd();
            },

            touchSwipeMove: function touchSwipeMove(touch) {
                
                if (isScrollableElementTouched.call(this, touch) && this._super) {
                    this._super(touch);
                } else {
                    if (masterSliderClicked) {
                        if (masterSliderClicked === 'MS') {
                            
                            this.moveMasterSlider(touch.pageX);
                        } else {
                            this.resizeMasterSlider(touch.pageX);
                        }
                        originalTouchPosition = touch.pageX; 
                    }
                }
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                if (masterSliderClicked) {
                    if (masterSliderClicked === 'MS') {
                        this.makeSureSliderOnPoint();
                        this.setMasterSliderLayout();
                        this.incFetchChart();
                    } else {
                        resizeMasterSliderDone.call(this);
                    }
                    return false;
                } else if (this._super) {
                    this._super(touch);
                }
            },

            touchSelectCancel: function touchSelectCancel(touch) {
                this.touchCancel(touch);
            },

            touchCancel: function touchCancel(touch) {
                this.touchSelectEnd(touch);
            },

            touchEnd: function touchEnd(touch) {
                if (masterSliderClicked && !chartSizeChanged) {
                    hideMasterSliderTooltip.call(this);
                    masterSliderClicked = null;
                }
                this._legend.hiddenSwitcherArrowGlowEffect();
                return false;
            },

            pointCanBeSelected: function pcbs(rowIdx, serieIdx) {
                if (this.selectionOrLinkdrillOnRow) {
                    return true;
                }

                var me = this,
                    m = me.model,
                    colHeaders = m.colHeaders,
                    colHL = colHeaders.length,
                    hi = m.series[serieIdx].hi,
                    hiLength = hi.length;

                for (var i = 0; i < colHL; i++) {
                    var colH = colHeaders[i];
                    if (colH.es) {
                        
                        if (colH.sc && colH.sc.tks) {
                            return true;
                        }
                        if (colH.lm && colH.lm[0] && colH.lm[0].links) {
                            return true;
                        }
                    } else {
                        
                        if (colH.sc && colH.sc.tks) {
                            return true;
                        }
                        var lmArray = colH.lm,
                            lm = lmArray && lmArray[hi[i]];
                        if (lm && lm.links) {
                            return true;
                        }

                    }
                }

                return false;
            },

            getModelK: function getModelK() {
                var k = this.baseModel && this.baseModel.k;

                return k;
            },

            
            getActionObjList: function getActionObjList(nearestPoint, selectedAll) {
                var actionObjList = [];

                var scObjList = [];
                var actionType = 0;
                var actionObjList = [];
                var linkDrillNode = null;
                var metricColHIdx = -1;

                var me = this,
                    model = me.model,
                    riArray = model.ri,
                    ri = riArray[nearestPoint.rowIdx],
                    rowHeaders = model.rowHeaders,
                    rowHL = rowHeaders.length;
                for (var i = 0; i < rowHL; i++) {
                    var rowH = rowHeaders[i];
                    if (rowH.sc && rowH.sc.tks) {
                        if (selectedAll && (rowH.sc.all === "false" || rowH.sc.all === false)) {
                            
                            return null;
                        }
                        var scObj = {};
                        scObj.sc = rowH.sc;
                        scObj.es = rowH.es[ri[i]];
                        scObj.eid = selectedAll ? "OA:(All)" : rowH.eid[ri[i]];
                        scObjList.push(scObj);
                        actionType = rowH.at || 0;
                    }
                    if (rowH.lm && rowH.lm[0] && rowH.lm[0].links && !linkDrillNode) {
                        
                        linkDrillNode = {};
                        linkDrillNode.titleInfo = rowH;
                        linkDrillNode._e = {id: rowH.eid[ri[i]], n: rowH.es[ri[i]]};
                    }
                }

                var colHeaders = model.colHeaders,
                    colHL = colHeaders.length,
                    hi = model.series[nearestPoint.serieIdx].hi,
                    hiLength = hi.length;

                for (var i = colHL - 1; i >= 0; i--) {
                    var colH = colHeaders[i];
                    if (colH.es) { 
                        if (colH.sc && colH.sc.tks) {
                            if (selectedAll && (colH.sc.all === "false" || colH.sc.all === false)) {
                                
                                return null;
                            }
                            var scObj = {};
                            scObj.sc = colH.sc;
                            scObj.es = colH.es[hi[i]];
                            scObj.eid = selectedAll ? "OA:(All)" : colH.eid[hi[i]];
                            scObjList.push(scObj);
                            actionType = colH.at || 0;
                        }
                        if (colH.lm && colH.lm[0] && colH.lm[0].links && !linkDrillNode) {
                            
                            linkDrillNode = {};
                            linkDrillNode.titleInfo = colH;
                            linkDrillNode._e = {id: colH.eid[hi[i]], n: colH.es[hi[i]]};
                        }
                    } else {
                        if (colH.sc && colH.sc.tks) {
                            
                            if (selectedAll && (colH.sc.all === "false" || colH.sc.all === false)) {
                                
                                return null;
                            }
                            var scObj = {};
                            scObj.sc = colH.sc;
                            scObj.es = colH.items[hi[i]].n;
                            scObj.eid = selectedAll ? "OA:(All)" : colH.items[hi[i]].id;
                            scObjList.push(scObj);
                            actionType = colH.at || 0;
                        }
                        
                        metricColHIdx = i;
                    }
                }
                if (scObjList.length > 0) {
                    actionType = actionType | SELECTOR_ACTION;

                    
                    this.infoWindowAnchor.style.left = (nearestPoint.point.x - 9) + 'px';
                    this.infoWindowAnchor.style.top = (nearestPoint.point.y - 9) + 'px';

                    

                    actionObjList.push({at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: this.infoWindowAnchor});
                    return actionObjList;
                }

                
                if (!linkDrillNode) {
                    
                    var metricH = colHeaders[metricColHIdx],
                        metric = metricH.items[hi[metricColHIdx]],
                        lm = metricH.lm[hi[metricColHIdx]];
                    if (lm && lm.links) {
                        linkDrillNode = {};
                        linkDrillNode.titleInfo = metricH;
                        linkDrillNode.mix = hi[metricColHIdx];
                        
                        var currNode = linkDrillNode;
                        for (var i = 0; i < rowHL; i++) {
                            var rowH = rowHeaders[i];
                            var nodeLP = {};
                            nodeLP.titleInfo = rowH;
                            nodeLP._e = {id: rowH.eid[ri[i]], n: rowH.es[ri[i]]};

                            currNode._lp = nodeLP;
                            currNode.axis = ROW_AXIS;
                            currNode = nodeLP;
                        }

                        currNode = linkDrillNode;
                        for (var i = colHL - 1; i >= 0; i--) {
                            var colH = colHeaders[i];
                            if (colH.es) { 
                                var nodeTP = {};
                                nodeTP.titleInfo = colH;
                                nodeTP._e = {id: colH.eid[hi[i]], n: colH.es[hi[i]]};

                                currNode._tp = nodeTP;
                                currNode.axis = COL_AXIS;
                                currNode = nodeTP;
                            }
                        }
                    }
                }
                if (linkDrillNode) {
                    actionType = actionType | HYPERLINK_ACTION;

                    actionObjList.push({at: actionType, k: this.getModelK(), node: linkDrillNode});
                    return actionObjList;
                }
                return null;
            },

            getLastHighlightPoint: function gtLstHighlightPnt() {
                
                return this.lastHighlightPoint || null;
            },

            performAction: function performAction(actionObjList) {
                this.hasNonifwTarget = this.hasNoninfowindowTarget(actionObjList[0]);

                if (this._super) {
                    this._super(actionObjList);
                }

            },

            touchTap: function touchTap(touch) {
                var me = this,
                    nearestPoint = this.getLastHighlightPoint(),
                    touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me);
                var touchPointInHighlightArea = tooltipShown && getPointDistanceSquare({x: nearestPoint.point.x, y: nearestPoint.point.y}, {x: touchPointOnWidget.touchX, y: touchPointOnWidget.touchY}) <= 45 * 45;

                if (touchPointInHighlightArea) {
                    
                    me.hiddenTooltipAndShowTimeSelector();
                    nearestPoint = this.getLastHighlightPoint();
                } else {
                    nearestPoint = this.getNearestPoint(touch.pageX, touch.pageY);
                }
                if (isScrollableElementTouched.call(this, touch)) {
                    var fallInPointArea = getPointDistanceSquare({x: nearestPoint.point.x, y: nearestPoint.point.y}, {x: touchPointOnWidget.touchX, y: touchPointOnWidget.touchY}) <= 45 * 45,
                        canBeSelected = me.pointCanBeSelected(nearestPoint.rowIdx, nearestPoint.serieIdx),
                        sameAsLastSelectedPoint = me.lastSelectedPoint && (nearestPoint.rowIdx == me.lastSelectedPoint.rowIdx && nearestPoint.serieIdx == me.lastSelectedPoint.serieIdx );
                    if (fallInPointArea && canBeSelected && !sameAsLastSelectedPoint) {
                        if (tooltipShown) {
                            me.hiddenTooltipAndShowTimeSelector();
                        }
                        me.lastSelectedPoint = nearestPoint;
                        me.incFetchChart(true);

                        var actionObjList = this.getActionObjList(nearestPoint);

                        me.performAction(actionObjList);

                    }
                    else if (fallInPointArea && !canBeSelected) {
                        
                        if (touchPointInHighlightArea) {
                            
                        } else {
                            this.handleTouchBegin(touch.pageX, touch.pageY);
                        }

                    } else {
                        
                        if (tooltipShown) {
                            me.hiddenTooltipAndShowTimeSelector();
                        }
                        else if (me.lastSelectedPoint) {
                            

                            var actionObjList = this.getActionObjList(nearestPoint, true);
                            
                            if (actionObjList) {
                                me.performAction(actionObjList);
                                me.lastSelectedPoint = null;
                                me.incFetchChart(true);
                            }
                        }
                    }

                }

            },

            
            highlightSelectedPoint: function highlightSelectedPoint() {

                
                var me = this,
                    ctx = me.animationContext,
                    utils = me.utils,
                    pointInfo = me.lastSelectedPoint,
                    point = pointInfo.point,
                    currStatus = chartStatus[this.chartID];

                ctx.save();

                if (currStatus.isLegendSelected && currStatus.legendSelectedIndex != pointInfo.serieIdx) {
                    ctx.globalAlpha = 0.3;
                } else {
                    ctx.globalAlpha = 1;
                }
                
                var pointX = (pointInfo.rowIdx - me.ACrns) * me.RTX;
                
                
                
                
                
                
                
                
                
                ctx.fillStyle = me.getSerieColor(pointInfo.serieIdx);
                ctx.lineWidth = 1;
                utils.drawArc(me, pointX, point.y, 4, 0, Math.PI * 2, true, true, ctx);

                if (this.theme == LIGHT_THEME) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 5, 0, Math.PI * 2, true, false, ctx);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 7, 0, Math.PI * 2, true, false, ctx);
                } else {
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 5, 0, Math.PI * 2, true, false, ctx);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 7, 0, Math.PI * 2, true, false, ctx);
                }
                
                
                
                
                
                
                
                ctx.restore();
            },

            destroy: function destroy() {
                
                if (this.currSelection) {
                    delete this.currSelection;
                }

                
                if (this._touchListener) {
                    
                    mstrmojo.touchManager.detachEventListener(this._touchListener);
                    delete this._touchListener;
                }
                
                 if(this._scrollDoneListener){
                    this._scroller.detachEventListener(this._scrollDoneListener);
                    delete this._scrollDoneListener;
                 }
                 if(this._scrollMovedListener){
                    this._scroller.detachEventListener(this._scrollMovedListener);
                    delete this._scrollMovedListener;
                 }

                 if(this._infoWClosedListener){
                    this.xtabModel.docModel.detachEventListener(this._infoWClosedListener);
                    delete this._infoWClosedListener;
                 }



                if (this.fullScreenListener) {
                    mstrmojo.touchManager.detachEventListener(this.fullScreenListener);
                    delete this.fullScreenListener;
                }

                if (this.selectorTargets) {
                    delete this.selectorTargets;
                }

                this._super();

                if (this._tn) {
                    delete this._tn;
                }
            }


        });

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.AndroidXtab");

    
    mstrmojo.AndroidXtabStandalone = mstrmojo.declare(
        
        mstrmojo.AndroidXtab,

        null,

        
        {
            scriptClass: "mstrmojo.AndroidXtabStandalone"
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.AndroidXtab",
                         "mstrmojo._IsInteractiveGrid",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsDocXtab");

    
    mstrmojo.DocInteractiveGridXtab = mstrmojo.declare(

        mstrmojo.AndroidXtab,


        [ mstrmojo._IsInteractiveGrid, mstrmojo._Formattable, mstrmojo._IsDocXtab ],

        
        {
            scriptClass: 'mstrmojo.DocInteractiveGridXtab',

            
            formatHandlers: {
                domNode: [ 'RW', 'T', 'font'],
                msgNode: [ 'D' ],
                viewport: [ 'D', 'B', 'fx' ]
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.AndroidXtab",
                        "mstrmojo._IsInteractiveGrid");

    
    mstrmojo.AndroidInteractiveGridXtab = mstrmojo.declare(

        mstrmojo.AndroidXtab,

        [ mstrmojo._IsInteractiveGrid ],

        
        {
            scriptClass: 'mstrmojo.AndroidInteractiveGridXtab'            
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.MetricSlider",
                         "mstrmojo.MetricQualification",
                         "mstrmojo.SearchBoxSelector",
                         "mstrmojo.Label",
                         "mstrmojo.hash",
                         "mstrmojo.array");

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        $FN = mstrmojo.emptyFn;

    var STYLES_PULLDOWN = 0,
        STYLES_SCROLLER = 1,
        STYLES_LIST = 2,
        STYLES_RADIO = 3,
        STYLES_CHECKBOX = 4,
        STYLES_BUTTON = 5,
        STYLES_LINK = 6,
        STYLES_METRIC_SLIDER = 7,
        STYLES_METRIC_QUAL = 8,
        STYLES_SEARCH_BOX = 9;

    var _ST_UC_ON_DS = 2;   

    var UNIT_CONDITION = 1,
		SUBTOTAL = 3;
    
    var ALL_ID = 'u;'; 

    
    var widgetMap = {};
    widgetMap[STYLES_METRIC_SLIDER] = 'MetricSlider';
    widgetMap[STYLES_METRIC_QUAL] = 'MetricQualification';
    widgetMap[STYLES_SEARCH_BOX] = 'SearchBoxSelector';

    
    function updateSelectorControl(selectorCtrl, style, data, defn, idx, elements) {
        
        switch (style) {
        case STYLES_PULLDOWN:
            
            selectorCtrl.idx = $HASH.any(idx, true);

            
            
            var selectorUnset = (typeof (selectorCtrl.idx) === 'undefined' || selectorCtrl.idx < 0);
            if (selectorUnset) {
                
                if ($ARR.find(elements, 'v', '-1') < 0) {
                    elements = [{
                        v: '-1',
                        n: ''
                    }].concat(elements);
                }
                selectorCtrl.idx = '0';
            }

            selectorCtrl.unset = !!selectorUnset;
            selectorCtrl.options = elements;
            break;

        case STYLES_METRIC_QUAL:
        case STYLES_METRIC_SLIDER:
            
            if (selectorCtrl.updateData) {
                selectorCtrl.updateData({
                    low: data.min,
                    high: data.max,
                    cnt: data.cnt,
                    nov: data.nov
                }, {
                    cs: data.cs,
                    f: data.f,
                    ft: data.ft,
                    qua : data.qt
                });
            }

            selectorCtrl.items = elements;
            selectorCtrl.selectedIndices = idx;
            break;

        case STYLES_SEARCH_BOX:

            if (elements && !defn.sos) {
                selectorCtrl.candidates = {
                    isComplete: true,
                    items: defn.srcid ? elements : []
                };
            }
            if (defn.srcid) {
                var ca = [],
                	ces = data.ces;
                if (ces && ces.constructor === Array) {
                	
                	if (defn['dfm'] == UNIT_CONDITION) {
                		for (var i = 0; i < ces.length; i++) {
                    		if (ces[i]['t'] != SUBTOTAL) {
                    			ca.push(ces[i]);
                    		}
                    	}
                	} else {
                		ca = ces.concat();
                	}
                }
                
                
              
              if (! defn.sos) {
                  var $ARRAY = mstrmojo.array,
                      new_ca = [];
                  $ARRAY.forEach(ca, function(item){
                      if ($ARRAY.find(selectorCtrl.candidates.items, 'v', item.v) > -1) {
                          new_ca.push(item);
                      }
                  });
                  ca = new_ca;
              }
                
                selectorCtrl.items = ca;
            }
            break;

        default:
            selectorCtrl.items = elements;
            selectorCtrl.selectedIndices = idx;
            break;
        }
    }

    
    mstrmojo.DocSelectorViewFactory = mstrmojo.declare(

        mstrmojo.Obj,

        null,

        
        {
            scriptClass: 'mstrmojo.DocSelectorViewFactory',

            
            newPulldown: $FN,

            attachTargetListeners: $FN,

            getSelectorClass: function getSelectorClass(selectorStyle, isHoriz) {
                
                var scriptClass = widgetMap[selectorStyle];

                
                if (scriptClass.constructor === Array) {
                    
                    scriptClass = scriptClass[(isHoriz) ? 0 : 1];
                }

                return scriptClass;
            },

            isSelectorSupported: function isSelectorSupported() {
                
                return true;
            },

            
            newSelector: function newSelector(selectorContainer) {
                var children = selectorContainer.children,
                    selectorCtrl = children && children[0],
                    selectorStyle = selectorContainer.style,
                    selectedIdx = selectorContainer.selIdx,
                    node = selectorContainer.node,
                    defn = node.defn,
                    data = node.data,
                    elements = data.elms,
                    elems;

                if (!this.isSelectorSupported(selectorContainer)) {
                    return null;
                }

                
                if (!selectorCtrl) {

                    
                    if (!selectorCtrl) {

                        var cekEvtListener = selectorContainer._cekEvtListener,
                            cekContextId = selectorContainer.id,
                            fnCEK;

                        
                        if (cekEvtListener) {
                            
                            defn.detachEventListener(cekEvtListener);

                            
                            delete selectorContainer._cekEvtListener;
                        }

                        
                        if (selectorStyle === STYLES_PULLDOWN) {
                            
                            selectorCtrl = this.newPulldown(selectorContainer);

                            
                            fnCEK = function (evt) {
                                
                                elems = this.options;

                                
                                if ($ARR.find(elems, 'v', evt.value) < 0) {
                                    if ($ARR.find(elems, 'v', '-1') < 0) {
                                        
                                        elems.unshift({
                                            v: '-1',
                                            n: ''
                                        });
                                    }

                                    selectorCtrl.idx = '0';
                                    selectorCtrl.options = elems;
                                    selectorCtrl.unset = true;

                                    selectorContainer._inSyncPhase = true;
                                    selectorCtrl.refresh();
                                    selectorContainer._inSyncPhase = false;
                                } else {
                                    selectorCtrl.set('value', evt.value);

                                }
                            };

                            
                            cekContextId = selectorCtrl.id;

                        } else {
                            
                            var cfg = this.getSelectorCtrlConfig(selectorContainer, selectorStyle, defn, elements),
                                scriptClass = cfg.scriptClass;

                            
                            if (!scriptClass) {
                                
                                selectorCtrl = new mstrmojo.Label({
                                    cssClass: 'unsupported',
                                    text: 'This selector is not supported.'
                                });

                            } else {
                                
                                delete cfg.scriptClass;

                                
                                var Clazz = $HASH.walk(scriptClass, mstrmojo);

                                
                                selectorCtrl = new Clazz(cfg);

                                
                                if (selectorStyle === STYLES_METRIC_SLIDER) {
                                    
                                    selectorContainer.attachEventListener('includeChange', selectorCtrl.id, function (evt) {
                                        
                                        this.set('include', evt.value);

                                        
                                        this.selectRange();
                                    });
                                }

                                
                                if (selectorStyle === STYLES_METRIC_SLIDER || selectorStyle === STYLES_METRIC_QUAL) {
                                    
                                    selectorContainer.attachEventListener('quaChange', selectorCtrl.id, function (evt) {
                                        
                                        this.set('qua', evt.value);
                                    });

                                    
                                    fnCEK = function (evt) {
                                        
                                        if (selectorContainer.id !== evt.value.id) {  
                                            selectorContainer._inSyncPhase = true;

                                            selectorCtrl.updateExpr(evt.value);

                                            if (selectorContainer.style === STYLES_METRIC_SLIDER) {
                                                selectorContainer.set('include', evt.value.include);
                                            }

                                            selectorContainer._inSyncPhase = false;
                                        }
                                    };

                                } else {

                                    
                                    fnCEK = function (evt) {
                                        var idxs = [];
                                        
                                        elems = this.node.data.elms;

                                        
                                        $ARR.forEach(evt.value, function (v) {
                                            var idx = $ARR.find(elems, 'v', v);
                                            if (idx > -1) {
                                                idxs.push(idx);
                                            }
                                        });

                                        this._inSyncPhase = true;
                                        selectorCtrl.select(idxs);
                                        this._inSyncPhase = false;
                                    };
                                }
                            }
                        }

                        
                        if (fnCEK) {
                            
                            selectorContainer._cekEvtListener = defn.attachEventListener('cekChange', cekContextId, fnCEK);
                        }
                    }

                    
                    selectorContainer.addChildren(selectorCtrl);
                }

                
                updateSelectorControl(selectorCtrl, selectorContainer.style, data, defn, selectedIdx, elements);

                return selectorCtrl;
            },

            
            getSelectorCtrlConfig: function getSelectorCtrlConfig(selectorContainer, selectorStyle, defn, elements) {
                
                var isHoriz = defn.horiz,
                    fmts = selectorContainer.getFormats(),
                    height = fmts && fmts.height,
                    copyProps = $HASH.copyProps,
                    data = selectorContainer.node.data,
                    cfg = {
                        scriptClass: this.getSelectorClass(selectorStyle, isHoriz),
                        multiSelect: defn.multi,
                        isHoriz: isHoriz,
                        include: defn.include,
                        itemWidthMode: defn.iwm,
                        allIdx: $ARR.find(elements, 'v', ALL_ID),
                        noneIdx: defn.include ? -1 : $ARR.find(elements, 'v', ALL_ID),
                        renderAllItems: !height,               
                        onchange: function () {
                            if (!selectorContainer._inSyncPhase) {
                                selectorContainer.selectorControlChange(this);
                            }
                        },
                        makeSelection: function(evt) {
                        	if (!selectorContainer._inSyncPhase) {
                        		selectorContainer.showInfoWin(evt && evt.selItem);
                        	}
                        }
                    };

                
                if (cfg.noneIdx !== -1) {
                    cfg.allIdx = -1;
                }

                
                if (selectorStyle === STYLES_SCROLLER || selectorStyle === STYLES_METRIC_SLIDER) {
                    
                    selectorContainer.extCls = 'extSlider';

                    if (defn.cek) {
                        defn.include = defn.cek.include;
                        data.cs = defn.cek.cs;
                        data.f = defn.cek.f;
                        data.ft = defn.cek.ft;
                        selectorContainer.qua = defn.cek.qua;
                    }

                }

                
                if (selectorStyle === STYLES_SCROLLER) {

                    
                    copyProps([ 'height', 'width' ], fmts, cfg);

                } else if (selectorStyle === STYLES_METRIC_QUAL || selectorStyle === STYLES_METRIC_SLIDER) {

                    if (selectorStyle === STYLES_METRIC_SLIDER) {
                        cfg.isHoriz = true;
                        cfg.include = defn.include;
                    }

                    copyProps([ 'height', 'width', 'font' ], fmts, cfg);
                    copyProps([ 'cs', 'ft' ], defn, cfg);
                    cfg.fmts = defn.f;
                    cfg.qua = selectorContainer.qua;
                    cfg.numFmts = defn.numFmts;
                }  else if (selectorStyle === STYLES_SEARCH_BOX) {
                	cfg = {
                			scriptClass: cfg.scriptClass,
                			cssText: fmts.height ? 'height: ' + fmts.height : '',
                			emptyText: mstrmojo.desc(4325, 'Search') + ' ' + (defn.ttl || ''),
                			items: defn.srcid ? (data.ces ? data.ces.concat() : []) : [],   
                			REQUEST_THRESHOLD: 55, 
                			suggestCount: 50, 
                			srcid: defn.srcid || '',
                			dsrc: defn.dsrc || '',
                			onitemsChange: function () {
                				if (!selectorContainer._inSyncPhase) {
                					
                					selectorContainer.showInfoWin();
                					
                					selectorContainer.selectorControlChange(this);
                				}
                			}
                	};

                	if (elements && !defn.sos) { 
                		cfg.candidates = {
                				isComplete: true,
                				items:  defn.srcid ? elements : []
                		};
                	} else {
                		cfg.useKeyDelay = true;
                		cfg.noCache = true;
                	}

                	if (!defn.multi) {
                		
                		cfg.maxObjectCount = 1;
                	}
                }

                return cfg;
            },

            
            updateControlStyles: function updateControlStyles(selectorContainer) {
                
                if (selectorContainer.isInFilterPanel() && !selectorContainer.isHorizFP()) {
                    
                    var style = selectorContainer.style;
                    if (style === STYLES_SCROLLER || style === STYLES_METRIC_QUAL || STYLES_METRIC_SLIDER) {
                        
                        selectorContainer.children[0].width = selectorContainer.parent.parent.contentWidth;
                    }
                }
            }

        }
    );

    var factory = mstrmojo.DocSelectorViewFactory;

    
    factory.STYLES = {
        PULLDOWN: STYLES_PULLDOWN,
        SCROLLER: STYLES_SCROLLER,
        LIST: STYLES_LIST,
        RADIO: STYLES_RADIO,
        CHECKBOX: STYLES_CHECKBOX,
        BUTTON: STYLES_BUTTON,
        LINK: STYLES_LINK,
        METRIC_SLIDER: STYLES_METRIC_SLIDER,
        METRIC_QUAL: STYLES_METRIC_QUAL,
        SEARCH_BOX: STYLES_SEARCH_BOX

    };

    factory.ELEM_ALL = ALL_ID;

    factory.UC_ON_DS = _ST_UC_ON_DS;

}());
(function(){
    
    mstrmojo.requiresCls(
            "mstrmojo.ObjectInputBox"
    );

    mstrmojo.ACL.UserInputBox = mstrmojo.declare(
            
            mstrmojo.ObjectInputBox,
            
            null,
            { 
                item2textCss: function item2textCss(data){
                    return (this._super && this._super(data)) || 
                    {
                        8704: 'u',
                        8705: 'ug'
                    }[data.st] || '';
                },
                getCandidatesThroughTaskCall: function getCandidatesThroughTaskCall(params, callbacks){
                    mstrmojo.ACL.UserDataService.searchUserCandidates(params.pattern, !params.isVerify, params.blockCount, callbacks);
                }
   });
 
})();
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.array",
        "mstrmojo.hash",
        "mstrmojo.HTMLButton",
        "mstrmojo.HBox",
        "mstrmojo.List",
        "mstrmojo.Label",
        "mstrmojo.ListMapperHoriz",
        "mstrmojo.WidgetList",
        "mstrmojo.WidgetListMapper",
        "mstrmojo.TristateCheckBox",
        "mstrmojo.Pulldown",
        "mstrmojo.ACL.UserTreeBrowser",
        "mstrmojo.DataGrid",
        "mstrmojo.DropDownButton",
        "mstrmojo.ListBox",
        "mstrmojo.DivItemRenderer",
        "mstrmojo.VBox",
        "mstrmojo.Box",
        "mstrmojo.ACL.UserInputBox",
        "mstrmojo.Editor",
        "mstrmojo.ACL.UserDataService",
        "mstrmojo.StackContainer",
        "mstrmojo.CheckList"
    );

    var $CSS = mstrmojo.css,
        $ARRAY = mstrmojo.array,
        publicUsers = [],
        editorID = "sharingEditor",
        defaultPublicAccess = 199,
        publicGuestDID = '294DEDC011D2F1D56000D98E67019608',
        everyoneDID = 'C82C6B1011D2894CC0009D9F29718E4F',
        Enum_RIGHT_FLAGS = [1, 4, 8, 16, 32, 64, 128],
        Enum_RIGHT_DESC = [mstrmojo.desc(1825, 'Browse'), mstrmojo.desc(8078, 'Read'), mstrmojo.desc(8079, 'Write'),
            mstrmojo.desc(629, 'Delete'), mstrmojo.desc(8080, 'Control'), mstrmojo.desc(8081, 'Use'), mstrmojo.desc(8082, 'Execute')],
        Enum_RIGHT_DESC_SHORT = ['B', 'R', 'W', 'D', 'C', 'U', 'E'],
        guestModeEnabled = false,
        showMsg = true,

        SUBTYPE_CUSTOM_GROUP = 257,
        SUBTYPE_METRIC = 1024,
        SUBTYPE_REPORT_DATAMART = 772,
        SUBTYPE_REPORT_CUBE = 776,
        SUBTYPE_REPORT_INCREMENTAL_REFRESH = 777;


    function _isFolder(oi) {
        return (oi && oi.t === 8);
    }

    function _showLinks(oi) {
    	return oi && oi.st != SUBTYPE_CUSTOM_GROUP
    	          && oi.st != SUBTYPE_METRIC
    	          && oi.st != SUBTYPE_REPORT_DATAMART
    	          && oi.st != SUBTYPE_REPORT_CUBE
    	          && oi.st != SUBTYPE_REPORT_INCREMENTAL_REFRESH;
    }

    function _fixACL(v) {
        return {
            '253000': 255000,
            '253': 255,
            '221': 223,
            '197': 199,
            '69': 71
        }[v] || v;
    }

    function _fixACLTwoStates(v) {
        return {
            '253000': 255000,
            '253': 255,
            '32221': 223,
            '56197': 199
        }[v] || v;
    }

    function _postProcessACLs(oi) {
        var acls = oi.acls,
            inhs = oi.inhs,
            exAcls = [],
            acl,
            g,
            rgt,
            i,
            len;
        
        if (_isFolder(oi)) {
            acls = acls.concat(mstrmojo.hash.valarray(inhs));
        }

        
        for (i = 0, len = acls.length; i < len; i++) {
            acl = acls[i];
            rgt = acl.rgt;
            if (rgt > 1000) { 
                g = mstrmojo.hash.copy(acl);
                g.den = true;
                g.rgt = Math.floor(rgt / 1000);
                exAcls.push(g);
            }

            if ((rgt % 1000) > 0) {
                g = mstrmojo.hash.copy(acl);
                g.den = false;
                g.rgt = rgt % 1000;
                exAcls.push(g);
            }
        }

        oi.acls = exAcls;

        return oi;
    }
    function _getSaveXML(oi) {
        var cfg = {
            isSerializable: function (nodeName, jsons, idx) {
                switch (nodeName) {
                case 'did':
                case 'rgt':
                case 'n':
                case 'acls':
                case 't':
                case 'st':
                case 'inh':
                case 'den':
                    return true;
                }
                return false;
            },
            getArrItemName: function (n, v, i) {
                if (n === 'acls') {
                    return 'acl';
                }
            },
            convertBoolean: true
        };

        return mstrmojo.string.json2xml('oi', oi, cfg);
    }

    function _saveACL(e, isToClose) {
    	var oi = e && e.oi,
			xml;
    	if (oi) {
            
            oi = _postProcessACLs(oi);

            xml = _getSaveXML(oi);

            mstrmojo.xhr.request('POST', mstrConfig.taskURL, {
                success: function (res) {
                    
                    if (isToClose) {
                        e.close();
                    }
                },
                failure: function (res) {
                    mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                    if (isToClose) {
                        e.close();
                    }
                }
            }, {
                taskId: 'saveObjectACL',
                objectXML: xml,
                sessionState: mstrApp.sessionState,
                objectType: oi.t,
                objectID: oi.did,
                propagateToChildren: e.childrenAccessPulldown.value
            });
        }
    }

    function _addACL(e) {
        var acl = e.aclList,
            ci = e.objectInputer,
            pd = e.rightPulldown,
            its = ci.getSelectedObjects(),
            len = its.length,
            added = [],
            it,
            rgt = pd.value,
            i,
            idx,
            ace;

        if (!ci.isValid()) { 
            mstrmojo.alert(mstrmojo.desc(9048, "Some users/groups do not exist. Please remove them in order to proceed."), null, e.alertTitle);
            return false;
        }

        for (i = 0; i < len; i++) {
            it = its[i];
            
            if (it.did === publicGuestDID || it.did === everyoneDID) {
                var editor = mstrmojo.all[editorID];
                if (rgt === editor.currentPublicRight) {
                    
                    if (showMsg) {
                        $CSS.removeClass(editor.userMessage.domNode, 'hideMsg');
                    }
                }
            }
            idx = $ARRAY.find(acl.items, 'did', it.did);
            if (idx !== -1) {
                ace = acl.items[idx];
                if (e.uneditableRights[ace.rgt]) {
                    continue;
                }
            }
            added.push(new mstrmojo.Obj({
                n: it.n,
                did: it.did,
                st: it.st,
                rgt: rgt,
                newItem: true
            }));
        }

        if (added.length > 0) {
            var ret = $ARRAY.findMulti(acl.items, 'did', added);
            if (ret.count) {
                var idxs = ret.indices.concat().sort($ARRAY.numSorter).slice(0, ret.count);
                for (i = idxs.length - 1; i > -1; i--) {
                    acl.remove(idxs[i]);
                }
            }
            acl.add(added);
            e.set("hasChanged", true);
        }
        ci.set('items', []);
        return true;
    }

    function _getACLHint(r) {
        var h = [],
            d = Math.floor(r / 1000),
            g = r % 1000,
            rf = Enum_RIGHT_FLAGS,
            rd = Enum_RIGHT_DESC,
            len = rf.length,
            s,
            i;
        for (i = 0; i < len; i++) {
            h.push(rd[i]);
            h.push(' ');
            if ((g & rf[i]) > 0) {
                h.push(mstrmojo.desc(8083, 'Granted'));
            } else if ((d & rf[i]) > 0) {
                h.push(mstrmojo.desc(8084, 'Denied'));
            } else {
                h.push(mstrmojo.desc(959, 'Default'));
            }
            h.push(',');
        }
        s = h.join('');
        return s.substring(s, s.length - 1);
    }

    function _getACLLabel(r) {
        var h = [],
            g = r % 1000,
            rf = Enum_RIGHT_FLAGS,
            rd = Enum_RIGHT_DESC_SHORT,
            len = rf.length,
            s,
            i;
        for (i = 0; i < len; i++) {
            if ((g & rf[i]) > 0) {
                h.push(rd[i]);
                h.push(',');
            }
        }
        s = h.join('');
        return s.substring(s, s.length - 1);
    }

    function _updatePulldown(w, v) {
        var its = w.items,
            idx = $ARRAY.find(its, w.itemIdField, v),
            iWas = w.customItem,
            iIdx = its.length - 2;
        if (idx === -1) { 
            var iNew = {
                n: _getACLLabel(v),
                rgt: v
            };
            if (iWas) {
                its.splice(iIdx, 1);
            }
            iIdx = its.length - 1;
            its.splice(iIdx, 0, iNew);

            w.customItem = iNew;
        } else {
            if (iWas && idx !== iIdx) {
                its.splice(iIdx, 1);
                w.customItem = null;
            }
        }
        w.set('title', _getACLHint(v));
        w.value = v;
    }

    function _getCategoriesByType(t) {
        return {
            '776': [{
                n: mstrmojo.desc(8085, 'Consume'),
                rgt: 71
            }, {
                n: mstrmojo.desc(531, 'Add'),
                rgt: 199
            }, {
                n: mstrmojo.desc(8086, 'Collaborate'),
                rgt: 223
            }, {
                n: mstrmojo.desc(8087, 'Full Control'),
                rgt: 255
            }, {
                n: mstrmojo.desc(8088, 'Denied All'),
                rgt: 255000
            }, {
                n: mstrmojo.desc(8089, 'Custom ...'),
                rgt: -1
            }]
        }[t] || [{
            n: mstrmojo.desc(8090, 'View'),
            rgt: 199
        }, {
            n: mstrmojo.desc(767, 'Modify'),
            rgt: 223
        }, {
            n: mstrmojo.desc(8087, 'Full Control'),
            rgt: 255
        }, {
            n: mstrmojo.desc(8088, 'Denied All'),
            rgt: 255000
        }, {
            n: mstrmojo.desc(8089, 'Custom ...'),
            rgt: -1
        }];
    }

    function _getHTMLCode(link, reset) {
        var finalStr = "";
        if (reset){
            var width = this.widthInput.value,
                height = this.heightInput.value,
                src = " src=\"" + link,
                hiddenSecStr = "",
                checkBoxes = this.checkBoxList.items,
                i;

            for (i = 0; i < checkBoxes.length; i++) {
                if (!this.checkBoxList.selectedIndices.hasOwnProperty(i)) {
                    if (hiddenSecStr == "") {
                        hiddenSecStr = "&hiddensections=" + checkBoxes[i].alias;
                    } else {
                        hiddenSecStr += "," + checkBoxes[i].alias;
                    }
                }

            }
            finalStr = "<iframe width=\"" + width + "\" ";
            finalStr += "height=\"" + height + "\" ";

            finalStr += src;
            finalStr += hiddenSecStr;
            finalStr += "\"></iframe>";
        }else{
            finalStr = "<iframe width=\"640\" height=\"480\" src=\"";
            finalStr += link;
            finalStr += "&hiddensections=header,path,dockTop,dockLeft,footer\"></iframe>";

        }
        return finalStr;
    }

    function _getURLLink(href) {
        var parsedURL = mstrmojo.string.parseUri(href).queryKey,
            parmStart = href.indexOf('?'),
            finalURL = parmStart > 0 ? href.substring(0,parmStart):href;
        
        if (parsedURL.hasOwnProperty("iframe")){
            delete parsedURL.iframe;
        }
        if (parsedURL.hasOwnProperty("validateRandNum")){
            delete parsedURL.validateRandNum;
        }
        
        if (!parsedURL.hasOwnProperty("server")){
            parsedURL.server = encodeURIComponent(mstrApp.serverName);
        }
        if (!parsedURL.hasOwnProperty("Project")){
            parsedURL.Project = encodeURIComponent(mstrmojo.string.decodeHtmlString(mstrApp.projectName));
        }
        if (!parsedURL.hasOwnProperty("port")){
            parsedURL.port = mstrApp.serverPort;
        }
        
        if (guestModeEnabled){
            parsedURL.connmode = 8;
            parsedURL.ru = 1;
        }
        
        parsedURL.share = 1;
        
        finalURL += '?';
        for (var key in parsedURL){
            finalURL += key + "=" + parsedURL[key] + "&";
        }
        
        finalURL = finalURL.substring(0,finalURL.length-1);
        return finalURL;
    }

    function _createPersonalView(sendEmail) {
		var now = new Date(),
            subName = this.objectName + ' ' + now.toLocaleDateString() + ' ' + now.toLocaleTimeString(),
            editor = this,
            callback = {
                success: function (res) {
                    var url = _getURLLink(res.url);
                    editor.linkBox.set('value', url);
                    editor.url = url;
                    editor.htmlPanel.htmlBox.set('value', _getHTMLCode(url));
                    var email = editor.tabDock.emailLink;
                    email.set('url', window.escape(url));
                    email.set('name', editor.objectName);

                },
                
                failure: function (res) {
                    mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                },
                complete: function () {
                    
                    editor.hideWait();
                    if (sendEmail) {
                        window.open('mailto:?body=' + window.escape(editor.url) + '&subject=' + editor.objectName, 'mailtoIframe');
                    }
                }
            };
        this.showWait();
        mstrmojo.xhr.request('POST', mstrConfig.taskURL, callback, {
            taskId: 'savePersonalView',
            messageID: this.mid,
            objectType: this.oi.t,
            subName: subName,
            objectSubType: 0,
            viewMode: this.viewMode || 0,
            isPVPublic: true
        });

    }

    function _getMouseOverLabel(rgt) {
        var access = _getCategoriesByType(this.oi.st),
            len = access.length,
            i;

        for (i = 0; i < len; i++) {
            if (access[i].rgt === rgt) {
                return access[i].n;
            }
        }
        return mstrmojo.desc(2056, "Custom");
    }
    mstrmojo.SharingEditor = mstrmojo.declare(mstrmojo.Editor, null, {
        scriptClass: "mstrmojo.SharingEditor",
        cssClass: 'mstrmojo-SharingEditor',
        hasChanged: false,
        help: 'sharing_dialog_box.htm',
        zIndex: 1000,
        defaultRight: 223,
        showButtonText: true,
        uneditableRights: {},
        currentPublicRight: 199,
        userSelectorTitle: mstrmojo.desc(8091, 'User/User Group Browser'),
        onShowLink: function (alias) {

            var name = {
                htmlCode: 'showLink',
                showLink: 'htmlCode'
            };

            this.tabDock[name[alias]].set('selected', false);

        },
        showWait: mstrmojo.emptyFn,
        hideWait: mstrmojo.emptyFn,
        checkPublicAccess: function () {
            var acls = this.oi.acls,
                i,
                everyoneIndex = $ARRAY.find(acls, 'did', everyoneDID),
                itemContainerNode = this.aclList.itemsContainerNode,
                publicLabel = this.publicAccessSection.publicLabel,
                dataRow,
                toggleClass = false,
                guestIndex = $ARRAY.find(acls, 'did', publicGuestDID),
                publicAccess;

                if (everyoneIndex !== -1 && guestModeEnabled && guestIndex !== -1) {
                    
                    var everyoneRight = acls[everyoneIndex].rgt,
                        guestRight = acls[guestIndex].rgt;
                    if (everyoneRight === guestRight) {
                        toggleClass = true;
                        publicAccess = guestRight;
                    }
                }
                if (everyoneIndex !== -1 && !guestModeEnabled) {
                    toggleClass = true;
                    publicAccess = acls[everyoneIndex].rgt;
                }
                
                dataRow = itemContainerNode.children[0].tBodies;

                if (guestModeEnabled && dataRow[guestIndex] ){
                    $CSS.toggleClass(dataRow[guestIndex].rows[0],'hide', toggleClass);
                }
                if (dataRow[everyoneIndex]){
                    $CSS.toggleClass(dataRow[everyoneIndex].rows[0],'hide', toggleClass);
                }
                publicLabel.set('checked', toggleClass);

                if (publicAccess){
                    this.set('currentPublicRight', publicAccess);
                }

        },
        oncurrentPublicRightChange: function () {
            
            var mouseOverContainer = this.publicAccessSection.publicMouseOver;
            mouseOverContainer.publicRight.set('value', this.currentPublicRight);
            mouseOverContainer.publicRightLabel.set('text', _getMouseOverLabel.call(this, this.currentPublicRight));
        },
        onOpen: function () {
            
        	var name = this.oi.n,
        		acl = this.oi.acls;
            this.objectName = name;
            this.set('showACL', !!acl); 
            guestModeEnabled = this.guestModeEnabled;
            
            if (this.href && !this.isLinkDirty) {
                var url = _getURLLink(this.href),
                    email = this.tabDock.emailLink;
                this.url = url;
                email.set('url', window.escape(url));
                email.set('name', name);
                this.htmlPanel.htmlBox.set('value', _getHTMLCode(url));
                this.linkBox.set('value', url);
            }

            this.set('title', mstrmojo.desc(8093, 'share').replace('##', mstrmojo.string.encodeHtmlString(name)));
            var tabDock = this.tabDock;
            tabDock.showLink.set('selected', false);
            tabDock.htmlCode.set('selected', false);

            if (acl){
	            
	            this.checkPublicAccess();
	            
	            var pd = this.rightPulldown;

	            pd.set('items', this.getAvailableRightsForSelection());
	            pd.set('value', defaultPublicAccess);

	            var ci = this.objectInputer,
	                us = this.userSelector,
	                ub = us && us.userBrowser;
	            ci.zIndex = this.zIndex;
	            if (ub && ub.hasRendered) {
	                ub.set('items', []);
	                ub.getContent(ub);
	            }

	            this.set("hasChanged", false);
            }
        },
        _set_hasChanged: function (n, v) {
            
            var returnVal = (v !== this.hasChanged);

            
            this.hasChanged = v;

            
            if (v === true) {
                this.checkPublicAccess();
            }
            return returnVal;
        },
        _set_oi: function (n, v) {
            this.oi = this.preProcessACLs(v);
            return true;
        },
        postCreate: function () {
            
            this.oi = this.preProcessACLs(this.oi);
        },
        getAvailableRightsForSelection: function () {
            return _getCategoriesByType(this.oi.st);
        },
        preProcessACLs: function (oi) {
        	if (oi && oi.acls){
        		var acls = oi.acls,
	                len = acls && acls.length,
	                isF = _isFolder(oi),
	                aclMap = {},
	                acl,
	                r,
	                inhs,
	                i;

	            if (isF) {
	                inhs = {};
	                oi.inhs = inhs;
	            }

	            
	            for (i = 0; i < len; i++) {
	                
	                acl = new mstrmojo.Obj(acls[i]);
	                if (isF && acl.inh) { 
	                    inhs[acl.n] = mstrmojo.hash.copy(acl);
	                    continue;
	                }

	                r = aclMap[acl.n];
	                if (!r) {
	                    r = mstrmojo.hash.copy(acl);
	                    r.rgt = 0;
	                    delete r.den;
	                    aclMap[acl.n] = r;
	                }
	                r.rgt += acl.den ? acl.rgt * 1000 : acl.rgt;
	            }

	            acls = mstrmojo.hash.valarray(aclMap);

	            oi.acls = acls;
        	}
            return oi;
        },
        onClose: function () {
            var ci = this.objectInputer;
            ci.set('items', []);
            this.aclList.clearSelect(); 
        },
        userSelector: {
            scriptClass: 'mstrmojo.Editor',
            cssClass: 'mstrmojo-UserEditor',
            help: 'user_group_browser.htm',
            onClose: function () {
                this.userBrowser.clearTreeSelect();
            },
            children: [{
                scriptClass: 'mstrmojo.ACL.UserTreeBrowser',
                alias: 'userBrowser',
                updateTreeContent: function (w, res) {
                    w.contentRetrieved = true;
                    var items = res[w.itemChildrenField],
                        tree = w.tree || w,
                        bc = res.bc,
                        sz = res.sz,
                        bb = res.bb;
                    if (bc !== -1) {
                        if (bb + bc <= sz) {
                            items.push(tree.nextItemCreaterFunc());
                        }
                        if ((bb - bc) > -1) {
                            items.unshift(tree.prevItemCreaterFunc());
                        }
                    }
                    w.blockBegin = bb;
                    tree.initializing = true;
                    w.clearSelect(false);
                    w.set('items', items);

                    
                    w.setSelectedItems(tree.getTotalSelections(), true);

                    tree.initializing = false;
                },
                selectionAcrossBranch: true,
                multiSelect: true
            }, {
                scriptClass: 'mstrmojo.HBox',
                cssClass: 'mstrmojo-Editor-buttonBox',
                slot: 'buttonNode',
                children: [{
                    scriptClass: 'mstrmojo.HTMLButton',
                    cssClass: "mstrmojo-Editor-button",
                    iconClass: "mstrmojo-Editor-button-OK",
                    text: mstrmojo.desc(1442, "OK"),
                    onclick: function (evt) {
                        var ue = this.parent.parent,
                            e = ue.opener,
                            ci = e.objectInputer,
                            ub = ue.userBrowser,
                            sls = ub.getTotalSelections();
                        if (sls && sls.length > 0) {
                            ci.add(sls, ci.items.length - 1);
                        }
                        ue.close();
                    },
                    preBuildRendering: function () {
                        if (!this.parent.parent.opener.showButtonText) {
                            this.set("text", "");
                        }
                    }
                }, {
                    scriptClass: 'mstrmojo.HTMLButton',
                    cssClass: "mstrmojo-Editor-button",
                    iconClass: "mstrmojo-Editor-button-Cancel",
                    text: mstrmojo.desc(221, "Cancel"),
                    onclick: function (evt) {
                        this.parent.parent.close();
                    },
                    preBuildRendering: function () {
                        if (!this.parent.parent.opener.showButtonText) {
                            this.set("text", "");
                        }
                    }
                }]
            }],
            onOpen: function () {
                this.set("title", this.opener.userSelectorTitle);
            }
        },
        customACL: {
            scriptClass: 'mstrmojo.Editor',
            title: mstrmojo.desc(8092, 'Custom Permission Level'),
            cssClass: 'mstrmojo-CustomACLEditor',
            help: 'Custom_Permission_Level_dialog_box.htm',
            onOpen: function () {
                var rgt = this.rgt,
                    d = Math.floor(rgt / 1000),
                    g = rgt % 1000,
                    chs = this.children,
                    ch,
                    r,
                    i,
                    len;
                for (i = 0, len = chs.length; i < len; i++) {
                    ch = chs[i];
                    r = ch.right;
                    if (this.twoStates) {
                        ch.set('grayed', false);
                        ch.set('checked', false);
                    } else {
                        ch.set('grayed', true);
                        ch.set('checked', true);
                    }
                    if ((d & r) > 0) {
                        ch.set('checked', false);
                        ch.set('grayed', false);
                    }
                    if ((g & r) > 0) {
                        ch.set('checked', true);
                        ch.set('grayed', false);
                    }
                }
            },
            getACLValue: function () {
                var g = 0,
                    d = 0,
                    chs = this.children,
                    ch,
                    i,
                    len;
                for (i = 0, len = chs.length; i < len; i++) {
                    ch = chs[i];
                    if (ch.grayed || !ch.right) {
                        continue;
                    }
                    if (ch.checked) {
                        g += ch.right;
                    } else {
                        d += ch.right;
                    }
                }
                return d * 1000 + g;
            },
            children: [{
                scriptClass: 'mstrmojo.TristateCheckBox',
                alias: 'browse',
                right: 1,
                text: mstrmojo.desc(1825, 'Browse')
            }, {
                scriptClass: 'mstrmojo.TristateCheckBox',
                alias: 'read',
                right: 4,
                text: mstrmojo.desc(8078, 'Read')
            }, {
                scriptClass: 'mstrmojo.TristateCheckBox',
                alias: 'write',
                right: 8,
                text: mstrmojo.desc(8079, 'Write')
            }, {
                scriptClass: 'mstrmojo.TristateCheckBox',
                alias: 'delete',
                right: 16,
                text: mstrmojo.desc(629, 'Delete')
            }, {
                scriptClass: 'mstrmojo.TristateCheckBox',
                alias: 'control',
                right: 32,
                text: mstrmojo.desc(8080, 'Control')
            }, {
                scriptClass: 'mstrmojo.TristateCheckBox',
                alias: 'use',
                right: 64,
                text: mstrmojo.desc(8081, 'Use')
            }, {
                scriptClass: 'mstrmojo.TristateCheckBox',
                alias: 'execute',
                right: 128,
                text: mstrmojo.desc(8082, 'Execute')
            }, {
                scriptClass: 'mstrmojo.HBox',
                cssClass: 'mstrmojo-Editor-buttonBox',
                slot: 'buttonNode',
                children: [{ 
                    scriptClass: "mstrmojo.HTMLButton",
                    cssClass: "mstrmojo-Editor-button",
                    iconClass: "mstrmojo-Editor-button-OK",
                    text: mstrmojo.desc(1442, "OK"),
                    onclick: function (evt) {
                        var e = this.parent.parent;
                        if (e.onOK) {
                            e.onOK();
                        }
                        e.close();
                    }
                }, { 
                    scriptClass: "mstrmojo.HTMLButton",
                    cssClass: "mstrmojo-Editor-button",
                    iconClass: "mstrmojo-Editor-button-Cancel",
                    text: mstrmojo.desc(221, "Cancel"),
                    onclick: function (evt) {
                        var e = this.parent.parent;
                        if (e.onCancel) {
                            e.onCancel();
                        }
                        e.close();
                    }
                }]
            }]
        },
        children: [{
            scriptClass: 'mstrmojo.Label',
            text: mstrmojo.desc(9811, 'Sharing Options'),
            bindings : {
            	visible : function (){
            		return _showLinks(this.parent.oi);
            	}
            },
            cssClass: 'SharingEditor-title'
        }, {
            scriptClass: "mstrmojo.HBox",
            alias: 'tabDock',
            cssClass: 'sharingEditor-tabDock',
            bindings : {
            	visible : function (){
            		return _showLinks(this.parent.oi);
            	}
            },
            children: [{
                scriptClass: 'mstrmojo.Widget',
                
                markupString: '<div id = "{@id}" class ="sharingEditor-emailLink style="{@cssText} mstrAttach:click>'
                    + mstrmojo.desc(9772, 'Email Link')
                    + ' <iframe name="mailtoIframe" style="display:none"></iframe> </div>',
                alias: 'emailLink',
                onclick: function () {
                    var editor = this.parent.parent;
                    
                    if (!this.url || editor.isLinkDirty) {
                        _createPersonalView.call(editor, true);
                        
                        editor.set('isLinkDirty', false);
                    } else {
                        window.open('mailto:?body=' + window.escape(editor.url) + '&subject=' + editor.objectName, 'mailtoIframe');
                    }
                }
            }, {
                scriptClass: 'mstrmojo.Label',
                alias: 'showLink',
                text: mstrmojo.desc(9773, "Show Link"),
                cssClass: 'SharingEditor-ShowLink',
                selected: false,
                onclick: function (evt) {
                    var editor = this.parent.parent;

                    if (this.selected) {
                        this.set('selected', false);
                    } else {
                        
                        if (!editor.url || editor.isLinkDirty) {
                            _createPersonalView.call(editor);
                            
                            editor.set('isLinkDirty', false);
                        }
                        
                        editor.onShowLink(this.alias);
                        this.set('selected', true);
                    }
                }
            }, {
                scriptClass: 'mstrmojo.Label',
                cssClass: 'SharingEditor-ShowHtml',
                alias: 'htmlCode',
                text: mstrmojo.desc(9774, "Show HTML"),
                selected: false,
                onclick: function (evt) {
                    var editor = this.parent.parent;
                    if (this.selected) {
                        this.set('selected', false);
                    } else {
                        
                        if (!editor.url || editor.isLinkDirty) {
                            _createPersonalView.call(editor);
                            
                            editor.set('isLinkDirty', false);
                        }
                        
                        editor.onShowLink(this.alias);
                        this.set('selected', true);
                    }
                }
            }]
        }, {
            scriptClass: 'mstrmojo.Box',
            alias: 'htmlPanel',
            cssClass: 'mstrmojo-SharingEditor-html-panel',
            children: [{
                scriptClass: "mstrmojo.TextBox",
                alias: 'htmlBox',
                cssClass: 'SharingEditor-Html'
            }, {
                scriptClass: "mstrmojo.TextBoxWithLabel",
                alias: 'widthInput',
                label: mstrmojo.desc(2985, "Width"),
                value: 640,
                onvalueChange: function (evt) {
                    var prt = this.parent,
                        editor = mstrmojo.all[editorID];
                    prt.htmlBox.set('value', _getHTMLCode.call(prt,editor.url,true));
                }
            }, {
                scriptClass: "mstrmojo.TextBoxWithLabel",
                label: mstrmojo.desc(2983, "Height"),
                alias: 'heightInput',
                value: 480,
                onvalueChange: function () {
                    var prt = this.parent,
                        editor = mstrmojo.all[editorID];
                    prt.htmlBox.set('value', _getHTMLCode.call(prt,editor.url,true));
                }
            }, {
                scriptClass: "mstrmojo.CheckListHoriz",
                alias: 'checkBoxList',
                items: [{
                    n: mstrmojo.desc(8145, "Navigation Bar"),
                    alias: 'path'
                }, {
                    n: mstrmojo.desc(2509, 'Toolbar'),
                    alias: 'dockTop'
                }, {
                    n: mstrmojo.desc(8146, 'Tools Panel'),
                    alias: 'dockLeft'
                }, {
                    n: mstrmojo.desc(8147, 'Footer'),
                    alias: 'footer'
                }],
                multiSelect: true,
                onselectionChange: function (evt) {
                    var prt = this.parent,
                        editor = mstrmojo.all[editorID];
                    prt.htmlBox.set('value', _getHTMLCode.call(prt,editor.url,true));
                }
            }],
            bindings: {
                visible: 'this.parent.tabDock.htmlCode.selected'
            }

        }, {
            scriptClass: "mstrmojo.TextBox",
            alias: 'linkBox',
            cssClass: 'SharingEditor-Link',
            bindings: {
                visible: 'this.parent.tabDock.showLink.selected'
            }

        }, {
            scriptClass: 'mstrmojo.Label',
            text: mstrmojo.desc(9775, "[Who has access]"),
            cssClass: 'SharingEditor-title',
            bindings:{
            	visible: 'this.parent.showACL'
            }
        }, {
            scriptClass: 'mstrmojo.HBox',
            alias: 'publicAccessSection',
            cssClass: 'sharingEditor-publicAccessSection',
            bindings:{
            	visible: 'this.parent.showACL'
            },
            children: [{
                scriptClass: 'mstrmojo.CheckBox',
                alias: 'publicLabel',
                cssClass: 'SharingEditor-Public',
                bindings: {
                    label: function () {
                        if (this.parent.parent.guestModeEnabled) {
                            return mstrmojo.desc(9776, 'Public (Login not required)');
                        }
                        return mstrmojo.desc(9777, 'Everyone (Login not required)');
                    }
                },
                oncheckedChange: function () {
                    $CSS.toggleClass(this.domNode.children[1], 'label-disabled', !this.checked);
                },
                
                getUserGroupsInfo: function () {
                    if (guestModeEnabled) {
                        this.getUserGroupFromTaskCall(publicGuestDID);
                    }
                    this.getUserGroupFromTaskCall(everyoneDID);

                },
                getUserGroupFromTaskCall: function (id) {
                    var editor = mstrmojo.all[editorID],
                        acls = editor.aclList,
                        DS = mstrmojo.ACL.UserDataService,
                        success = function (candidates) {
                            var added = new mstrmojo.Obj({
                                n: candidates.n,
                                did: candidates.did,
                                st: candidates.st,
                                rgt: defaultPublicAccess,
                                newItem: true
                            });
                            publicUsers.push(added);
                        },
                        failure = function (res) {},
                        complete = function () {
                            if (!guestModeEnabled || (guestModeEnabled && publicUsers.length == 2)) {
                                acls.add(publicUsers);
                                editor.set("hasChanged", true);
                            }

                        };

                    DS.getMembers({
                        blockBegin : 0,
                        blockCount : 1,
                        outputElements: 1,
                        data : {
                            did : id
                        }
                    }, {
                        success : success,
                        failure : failure,
                        complete : complete
                    });

                },

                onclick: function () {
                    var editor = mstrmojo.all[editorID];
                    var acls = editor.aclList.items;
                    var everyoneIndex = $ARRAY.find(acls, 'did', everyoneDID);
                    if (everyoneIndex !== -1) {
                        acls.remove(everyoneIndex);
                    }
                    var guestIndex = $ARRAY.find(acls, 'did', publicGuestDID);
                    if (guestModeEnabled && guestIndex !== -1) {
                        acls.remove(guestIndex);
                    }
                    if (this.checked === true) {
                        
                        if (publicUsers.length < 1) {
                            
                            this.getUserGroupsInfo();
                        } else {
                            
                            
                            mstrmojo.array.forEach(publicUsers,function (item){
                                item.rgt = defaultPublicAccess;
                            });
                            acls.add(publicUsers);
                            editor.set("hasChanged", true);
                        }

                    } else {
                        
                        editor.set('currentPublicRight', defaultPublicAccess);
                        editor.set('hasChanged', true);
                    }
                }

            }, {
                scriptClass: "mstrmojo.MouseOverContainer",
                alias: 'publicMouseOver',
                bindings: {
                    visible: "this.parent.publicLabel.checked"
                },
                children: [{
                    scriptClass: "mstrmojo.Label",
                    alias: 'publicRightLabel',
                    cssClass: 'sharingEditor-rightLabel',
                    bindings: {
                        text: function () {
                            var editor = this.parent.parent.parent;
                            return _getMouseOverLabel.call(editor,editor.currentPublicRight);
                        }
                    }
                }, {
                    scriptClass: "mstrmojo.Pulldown",
                    cssClass: 'sharingEditor-pulldown',
                    itemIdField: 'rgt',
                    alias: "publicRight",
                    visible: false,
                    postCreate: function () {
                        this.items = this.parent.parent.parent.getAvailableRightsForSelection();
                    },
                    bindings: {
                        value: "this.parent.parent.parent.currentPublicRight"
                    },
                    selectionPolicy: 'reselect',
                    onvalueChange: function () {
                        var mouseOverContainer = this.parent;
                        var editor = mouseOverContainer.parent.parent;
                        mouseOverContainer.publicRightLabel.set('text', _getMouseOverLabel.call(editor, this.value));
                    },
                    _set_value: function (n, v) {
                        var vWas = this.value,
                            bChanged = (vWas !== v);

                        if (bChanged) {
                            if (v === -1) { 
                                var e = this.parent.parent.parent,
                                    me = this;
                                e.openPopup('customACL', {
                                    zIndex: e.zIndex + 10,
                                    rgt: vWas,
                                    twoStates: true,
                                    onOK: function () {
                                        me.set('value', this.getACLValue());
                                    },
                                    onCancel: function () {
                                        me.set('value', vWas);
                                    }
                                });
                                return false;
                            }

                            v = _fixACLTwoStates(v);
                            _updatePulldown(this, v);
                            this.updatePublicRight(v);
                            return true;
                        }
                        return true;
                    },

                    updatePublicRight: function (v) {
                        var editor = this.parent.parent.parent;
                        if (editor.aclList) {
                            var acls = editor.aclList.items;
                            var guestIndex = $ARRAY.find(acls, 'did', publicGuestDID);
                            var everyoneIndex = $ARRAY.find(acls, 'did', everyoneDID);

                            if (guestModeEnabled && guestIndex !== -1) {
                                acls[guestIndex].rgt = v;
                            }
                            if (everyoneIndex !== -1) {
                                acls[everyoneIndex].rgt = v;
                            }
                            editor.set('hasChanged', true);
                            editor.set('currentPublicRight', v);
                        }
                    }
                }]
            }]
        }, {
            scriptClass: "mstrmojo.Label",
            alias: "userMessage",
            text: mstrmojo.desc(9771, "The permission you added is already granted"),
            cssClass: "sharingEditorUserMessage hideMsg",
            bindings:{
            	visible: 'this.parent.showACL'
            },
            onclick: function () {
                $CSS.addClass(this.domNode, 'hideMsg');
                showMsg = false;
            }

        }, {
            scriptClass: "mstrmojo.DataGrid",
            alias: "aclList",
            renderOnScroll: false,
            makeObservable: true,
            itemDisplayField: 'n',
            dropZone: true,
            bindings: {
                items: function() {
                	return this.parent.oi.acls || [];
                },
                visible: "this.parent.showACL"
            },

            onremove: function (evt) {
                var oi = this.parent.oi;
                if (!_isFolder(oi)) {
                    return;
                }
                var inhs = oi.inhs,
                    its = evt.value,
                    len = its && its.length,
                    n,
                    i;
                for (i = 0; i < len; i++) {
                    n = its[i].n;
                    delete inhs[n];
                }
            },

            onadd: function (evt) {
                var oi = this.parent.oi;
                if (!_isFolder(oi)) {
                    return;
                }
                var inhs = oi.inhs,
                    its = evt.value,
                    len = its && its.length,
                    n,
                    i;
                for (i = 0; i < len; i++) {
                    n = its[i].n;
                    inhs[n] = mstrmojo.hash.copy(its[i]);
                    inhs[n].inh = true;
                }
            },
            onACLChanged: function (d) {
                var oi = this.parent.oi;
                this.parent.set("hasChanged", true);
                if (!_isFolder(oi)) {
                    return;
                }
                oi.inhs[d.n] = mstrmojo.hash.copy(d);
                oi.inhs[d.n].inh = true;
            },
            columns: [{
                dataFunction: function (item, idx, w) {
                    
                    return '<div class="mstrmojo-ACLEditor-user ' + (item.st === 8705 ? 'ug' : 'u') + '">' + mstrmojo.string.encodeHtmlString(item.n) + '</div>';
                }
            }, {
                dataWidget: {
                    scriptClass: 'mstrmojo.MouseOverContainer',
                    alias: 'mouseOverContainer',
                    children: [{
                        scriptClass: 'mstrmojo.Label',
                        cssClass: 'sharingEditor-rightLabel',
                        bindings: {
                            text: function () {
                                return _getMouseOverLabel.call(mstrmojo.all[editorID], this.parent.parent.data.rgt);
                            }
                        }
                    }, {
                        scriptClass: 'mstrmojo.HBox',
                        cssClass: 'sharingEditor-datagridContainer',
                        visible: false,
                        children: [{
                            scriptClass: 'mstrmojo.Pulldown',
                            cssClass: 'sharingEditor-datagridPulldown',
                            itemIdField: 'rgt',
                            popupToBody: true,
                            selectionPolicy: 'reselect',
                            popupZIndex: 1001,
                            postCreate: function () {
                                this.markupMethods = mstrmojo.hash.copy({
                                    ondataChange: function () {
                                        var d = this.parent.parent.data;
                                        this.set('value', d[this.itemIdField]);
                                    },
                                    onvisibleChange: function () {
                                        this.domNode.style.display = this.visible ? 'block' : 'none';

                                        if (!this.visible && this.popupRef) {
                                            this.popupRef.set("visible", false);
                                        }
                                    }
                                }, mstrmojo.hash.copy(this.markupMethods));
                                this.items = this.parent.parent.dataGrid.parent.getAvailableRightsForSelection();
                            },
                            _set_value: function (n, v) {
                                var vWas = this.value,
                                    bChanged = (vWas !== v);
                                if (bChanged) {
                                    if (v === -1) { 
                                        var e = this.parent.parent.dataGrid.parent,
                                            me = this;
                                        e.openPopup('customACL', {
                                            zIndex: e.zIndex + 10,
                                            rgt: vWas,
                                            twoStates: !!this.parent.parent.data.newItem,
                                            onOK: function () {
                                                me.set('value', this.getACLValue());
                                            },
                                            onCancel: function () {
                                                me.set('value', vWas);
                                            }
                                        });
                                        return false;
                                    }

                                    v = _fixACL(v);
                                    _updatePulldown(this, v);
                                    this.parent.parent.data.set(this.itemIdField, v);

                                    if (vWas !== null) {
                                        this.parent.parent.dataGrid.onACLChanged(this.parent.parent.data);
                                    }
                                    return true;
                                }
                                return true;
                            }
                        }, {
                            scriptClass: "mstrmojo.Button",
                            cssClass: "mstrmojo-ACLEditor-delete",
                            text: "&nbsp",
                            title: mstrmojo.desc(629, 'Delete'),
                            onclick: function (evt) {
                                var dg = this.parent.parent.dataGrid;
                                dg.remove(this.parent.parent.data);
                                dg.parent.set("hasChanged", true);
                            }
                        }]

                    }]

                }
            }]

        }, {
            scriptClass: "mstrmojo.Box",
            cssClass: 'sharingEditor-ACLUserPanel',
            bindings: {
                visible: 'this.parent.showACL'
            },
            children: [{
                scriptClass: "mstrmojo.HBox",
                cssClass: 'sharingEditor-CPSection',
                children: [{
                    scriptClass: "mstrmojo.ACL.UserInputBox",
                    emptyText: mstrmojo.desc(9151, 'Type users or groups here.'),
                    noCache: true,
                    onRender: function () {
                        var e = this.parent.parent.parent;
                        if (e) {
                            e.objectInputer = this;
                        }
                    }

                }, {
                    scriptClass: 'mstrmojo.Pulldown',
                    itemIdField: 'rgt',
                    value: 199,
                    defaultSelection: 0,
                    selectionPolicy: 'reselect',
                    onRender: function () {
                        var e = this.parent.parent.parent;
                        if (e) {
                            e.rightPulldown = this;
                        }
                    },
                    postCreate: function () {
                        this.items = this.parent.parent.parent.getAvailableRightsForSelection();
                    },
                    _set_value: function (n, v) {
                        var vWas = this.value,
                            bChanged = (vWas !== v);

                        if (bChanged) {
                            if (v === -1) { 
                                var e = this.parent.parent.parent,
                                    me = this;
                                e.openPopup('customACL', {
                                    zIndex: e.zIndex + 10,
                                    rgt: vWas,
                                    twoStates: true,
                                    onOK: function () {
                                        me.set('value', this.getACLValue());
                                    },
                                    onCancel: function () {
                                        me.set('value', vWas);
                                    }
                                });
                                return false;
                            }

                            v = _fixACLTwoStates(v);
                            _updatePulldown(this, v);

                            return true;
                        }
                        return true;
                    }
                }, {
                    scriptClass: "mstrmojo.HTMLButton",
                    cssClass: "mstrmojo-Editor-button",
                    onclick: function (evt) {

                        var e = this.parent.parent.parent;
                        _addACL(e);

                    },
                    text: mstrmojo.desc(2156, "Add")

                }, {
                    scriptClass: "mstrmojo.HTMLButton",
                    cssClass: "mstrmojo-Editor-button",
                    iconClass: "mstrmojo-ACLEditor-chooseLabel",
                    onclick: function (evt) {
                        var e = this.parent.parent.parent;
                        e.openPopup('userSelector', {
                            zIndex: e.zIndex + 10
                        });
                    },
                    text: mstrmojo.desc(1825, "Browse")

                }]
            }]

        }, {
            scriptClass: 'mstrmojo.Label',
            text: mstrmojo.desc(9892, "Children Access"),
            cssClass: 'SharingEditor-title',
            bindings: {
                visible: function (){
                    return this.parent.showACL && _isFolder(this.parent.oi);
                }
            }
        },{
            scriptClass: 'mstrmojo.Pulldown',
            alias: 'childrenAccessPulldown',
            value: 0,
            items: [{
                n: mstrmojo.desc(9890, 'Preserve children\'s access control lists'),
                idx: 0
            }, {
                n: mstrmojo.desc(9891, 'Overwrite children\'s access control lists'),
                idx: 1
            }],
            itemIdField: 'idx',
            bindings: {
                visible: function (){
                    return this.parent.showACL && _isFolder(this.parent.oi);
                }
            }
        },{
            scriptClass: "mstrmojo.HBox",
            cssClass: "Editor-buttonBox",
            slot: "buttonNode",
            bindings: {
            	visible: 'this.parent.showACL'
            },
            children: [{ 
                scriptClass: "mstrmojo.HTMLButton",
                cssClass: "mstrmojo-Editor-button",
                iconClass: "mstrmojo-Editor-button-OK",
                text: mstrmojo.desc(1442, "OK"),
                bindings: {
                    enabled: function () {
                        
                        var oi = this.parent.parent.oi;
                        return (oi.acg & 32) > 0 && this.parent.parent.hasChanged;
                    }
                },
                onclick: function (evt) {
                    var e = this.parent.parent;

                    if (_addACL(e)) {
                        _saveACL(e, true);
                    }
                },
                preBuildRendering: function () {
                    if (!this.parent.parent.showButtonText) {
                        this.set("text", "");
                    }
                }
            }, {
                scriptClass: "mstrmojo.HTMLButton",
                cssClass: "mstrmojo-Editor-button",
                iconClass: "mstrmojo-Editor-button-Close",
                onclick: function (evt) {
                    var editor = this.parent.parent;
                    editor.close();
                    editor.set("hasChanged", false);
                },
                bindings: {
                    iconClass: function () {
                        var editor = this.parent.parent;
                        if (editor.hasChanged) {
                            return "mstrmojo-Editor-button-Cancel";
                        }
                        return "mstrmojo-Editor-button-Close";
                    },
                    text: function () {
                        var editor = this.parent.parent;
                        if (!editor.showButtonText) {
                            return "";
                        }
                        if (editor.hasChanged) {
                            return mstrmojo.desc(2140, "Cancel");
                        }
                        return mstrmojo.desc(2102, "Close");
                    }
                }
            }]
        }]

    });
    mstrmojo.MouseOverContainer = mstrmojo.declare(mstrmojo.StackContainer, null, {
        scriptClass: "mstrmojo.MouseOverContainer",
        markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@cssText}" mstrAttach:mouseover,mouseout></div>',
        doSwitch: true,
        markupSlots: {
            containerNode: function () {
                return this.domNode;
            }
        },
        markupMethods: {
            onvisibleChange: function () {
                this.domNode.style.display = this.visible ? 'block' : 'none';
            }
        },
        onmouseover: function () {
            if (this.doSwitch) {
                this.set("selected", this.children[1]);
            }
        },
        onmouseout: function () {
            if (this.doSwitch) {
                this.set("selected", this.children[0]);
            }
        },
        preBuildRendering: function () {
            this.set("selected", this.children[0]);
        }
    });

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocSelectorViewFactory",
                         "mstrmojo.android.DropDownList",
                         "mstrmojo.android.selectors.CheckList",
                         "mstrmojo.android.selectors.ListBox",
                         "mstrmojo.android.selectors.LinkBar",
                         "mstrmojo.android.selectors.ButtonBar",
                         "mstrmojo.android.selectors.Slider",
                         "mstrmojo.array");

    var $STYLES = mstrmojo.DocSelectorViewFactory.STYLES;

    
    var widgetMap = {};
    widgetMap[$STYLES.RADIO] = 'CheckList';
    widgetMap[$STYLES.CHECKBOX] = 'CheckList';
    widgetMap[$STYLES.LIST] = 'ListBox';
    widgetMap[$STYLES.LINK] = 'LinkBar';
    widgetMap[$STYLES.BUTTON] = 'ButtonBar';
    widgetMap[$STYLES.SCROLLER] = 'Slider';
    
    widgetMap['9'] = 'LinkBar';

    
    mstrmojo.android.DocSelectorViewFactory = mstrmojo.declare(

        mstrmojo.DocSelectorViewFactory,

        null,

        
        {
            scriptClass: 'mstrmojo.android.DocSelectorViewFactory',

            isSelectorSupported: function isSelectorSupported(selectorContainer) {
                
                var defn = selectorContainer.node.defn;

                
                if (defn.ct === "3") {
                    
                    var targetKey = selectorContainer.tks;
                    if (targetKey && selectorContainer.defn.dk) {
                        
                        selectorContainer.model.getLayoutUnitDefn(targetKey, defn._lkz).dk = true;

                        
                        return false;
                    }
                }

                
                return true;
            },

            
            newPulldown: function newPulldown(selectorContainer) {
                return new mstrmojo.android.DropDownList({
                    name: selectorContainer.node.defn.n,
                    postvalueChange: function () {
                    	
                    	if (!selectorContainer._inSyncPhase) {
                    		selectorContainer.showInfoWin();
                    		
                    		selectorContainer.selectorControlChange(this);
                    	}
                    }
                });
            },

            updateControlStyles: function updateControlStyles(selectorContainer) {
                var fmts = selectorContainer.getFormats(),
                    selectorStyle = selectorContainer.style,
                    ctrl = selectorContainer.children && selectorContainer.children[0];

                if (!ctrl) {
                    return;
                }

                
                if (fmts) {

                    
                    var height = fmts.height,
                        width = fmts.width;

                    
                    if (height !== undefined) {
                        
                        ctrl.height = height;
                    }

                    
                    if (width !== undefined) {
                        
                        ctrl.width = width;
                    }

                    
                    if (selectorStyle === $STYLES.LINK) {
                        
                        var selectedColor = selectorContainer.defn.ssc;
                        if (selectedColor) {
                            
                            ctrl.selColor = selectedColor;
                        }
                    }
                }

                this._super(selectorContainer);
            },

            attachTargetListeners: function attachTargetListeners(selectorContainer) {
                this._super(selectorContainer);

                
                if (selectorContainer.defn.ct === '3' && this.isSelectorSupported(selectorContainer)) {
                    
                    if (!selectorContainer._panelEvtListener) {
                        
                        var panelStack = selectorContainer.model.getUnitInstance(selectorContainer.tks, 1);
                        if (panelStack) {
                            
                            selectorContainer._panelEvtListener = panelStack.attachEventListener('panelSelected', selectorContainer.id, function (evt) {
                                
                                this._inSyncPhase = true;

                                
                                this.content.singleSelectByField(evt.key, 'v');

                                
                                this._inSyncPhase = false;
                            });
                        }
                    }
                }
            },

            getSelectorClass: function getSelectorClass(selectorStyle, isHoriz) {
                
                var cls = widgetMap[selectorStyle];
                return (cls && 'android.selectors.' + cls) || this._super(selectorStyle, isHoriz);
            },
            
            getSelectorCtrlConfig: function getSelectorCtrlConfig(selectorContainer, selectorStyle, defn, elements) {
            	
            	if ( selectorStyle === 9 ) {
            		if ( elements && elements.length === 0) {
	            		elements.push({
	            			n: "(All)",
	            			t: 14,
	            			v: "u;"
	            		});
                	}
            		
            		selectorContainer.style = selectorStyle = $STYLES.LINK;
            	}
            	return this._super(selectorContainer, selectorStyle, defn, elements);
            }            
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo.DocSelectorViewFactory",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo.elementHelper");


    var $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash,
        $D = mstrmojo.dom,
        STYLES = mstrmojo.DocSelectorViewFactory.STYLES,
        ELEM_ALL_ID = mstrmojo.DocSelectorViewFactory.ELEM_ALL,
        _EH = mstrmojo.elementHelper;

    var _ST_UC_ON_DS = mstrmojo.DocSelectorViewFactory.UC_ON_DS;

    
    function getEvent() {
        return {
            type: parseInt(this.type, 10),
            src: this.k,
            ck: this.ck,
            ctlKey: this.ckey,      
            tks: this.tks,
            include: this.include,
            disablePU: (parseInt(this.defn.subTp, 10) === _ST_UC_ON_DS)  
        };
    }

    
    mstrmojo.DocSelector = mstrmojo.declare(

        mstrmojo.Container,


        [mstrmojo._Formattable, mstrmojo._IsSelectorTarget],

        
        {
            scriptClass: 'mstrmojo.DocSelector',

            markupString: '<div id="{@id}" class="mstrmojo-DocSelector {@extCls}" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div class="filter" style="{@filterNodeCssText}"></div>' +
                                '<div class="wait" style="display:none;z-index:100; position:absolute; top:0px; left:0px; width:100%; height:100%"></div>' +
                                '<div class="content" style="{@contentNodeCssText}"></div>' +
                    '</div>',

            markupSlots: {
                filterNode: function () { return this.domNode.firstChild; },
                contentNode: function () { return this.domNode.lastChild; },
                dimNode: function () { return this.domNode.lastChild; },           
                containerNode: function () { return this.domNode.lastChild; },
                scrollboxNode: function () { return this.domNode.lastChild; },
                wIconNode: function () { return this.domNode.childNodes[1]; }
            },

            markupMethods: {
                onincludeChange: function () { mstrmojo.css.toggleClass(this.domNode, 'strikeout', !this.include); },
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onwaitChange: function () { this.wIconNode.style.display = ((this.wait) ? 'block' : 'none'); }
            },

            
            formatHandlers: {
                domNode: [ 'F', 'text-align', 'vertical-align', 'line-height', 'z-index', 'top', 'left' ],
                contentNode: [ 'width', 'B', 'P' ],
                filterNode: [ 'height', 'width', 'B', 'P', 'fx', 'background-color' ],
                item: [ 'color', 'font', 'text-decoration', 'text-align', 'line-height' ]
            },

            
            ckey: null,

            
            ck: null,

            
            tks: null,

            
            style: 0,

            
            selIdx: null,

            
            extCls: '',

            
            bGetElems: false,

            
            init: function init(props) {
                this._super(props);

                
                
                var s = this.node.defn.style;
                this.spm = (s === STYLES.METRIC_QUAL || s === STYLES.METRIC_SLIDER);
            },

            
            initControlInfo: function initControlInfo() {

                var node = this.node,
                    data = node.data,
                    defn = node.defn,
                    elements = data.elms,
                    currentSelections = data.ces,
                    style = defn.style;

                
                var defnProps = [ 'include', 'ckey', 'ck', 'tks', 'style', 'multi', 'showall' ];

                
                
                
                if (!this.bGetElems && parseInt(defn.subTp, 10) === _ST_UC_ON_DS && style !== STYLES.SEARCH_BOX) {
                    this._fetchAllElems();
                    elements = data.elms; 
                }

                
                if (style === STYLES.METRIC_QUAL || style === STYLES.METRIC_SLIDER) {
                    
                    defnProps = defnProps.concat([ 'srcid', 'srct' ]);

                    
                    this.qua = data.qt;
                    this.dt = data.dt;
                }

                
                this.type = defn.ct;

                
                var fmts = defn.fmts;
                if (fmts) {
                    var w = fmts.width;
                    if (!w || parseInt(w, 10) <= 0) {
                        
                        fmts.width = '95px';
                    }
                }

                
                $HASH.copyProps(defnProps, defn, this);

                
                var selectedIndices = this.selIdx = {},
                    multi = defn.multi;

                
                
























                
                if (this.include && multi && $ARR.find(currentSelections, 'v', ELEM_ALL_ID) > -1) {
                    
                    currentSelections = elements;
                }

                
                if (currentSelections) {
                    
                    $ARR.forEach(elements, function (el, idx) {
                        
                        if ($ARR.find(currentSelections, 'v', el.v) >= 0) {
                            
                            selectedIndices[idx] = true;
                        }
                    });
                }

            },

            
            resetFormatHandlers: function resetFormatHandlers() {
                this.formatHandlers = {
                    contentNode: [ 'RW' ]
                };
            },

            
            selectorControlChange: function selectorControlChange(widget) {
                
                var rEvt = getEvent.call(this),
                    elementSeparator = '\u001E',
                    elementIDs = [],
                    style = this.style,
                    showElementCount = this.defn.sec,
                    i;

                switch (style) {
                case STYLES.PULLDOWN:
                    var value = widget.value,
                        n = null;

                    if (widget.selectNode) {
                        var sn = widget.selectNode;
                        n = sn.options[sn.selectedIndex].text;
                    }


                    
                    rEvt.eid = value;
                    if (parseInt(rEvt.type, 10) === 1 && n !== null) {
                        rEvt.eid = rEvt.eid + ';' + n;   
                    }

                    
                    this.defn.set('cek', value);

                    
                    this.currSelValue = value;


                    if (showElementCount) {
                        
                        this.parent.set('count', _EH.buildElemsCountStr([value], this.node.data.elms));
                    }

                    break;

                case STYLES.SEARCH_BOX:
                    
                    $ARR.forEach(widget.items, function (item) {
                        
                        elementIDs.push(item.v + ';' + item.n);
                    });

                    
                    if (!elementIDs.length && this.showall) {
                        
                        elementIDs.push('u;');
                    }

                    
                    rEvt.eid = elementIDs.join(elementSeparator);

                    
                    if (showElementCount) {
                        
                        this.parent.set('count', _EH.buildElemsCountStr(elementIDs, this.node.data.elms));
                    }
                    break;

                case STYLES.METRIC_QUAL:
                case STYLES.METRIC_SLIDER:
                    if(this.srcid === undefined) {
                        return; 
                    }
                    var cs = [];

                    
                    $ARR.forEach(widget.cs, function (item) {
                        
                        cs.push(item.v);

                        if (rEvt.dtp === undefined) {
                            rEvt.dtp = item.dtp;
                        }
                    });

                    
                    if (cs.length) {
                        
                        rEvt.cs = cs.join(elementSeparator);
                    }

                    
                    var fInfo = mstrmojo.MCSUtil.getFuncInfo(widget.opId, widget.qua);
                    rEvt.f = widget.f = fInfo.f;
                    rEvt.ft = widget.ft = fInfo.ft;

                    
                    rEvt.include = widget.include = this.include;

                    
                    rEvt.ckey = this.ckey;
                    rEvt.srcid = this.srcid;
                    rEvt.srct = this.srct;

                    rEvt.unset = widget.unSet;
                    rEvt.onlyInclude = widget.onlyInclude;
                    rEvt.changeQual = widget.changeQual;
                    rEvt.qt = widget.qua;

                    
                    this.node.defn.set("cek", {
                        id: this.id,
                        f: widget.f,
                        ft: widget.ft,
                        cs: widget.cs,
                        qua: widget.qua,
                        include: widget.include
                    });
                    break;

                default:
                    var node = this.node,
                        elements = node.data.elms,
                        indices = widget.selectedIndices,
                        allIdx = widget.allIdx,
                        isAll = !!indices[allIdx],
                        eidts = [],     
                        inc = this.include;

                    
                    if (isAll) {
                        
                        elementIDs = [ elements[allIdx].v ];
                        eidts = [ elements[allIdx].v ];

                    } else {
                        if (indices[allIdx]) {
                            indices[allIdx] = false;
                        }

                        
                        var keyArr = $HASH.keyarray(indices, true).sort($ARR.numSorter),
                            sortedIndices  = {};

                        for (i in keyArr) {
                            sortedIndices[keyArr[i]] = indices[keyArr[i]];
                        }
                        indices = sortedIndices;

                        
                        $HASH.forEach(indices, function (item, idx) {
                            
                            if (item) {
                                
                                elementIDs.push(elements[idx].v);
                                eidts.push(elements[idx].v + ';' + elements[idx].n);
                            }
                        });
                    }

                    
                    rEvt.eid = ((parseInt(rEvt.type, 10) === 1) ? eidts : elementIDs).join(elementSeparator);

                    
                    var pos = mstrmojo.dom.position(widget.domNode, true);
                    if (pos) {
                        
                        rEvt.left = pos.x;
                        rEvt.top = pos.y;
                    }

                    
                    if (isAll && this.multi && inc) {
                        
                        $ARR.forEach(elements, function (elem) {
                            var v = elem.v;

                            
                            if (elementIDs[0] !== v) {
                                
                                elementIDs.push(v);
                            }
                        });
                    }

                    
                    node.defn.set('cek', elementIDs);

                    if (showElementCount && style !== STYLES.SCROLLER) {
                        
                        this.parent.set('count', _EH.buildElemsCountStr(elementIDs, elements));

                    }
                    break;
                }

                
                var me = this;
                window.setTimeout(function () {
                    me.slice(rEvt);
                }, 0);
            },

            showInfoWin: function showInfoWin(anchor) {
            	var m = this.model,
            		ifws = m.getTargetInfoWin(this.tks);

            	if (ifws && ifws.length) {
            		var horiz = this.defn.horiz,
            			actualAnchor = anchor || this.contentNode,
            			aPos = $D.position(actualAnchor), 
            			sPos = $D.position(this.contentNode), 
            			
            			
            			position = (horiz || this.defn.style == STYLES.SCROLLER) ? null : {x : sPos.x, y : aPos.y, w : sPos.w, h : aPos.h};


        			for (var i = 0;i < ifws.length; i++) {

            			m.showInfoWin(ifws[i],
            						  actualAnchor,
            						  horiz ? 'v' : 'h', false, $HASH.copy(position));
            		}
            	}
            },

            
            preBuildRendering: function preBuildRendering() {
                var ret = true,
                    style = this.node.defn.style,
                    formatHandlers = $HASH.clone(this.formatHandlers),
                    contentNodeHandler = formatHandlers.contentNode;

                
                
                
                
                if (contentNodeHandler) {
                    if ((style === STYLES.RADIO || style === STYLES.CHECKBOX) && formatHandlers.filterNode) {
                        contentNodeHandler.push('fx');
                        contentNodeHandler.push('background-color');

                        delete formatHandlers.filterNode;
                    }

                    if (style === STYLES.LIST) {
                        delete contentNodeHandler.height;
                    }

                    if (style === STYLES.SEARCH_BOX) {
                        
                        var domHandler = formatHandlers.domNode;

                        $ARR.removeItem(domHandler, 'color');

                        var idx = $ARR.indexOf(domHandler, 'F');
                        if (idx > -1) {
                            $ARR.removeIndices(domHandler, idx, 1);
                            domHandler.push('font');
                        }
                    }
                }

                
                this.formatHandlers = formatHandlers;

                
                ret = this._super();

                
                this.builder.selectorFactory.updateControlStyles(this);

                return ret;
            },

            
            postBuildRendering: function postBuildRendering() {
                var style = this.node.defn.style,
                    filterNodeStyle = this.filterNode.style,
                    contentNode = this.contentNode,
                    defn = this.node.defn;

                this._super();

                if (this.formatHandlers.filterNode) {
                    
                    var f = this.getFormats();

                    if (!f.width) {
                        filterNodeStyle.width = contentNode.clientWidth + 'px';
                    }

                    if (!f.height) {
                        filterNodeStyle.height = contentNode.clientHeight + 'px';
                        if (style === STYLES.METRIC_QUAL || style === STYLES.METRIC_SLIDER) {
                            this.updateHeight();
                        }
                    } else {
                        
                        if (style === STYLES.METRIC_QUAL) {
                            contentNode.style.height = f.height;
                        }
                    }

                } else {
                    
                    filterNodeStyle.display = 'none';
                }

                if (this.isInFilterPanel() && !this.isHorizFP()) {
                    this.domNode.style.width = this.contentNode.style.width = '100%';
                    if (this.formatHandlers.filterNode) {
                        this.filterNode.style.width = this.contentNode.style.width = '100%';
                    }
                    this.set('visible', parseInt(defn.ds, 10) === 0); 
                }

                
                this.model.attachEventListener('CGBMapChange', this.id, 'onCGBMapChange');

                
                this.builder.selectorFactory.attachTargetListeners(this);

                if($D.isAndroid && style === STYLES.SCROLLER) {
                    contentNode.style.overflow = 'visible';
                }

                return true;
            },

            _fetchAllElems: function _fetchAllElems() {
                var defn = this.node.defn,
                    data = this.node.data;

                var taskParams = {
                    taskId: 'browseElements',
                    styleName: 'MojoAttributeStyle',
                    attributeID: defn.srcid || '',
                    dataSourcesXML: defn.dsrc || '',
                    browseFlags: 1
                };

                var me = this,
                    callbacks = {
                        success: function (res) {
                            me.bGetElems = true;
                            me.set('wait', false);

                            if (res && res.es) {
                                data.elms = (defn.srcid) ? _EH.buildElemsTerseID(res.es, defn.srcid, true) : res.es;

                                var parent = me.parent,
                                    grandParent = parent && parent.parent;

                                if (data.ces && data.elms && data.elms.length > 0 && parent) {
                                    parent.set('count', _EH.buildElemsCountStr(data.ces, data.elms));
                                }

                                if (me.hasRendered) {
                                    me.refresh();
                                    if (me.isInFilterPanel()) {
                                        if (parent && parent.defn.ttl) { 
                                            parent.updateContentHeight();
                                        }
                                        if (grandParent && grandParent.refreshFP) {   
                                            grandParent.refreshFP();
                                        }
                                    }
                                }
                            }
                        },
                        failure: function (res) {
                            mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                        }
                    };

                this.set('wait', true);
                mstrmojo.xhr.request('POST', mstrConfig.taskURL, callbacks, taskParams, false, null, true);
            },

            
            updateHeight: function updateHeight() {
                this.contentNode.style.height = this.filterNode.style.height = this.content.getClientHeight() + 'px';

                var parent = this.parent;
                if (parent && (parent.defn.ttl !== undefined) &&
                		parent.updateContentHeight) {   
                    parent.updateContentHeight();
                }
            },

            
            onCGBMapChange: function onCGBMapChange(evt) {
                
                var cgbMap = evt.cgbMap;
                if (!cgbMap) {
                    return;
                }

                
                var tks = this.tks;

                
                $HASH.forEach(this.defn.cgb, function (key) {
                    
                    var targetKey = cgbMap[key];
                    if (targetKey && tks.indexOf(targetKey) < 0) {
                        
                        tks += '\u001E' + targetKey;
                    }
                });

                
                this.tks = tks;
            },

            
            update: function update(node) {
                
                this.node = node;

                var defn = this.node.defn,
                    style = defn.style,
                    elements = this.node.data.elms,
                    parent = this.parent,
                    isScroller = (style === STYLES.SCROLLER);

                
                if (isScroller && defn.multi) {
                    
                    var allIdx = $ARR.find(elements, 'v', ELEM_ALL_ID);
                    if (allIdx > -1) {
                        $ARR.removeIndices(elements, allIdx, 1);
                    }
                }

                
                if (defn.sec && !isScroller && !defn.sos) {
                    var ces = node.data.ces;
                    
                    if (parent && parent.count) {
                        
                        if (ces && elements && elements.length) {
                            
                            parent.set('count', _EH.buildElemsCountStr(ces, elements));
                        }
                    }
                }

                
                this.initControlInfo();

                
                var widget = this.content = this.builder.selectorFactory.newSelector(this);

                
                if (!widget) {
                    
                    this.set('visible', false);
                }
            },

            
            onincludeChange: function onincludeChange(evt) {
                this.node.defn.include = this.include = evt.value;

                if (this.style !== STYLES.METRIC_SLIDER) {
                    this.include = evt.value;

                    
                    var rEvt = getEvent.call(this);
                    rEvt.ckey = this.ckey;
                    this.slice(rEvt);
                }
            },

            
            slice: function slice(rEvt) {
                var m = this.model;
                if (this.isInFilterPanel()) {
                    var fp = this.getFilterPanel();
                    if (fp && !fp.defn.cas) {  
                        fp.bufferSlice(rEvt);
                        return;
                    }
                }

                m.slice(rEvt);
            },

            onquaChange: function onquaChange(evt) {
                this.node.data.qt = evt.value;
            },

            isInFilterPanel: function isInFilterPanel() {
                var parent = this.parent;
                return (parent && parent.isInFilterPanel && parent.isInFilterPanel()) || false;
            },

            isHorizFP: function isHorizFP() {
                var parent = this.parent;
                return (parent && parent.isHorizFP && parent.isHorizFP()) || false;
            },

            getFilterPanel: function getFilterPanel() {
                var parent = this.parent;
                return (parent && parent.getFilterPanel && parent.getFilterPanel()) || null;
            }

        }
    );

    
    if (!mstrmojo.dom.isIE) {
        
        var formatHandlers = mstrmojo.DocSelector.prototype.formatHandlers;
        formatHandlers.contentNode = formatHandlers.filterNode;
        delete formatHandlers.filterNode;
    }

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.VisTimeSeries");

    
    mstrmojo.DocVisTimeSeries = mstrmojo.declare(

        mstrmojo.VisTimeSeries,

        null,

        
        {
            scriptClass: 'mstrmojo.DocVisTimeSeries'
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.VisTimeSeries");

    
    mstrmojo.AndroidVisTimeSeries = mstrmojo.declare(

        mstrmojo.VisTimeSeries,

        null,
        
        {
            scriptClass: 'mstrmojo.AndroidVisTimeSeries'
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Vis",
        "mstrmojo.VisMicroChartTable",
        "mstrmojo.dom",
        "mstrmojo._TouchGestures",
        "mstrmojo._HasTouchScroller",
        "mstrmojo.VisTextTooltip",
        
        "mstrmojo.hash",
        "mstrmojo.color",
        "mstrmojo.css");

    var $CLR = mstrmojo.color,
        $CSS = mstrmojo.css,
        $HASH = mstrmojo.hash,
        $forEachHash = $HASH.forEach,
        $M = Math,
        $D = mstrmojo.dom;

    var zf = 1;

    
    var PAGE_COUNT = 5;

    var TRIANGLE_WIDTH = 30;

    
    var COMPACT = 0;
    var NORMAL = 1;
    var LARGE = 2;

    var DEFAULT_TH_CSS = "border:none;word-break:break-word;white-space:normal;";
    var DEFAULT_TD_CSS = "border:none;background:transparent;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-top:0px;padding-bottom:0px;";
    var TD_SELECTED_CSS = "border:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-top:0px;padding-bottom:0px;";
    var TH_SELECTED_CSS = "border:none;word-break:break-word;white-sapce:normal;";

    var NO_REPLACE = 2;
    var IN_REPLACE = 3;

    var TOP_Z_INDEX = 200;

    var DOCKED_HEADER = 0,
        OTHER_ROW = 1;

    var ROW_AXIS = 1, COL_AXIS = 2;
    var DRILLING_ACTION = 1, SELECTOR_ACTION = 2, HYPERLINK_ACTION = 4;
    var linkCount = 0;
    var attrCount = 0;
    var order = [];
    var ID_NAME = {};
    var METRIC_INDEX = {};
    var METRICS = [];
    var models = [];

    var LEFT_CHART_ROW = 'leftRow';
    var RIGHT_CHART_ROW = 'rightRow';

    
    var GFL = 1;
    
    var CGL = 0;

    var textAlign = { 
        
        left: "microchart-table-text-L",
        center: "microchart-table-text-M",
        right: "microchart-table-text-R"
    };

    function getParentBkgColor() {
        var parentNode = this.domNode.parentNode;
        while (parentNode) {
            var compStyle = mstrmojo.css.getComputedStyle(parentNode);
            var bkgColor = compStyle.backgroundColor;
            if (bkgColor) {
                if (bkgColor.indexOf('rgba') >= 0) {
                    var rgba = this.utils.rgbaStr2rgba(bkgColor);
                    if (rgba && rgba[4]) {
                        return rgba;
                    }
                } else if (bkgColor.indexOf('rgb') >= 0) {
                    var rgb = $CLR.rgbStr2rgb(bkgColor);
                    return rgb;
                }

            }
            parentNode = parentNode.parentNode;
        }

        bkgColor = this.model['background-color'];
        if (bkgColor) {
            return $CLR.hex2rgb(bkgColor);
        }

        
        return  [255, 255, 255];
    }

    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    function getUITheme() {
        var ct = this.model.vp.ct;
        if (!ct || ct == "") {
            
            ct = "0";
        }
        this.theme = parseInt(ct);

        if (this.theme == 0) {
            
            var rgb = getParentBkgColor.call(this);

            var opacity = this.otherProps.mfBkgOpacity;
            rgb = this.utils.getRGBWithOpacity(rgb, opacity);

            
            this.backgroundColor = this.utils.rgb2rgbStr(rgb);

            var brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
            if (brightness > 150) {
                this.theme = CUSTOM_LIGHT_THEME;
            } else {
                this.theme = CUSTOM_DARK_THEME;
            }
        } else if (this.theme == 1) {
            
            this.backgroundColor = '#333333';
        } else if (this.theme == 2) {
            
            this.backgroundColor = '#f9f9f9';
        }

        this.domNode.style.backgroundColor = this.backgroundColor;
    }

    function setDimensionWithDPI() {
        zf = this.utils.getScreenZoomFactor();

        var otherProps = this.otherProps;
        otherProps.mRowHeight = Math.round(zf * otherProps.mRowHeight);
        TRIANGLE_WIDTH = Math.round(zf * 36);

        this.dropShadowWidth = Math.round(zf * 7);

        paddingForSS = [Math.round(5 * zf), Math.round(8 * zf), Math.round(10 * zf)];
        colWidthForChart = [Math.round(100 * zf), Math.round(150 * zf), Math.round(200 * zf)];
        maxColWidthForAttr = [Math.round(120 * zf), Math.round(150 * zf), Math.round(180 * zf)];
        maxColWidthForMetric = [Math.round(100 * zf), Math.round(150 * zf), Math.round(200 * zf)];
        adjustWidthForColumnValue = [Math.round(20 * zf), Math.round(40 * zf), Math.round(80 * zf)];
    }

    function isScrollableElementTouched(touch) {
        if (this.enableSmoothScroll) {
            var touchPointOnWidget = this.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, this);

            var x = touchPointOnWidget.touchX,
                y = touchPointOnWidget.touchY;

            if (x < this.leftWidth) {
                return false;
            }
            return true;
        } else {
            return true;
        }
    }

    
    
    function setNodeCssText(node, cssText) {
        var height = node.style.height;
        var width = node.style.width;
        var textDecoration = node.style.textDecoration;
        var display = node.style.display;
        var fontSize = node.style.fontSize;
        var fontWeight = node.style.fontWeight;
        var paddingLeft = node.style.paddingLeft;
        var paddingRight = node.style.paddingRight;
        var boxShadow = node.style.boxShadow;
        node.style.cssText = cssText;
        node.style.height = height;
        node.style.width = width;
        node.style.textDecoration = textDecoration;
        if (display) {
            node.style.display = display;
        }
        if (fontSize) {
            node.style.fontSize = fontSize;
        }
        if (fontWeight) {
            node.style.fontWeight = fontWeight;
        }
        if (paddingLeft) {
            node.style.paddingLeft = paddingLeft;
        }
        if (paddingRight) {
            node.style.paddingRight = paddingRight;
        }
        if (boxShadow) {
            node.style.boxShadow = boxShadow;
        }
        
        
        
        
        
        
        
        
    }

    function init(w) {
        METRICS = [];
        METRIC_INDEX = {};
        ID_NAME = {};
        order = [];
        models = [];
        GFL = 1;
        CGL = 0;
        linkCount = 0;
        attrCount = 0;
    }

    function initProp() {
        
        
        
        
        
        
        var sparklineProps = this.sparklineProps = {};
        sparklineProps.mbShow = true;
        sparklineProps.mbAllPoints = false;
        sparklineProps.mbEndPoints = true;
        sparklineProps.mbRefLine = true;
        sparklineProps.mbRefArea = true;
        sparklineProps.mbAssMetric = true;
        sparklineProps.mbShowTooltip = true;
        sparklineProps.mwSeriesLineCol = "#333333";
        sparklineProps.mwRefLineCol = "#0066FF";
        sparklineProps.mwRefAreaCol = "#DEDEDE";
        sparklineProps.mstrHeader = "[Sparkline]";
        sparklineProps.mstrAssMetric = "";

        var barProps = this.barProps = {};
        barProps.mbShow = false;
        barProps.mbShowLegend = true;
        barProps.mbRefLine = true;
        barProps.mbShowTooltip = true;
        barProps.mwPosCol = "#66CC00";
        barProps.mwNegCol = "#FF0000";
        barProps.mwRefLineCol = "#0066FF";
        barProps.mstrHeader = "[Bar]";

        var bulletProps = this.bulletProps = {};
        bulletProps.mbShow = true;
        bulletProps.mbRefLine = true;
        bulletProps.mbRefBands = true;
        bulletProps.mbShowLegend = true;
        bulletProps.mbAssMetric = true;
        bulletProps.mbInvertAxis = false;
        bulletProps.mbShowTooltip = true;
        bulletProps.mfMinValue = 0;
        bulletProps.mwPosCol = "#000066";
        bulletProps.mwNegCol = "#FF0000";
        bulletProps.mwRefLineCol = "#0066FF";
        bulletProps.mwBand1 = "#999999";
        bulletProps.mwBand2 = "#BBBBBB";
        bulletProps.mwBand3 = "#DEDEDE";
        bulletProps.mstrHeader = "[Bullet]";
        bulletProps.mstrAssMetric = "";
        bulletProps.mstrBand1 = "Low";
        bulletProps.mstrBand2 = "Medium";
        bulletProps.mstrBand3 = "High";

        var otherProps = this.otherProps = {};
        otherProps.mfBkgOpacity = 1.0;
        otherProps.mnMetricsPerKPI = 1;
        otherProps.mbHideColHeaders = false;
        otherProps.mbHideTextColumns = false;
        otherProps.mbLockLayout = false;
        otherProps.mbShowForHiddenGraphs = true;
        otherProps.mbInheritFromGridGraph = false;
        otherProps.mbInSingleColumnMode = false;

        otherProps.mpColumnIDs = [];
        otherProps.mpColumnIDsInTreeMode = [];
        otherProps.mpColumnPositions = null;
        otherProps.mpColumnWidths = null;
        otherProps.mpSortKey = null;

        otherProps.mbSortDescend = true;

        
        otherProps.mRowHeight = 36;
        
        
        
        
        

    }

    function isTouchedOnWidget(touch) {

        if (!touch) {
            return false;
        }
        var me = this;

        var pos = mstrmojo.dom.position(this.domNode);

        
        
        

        var x = touch.pageX - pos.x,
            y = touch.pageY - pos.y;

        if ((x > 0 && x < me.getWidth()) && (y > 0 && y < me.getHeight())) {
            return true;
        }
        return false;
    }

    
    function convertToColor(intString) {
        var colorString = parseInt(intString).toString(16);
        var len = colorString.length;
        for (var i = len; i < 6; i++) {
            colorString = "0" + colorString;
        }
        colorString = "#" + colorString;
        return colorString;
    }

    function buildNonTreeRows() {
        this.rows = [];
        for (var i = 0; i < models.length; i++) {
            this.rows[i] = {model: models[i],
                rowIdx: i,
                selected: {},
                rowRef: {}};
        }
    }

    function isSubTotal(row, rowTitles) {
        for (var i = 0; i < row.length; i++) {
            if (row[i].etk != undefined && row[i].etk < 0) {
                return true;
            }
        }
        return false;
    }

    
    function getAttrIdxArray(w) {

        var attrIDArray = w.attrIDArray;

        var m = w.model, gts = m.gts, rows = gts.row;
        var id = rows[0].id;

        attrIDArray[0] = id;
        for (var i = 1; i < rows.length; i++) {
            if (id == rows[i].id || id == rows[i].id + ":CG") {
                
                
            } else {
                
                id = rows[i].id;
                attrIDArray[i] = id;
            }
        }
    }

    
    function getTreeNode(tree, treePath) {
        var treePathArray = treePath.split("_");
        var treeNode = tree;
        for (var i = 0; i < treePathArray.length; i++) {
            var idx = treePathArray[i];
            treeNode = treeNode.childrenTreeNodeList[idx];
        }
        return treeNode;
    }

    function getPreSiblingTreeNode(tree, treePath) {
        var treePathArray = treePath.split("_");
        var lowestLevelIdx = treePathArray[treePathArray.length - 1];
        if (lowestLevelIdx > 0) {
            
            treePathArray[treePathArray.length - 1] = lowestLevelIdx - 1;
            var treeNode = tree;
            for (var i = 0; i < treePathArray.length; i++) {
                var idx = treePathArray[i];
                treeNode = treeNode.childrenTreeNodeList[idx];
            }
            return treeNode;
        } else {
            return null;
        }
        return null;
    }

    function getParentTreeNodeAtLevel(tree, treePath, level) {
        var treePathArray = treePath.split("_");
        var treeNode = tree;
        for (var i = 0; i <= level; i++) {
            var idx = treePathArray[i];
            treeNode = treeNode.childrenTreeNodeList[idx];
        }
        return treeNode;
    }

    function getBoolValue(value) {
        if (value === true || value === "true") {
            return true;
        }
        return false;
    }

    
    function setNeedExpandToLevel(tree, level) {
        if (!tree) {
            return;
        }

        if (tree.level <= level) {
            tree.needExpand = true;
        } else {
            tree.needExpand = false;
        }

        var treeNodeList = tree.childrenTreeNodeList;

        for (var j = 0; j < treeNodeList.length; j++) {
            setNeedExpandToLevel(treeNodeList[j], level);
        }

    }

    function initTree() {

        this.tree = {};
        this.tree.childrenTreeNodeList = [];
        this.tree.needExpand = true;
        
        this.tree.treePath = "";
        this.tree.level = -1;

        this.attrIDArray = [];

        
        this.currSelectedObj = [];
        this.lastSelectedObj = [];

        this.initDockedHeadersDone = false;
    }

    
    
    
    
    
    
    

    
    function compareTreePath(src, des) {
        var count = src.length;
        if (des.length != count) {
            return false;
        }
        for (var i = 0; i < count - 1; i++) {
            if (src[i] != des[i].idx) {
                return false;
            }
        }
        return true;
    }

    
    function convertDataToTreeModels(AttrIndexes) {
        var treeNodeList = this.tree.childrenTreeNodeList,
            model = this.model,
            rhs = model.ghs.rhs,
            rowTitles = model.gts.row,
            gvs = model.gvs,
            expsTree = model.vp.exps && model.vp.exps.tree;
        var allExpanded = expsTree && getBoolValue(expsTree.allExpanded);
        
        var mcStatus = this.mcStatus;
        var expandToLevel = -1;
        var expandedEntryArray = mcStatus ? mcStatus.expandedEntryArray : expsTree && expsTree.expandedEntry;

        this.attrIDArray = [];

        var attrIdxArray = this.attrMapIdx;

        
        getAttrIdxArray(this);

        var rowAttrCount = rhs.items && rhs.items[0] && rhs.items[0].items
            && rhs.items[0].items.length;
        
        var levelCount = attrIdxArray.length - 1;
        this.maxTreeLevel = levelCount - 2;

        expandToLevel = mcStatus ? mcStatus.expandToLevel : allExpanded ? this.maxTreeLevel - 1 : -1;

        var lastTreePath = [];
        
        for (var i = 0; i < rowAttrCount; i++) {
            lastTreePath.push(-1);
        }
        var modelIdx = -1;
        var gridRowCount = rhs.items.length;
        if (this.mcStatus && this.mcStatus.currSelectedObj) {
            this.currSelectedObj = this.mcStatus.currSelectedObj;
        }
        for (var i = 0; i < gridRowCount; i++) {
            var currRow = rhs.items[i].items;
            var sameAsLastRow = compareTreePath(lastTreePath, currRow);
            if (!sameAsLastRow) {
                modelIdx++;
            } else {
                continue;
            }

            
            for (var j = 0; j < levelCount - 1; j++) {
                var attrIdx = attrIdxArray[j];
                var currSelectedNodeID = this.currSelectedObj[j];
                if (lastTreePath[attrIdx] != currRow[attrIdx].idx) {
                    var isSubtotal = isSubTotal(currRow);
                    
                    var addToNodeList = treeNodeList;
                    var lastSameNode = null;
                    
                    var treePath = "";
                    for (var k = 1; k <= j; k++) {
                        var treeNodeIdx = addToNodeList.length - 1;
                        if (k == j) {
                            lastSameNode = addToNodeList[treeNodeIdx];
                        }
                        addToNodeList = addToNodeList[treeNodeIdx].childrenTreeNodeList
                        treePath += treeNodeIdx;
                        treePath += "_";
                    }

                    if (isSubtotal && lastSameNode) {
                        lastSameNode.model = models[modelIdx];
                        break;
                    } else {

                        
                        var newTreeNode = {};
                        newTreeNode.es = [];
                        
                        newTreeNode.es.push(rowTitles[j].es[currRow[attrIdx].idx]);
                        
                        var elem = rowTitles[j].es[currRow[attrIdx].idx];
                        newTreeNode.id = elem.id;
                        newTreeNode.n = elem.n;

                        newTreeNode.model = models[modelIdx];

                        newTreeNode.selected = false;
                        newTreeNode.childrenTreeNodeList = [];
                        
                        newTreeNode.attrElemIdx = currRow[attrIdx].idx;
                        newTreeNode.isLeaf = (j == this.maxTreeLevel);
                        newTreeNode.level = j;

                        var preSiblingCount = addToNodeList.length;
                        newTreeNode.preSiblingCount = preSiblingCount;
                        newTreeNode.preSibling = preSiblingCount > 0 ? addToNodeList[preSiblingCount - 1] : null;

                        treePath += addToNodeList.length;
                        newTreeNode.treePath = treePath;

                        
                        

                        addToNodeList.push(newTreeNode);

                        
                        newTreeNode.needExpand = j <= expandToLevel ? true : false;

                        
                        if (currSelectedNodeID == newTreeNode.id) {
                            this.currSelectedObj[j] = newTreeNode;
                        }

                    }
                }
            }
            
            for (var j = 0; j < rowAttrCount; j++) {
                lastTreePath[j] = currRow[j].idx;
            }
        }

        if (expandToLevel < 0 && expandedEntryArray) {
            

            for (var i = 0; i < expandedEntryArray.length; i++) {
                var expandedEntry = expandedEntryArray[i];
                var treeNode = this.tree;
                for (var j = 0; j < expandedEntry.length; j++) {
                    var eid = expandedEntry[j].element;
                    var idx = mstrmojo.array.find(
                        treeNode.childrenTreeNodeList, 'id', eid);
                    if (idx < 0) {
                        break;
                    }
                    treeNode = treeNode.childrenTreeNodeList[idx];
                }
                treeNode.needExpand = true;
            }
        }

        
        var preOrderTreeNodeQueue = [];
        preOrderTreeNodeQueue.push(this.tree);
        var treeNode = null;
        
        while (preOrderTreeNodeQueue.length > 0) {
            treeNode = preOrderTreeNodeQueue.pop();
            var treeNodeList = treeNode.childrenTreeNodeList;
            var childrenCount = treeNodeList.length;
            for (var i = childrenCount - 1; i >= 0; i--) {
                treeNode = treeNodeList[i];
                preOrderTreeNodeQueue.push(treeNode);
                treeNode.postSiblingCount = childrenCount - treeNode.preSiblingCount;
            }

        }

    }

    
    var ATTR_NAME = 0,
        METRIC_NAME = 1,
        METRIC_VALUE = 2,
        CHART = 3,
        TREE_TRIANGLE = 4;
    DROP_SHADOW = 5;

    function scaleColumnWidthToFitWidget(colInfos, fitToWidth) {
        var colLen = colInfos.length;
        var totalWidth = 0;
        for (var i = 0; i < colLen; i++) {
            if (colInfos[i].type == TREE_TRIANGLE) {
                
                fitToWidth -= TRIANGLE_WIDTH;
            } else {
                totalWidth += colInfos[i].colWidth;
            }
        }

        var scaleRatio = fitToWidth / totalWidth;

        for (var i = 0; i < colLen; i++) {
            if (colInfos[i].type == TREE_TRIANGLE) {
                colInfos[i].colWidth = TRIANGLE_WIDTH;
            } else {
                colInfos[i].colWidth = Math.round(colInfos[i].colWidth * scaleRatio);
            }
        }

        return scaleRatio;
    }

    function getContentOffsetWidth(rows, rowIdx, colIdx) {
        var rowInfo = rows[rowIdx],
            curM = rowInfo.model,
            elms = curM.elms,
            treeNode = rowInfo.treeNode,
            colInfos = this.colInfos,
            rowIdx = rowInfo.rowIdx,
            colCount = colInfos.length,
            colInfo = colInfos[colIdx],
            colIdx = colInfo.colIdx;

        if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME) {
            if (this.isTreeMode) {
                var attrName = "";
                for (var k = 0; k < treeNode.es.length; k++) {
                    attrName += treeNode.es[k].n;
                }
                
                if (attrName.indexOf("&lt;") >= 0) {
                    attrName = attrName.replace(/&lt;/g, "<");
                    attrName = attrName.replace(/&gt;/g, ">");
                }

                return this.getTextWidth(attrName, colInfo.valueCssClass, null, null, null, treeNode.level == 0 ? true : false);

            } else {
                attr = elms[colInfo.order];
                var attrName = attr ? attr.n : "";
                
                if (attrName.indexOf("&lt;") >= 0) {
                    attrName = attrName.replace(/&lt;/g, "<");
                    attrName = attrName.replace(/&gt;/g, ">");
                }
                return this.getTextWidth(attrName, colInfo.valueCssClass, null, null, null, false);

            }

        }

        if (colInfo.type == METRIC_VALUE) {
            var metricIdx = -1;
            var idx = -1;

            if (this.isKPI) {
                
                idx = parseInt(colInfo.order) % this.otherProps.mnMetricsPerKPI;

                
                var metricIdx = rowInfo.model.metricIdx + idx;
            } else {
                if (colInfo.type == METRIC_VALUE) {
                    metricIdx = parseInt(colInfo.order);
                    idx = metricIdx;
                }
            }

            var innerHTML = "";
            var cssClass = "";

            if (curM.refv[idx].ti === undefined) { 
                if (curM.refv[idx].ts === 4) { 
                    innerHTML = "<img src='" + curM.refv[idx].v + "'/>";
                } else {
                    innerHTML = curM.refv[idx].v;
                }
            } else { 
                try { 
                    
                    var model = this.model;
                    var th = model.th['' + metricIdx];
                    var ti = curM.refv[idx].ti;

                    if (curM.refv[idx].ty === 4) { 
                        var path;
                        if (th[ti] && th[ti].n) {
                            path = th[ti].n;
                        } else {
                            path = curM.refv[idx].v;
                        }
                        if (path.indexOf(":") >= 0) { 
                            
                        } else { 
                            var baseURL;
                            try {
                                baseURL = mstrApp.getConfiguration().getHostUrlByProject(mstrApp.getCurrentProjectId());
                            } catch (err) {
                                baseURL = "";
                            }
                            path = baseURL + path;
                        }
                        innerHTML = "<img src='" + path + "'/>";
                    } else {
                        if (th[ti] && th[ti].n && th[ti].cni !== undefined) { 
                            innerHTML = th[ti].n;
                        } else {
                            innerHTML = curM.refv[idx].v;
                        }
                        
                        
                    }
                    cssClass = model.css[th[ti].cni].n;
                } catch (err) {
                    if (!innerHTML) { 
                        innerHTML = curM.refv[idx].v;
                    }
                }
            }

            var className = "";
            if (cssClass) {
                className = colInfo.valueCssClass + " " + cssClass;
            } else if (this.valueCssClass) {
                className = colInfo.valueCssClass + " " + this.valueCssClass;
            } else {
                className = colInfo.valueCssClass;
            }

            return this.getTextWidth(innerHTML, className, null, null, null, this.isTreeMode && treeNode.level == 0 ? true : false);

        }

        return 0;

    }

    
    var paddingForSS = [5, 8, 10];
    var colWidthForChart = [100, 150, 200];
    var maxColWidthForAttr = [120, 150, 180];
    var maxColWidthForMetric = [100, 150, 200];
    var adjustWidthForColumnValue = [20, 40, 80];

    function updateColumnWidth() {
        var colInfos = this.colInfos,
            width = this.getWidth();

        if (this.enableSmoothScroll) {
            
            var rows = this.isTreeMode ? getTreeNodeRows.call(this, true, 50) : this.rows;
            var rowCount = Math.min(rows.length, 50);
            var mcs = this.metricColumnsSpacing;
            var paddingWidth = paddingForSS[mcs];

            for (var j = 0; j < this.colInfos.length; j++) {
                var colInfo = this.colInfos[j];

                if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME || colInfo.type == METRIC_VALUE) {

                    
                    var maxColumnValueW = 0;
                    for (var i = 0; i < rowCount; i++) {
                        var columnW = getContentOffsetWidth.call(this, rows, i, j);
                        if (columnW > maxColumnValueW) {
                            maxColumnValueW = columnW;
                        }
                    }

                    
                    var headerStr = colInfo.title;
                    var midPos = Math.round(headerStr.length / 2);

                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    var leftHalf = headerStr.slice(0, midPos);
                    var rightHalf = headerStr.slice(midPos);

                    var leftW = this.getTextWidth(leftHalf, colInfo.headerCssClass, null, null, null, true, false);
                    var rightW = this.getTextWidth(rightHalf, colInfo.headerCssClass, null, null, null, true, false);
                    var maxColumnHeaderW = Math.max(leftW, rightW);

                    var finalColumnW = 0;
                    if (maxColumnValueW > maxColumnHeaderW) {
                        finalColumnW = Math.min(maxColumnValueW, maxColWidthForMetric[mcs]);
                    } else {
                        finalColumnW = Math.min(maxColumnValueW + adjustWidthForColumnValue[mcs], maxColumnHeaderW, 100);
                    }

                    colInfo.colWidth = Math.round(finalColumnW + paddingWidth);
                    colInfo.padding.l = Math.floor(paddingWidth / 2);
                    colInfo.padding.r = Math.ceil(paddingWidth / 2);
                } else if (colInfo.type == TREE_TRIANGLE) {
                    colInfo.colWidth = Math.round(TRIANGLE_WIDTH);
                } else if (colInfo.type == DROP_SHADOW) {
                    colInfo.colWidth = Math.round(this.dropShadowWidth);
                } else {
                    
                    colInfo.colWidth = Math.round(colWidthForChart[mcs] + paddingWidth);
                    colInfo.padding.l = Math.floor(paddingWidth / 2);
                    colInfo.padding.r = Math.ceil(paddingWidth / 2);
                }
            }

            
            this.leftWidth = 0;
            for (var i = 0; i < this.attrColumnCount; i++) {
                this.leftWidth += colInfos[i].colWidth;
            }

            this.rightWidth = 0;
            var maxMetricWidth = 0;
            for (var i = this.attrColumnCount; i < colInfos.length; i++) {
                console.log(i + ": " + colInfos[i].colWidth);
                this.rightWidth += colInfos[i].colWidth;
                if (colInfos[i].colWidth > maxMetricWidth) {
                    maxMetricWidth = colInfos[i].colWidth;
                }
            }

            if (this.leftWidth + this.rightWidth < this.getWidth()) {
                
                var scaleRatio = scaleColumnWidthToFitWidget(this.colInfos, this.getWidth());

                this.dropShadowDiv.style.display = "none";
                this.enableSmoothScroll = false;
                this.scrollerConfig.hScroll = false;

                this.leftWidth = this.getWidth();
                this.rightWidth = 0;
                this.leftChart.style.width = this.getWidth() + 'px';
            } else {
                
                if (this.attrColumnCount >= 0) {
                    
                    var spaceCol = {order: "",
                        type: DROP_SHADOW,
                        title: "",
                        titleAlign: textAlign.center,
                        colWidth: this.dropShadowWidth,
                        padding: {},
                        headerCssClass: this.headerCssClass,
                        valueCssClass: "",
                        colIdx: this.colInfos.length};
                    this.colInfos.splice(this.attrColumnCount, 0, spaceCol);
                    this.rightWidth += this.dropShadowWidth;
                }

                
                var requiredSpace = this.leftWidth + maxMetricWidth + this.dropShadowWidth;
                if (this.getWidth() < requiredSpace) {
                    var rightContainWidth = Math.min(maxMetricWidth + this.dropShadowWidth, 0.75 * this.getWidth());
                    this.leftWidth = this.getWidth() - rightContainWidth;

                    
                    var attrWidth = this.treeColumnIdx > -1 ? (this.leftWidth - TRIANGLE_WIDTH) / (this.attrColumnCount - 1) : this.leftWidth / this.attrColumnCount;
                    for (var i = 0; i < this.attrColumnCount; i++) {
                        colInfos[i].colWidth = colInfos[i].type == TREE_TRIANGLE ? TRIANGLE_WIDTH : attrWidth;
                    }

                }

                this.dropShadowDiv.style.display = "block";
                this.scrollerConfig.hScroll = true;

                this.leftChart.style.width = this.leftWidth + 'px';
                this.rightChart.style.width = this.rightWidth + 'px';
                this.itemsContainerNode.style.width = ( this.getWidth() - this.leftWidth ) + 'px';
                this.itemsContainerNode.style.left = this.leftWidth + 'px';
            }

            for (var i = 0; i < this.colInfos.length; i++) {
                
                this.colInfos[i].colIdx = i;

                if (this.colInfos[i].type == TREE_TRIANGLE) {
                    this.treeColumnIdx = i;
                }
            }

        } else {
            
            var colLen = colInfos.length;

            if (this.otherProps.mpColumnWidths.length > 0) {
                
                scaleColumnWidthToFitWidget(this.colInfos, width);
            } else {
                if (this.treeColumnIdx > -1) {
                    colLen--;
                    width -= TRIANGLE_WIDTH;
                }
                var chWidth = Math.round(width / colLen);
                for (var i = 0; i < colInfos.length; i++) {
                    if (colInfos[i].type == TREE_TRIANGLE) {
                        colInfos[i].colWidth = TRIANGLE_WIDTH;
                    } else {
                        colInfos[i].colWidth = chWidth;
                    }

                }
            }
        }

    }

    
    function buildColInfos(metricColIdx) {
        var m = this.model,
            rows = m.gts.row,
            cols = m.gts.col,
            mes = cols[metricColIdx].es,
            propValue = m.vp ? m.vp : {},
            width = this.getWidth(),
            otherProps = this.otherProps;

        otherProps.mpColumnWidths = propValue.cw ? propValue.cw.split(",") :
            (propValue.tcw ? propValue.tcw.split(",") : [] );

        var columnWidths = otherProps.mpColumnWidths;
        
        if (columnWidths.length != order.length) {
            columnWidths = [];
            otherProps.mpColumnWidths = [];
        }

        this.colInfos = [];

        this.showGauge = false;
        for (var i = 0; i < order.length; i++) {
            if (order[i] == "GaugeChart") {
                
                
                this.showGauge = true;
            }
        }

        for (var i = 0, colInfoIdx = 0; i < order.length; i++) {
            var orderID = order[i];

            var colInfo = {order: orderID,
                colWidth: 0,
                padding: {},
                headerCssClass: " ",
                valueCssClass: " "};

            if (orderID == "LineChart") {
                colInfo.type = CHART;
                colInfo.title = this.sparklineProps.mstrHeader;
                colInfo.titleAlign = textAlign.center;
                colInfo.padding.l = Math.round(3 * zf);
                colInfo.padding.r = Math.round(3 * zf);
            } else if (orderID == "BarChart") {
                colInfo.type = CHART;
                colInfo.title = this.barProps.mstrHeader;
                colInfo.titleAlign = textAlign.center;
                colInfo.padding.l = Math.round(3 * zf);
                colInfo.padding.r = Math.round(3 * zf);
            } else if (orderID == "GaugeChart") {
                colInfo.type = CHART;
                colInfo.title = this.bulletProps.mstrHeader;
                colInfo.titleAlign = textAlign.center;
                colInfo.padding.l = Math.round(3 * zf);
                colInfo.padding.r = Math.round(3 * zf);
            } else if (orderID == 'Metric') {
                if (otherProps.mbHideTextColumns) {
                    
                    
                    this.treeColumnIdx = -1;
                    continue;
                }
                colInfo.type = METRIC_NAME;
                colInfo.title = mstrmojo.desc(1158, 'Metrics');
                colInfo.titleAlign = textAlign.left;
                colInfo.valueCssClass += " " + this.valueCssClass;
                if (cols[metricColIdx].lm && cols[metricColIdx].lm.length > 0) {
                    colInfo.lm = cols[metricColIdx];
                    linkCount++;
                }
            } else if (orderID != parseInt(orderID)) {
                
                if (otherProps.mbHideTextColumns) {
                    
                    
                    this.treeColumnIdx = -1;
                    continue;
                }

                
                
                colInfo.associateAttr = [];

                if (this.isTreeMode) {
                    
                    
                    this.treeColumnIdx = colInfoIdx;
                    this.colInfos[colInfoIdx] = {order: orderID,
                        type: TREE_TRIANGLE,
                        title: "",
                        titleAlign: textAlign.center,
                        colWidth: 0,
                        padding: {},
                        headerCssClass: this.headerCssClass,
                        valueCssClass: "",
                        colIdx: this.treeColumnIdx};
                    

                    colInfo.associateAttr.push(colInfoIdx);

                    colInfoIdx++;
                }
                colInfo.type = ATTR_NAME;
                colInfo.title = ID_NAME[orderID];
                colInfo.titleAlign = textAlign.left;
                colInfo.valueCssClass += " " + this.valueCssClass;

                for (var j = 0; j < rows.length; j++) {
                    if (orderID.split(":")[0] == rows[j].id) {
                        

                        if (otherProps.mbInheritFromGridGraph && rows[j].cni !== undefined && m.css.length > rows[j].cni) {
                            colInfo.titleAlign = m.css[rows[j].cni].n;
                        }

                        var isFirstAttrForm = (orderID == rows[j].id + ":" + rows[j].fid);

                        if (isFirstAttrForm) {
                            
                            attrCount++;
                        }

                        if (rows[j].lm && rows[j].lm.length > 0 && rows[j].lm[0].links) {
                            colInfo.lm = rows[j];
                            if (isFirstAttrForm) {
                                linkCount++;
                            }

                        }

                        
                        var fs = rows[j].fs;
                        for (var q = 0; q < fs.length; q++) {
                            var attrID = rows[j].id + ":" + fs[q].id;
                            if (attrID == orderID) {
                                
                                continue;
                            } else {
                                
                                
                                for (var n = 0; n < order.length; n++) {
                                    if (order[n] == attrID) {
                                        colInfo.associateAttr.push(n);
                                        break;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
            } else {
                
                colInfo.type = METRIC_VALUE;
                var index = parseInt(orderID);
                if (index >= mes.length) {
                    continue;
                }
                if (otherProps.mbInheritFromGridGraph && mes[index].cni !== undefined && m.css.length > mes[index].cni) {
                    colInfo.titleAlign = m.css[mes[index].cni].n;
                } else {
                    colInfo.titleAlign = textAlign.right; 
                }
                if (orderID == "0") {
                    if (this.sparklineProps.mstrAssMetric) {
                        
                        colInfo.title = this.sparklineProps.mstrAssMetric;
                    } else if (this.isKPI) {
                        colInfo.title = "";
                    } else {
                        colInfo.title = mes[index].n;
                    }
                } else if (orderID == "2") {
                    if (this.bulletProps.mstrAssMetric) {
                        
                        colInfo.title = this.bulletProps.mstrAssMetric;
                    } else if (this.isKPI && this.showGauge) {
                        colInfo.title = "";
                    } else {
                        colInfo.title = mes[index].n;
                    }
                } else {
                    colInfo.title = mes[index].n;
                }
                if (cols[metricColIdx].lm[index].links) {
                    colInfo.lm = cols[metricColIdx];
                    linkCount++;
                }

            }

            colInfo.valueCssClass += " microchart-table-text " + colInfo.titleAlign;
            colInfo.headerCssClass += " microchart-table-text " + colInfo.titleAlign + " " + this.headerCssClass;

            if (columnWidths.length > 0) {
                colInfo.colWidth = parseFloat(columnWidths[i]);
            }
            colInfo.colIdx = colInfoIdx;
            this.colInfos[colInfoIdx++] = colInfo;
        }

        if (order.length == 0) {
            colInfos[0].title = rows[0].n;
            for (var i = 1; i < rows.length - GFL; i++) {
                colInfos[i].title = rows[i].n;
            }
        }

        
        if (this.enableSmoothScroll) {
            var belongToLeft = function (type) {
                switch (type) {
                case ATTR_NAME:
                    return -1;
                case TREE_TRIANGLE:
                    return -1;
                case METRIC_NAME:
                    return -1;
                default:
                    return 1;
                }
            }

            var sortFunc = function (colInfo1, colInfo2) {
                if (belongToLeft(colInfo1.type) * belongToLeft(colInfo2.type) > 0) {
                    
                    return colInfo1.colIdx < colInfo2.colIdx ? -1 : 1;
                } else {
                    return belongToLeft(colInfo1.type);
                }
            }

            this.colInfos.sort(sortFunc);

            for (var i = 0; i < this.colInfos.length; i++) {
                if (belongToLeft(this.colInfos[i].type) > 0) {
                    
                    this.attrColumnCount = i;
                    break;
                }
            }

        }

    }

    function convertDataToModels() {
        init(this);

        var m = this.model,
            cols = m.gts.col,
            metricL = m.gts.col[0].es.length,
            rows = m.gts.row,
            rowL = rows.length,
            rl = m.gvs.items.length,
            propValue = m.vp ? m.vp : {};

        if (rowL === 0 || metricL === 0 || cols.length > 1) {
            var errmsg = "The widget requires at least two attributes on row axis and one metrics in column axis OR exactly one attribute on row axis and at least one metric on column axis for KPI List mode.";
            m.err = mstrmojo.desc(8424, errmsg);
            return;
        }

        
        if (this.isTreeMode) {
            var row = this.model.gts.row;
            if (row.length < 3) {
                this.isTreeMode = false;
            }

        }

        var len = rows.length;
        var gfid = rows[len - 1].id;
        len = len - 2;
        while (len >= 0) {
            if (gfid == rows[len].id) {
                GFL++;
                len--;
            } else {
                break;
            }
        }

        if (rowL <= GFL) {
            this.isKPI = true;
        }
        for (var i = 0; i < rows.length; i++) {
            if (rows[i].otp == 1) {
                
                rows[i].otp = -1;
                while (++i < rows.length && rows[i].otp == 1) {
                    rows[i].id += ":CG";
                    rows[i].n = " ";
                    rows[i].otp = -1;
                }
            }
        }

        for (var i = 0; i < rows.length; i++) {
            if (rows[i].fs && rows[i].fs.length > 0) {
                for (var q = 0; q < rows[i].fs.length; q++) {
                    
                    if (q == 0) {
                        ID_NAME[rows[i].id + ":" + rows[i].fs[q].id] = rows[i].n;
                    } else {
                        ID_NAME[rows[i].id + ":" + rows[i].fs[q].id] = " ";
                    }
                }
            }
            if (rows[i].fid && rows[i].fid.length > 0) {
                
                
                
                var headerTitle;
                headerTitle = rows[i].n; 
                ID_NAME[rows[i].id] = headerTitle;
                ID_NAME[rows[i].id + ":" + rows[i].fid] = headerTitle;
            } else {
                ID_NAME[rows[i].id] = rows[i].n;
            }
        }

        
        var metricIdx = -1;
        for (var i = 0; i < cols.length; i++) {
            if (cols[i].n = "Metrics") {
                metricIdx = i;
                var mes = cols[i].es;
                for (var j = 0; j < mes.length; j++) {
                    ID_NAME[mes[j].oid] = mes[j].n;
                    METRIC_INDEX[mes[j].n] = j;
                    METRIC_INDEX[mes[j].oid] = j;
                    METRICS[j] = mes[j].n;
                }
            }
        }

        var orderValid = true;
        if (!propValue.co && !propValue.tco) {
            orderValid = false;
        } else {
            order = propValue.tco ? propValue.tco.split(",") : propValue.co.split(",");
            orderValid = processAndCheckOrderValid.call(this);
            if (!orderValid) {
                
                propValue.cw = null;
                propValue.tcw = null;
            }
        }

        if (!orderValid) {
            order = [];

            if (!this.isKPI) {
                createNonKPIDefaultCol.call(this);
            } else {
                createKPIDefaultCol.call(this);

            }
        }

        var otherProps = this.otherProps;
        
        

        if (otherProps.mpSortKey && otherProps.mpSortKey.length > 0) {
            var tempSortKey = "";
            for (var i = 0; i < otherProps.mpSortKey.length; i++) {
                if (otherProps.mpSortKey[i] == '_') {
                    break;
                }
                tempSortKey += otherProps.mpSortKey[i];
            }

            var mIdx = METRIC_INDEX[tempSortKey];
            if (mIdx >= 0) {
                
                otherProps.mpSortKey = mIdx
            } else {
                
                for (var id in ID_NAME) {
                    if (ID_NAME[id] == tempSortKey) {
                        otherProps.mpSortKey = id;
                        break;
                    }
                }

                if (!ID_NAME[otherProps.mpSortKey]) {
                    
                    otherProps.mpSortKey = null;
                }
            }
        } else {
            otherProps.mpSortKey = null;
        }

        
        
        if (otherProps.mbInheritFromGridGraph && (this.theme == CUSTOM_DARK_THEME || this.theme == CUSTOM_LIGHT_THEME)) {
            try {
                var headerIndex = m.headercni ? m.headercni : 0;
                var valueIndex = m.valuecni ? m.valuecni : (m.css.length - 1);

                var getCssClass = function (name) {
                    if (name) {
                        
                        return name;
                    }

                    return "";

                }

                this.headerCssClass = getCssClass(m.css[headerIndex].n);
                this.valueCssClass = getCssClass(m.css[valueIndex].n);

                
                if (this.valueCssClass && this.valueCssClass.length > 0) {
                    var textSpan = this.textSpan;
                    textSpan.className = this.valueCssClass;
                    textSpan.style.font = "";

                    this.fontSize = mstrmojo.css.getStyleValue(textSpan, 'fontSize');

                }

                
                var fontHeight = this.getTextHeight("a", this.valueCssClass, true);
                if (fontHeight > otherProps.mRowHeight) {
                    otherProps.mRowHeight = fontHeight;
                }
            } catch (err) {
                
            }
        }

        
        var applyLocale = function (proOwner, proName, dftStr, hasBracket, descID) {
            var compareStr = dftStr;
            var returnStr;
            if (hasBracket) {
                compareStr = "[" + dftStr + "]";
            }

            if (proOwner[proName] === compareStr) {
                
                returnStr = mstrmojo.desc(descID, dftStr);
                if (hasBracket) {
                    returnStr = "[" + returnStr + "]";
                }
                proOwner[proName] = returnStr;
            }
        };

        buildColInfos.call(this, metricIdx);

        if (!this.isKPI) {
            convertAttributeDrivenData(this);
        } else {

            convert(this);
        }

        
        var kpi = otherProps.mnMetricsPerKPI;
        var m = this.model;

        if (this.isKPI && metricL < kpi) {
            var errmsg = "Metric per KPI should be at least 1 or less than or equal to the total number of Metrics in the widget";
            m.err = errmsg;
            return;
        }

        if (models.length == 0) {
            var errmsg = "No data returned for this view, this might be because the applied filter excludes all data";
            m.err = errmsg;
            return;
        }

        this.buildRows();

        updateColumnWidth.call(this);

        this.showMinLabel = bulletShowMinLabel.call(this);

    }

    
    function processAndCheckOrderValid() {

        for (var i = 0; i < order.length; i++) {
            if (order[i] == "LineChart" || order[i] == "BarChart"
                || order[i] == "GaugeChart" || order[i] == "Metric") {
                
                continue;
            }
            if (order[i].length < 3) {
                return false;
            }
            var tstStr = order[i];
            var len = tstStr.length;

            if (tstStr[len - 2] == '|') {
                order[i] = tstStr = tstStr.substring(0, len - 2);
            }
            if (!ID_NAME[tstStr]) {
                return false;
            } else if (METRIC_INDEX[tstStr] !== undefined) {
                
                order[i] = METRIC_INDEX[tstStr] + "";
            } else if (this.isKPI) {
                order[i] = "0";
            }
        }

        if (this.enableSmoothScroll) {
            return false;
        }

        var m = this.model,
            metricES = m.gts.col[0].es;
        var columnIDs = [],
            cIDs = [];
        if (this.isTreeMode) {
            columnIDs = this.otherProps.mpColumnIDsInTreeMode;
            if (columnIDs.length == 1) {
                return false;
            }

            for (var i = 0; i < metricES.length; i++) {
                var metricID = metricES[i].oid;
                cIDs.push(metricID);
            }
        } else {
            
            columnIDs = this.otherProps.mpColumnIDs;
            if (this.isKPI) {
                if (columnIDs.length <= 1) {
                    
                    
                    return false;
                }

                cIDs.push("Metric");
                var metricPerKPI = this.otherProps.mnMetricsPerKPI;
                if (metricPerKPI > 2) {
                    for (var i = 0; i < metricPerKPI; i++) {
                        if (i % metricPerKPI <= 1) {
                            
                            continue;
                        }
                        var metricID = metricES[i].oid;
                        cIDs.push(metricID);
                    }
                }

            } else {
                if (columnIDs.length == 1) {
                    return false;
                }
                var rows = m.gts.row,
                    attrCnt = rows.length - 1,
                    rowHeaderCnt = 0;

                for (var i = 0; i < attrCnt; i++) {
                    var attr = rows[i],
                        attrFormCnt = attr.fs && attr.fs.length;
                    cIDs.push(attr.id);

                    for (var j = 1; j < attrFormCnt; j++) {
                        cIDs.push(attr.fs[j].id);
                    }
                    rowHeaderCnt += attrFormCnt;
                }

                for (var i = 0; i < metricES.length; i++) {
                    var metricID = metricES[i].oid;
                    cIDs.push(metricID);
                }

            }

        }

        if (cIDs.length != columnIDs.length) {
            return false;
        }
        for (var i = 0; i < cIDs.length; i++) {
            var metricID = cIDs[i];
            if (mstrmojo.array.indexOf(columnIDs, metricID) == -1) {
                
                return false;
            }
        }

        return true;
    }

    function createKPIDefaultCol() {
        var ind = 0;
        var otherProps = this.otherProps,
            sparklineProps = this.sparklineProps,
            barProps = this.barProps,
            bulletProps = this.bulletProps;

        order[ind++] = "Metric";
        var kpi = otherProps.mnMetricsPerKPI;
        if (isNaN(kpi)) {
            kpi = 1;
        }
        var firstChartShow = false;
        if (sparklineProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "LineChart";
        }
        if (barProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "BarChart";
        }
        if ((!firstChartShow && otherProps.mbShowForHiddenGraphs)
            || (firstChartShow && sparklineProps.mbAssMetric)) {
            
            
            order[ind++] = "0";
        }

        if (kpi >= 7) {
            if (bulletProps.mbShow) {
                if (bulletProps.mbAssMetric) {
                    order[ind++] = "2";
                }
                order[ind++] = "GaugeChart";
            } else if (otherProps.mbShowForHiddenGraphs) {
                for (var i = 3; i <= kpi && i <= 7; i++) {
                    order[ind++] = "" + (i - 1);
                }
            }
            for (var i = 8; i <= kpi; i++) {
                order[ind++] = "" + (i - 1);
            }
        } else {
            for (var i = 3; i <= kpi; i++) {
                order[ind++] = "" + (i - 1);
            }
        }
    }

    function createNonKPIDefaultCol() {
        var ind = 0;
        var m = this.model,
            rows = m.gts.row,
            cols = m.gts.col;
        var mtrcNum = 0;

        if (this.isTreeMode) {
            order[ind++] = rows[0].id;
        } else {

            for (var i = 0; i < rows.length - GFL; i++) {
                if (rows[i].fs && rows[i].fs.length > 0) {
                    for (var q = 0; q < rows[i].fs.length; q++) {
                        order[ind++] = rows[i].id + ":" + rows[i].fs[q].id;
                    }
                } else {
                    if (rows[i].fid && rows[i].fid.length > 0) {
                        order[ind++] = rows[i].id + ":" + rows[i].fid;
                    } else {
                        order[ind++] = rows[i].id;
                    }
                }
            }
        }

        for (var i = 0; i < cols.length; i++) {
            if (cols[i].n = "Metrics") {
                mtrcNum = cols[i].es.length;
            }
        }

        var firstChartShow = false;
        if (this.sparklineProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "LineChart";
        }
        if (this.barProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "BarChart";
        }
        if ((!firstChartShow && this.otherProps.mbShowForHiddenGraphs)
            || (firstChartShow && this.sparklineProps.mbAssMetric)) {
            
            
            order[ind++] = "0";
        }

        if (mtrcNum >= 7) {
            if (this.bulletProps.mbShow) {
                if (this.bulletProps.mbAssMetric) {
                    order[ind++] = "2";
                }
                order[ind++] = "GaugeChart";
            } else if (this.otherProps.mbShowForHiddenGraphs) {
                for (var i = 3; i <= 7 && i <= mtrcNum; i++) {
                    order[ind++] = "" + (i - 1);
                }
            }
            for (var i = 8; i <= mtrcNum; i++) {
                order[ind++] = "" + (i - 1);
            }
        } else {
            for (var i = 3; i <= mtrcNum; i++) {
                order[ind++] = "" + (i - 1);
            }
        }
    }

    function convertAttributeDrivenData(w) {
        var m = w.model,
            metricES = m.gts.col[0].es,
            rows = m.gts.row,
            gvsRows = m.gvs.items,
            rl = m.gvs.items.length,
            rhs = m.ghs.rhs.items;

        var rowsLen = rows.length;
        
        var lai = rows.length - GFL;
        
        var slai = lai - 1;

        var idxPos = 0;
        w.attrMapIdx = []; 
        
        var attrMapIdx = w.attrMapIdx;
        for (var q = 0; q < rowsLen; q++) {
            attrMapIdx[q] = idxPos;
            if (!rows[q].fs || rows[q].fs.length == 0) {
                idxPos++;
            } else {
                idxPos += rows[q].fs.length;
            }
        }

        
        attrMapIdx[rowsLen] = idxPos;

        var attrName = rows[lai].dn || rows[lai].n;

        var fnCopyArray = function (src, isIdx) {
            var dest = [];
            for (var i = 0; i < src.length; i++) {
                dest[i] = src[i];
            }
            return dest;
        };

        
        w.ctlMatrix = {};
        w.isAllAttrSelectable = true;
        for (var i = 0; i < lai; i++) {
            var attribute = rows[i];
            if (!attribute.sc || !attribute.sc.tks || attribute.sc.tks == "") {
                w.isAllAttrSelectable = false;
                continue;
            }

            w.ctlMatrix[attribute.id] = {
                es: attribute.es,
                sc: attribute.sc,
                map: [],
                selectedIdx: {},
                colIdx: w.getColIdx(attribute.id)
            };

            
            if (attribute.sc.all && attribute.sc.allSelected) {
                w.ctlMatrix[attribute.id].selectedIdx["-1"] = true;
            }
        }

        
        var AttrIndexes = [];
        var i = 0, j = 0;
        var template = [];
        var tempLen = 0;
        for (i = 0; i < rhs.length; i++) {
            if (i === 0) {
                
                AttrIndexes[0] = [];
                for (j = 0; j < rhs[i].items.length; j++) {
                    AttrIndexes[0][j] = rhs[0].items[j].idx;
                    if (AttrIndexes[0][j] < 0 && rows[j].otp == -1) {
                        
                        AttrIndexes[0][j] = rows[j].es.length + AttrIndexes[0][j - 1];
                    }
                    
                    if (rhs[0].items[j].cet) {
                        var id = rhs[0].items[j].cet;
                        if (order[j] == id + ":CG") {
                            
                            id += ":CG";
                        }
                        var controlMatrix = w.ctlMatrix[id];
                        if (controlMatrix && !controlMatrix.selectedIdx[-1]) {
                            
                            controlMatrix.selectedIdx[AttrIndexes[0][j]] = true;
                        }
                    }
                }
                template = fnCopyArray(AttrIndexes[0]);
                tempLen = template.length;
                continue;
            }
            var rhsRow = rhs[i].items;
            var rhsRowLen = rhsRow.length;
            for (j = 1; j <= rhsRowLen; j++) {
                template[tempLen - j] = rhsRow[rhsRowLen - j].idx;

                if (template[tempLen - j] < 0) {
                    
                    var k = 0;
                    for (; k < attrMapIdx.length; k++) {
                        if (tempLen - j < attrMapIdx[k]) {
                            break;
                        }
                    }
                    template[tempLen - j] = rows[k - 1].es.length + rhsRow[rhsRowLen - j - 1].idx;
                }
                if (rhsRow[rhsRowLen - j].cet) {
                    var id = rhsRow[rhsRowLen - j].cet;
                    if (order[rhsRowLen - j] == id + ":CG") {
                        
                        id += ":CG";
                    }
                    var controlMatrix = w.ctlMatrix[id];
                    if (controlMatrix) {
                        delete controlMatrix.selectedIdx[-1];
                        controlMatrix.selectedIdx[template[tempLen - j]] = true;
                    }
                }
            }
            AttrIndexes[i] = fnCopyArray(template);
        }

        var fnBEL = function (index) {
            var elms = {};
            var ind = 0;
            for (var i = 0; i < rows.length - GFL; i++) {
                var fL = rows[i].fs.length;
                if (fL < 1) {
                    fL = 1;
                }
                var attId = rows[i].id;
                if (AttrIndexes[index][ind] < 0) {
                    elms[attId] = "";
                } else {
                    elms[attId] = rows[i].es[AttrIndexes[index][ind]];
                }

                if (elms[attId] == undefined) {
                    elms[attId] = {n: ""};
                }

                var fidId = rows[i].fid;
                if (fidId && fidId.length > 0) {
                    elms[attId + ":" + fidId] = rows[i].es[AttrIndexes[index][ind]];
                }
                for (var j = 0; j < fL; j++) {
                    var formId = "";
                    if (rows[i].fs && rows[i].fs[j]) {
                        formId = rows[i].fs[j].id;
                    }
                    if (formId && formId.length > 0) {
                        var afID = attId + ":" + formId;
                        elms[afID] = rows[i].es[AttrIndexes[index][ind]];
                    }
                    ind++;
                }
            }

            return elms;
        };

        var s = {
            v: [],
            rv: [],
            thClr: [],
            hi: [ 0 ]
        };
        var referValue = [];
        var sortValue = 0;
        var attrElems = null;
        var ch = [
            {
                items: [
                    {
                        n: metricES[0].n
                    }
                ]
            }
        ];

        var c = [],
            baseRow = [],
            j = 0, si = 0,
            isTotal = false,
            compareResult = false;

        function indexChanged(baseRow, newRow) {
            
            if (baseRow.length != newRow.length) {
                return true;
            }
            var endIndex = attrMapIdx[lai] - 1;
            if (endIndex >= baseRow.length) {
                endIndex = baseRow.length - 1;
            }
            for (var i = endIndex; i >= 0; i--) {
                
                if (baseRow[i] != newRow[i]) {
                    return true;
                }
            }
            return false;
        }

        for (var i = 0; i <= rl; i++) {
            if (i === 0) {
                baseRow = AttrIndexes[i];
            } else if ((compareResult = (i === rl || indexChanged(baseRow,
                AttrIndexes[i])))
                || isTotal) {
                if (isTotal && !compareResult) {
                    
                    
                } else {
                    
                    for (var x = 0; x < lai; x++) {
                        var controlMatrix = w.ctlMatrix[rows[x].id];
                        if (controlMatrix) {
                            controlMatrix.map[si] = AttrIndexes[i - 1][x];
                        }
                    }
                    models[si] = {
                        sortV: sortValue,
                        isTotal: isTotal,
                        refv: referValue,
                        elms: attrElems,
                        tr: s.v[s.v.length - 1],
                        model: {
                            categories: {
                                items: c,
                                tn: attrName
                            },
                            mtrcs: {
                                items: METRICS
                            },
                            colHeaders: ch,
                            series: [ s ],
                            rowHeaders: [
                                {
                                    n: rows[lai].n
                                }
                            ]
                        }
                    };
                    si++;
                    if (i === rl) {
                        break; 
                    }
                }
                
                s = {
                    v: [],
                    rv: [],
                    thClr: [],
                    hi: [ 0 ]
                };
                referValue = [];

                c = [];

                baseRow = AttrIndexes[i];
                j = 0;
                isTotal = false;
            }

            var otherProps = w.otherProps;

            
            
            
            for (var p = 0; p < gvsRows[i].items.length; p++) {
                if (!referValue[p]) {
                    referValue[p] = {};
                }
                referValue[p] = gvsRows[i].items[p];
            }

            attrElems = fnBEL(i);

            if (otherProps.mpSortKey != null) {
                var sortByAttr = ( otherProps.mpSortKey != parseInt(otherProps.mpSortKey) );
                if (sortByAttr) {
                    sortValue = attrElems[otherProps.mpSortKey].n;
                } else {
                    
                    sortValue = parseFloat(referValue[otherProps.mpSortKey].rv);
                }

            }

            if (!w.isTreeMode) { 
                
                
                
                var isSubTotal = function (attr) {
                    return (attr.id && attr.id.substring(0, 1) === "D")
                        || (attr.id === undefined && attr.n === "Total")
                }
                var attrSlai = rows[slai].es[AttrIndexes[i][attrMapIdx[slai]]];
                if (attrSlai && isSubTotal(attrSlai)) {
                    
                    isTotal = true;
                    continue;
                }

                var attr = rows[lai].es[AttrIndexes[i][attrMapIdx[lai]]];
                if (attr && isSubTotal(attr)) {
                    
                    
                    continue;
                }
            }

            var attrElement = "";
            var attIdxPos = attrMapIdx[lai];
            var thisAtt = null;
            var thisAttFormLen = 1;
            try {
                for (var p = 0; p < GFL; p++) {
                    thisAtt = rows[lai + p];
                    if (thisAtt.fs && thisAtt.fs.length > 0) {
                        
                        thisAttFormLen = thisAtt.fs.length;
                    } else {
                        thisAttFormLen = 1;
                    }
                    for (var pp = 0; pp < thisAttFormLen; pp++) {
                        attrElement += " " + thisAtt.es[AttrIndexes[i][attIdxPos]].n;
                        attIdxPos++;
                    }
                }
            } catch (err) {
                
            }

            c[j] = attrElement;

            var item = gvsRows[i].items[0];
            s.v[j] = item.v;
            s.rv[j] = item.rv;

            var th = m.th && m.th['0'];
            var ti = item.ti;
            
            if (ti != undefined && item.ty == 2 && th[ti].cni != undefined && otherProps.mbInheritFromGridGraph) {
                this.textSpan.className = m.css[th[ti].cni].n;
                var compStyle = mstrmojo.css.getComputedStyle(this.textSpan);
                s.thClr[j] = compStyle.backgroundColor;
                if (s.thClr[j] == "rgba(0, 0, 0, 0)") {
                    s.thClr[j] = null;
                }
            } else {
                s.thClr[j] = null;
            }

            j++;
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        

        if (!w.isTreeMode && otherProps.mpSortKey != null) {
            var rowCount = models.length;
            for (var i = 0; i < rowCount; i++) {
                for (var j = 0; j < rowCount - 1; j++) {
                    if ((otherProps.mbSortDescend && models[j].sortV < models[j + 1].sortV)
                        || (!otherProps.mbSortDescend && models[j].sortV > models[j + 1].sortV)) {
                        var temp = models[j];
                        models[j] = models[j + 1];
                        models[j + 1] = temp;
                    }
                }
            }
        }

        if (w.isTreeMode) {
            
            convertDataToTreeModels.call(w, AttrIndexes);

        }

    }

    function convert(w) {
        var m = w.model,
            rows = m.gts.row,
            cols = m.gts.col,
            cs = rows[rows.length - 1].es,
            sn = cols[0].es,
            idxItems = m.ghs.rhs.items,
            csl = idxItems.length,
            v = m.gvs.items,
            ch = [];

        for (var i = 0; i < sn.length; i++) {
            if (!ch[0]) {
                ch[0] = {
                    items: []
                };
            }
            ch[0].items[i] = [
                {
                    n: sn[i].n
                }
            ];
        }

        var vl = v[0].items.length;

        var series = [];
        var c = [];
        var attrName = m.gts.row[0].dn || m.gts.row[0].n;

        var referValue = [];
        var kpi = w.otherProps.mnMetricsPerKPI;
        if (isNaN(kpi)) {
            kpi = 1;
        }
        var sNum = 0;
        var metrixIdxArray = [];
        for (var i = 0; i + kpi <= vl; i = i + kpi) {
            var fv = [];
            var rv = [];
            series[sNum] = {
                v: fv,
                rv: rv,
                hi: [ 0 ]
            };
            var refV = [];
            referValue[sNum] = {
                refv: refV
            };
            for (var j = 0; j < kpi; j++) {
                referValue[sNum].refv[j] = v[csl - 1].items[i + j];
            }
            metrixIdxArray[sNum] = i;
            sNum++;
        }

        for (var i = 0; i < csl; i++) {
            var idxItemsItems = idxItems[i].items;
            
            var idx = idxItemsItems[idxItemsItems.length - 1].idx;
            if (isNaN(idx)) {
                console.log("idx is not a number!" + idx);
                
                c[i] = cs[i].n;
            } else {
                if (idx < 0) {
                    c[i] = "";
                } else {
                    c[i] = cs[idx].n;
                }
                
                for (var k = 2; k <= idxItemsItems.length && k <= rows.length; k++) {
                    
                    var anotherIdx = idxItemsItems[idxItemsItems.length - k].idx;
                    if (!isNaN(anotherIdx)) {
                        
                        c[i] = rows[rows.length - k].es[anotherIdx].n + " " + c[i];
                    }
                }

            }
            var ind = 0;
            for (var j = 0; j + kpi <= vl; j = j + kpi) {
                series[ind].v[i] = v[i].items[j].v;
                series[ind].rv[i] = v[i].items[j].rv;
                ind++;
            }
        }

        var sl = series.length;
        for (var i = 0; i < sl; i++) {
            var elmsValue = {};
            elmsValue[m.gts.row[0].id] = ch[0].items[i * kpi][0];
            if (m.gts.row[0].fid) {
                elmsValue[m.gts.row[0].id + ":" + m.gts.row[0].fid] = ch[0].items[i * kpi][0];
            }
            elmsValue["Metric"] = ch[0].items[i * kpi][0];
            models[i] = {
                refv: referValue[i].refv,
                elms: elmsValue,
                tr: series[i].v[series[i].v.length - 1],
                model: {
                    categories: {
                        items: c,
                        tn: attrName
                    },
                    mtrcs: {
                        items: METRICS
                    },
                    series: [ series[i] ],
                    colHeaders: [
                        {
                            items: ch[0].items[i]
                        }
                    ],
                    rowHeaders: [
                        {
                            n: rows[0].n
                        }
                    ]
                },
                metricIdx: metrixIdxArray[i]
            };
        }
    }

    function bulletShowMinLabel() {
        var showMinLabel = false;
        var otherProps = this.otherProps;
        if (this.showGauge) {
            var minValue = this.bulletProps.mfMinValue;
            var count = models.length;
            for (var i = 0; i < count; i++) {
                var v = models[i].refv[2];
                if (v && v.rv < minValue) {
                    showMinLabel = true;
                    otherProps.mRowHeight = otherProps.mRowHeight > 36 ? otherProps.mRowHeight : 36;
                    break;
                }

            }

        }

        return showMinLabel;
    }

    function getFirstRowUnderDockedHeader(yPos) {
        var scl = this.getChartWithScrollBar()._scroller;
        var y = yPos || scl && scl.origin && scl.origin.y;
        var rowOffsetHeight = this.rowOffsetHeight;

        var rowIdx = this.startCnt + parseInt(y / rowOffsetHeight) + this.dockedHeaderRows.length;
        var rowPast = y % rowOffsetHeight;

        var rowInfo = getRowAtIdx.call(this, rowIdx);

        return{rowInfo: rowInfo, treeNode: rowInfo.treeNode, pastOffset: rowPast, rowIdx: rowIdx};
    }

    function getRowAtIdx(rowIdx) {
        if (rowIdx < 0) {
            rowIdx = 0;
        }
        var maxRowIdx = this.rows.length - 1;
        if (rowIdx > maxRowIdx) {
            rowIdx = maxRowIdx;
        }

        return this.rows[rowIdx];
    }

    
    function getTreeNodeRows(allExpand, rowCnt) {
        var preOrderTreeNodeQueue = [];
        var treeNode = null;
        var rows = [];

        
        var treeNodeList = this.tree.childrenTreeNodeList;
        var childrenCount = treeNodeList.length;
        for (var i = childrenCount - 1; i >= 0; i--) {
            preOrderTreeNodeQueue.push(treeNodeList[i]);
        }

        var rowCount = 0;
        
        while (preOrderTreeNodeQueue.length > 0) {
            treeNode = preOrderTreeNodeQueue.pop();
            var row = {treeNode: treeNode,
                model: treeNode.model,
                rowIdx: rowCount,
                selected: treeNode.selected,
                rowRef: {}};
            rows.push(row);
            if (!allExpand) {
                treeNode.rowIdx = rowCount++;
            }

            if (rowCnt && rowCount >= rowCnt) {
                break;
            }
            if (treeNode.needExpand || allExpand) {
                treeNodeList = treeNode.childrenTreeNodeList;
                childrenCount = treeNodeList.length;
                for (var i = childrenCount - 1; i >= 0; i--) {
                    preOrderTreeNodeQueue.push(treeNodeList[i]);
                }
            }
        }

        return rows;

    }

    function getLowestLevelOnScreen() {
        var scl = this.getChartWithScrollBar()._scroller;
        var y = scl && scl.origin && scl.origin.y;
        var rowOffsetHeight = this.rowOffsetHeight;

        var firstRowIdx = this.startCnt + parseInt(y / rowOffsetHeight);
        var chartHeight = Math.min(this.chartTableMaxHeight, parseInt(this._leftChart.itemsContainerNode.style.height));
        var lastRowIdx = this.startCnt + parseInt((y + chartHeight) / rowOffsetHeight);

        if (firstRowIdx < 0) {
            firstRowIdx = 0;
        }
        if (lastRowIdx >= this.rows.length) {
            lastRowIdx = this.rows.length - 1;
        }

        var lowestLevel = -1;
        for (var i = firstRowIdx; i <= lastRowIdx; i++) {
            var currLevel = this.rows[i].treeNode.level;
            if (currLevel > lowestLevel) {
                lowestLevel = currLevel;
            }
        }

        return lowestLevel;
    }

    function removeChildren(container) {
        var count = container && container.childNodes && container.childNodes.length;
        for (var i = 0; i < count; ++i) {
            container.removeChild(container.firstChild);
        }

    }

    function hasScrollDownPast(yPos) {
        return yPos < 0;
    }

    function expandOrCollapseTreeAndSetScrlPos(levelToExpand, anchorRowTreeNode, anchorRowIdxOnScrn) {

        if (this.expandToLevel == levelToExpand) {
            
            return;
        }

        setNeedExpandToLevel(this.tree, levelToExpand);

        this.expandToLevel = levelToExpand;

        this.rowsNeedRebuild = true;

        this.reRenderChartWithAnchor(anchorRowTreeNode, anchorRowIdxOnScrn);

        setChartTableHeight.call(this);

        this.reBuildDH(levelToExpand);

    }

    function expandTreeNodeAndSetScrlPos(rowInfo, rowType) {
        var treeNode = rowInfo.treeNode;

        treeNode.needExpand = true;

        this.expandToLevel = -1;

        var scl = this.getChartWithScrollBar()._scroller;

        var currRowIdx = rowInfo.rowIdx;

        this.reRenderChart(scl.origin);

        setChartTableHeight.call(this);

        if (currRowIdx == this.startCnt + parseInt(scl.origin.y / this.rowOffsetHeight) + this.dockedHeaderRows.length) {
            

            var rowIdxList = [];
            var currRowTreeNode = rowInfo.treeNode;
            while (currRowTreeNode.needExpand) {
                
                
                rowIdxList.push(currRowIdx);
                currRowTreeNode = getRowAtIdx.call(this, ++currRowIdx).treeNode;
            }
            this.addRowsToDH(rowIdxList);

            
        }

        
        var rowOffsetHeight = this.rowOffsetHeight;
        var lastRowOnScrnIdx = this.startCnt + Math.round((scl.origin.y + this.chartTableHeight) / rowOffsetHeight) - 1;
        if (currRowIdx == lastRowOnScrnIdx) {
            var scroller = scl;
            var maxYPos = Math.min(scl.origin.y + 2 * rowOffsetHeight, scl.offset.y.end);
            scl.origin.y = maxYPos;

            $D.translate(scroller.scrollEl, -scroller.origin.x, -scroller.origin.y, 0, scroller.transform, scroller.useTranslate3d);

            

            this.onScrollMoved({y: maxYPos});
        }

    }

    function getIdxByRowIdx(rows, targetIdx) {
        var rowCount = rows.length;
        for (var i = 0; i < rowCount; i++) {
            var rowInfoDH = rows[i];
            if (rowInfoDH.rowIdx == targetIdx) {
                return i;
            }
        }
        return -1;
    }

    function collapseTreeNodeAndSetScrlPos(rowInfo, rowType) {
        var treeNode = rowInfo.treeNode;
        treeNode.needExpand = false;

        this.expandToLevel = -1;

        var scl = this.getChartWithScrollBar()._scroller;

        if (rowType == DOCKED_HEADER) {

            var adjustOffset = 0;
            
            var rowCount = this.dockedHeaderRows.length;
            var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, rowInfo.rowIdx);

            if (dockedHeaderIdx >= 0) {
                this.removeRowsFromDH(rowCount - dockedHeaderIdx);
                
                this.removeChildrenForDHReplaceTable();
                this.dockedHeaderStatus = NO_REPLACE;

            } else {
                
                dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, rowInfo.rowIdx);

                if (dockedHeaderIdx < 0) {
                    
                    return;
                }
                dockedHeaderIdx += rowCount;
                adjustOffset = scl.origin.y % this.rowOffsetHeight;
                this.removeChildrenForDHReplaceTable();
                this.dockedHeaderStatus = NO_REPLACE;
                
            }

            var rowCount = this.startCnt + parseInt(scl.origin.y / this.rowOffsetHeight) + dockedHeaderIdx - rowInfo.rowIdx;
            this.reRenderChart(scl.origin, rowCount, adjustOffset);
        } else if (rowType == OTHER_ROW) {

            this.reRenderChart(scl.origin);
        }

        setChartTableHeight.call(this);

    }

    var hideTooltipGlobal = function () {
        if (this.tooltip.style["display"] === "block") {
            var highLightCav = document.getElementById("highLightCav"
                + this.domNode.id);
            if (highLightCav) {
                highLightCav.id = "";
                
                
                var context = highLightCav.getContext('2d');
                context.clearRect(0, 0, highLightCav.width, highLightCav.height);
            }
            
            this.tooltip.style.display = "none";
            this.tooltipShow = false;

            if (this._touchListener) {
                var touchManager = mstrmojo.touchManager;
                touchManager.detachEventListener(this._touchListener);
                delete this._touchListener;
            }

        }
    };

    function setChartTableHeight() {
        if (!this._leftChart) {
            return;
        }

        var chartTableOffsetHeight = (this.otherProps.mbHideTextColumns && this.enableSmoothScroll) ? this._rightChart.chartTableOffsetHeight : this._leftChart.chartTableOffsetHeight;
        var headerTableOffsetHeight = (this.otherProps.mbHideTextColumns && this.enableSmoothScroll) ? this._rightChart.headerTableOffsetHeight : this._leftChart.headerTableOffsetHeight;

        var chartTableHeight = 0;
        if (chartTableOffsetHeight >= this.chartTableMaxHeight) {
            chartTableHeight = this.chartTableMaxHeight;
        } else {
            chartTableHeight = chartTableOffsetHeight;
        }

        this._leftChart.itemsContainerNode.style.height = chartTableHeight + "px";
        if (this._rightChart) {
            this._rightChart.itemsContainerNode.style.height = chartTableHeight + "px";
        }

        this.legend.style.top = (headerTableOffsetHeight + chartTableHeight) + "px";
        this.dropShadowDiv.style.height = (headerTableOffsetHeight + chartTableHeight) + "px";

        this.indicatorEl.parentNode.style.top = headerTableOffsetHeight + "px";
        this.indicatorEl.parentNode.style.height = chartTableHeight + "px";

        this.chartTableHeight = chartTableHeight;

        
        
        var scl = this.getChartWithScrollBar()._scroller;
        var yPos = scl.origin.y;
        var maxYPos = chartTableOffsetHeight - chartTableHeight + 2;
        if (yPos > maxYPos) {
            if (scl.vScroll) {
                scl.origin.y = maxYPos;
                this._leftChart.scrollTo(scl.origin);
                if (this._rightChart) {
                    this._rightChart.scrollTo(scl.origin);
                }

                var rowOffsetHeight = this.rowOffsetHeight;

                while ((yPos = yPos - rowOffsetHeight) > maxYPos) {
                    this.updateDockedHeadersByOneRow(yPos, true);
                }
                this.updateDockedHeadersByOneRow(maxYPos);

                this.firstRowIdxOnScrn = parseInt(this.startCnt + scl.origin.y / rowOffsetHeight);
            } else {
                scl.origin.y = 0;
                this._leftChart.scrollTo(scl.origin);
                if (this._rightChart) {
                    this._rightChart.scrollTo(scl.origin);
                }
                this.firstRowIdxOnScrn = parseInt(this.startCnt + scl.origin.y / rowOffsetHeight)
            }

        }

        this.updateWindowRatio();
        this.updateScrollBarPosition();
    }

    function setScrollerPosition(scrollTo) {

        var scl = this._scroller,
            icn = this.rightChart,
            offsetEnd = this.rightChart.offsetWidth - ( this.getWidth() - this.leftWidth );

        scl.origin = {
            x: scrollTo && scrollTo.x || 0,
            y: scrollTo && scrollTo.y || 0
        };

        scl.showScrollbars = true;
        scl.hScroll = (offsetEnd !== 0 && scl.noHScroll !== true) || this.scrollPast;

        if (scl.hScroll) {

            scl.offset = {
                x: {
                    start: 0,
                    end: offsetEnd
                },
                scrollPast: this.scrollPast
            };
        }

        this.utils.translateCSS(-scl.origin.x, -scl.origin.y, false, icn);
    }

    mstrmojo.VisMicroChart = mstrmojo.declare(

        mstrmojo.Vis,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        {

            scriptClass: 'mstrmojo.VisMicroChart',

            utils: mstrmojo.VisChartUtils,

            scrollerConfig: {
                bounces: false,
                showScrollbars: true,
                vScroll: false,
                hScroll: true,
                useTranslate3d: false
            },

            scrollPast: false,

            legendHeight: 30,

            
            selectedStyle: "background-color:#015DE6;color:#FFFFFF;",

            

            selectedClass: "",

            isAllAttrSelectable: false,

            
            prevSelected: {
                mrow: -2,
                mcol: -1
            },

            rows: [],

            dockedHeaderRows: [],

            dockedHeaderReplaceRows: [],

            rowsReusePool: [],

            unselectedRemainCells: [],

            isTreeMode: false,

            isKPI: false,

            showMinLabel: false,

            rowsNeedRebuild: true,

            lastScrollPosition: {y: 0},

            
            startCnt: -1,

            endCnt: -1,

            
            firstRowIdxOnScrn: 0,

            pageSize: 10,

            mcStatus: null,

            
            fontSize: '10pt',

            headerCssClass: '',

            valueCssClass: '',

            
            enableSmoothScroll: false,

            metricColumnsSpacing: NORMAL,

            attrColumnCount: 0,

            dropShadowWidth: 7,

            markupString: '<div id="{@id}-microchart" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};left:{@left};top:{@top};z-index:{@zIndex};position:absolute" '
                + ' mstrAttach:mousedown,mouseup,mousemove,click >'
                +
                '<div id="{@id}-microchart-left" style="width:{@leftWidth+"px"};height:{@height};left:0px;right:0px;position:absolute;z-index:1;" > </div>'
                +
                '<div id="{@id}-microchart-smoothscroll-container" class="mstrmojo-Chart {@cssClass}" style="width:{@rightWidth+"px"};height:{@height};left:{@leftWidth+"px"};top:0;position:absolute;overflow:hidden;">'
                + '<div id="{@id}-microchart-right" style="width:{@rightWidth};position:absolute;" > </div>'
                + '<div id="{@id}-drop-shadow-ss" style="position:absolute;left:0px;width:{@dropShadowWidth+"px"}" > </div>'
                + '</div>'
                +
                '<div style="display:none;position:absolute;right:0;z-index:5;height:{@legendHeight + "px"};width:{@width};border:none;background:transparent;text-decoration:none;" class="microchart-lengend-text">'
                + '<div style="position:absolute;right:0;top:0;padding-bottom:7px">'
                + '<div style="float:left;padding-top:7px;">'
                + '<div class="microchart-legend-band" ></div>'
                + '<div style="float:right;margin-right:10px;margin-left:10px;">Low</div>'
                + '</div>'
                + '<div style="float:left;padding-top:7px;">'
                + '<div class="microchart-legend-band"></div>'
                + '<div style="float:right;margin-right:10px;margin-left:10px;">Mid</div>'
                + '</div>'
                + '<div style="float:left;padding-top:7px;">'
                + '<div class="microchart-legend-band"></div>'
                + '<div style="float:right;margin-right:10px;margin-left:10px;">High</div>'
                + '</div>'
                + '</div>'
                + '</div>'
                +
                '<span id="textSpan" style="z-index:-10;visibility:hidden;-webkit-text-size-adjust: none;"></span>'
                +
                '<div id="{@id}-loading-msg" class="mstrmojo-loading-msg" style="display:none;z-index:10"></div>'
                +
                '<canvas id="textCanvas" width="900" height="500" style="z-index:-11;visibility:hidden;-webkit-text-size-adjust: none;"></canvas>'
                +
                '<div id="{@id}-tooltip" class="mstrmojo-MicroChart-tooltip" style="z-index:10;opacity: 0.9;"></div>'
                +
                '<div id="{@id}-text-tooltip" class="mstrmojo-Chart-tooltip timeseries-legend-tooltip" style="z-index:10"></div>'
                +
                '<div id="{@id}-errMsg" class="mstrmojo-message" style="width:{@width};height:{@height};top:0px;left:0px;position:absolute; display:none; z-index:30;"><div style="width:{@width};position:absolute;top:50%;text-align:center"></div></div>'
                +
                '<div id="{@id}-indicatorEl-container"  style="width:{@width};height:{@height};top:0px;left:0px;position:absolute;z-index:-5"><div></div></div>'
                +
                '</div>',

            markupSlots: {
                leftChart: function () {
                    return this.domNode.childNodes[0];
                },

                rightChart: function () {
                    return this.domNode.childNodes[1].firstChild;
                },

                dropShadowDiv: function () {
                    return this.domNode.childNodes[1].childNodes[1];
                },

                itemsContainerNode: function () {
                    return this.domNode.childNodes[1];
                },

                textSpan: function () {
                    return this.domNode.childNodes[3];
                },

                loadingMsg: function () {
                    return this.domNode.childNodes[4];
                },

                textCanvas: function () {
                    return this.domNode.childNodes[5];
                },

                tooltip: function () {
                    return this.domNode.childNodes[6];
                },

                textTooltip: function () {
                    return this.domNode.childNodes[7];
                },

                
                errorMsg: function () {
                    return this.domNode.childNodes[8];
                },

                indicatorEl: function () {
                    return this.domNode.childNodes[9].firstChild;
                },

                legend: function () {
                    return this.domNode.childNodes[2];
                },

                legendLow: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[0];
                },

                legendLowFont: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[0].childNodes[1];
                },

                legendLowBand: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[0].childNodes[0];
                },

                legendMid: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[1];
                },

                legendMidFont: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[1].childNodes[1];
                },

                legendMidBand: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[1].childNodes[0];
                },

                legendHigh: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[2];
                },

                legendHighFont: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[2].childNodes[1];
                },

                legendHighBand: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[2].childNodes[0];
                }
            },

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

            renderErrorMessage: function renderErrorMessage(msg) {
                var contentDiv = this.errorMsg.firstChild;
                contentDiv.innerHTML = msg; 
                this.errorMsg.style.display = 'block';
                var contentHeight = contentDiv.offsetHeight;
                contentDiv.style.marginTop = -0.5 * contentHeight;
            },

            
            getTextWidthByCanvas: function gtwCvs(text, elem, withPadding) {
                var canvas = this.textCanvas;

                var context = canvas.getContext('2d');

                var computedStyle = mstrmojo.css.getComputedStyle(elem);
                var fontStyle = computedStyle.fontStyle + " "
                    + computedStyle.fontWeight + " "
                    + computedStyle.fontSize + "/"
                    + computedStyle.fontVariant
                    + " " + computedStyle.fontFamily;

                context.font = fontStyle;

                context.textAlign = 'center';
                context.fillStyle = 'blue';

                
                var metrics = context.measureText(text);

                var result = metrics.width;

                if (withPadding) {
                    var addPadding = function (padding) {
                        if (computedStyle[padding]) {
                            result += parseInt(computedStyle[padding]);
                        }
                    }

                    addPadding("paddingLeft");
                    addPadding("paddingRight");
                }

                return result;
            },

            getTextWidth: function gtw(str, className, fontName, fontSize, fontSizeUnit, bold, withoutPadding) {
                var selfTextSpan = this.textSpan;
                if (selfTextSpan.className !== className || "") {
                    selfTextSpan.className = className || "";
                }
                if (selfTextSpan.style.fontFamily !== fontName || "") {
                    selfTextSpan.style.fontFamily = fontName || "";
                }

                var fsUnit = fontSizeUnit || "pt"

                if (fontSize) {
                    selfTextSpan.style.fontSize = fontSize + fsUnit;
                } else {
                    selfTextSpan.style.fontSize = '';
                }

                if (bold) {
                    if (selfTextSpan.style.fontWeight !== 'bold') {
                        selfTextSpan.style.fontWeight = 'bold';
                    }
                } else {
                    if (selfTextSpan.style.fontWeight !== '') {
                        selfTextSpan.style.fontWeight = '';
                    }
                }
                if (withoutPadding) {
                    selfTextSpan.style.padding = "0px 0px";
                } else {
                    selfTextSpan.style.padding = "";
                }

                selfTextSpan.innerHTML = str;
                var ret = selfTextSpan.offsetWidth;
                return ret;
            },

            getTextHeight: function gth(str, className, bold, fontFamily, fontSize) {
                
                this.textSpan.style.fontFamily = fontFamily || "";
                this.textSpan.style.fontSize = fontSize || "";
                if (bold) {
                    this.textSpan.style.fontWeight = 'bold';
                } else {
                    this.textSpan.style.fontWeight = '';
                }
                
                this.textSpan.className = className;
                
                this.textSpan.innerHTML = str;

                return this.textSpan.offsetHeight;
            },

            
            removeMCStatus: function removeMCStatus() {
                this.mcStatus = null;
                if (this.controller && this.controller.view && this.controller.view.model) {
                    this.controller.view.model.mcStatus = null;
                }
            },

            restoreMCStatus: function restoreMCStatus() {
                
                if (this.isTreeMode && this.mcStatus && this.mcStatus.currSelectedObj && this.mcStatus.currSelectedObj.length > 0) {
                    this.lastSelectedObj = $HASH.clone(this.currSelectedObj);

                }
                if (this.mcStatus && this.mcStatus.startCnt != undefined && this.mcStatus.endCnt != undefined) {
                    this.startCnt = this.mcStatus.startCnt;
                    this.firstRowIdxOnScrn = this.mcStatus.firstRowIdxOnScrn;

                    var minRowCntToCoverScreen = Math.max(this.mcStatus.endCnt - this.mcStatus.firstRowIdxOnScrn, this.minPageSize);
                    this.endCnt = Math.min(this.mcStatus.firstRowIdxOnScrn + minRowCntToCoverScreen, this.rows.length);
                }

                if (this.isTreeMode && this.mcStatus) {
                    this.replacingStartRowIdx = this.mcStatus.replacingStartRowIdx;
                    this.needReplaceCount = this.mcStatus.needReplaceCount;
                    this.lastFirstRowIdxOnScrn = this.mcStatus.lastFirstRowIdxOnScrn;
                    this.dockedHeaderStatus = this.mcStatus.dockedHeaderStatus;
                    this.lastScrollPosition = this.mcStatus.lastScrollPosition;
                }
            },

            storeMCStatus: function storeMCStatus(noNeedToStoreScrollInfo) {
                this.mcStatus = {};
                if (this.isTreeMode) {
                    this.mcStatus.expandToLevel = this.expandToLevel || -1;
                    this.mcStatus.expandedEntryArray = [];
                    if (this.mcStatus.expandToLevel < 0) {
                        
                        this.addTreeNodeToExpanedEntry(this.tree.childrenTreeNodeList, []);
                    }

                    this.mcStatus.currSelectedObj = [];

                    
                    for (var i = 0; i < this.currSelectedObj.length; i++) {
                        
                        
                        var treeNode = this.currSelectedObj[i];
                        this.mcStatus.currSelectedObj[i] = treeNode && treeNode.id;
                    }

                    
                    if (!noNeedToStoreScrollInfo) {
                        this.mcStatus.dHRowIdxList = [];
                        var dHRows = this.dockedHeaderRows;
                        for (var i = 0; i < dHRows.length; i++) {
                            this.mcStatus.dHRowIdxList.push(dHRows[i].rowIdx);
                        }
                        this.mcStatus.dHReplaceRowIdxList = [];
                        var dHRows = this.dockedHeaderReplaceRows;
                        for (var i = 0; i < dHRows.length; i++) {
                            this.mcStatus.dHReplaceRowIdxList.push(dHRows[i].rowIdx);
                        }

                        this.mcStatus.replacingStartRowIdx = this.replacingStartRowIdx;
                        this.mcStatus.needReplaceCount = this.needReplaceCount;
                        this.mcStatus.lastFirstRowIdxOnScrn = this.lastFirstRowIdxOnScrn;
                        this.mcStatus.dockedHeaderStatus = this.dockedHeaderStatus;
                        this.mcStatus.lastScrollPosition = this.lastScrollPosition;
                    }

                }

                if (!noNeedToStoreScrollInfo) {
                    this.mcStatus.startCnt = this.startCnt;
                    this.mcStatus.endCnt = this.endCnt;
                    this.mcStatus.firstRowIdxOnScrn = this.firstRowIdxOnScrn;
                    var chart = this.getChartWithScrollBar()
                    this.mcStatus.scrollTo = chart && chart._scroller.origin || {x: 0, y: 0};
                }

                if (this.enableSmoothScroll && this._scroller && this._scroller.origin) {
                    
                    this.mcStatus.hScrollPos = this._scroller.origin.x / this.rightWidth;
                }

                
                if (this.controller && this.controller.view && this.controller.view.model) {
                    this.controller.view.model.mcStatus = this.mcStatus;
                }

            },

            addTreeNodeToExpanedEntry: function addExpanedEntry(treeNodeList, parentEntry) {
                var expEntryArray = this.mcStatus.expandedEntryArray;
                var treeNodeCount = treeNodeList.length;
                for (var i = 0; i < treeNodeCount; i++) {
                    var treeNode = treeNodeList[i];
                    if (treeNode.needExpand) {
                        
                        var expandedEntry = $HASH.clone(parentEntry)
                        expandedEntry.push({element: treeNode.id});
                        expEntryArray.push(expandedEntry);
                        
                        this.addTreeNodeToExpanedEntry(treeNode.childrenTreeNodeList, expandedEntry);
                    }
                }

            },

            unrender: function unrender(ignoreDom, noNeedToStoreScrollInfo) {
                console.log("in unrender");
                if (!this.mcStatus) {
                    
                    
                    this.storeMCStatus(noNeedToStoreScrollInfo);
                }

                this.destroyChartWidget();
                if (this._super) {
                    this._super(ignoreDom);
                }
            },

            
            refresh: function refresh() {
                this.unrender(null, true);
                this.render();
            },

            initScroller: function initScroller(scroller) {
                if (this._super) {
                    this._super(scroller);
                }

                if (this.enableSmoothScroll) {
                    
                    
                    this._scrollDoneListener = this._scroller.attachEventListener('scrollDone', this.id, function () {
                        this.updateScrollBarPosition();
                        var scrl = this._scroller;
                        if (scrl) {
                            scrl.toggleScrollBars(false);
                        }

                    });

                }

            },

            updateScrollBarPosition: function updateScrollBarPosition() {
                var scroller = this._rightChart && this._rightChart._scroller;
                var scrollBar = scroller && scroller._scrollBarEls && scroller._scrollBarEls.y;

                if (scrollBar) {
                    scrollBar.style.left = (this._scroller.origin.x + this.getWidth() - this.leftWidth - 9) + "px";
                }

                scroller = this._scroller;
                scrollBar = scroller && scroller._scrollBarEls && scroller._scrollBarEls.x;

                if (scrollBar) {
                    scrollBar.style.top = (this.chartTableHeight + this._leftChart.headerTableOffsetHeight - 9) + "px";
                }
            },

            onScrollDone: function onScrollDone(evt) {
                var scrl = this.getChartWithScrollBar()._scroller;
                scrl.toggleScrollBars(false);
                if (this.partialRender) {
                    this.firstRowIdxOnScrn = parseInt(this.startCnt + evt.y / this.rowOffsetHeight);
                    if ((this.firstRowIdxOnScrn - this.startCnt <= this.pageSize && this.firstRowIdxOnScrn >= this.pageSize)
                        || this.endCnt - 1 - this.firstRowIdxOnScrn <= this.pageSize && this.endCnt != this.rows.length) {
                        
                        this.reRenderChartWhenScrollDone(scrl.origin);
                        setChartTableHeight.call(this);
                    }
                }
            },

            onScrollMoved: function onScrollMoved(evt) {
                hideTooltipGlobal.call(this);
                if (this.isTreeMode) {
                    
                    if (hasScrollDownPast(evt.y)) {
                        this._leftChart.hideDockedHeader();
                        if (this._rightChart) {
                            this._rightChart.hideDockedHeader();
                        }
                    } else {
                        this._leftChart.showDockedHeader();
                        if (this._rightChart) {
                            this._rightChart.showDockedHeader();
                        }
                    }

                    var rowOffsetHeight = this.rowOffsetHeight;
                    this.firstRowIdxOnScrn = this.startCnt + parseInt(evt.y / rowOffsetHeight);

                    var currPos = evt.y;
                    var lastPos = this.lastScrollPosition.y;
                    if (lastPos > currPos) {
                        while ((lastPos -= rowOffsetHeight) > currPos) {
                            this.updateDockedHeadersByOneRow(lastPos, true);
                        }
                        this.updateDockedHeadersByOneRow(currPos);
                    } else {
                        while ((lastPos += rowOffsetHeight) < currPos) {
                            this.updateDockedHeadersByOneRow(lastPos, true);
                        }
                        this.updateDockedHeadersByOneRow(currPos);
                    }

                    
                }
            },

            initDockedHeaders: function initDockedHeaders() {
                this._leftChart.initDHs();
                if (this._rightChart) {
                    this._rightChart.initDHs();
                }

                this.clearDockedHeader();

                var rowIdx = 0;
                var rowIdxList = [];

                var currRow = getRowAtIdx.call(this, rowIdx);
                while (currRow && currRow.treeNode.needExpand) {
                    rowIdxList.push(rowIdx);
                    currRow = getRowAtIdx.call(this, ++rowIdx);
                }

                this.addRowsToDH(rowIdxList);

                
                this.lastFirstRowIdxOnScrn = rowIdx;
                this.lastScrollPosition = {x: 0, y: 0};
                this.dockedHeaderStatus = NO_REPLACE;
            },

            clearDockedHeader: function clearDockedHeader() {
                this.removeRowsFromDH(this.dockedHeaderRows.length);
                this.removeChildrenForDHReplaceTable();
            },

            reBuildDH: function reBuildDH(level) {
                this.clearDockedHeader();

                var rows = this.rows;
                var rowIdxToCheck = this.firstRowIdxOnScrn + level;
                if (rowIdxToCheck < 0 || rowIdxToCheck >= rows.length) {
                    return;
                }
                var treeNodeToCheck = rows[rowIdxToCheck].treeNode;

                if (treeNodeToCheck.level > level) {
                    var rowIdxList = [];
                    for (var i = 0; i <= level; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    this.addRowsToDH(rowIdxList);
                } else if (treeNodeToCheck.level == level) {
                    var rowIdxList = [];
                    for (var i = 0; i < level; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    rowIdxList.push(treeNodeToCheck.rowIdx);
                    this.addRowsToDH(rowIdxList);
                } else if (treeNodeToCheck.level < level) {
                    var preSiblingTreeNode = getPreSiblingTreeNode(this.tree, treeNodeToCheck.treePath);
                    while (!preSiblingTreeNode) {
                        rowIdxToCheck--;
                        var treeNodeToCheck = rows[rowIdxToCheck].treeNode;
                        preSiblingTreeNode = getPreSiblingTreeNode(this.tree, treeNodeToCheck.treePath);
                    }
                    var rowIdxList = [];
                    for (var i = 0; i < treeNodeToCheck.level; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    rowIdxList.push(preSiblingTreeNode.rowIdx);

                    var dHCount = treeNodeToCheck.rowIdx - this.firstRowIdxOnScrn;
                    rowIdxToCheck--;
                    var treeNodeToCheck = rows[rowIdxToCheck].treeNode;
                    for (var i = rowIdxList.length; i < dHCount; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    this.addRowsToDH(rowIdxList);
                }

                this.dockedHeaderStatus = NO_REPLACE;
            },

            updateDockedHeadersByOneRow: function updateDHBOR(yPos, onlyUpdateStatus) {
                var scroller = this.getChartWithScrollBar()._scroller;
                if (!scroller.vScroll || yPos > scroller.offset.y.end || yPos < 0) {
                    
                    return;
                }

                var lastDockedHeaderRow;

                var currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                this.firstRowIdxOnScrn = currFirstRow.rowIdx - this.dockedHeaderRows.length;
                

                if (this.dockedHeaderStatus == IN_REPLACE) {
                    var hasReplacedRowCount = this.firstRowIdxOnScrn - this.replacingStartRowIdx;
                    if (hasReplacedRowCount >= 0) {
                        if (hasReplacedRowCount < this.needReplaceCount) {
                            lastDockedHeaderRow = this.dockedHeaderRows[this.dockedHeaderRows.length - 1];
                            if (this.firstRowIdxOnScrn > this.lastFirstRowIdxOnScrn) {
                                

                                
                                this.removeChildrenForDHReplaceTable();
                                this.shiftDockedHeaderWithRow(0, onlyUpdateStatus);

                                if (lastDockedHeaderRow) {
                                    this.removeRowsFromDH(1, true);
                                }
                            } else if (this.firstRowIdxOnScrn < this.lastFirstRowIdxOnScrn) {
                                
                                
                                this.dockedHeaderStatus = NO_REPLACE;

                                this.moveRowFromDHRplcTableToDH();

                                
                                currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                            }
                            this.shiftDockedHeaderWithRow(-currFirstRow.pastOffset, onlyUpdateStatus);
                        } else {
                            
                            this.dockedHeaderStatus = NO_REPLACE;

                            
                            this.removeChildrenForDHReplaceTable();
                            this.shiftDockedHeaderWithRow(0, onlyUpdateStatus);

                            
                            currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                        }
                    } else {
                        
                        this.dockedHeaderStatus = NO_REPLACE;

                        
                        this.moveRowFromDHRplcTableToDH();

                        
                        currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                    }

                }

                if (this.dockedHeaderStatus == NO_REPLACE && currFirstRow.treeNode) {
                    var currLevel = currFirstRow.treeNode.level;
                    lastDockedHeaderRow = this.dockedHeaderRows[this.dockedHeaderRows.length - 1];
                    var lastLevel = lastDockedHeaderRow ? lastDockedHeaderRow.treeNode.level : -1;
                    if (yPos > this.lastScrollPosition.y) {
                        
                        if (currLevel <= lastLevel) {
                            
                            if (lastDockedHeaderRow) {
                                this.removeRowsFromDH(1, true);
                            }
                            this.replacingRowTreeNode = currFirstRow.treeNode;
                            this.replacingStartRowIdx = this.firstRowIdxOnScrn;
                            this.needReplaceCount = lastLevel - currLevel + 1;
                            this.dockedHeaderStatus = IN_REPLACE;
                            
                            this.shiftDockedHeaderWithRow(-currFirstRow.pastOffset, onlyUpdateStatus);
                        } else if (currLevel > lastLevel) {
                            var currRowIdx = currFirstRow.rowIdx;
                            var rowIdxList = [];
                            var currRowTreeNode = currFirstRow.treeNode;
                            while (currRowTreeNode.needExpand) {
                                
                                
                                rowIdxList.push(currRowIdx);
                                
                                currRowTreeNode = getRowAtIdx.call(this, ++currRowIdx).treeNode;
                            }
                            this.addRowsToDH(rowIdxList);

                            

                        }
                    } else if (yPos < this.lastScrollPosition.y) {
                        
                        if (currLevel == lastLevel) {

                            var addedTreeNode = currFirstRow.treeNode.preSibling;
                            var currRowIdx = currFirstRow.rowIdx;
                            var rowCount = 0;
                            while (!addedTreeNode) {
                                
                                rowCount++;
                                
                                currFirstRow = getRowAtIdx.call(this, --currRowIdx);
                                addedTreeNode = currFirstRow && currFirstRow.treeNode.preSibling;
                            }
                            this.removeRowsFromDH(rowCount);

                            
                            lastDockedHeaderRow = this.dockedHeaderRows[this.dockedHeaderRows.length - 1];
                            if (lastDockedHeaderRow) {
                                this.removeRowsFromDH(1);
                            }

                            if (addedTreeNode.needExpand) {
                                var rowIdxList = [addedTreeNode.rowIdx];
                                this.addRowsToDH(rowIdxList, true);
                            } else {
                                
                            }

                            this.replacingStartRowIdx = this.firstRowIdxOnScrn;
                            this.replacingRowTreeNode = addedTreeNode;

                            this.needReplaceCount = 1;
                            this.dockedHeaderStatus = IN_REPLACE;
                            var pastOffset = yPos % this.rowOffsetHeight;
                            
                            this.shiftDockedHeaderWithRow(-pastOffset, onlyUpdateStatus);

                        } else if (currLevel > lastLevel + 1) {
                            var addedTreeNode = getParentTreeNodeAtLevel(this.tree, currFirstRow.treeNode.treePath, lastLevel + 1);

                            var rowIdxList = [addedTreeNode.rowIdx];
                            this.addRowsToDH(rowIdxList, true);

                            this.replacingStartRowIdx = this.firstRowIdxOnScrn;
                            this.replacingRowTreeNode = addedTreeNode;
                            this.needReplaceCount = currLevel - lastLevel - 1;
                            this.dockedHeaderStatus = IN_REPLACE;
                            
                            this.shiftDockedHeaderWithRow(-currFirstRow.pastOffset, onlyUpdateStatus);
                        }

                    }
                }
                this.lastScrollPosition.y = yPos;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;
            },

            checkParentBeforeAddToDH: function checkParentBeforeAddToDH(addedRowIdx) {
                var rowInfo = this.rows[addedRowIdx];
                var treeNode = rowInfo && rowInfo.treeNode;

                var rowCount = this.dockedHeaderRows.length;
                if (rowCount != treeNode.level) {
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                }

            },

            addRowsToDH: function addRowsToDH(rowIdxList, toDHReplacingTable) {
                var rows = this.rows;
                var rowCount = rowIdxList.length;
                if (rowCount <= 0) {
                    return;
                }

                var addTo = null;
                if (toDHReplacingTable) {
                    addTo = this.dockedHeaderReplaceRows;
                } else {
                    addTo = this.dockedHeaderRows;
                    
                }

                for (var i = 0; i < rowCount; i++) {
                    var rowIdx = rowIdxList[i];
                    var rowInfo = rows[rowIdx];
                    addTo.push({rowIdx: rowIdx, treeNode: rowInfo.treeNode, rowRef: this.popFromReusePool()});
                }

                this._leftChart.addRowsToDH(rowCount, toDHReplacingTable);
                if (this._rightChart) {
                    this._rightChart.addRowsToDH(rowCount, toDHReplacingTable);
                }
            },

            removeRowsFromDH: function removeRowsFromDH(rowCount, moveToReplacingTable) {
                
                if (this._leftChart) {
                    this._leftChart.removeRowsFromDH(rowCount, moveToReplacingTable);
                }

                if (this._rightChart) {
                    this._rightChart.removeRowsFromDH(rowCount, moveToReplacingTable);
                }

                if (rowCount > this.dockedHeaderRows.length) {
                    
                    rowCount = this.dockedHeaderRows.length;
                }
                
                for (; rowCount > 0; rowCount--) {
                    var row = this.dockedHeaderRows.pop();
                    if (!moveToReplacingTable) {
                        this.pushRowRefToReusePool(row);
                    } else {
                        
                        this.dockedHeaderReplaceRows.push(row);
                    }

                }
            },

            moveRowFromDHRplcTableToDH: function moveRowFromDHRplcTableToDH() {
                this._leftChart.moveRowFromDHRplcTableToDH();
                if (this._rightChart) {
                    this._rightChart.moveRowFromDHRplcTableToDH();
                }
                this.shiftDockedHeaderWithRow(0);
                
                var row = this.dockedHeaderReplaceRows.pop();
                
                
                
                
                if (row) {
                    this.dockedHeaderRows.push(row);
                }

                

                
            },

            removeChildrenForDHReplaceTable: function removeChildrenForDHReplaceTable() {
                if (this._leftChart) {
                    this._leftChart.removeChildrenForDHReplaceTable();
                }
                if (this._rightChart) {
                    this._rightChart.removeChildrenForDHReplaceTable();
                }

                var rowCount = this.dockedHeaderReplaceRows.length;
                for (; rowCount > 0; rowCount--) {
                    var row = this.dockedHeaderReplaceRows.pop();
                    this.pushRowRefToReusePool(row);
                }
            },

            pushRowRefToReusePool: function pushRowRefToReusePool(row) {
                if (!row) {
                    return;
                }
                var rowRef = row.rowRef;
                this.rowsReusePool.push(rowRef);
                row.rowRef = {};
            },

            shiftDockedHeaderWithRow: function shiftDockedHeaderWithRow(pastOffset, onlyUpdateStatus) {

                if (onlyUpdateStatus) {
                    return;
                }
                if (this._leftChart) {
                    this.utils.translateCSS(0, pastOffset, 0, this._leftChart.dockedHeaderReplaceDiv.firstChild);
                }
                if (this._rightChart) {
                    this.utils.translateCSS(0, pastOffset, 0, this._rightChart.dockedHeaderReplaceDiv.firstChild);
                }

            },

            init: function init(props) {
                this._super(props);
            },

            initFromVisProps: function (vp) {
                initProp.call(this);
                var propValue = vp ? vp : {},
                    sparklineProps = this.sparklineProps,
                    barProps = this.barProps,
                    bulletProps = this.bulletProps,
                    otherProps = this.otherProps;

                this.isTreeMode = getBoolValue(propValue.itd);

                if (propValue.lsh) {
                    sparklineProps.mbShow = (propValue.lsh === "true");
                }
                if (propValue.lap) {
                    sparklineProps.mbAllPoints = (propValue.lap === "true");
                }
                if (propValue.lep) {
                    sparklineProps.mbEndPoints = (propValue.lep === "true");
                }
                if (propValue.lrl) {
                    sparklineProps.mbRefLine = (propValue.lrl === "true");
                }
                if (propValue.lra) {
                    sparklineProps.mbRefArea = (propValue.lra === "true");
                }
                if (propValue.lmsh) {
                    sparklineProps.mbAssMetric = (propValue.lmsh === "true");
                }
                if (propValue.let) {
                    sparklineProps.mbShowTooltip = (propValue.let === "true");
                }
                if (propValue.llsc) {
                    sparklineProps.mwSeriesLineCol = convertToColor(propValue.llsc);
                }
                if (propValue.lrlc) {
                    sparklineProps.mwRefLineCol = convertToColor(propValue.lrlc);
                }
                if (propValue.lrac) {
                    sparklineProps.mwRefAreaCol = convertToColor(propValue.lrac);
                }
                if (propValue.lh) {
                    sparklineProps.mstrHeader = propValue.lh;
                }
                if (propValue.lam) {
                    sparklineProps.mstrAssMetric = propValue.lam;
                }

                if (propValue.bsg) {
                    barProps.mbShow = (propValue.bsg === "true");
                }
                if (propValue.bl) {
                    barProps.mbShowLegend = (propValue.bl === "true");
                }
                if (propValue.brl) {
                    barProps.mbRefLine = (propValue.brl === "true");
                }
                if (propValue.bet) {
                    barProps.mbShowTooltip = (propValue.bet === "true");
                }
                if (propValue.bpv) {
                    barProps.mwPosCol = convertToColor(propValue.bpv);
                }
                if (propValue.bnv) {
                    barProps.mwNegCol = convertToColor(propValue.bnv);
                }
                if (propValue.brlc) {
                    barProps.mwRefLineCol = convertToColor(propValue.brlc);
                }
                if (propValue.bh) {
                    barProps.mstrHeader = propValue.bh;
                }

                if (propValue.gsh) {
                    bulletProps.mbShow = (propValue.gsh === "true");
                }
                if (propValue.grl) {
                    bulletProps.mbRefLine = (propValue.grl === "true");
                }
                if (propValue.gra) {
                    bulletProps.mbRefBands = (propValue.gra === "true");
                }
                if (propValue.gl) {
                    bulletProps.mbShowLegend = (propValue.gl === "true");
                }
                if (propValue.gmsh) {
                    bulletProps.mbAssMetric = (propValue.gmsh === "true");
                }
                if (propValue.gia) {
                    bulletProps.mbInvertAxis = (propValue.gia === "true");
                }
                if (propValue.get) {
                    bulletProps.mbShowTooltip = (propValue.get === "true");
                }
                if (propValue.gmm) {
                    bulletProps.mfMinValue = parseFloat(propValue.gmm);
                }

                if (propValue.ggc) {
                    bulletProps.mwPosCol = convertToColor(propValue.ggc);
                }
                if (propValue.gnv) {
                    bulletProps.mwNegCol = convertToColor(propValue.gnv);
                }
                if (propValue.grlc) {
                    bulletProps.mwRefLineCol = convertToColor(propValue.grlc);
                }
                if (propValue.gpc) {
                    bulletProps.mwBand1 = convertToColor(propValue.gpc);
                }
                if (propValue.grc) {
                    bulletProps.mwBand2 = convertToColor(propValue.grc);
                }
                if (propValue.gsc) {
                    bulletProps.mwBand3 = convertToColor(propValue.gsc);
                }
                if (propValue.gh) {
                    bulletProps.mstrHeader = propValue.gh;
                }
                if (propValue.gtam) {
                    bulletProps.mstrAssMetric = propValue.gtam;
                }
                if (propValue.glt) {
                    bulletProps.mstrBand1 = propValue.glt;
                }
                if (propValue.gmt) {
                    bulletProps.mstrBand2 = propValue.gmt;
                }
                if (propValue.ght) {
                    bulletProps.mstrBand3 = propValue.ght;
                }

                
                
                
                if (propValue.wa) {
                    var value = parseFloat(propValue.wa);
                    if (propValue.wa.indexOf("%")) {
                        value /= 100; 
                    }
                    otherProps.mfBkgOpacity = value;
                }
                if (propValue.metkpi) {
                    otherProps.mnMetricsPerKPI = parseInt(propValue.metkpi);
                }
                if (propValue.hch) {
                    otherProps.mbHideColHeaders = (propValue.hch === "true");
                }
                if (propValue.htc) {
                    otherProps.mbHideTextColumns = (propValue.htc === "true");
                }
                if (propValue.ll) {
                    otherProps.mbLockLayout = (propValue.ll === "true");
                }
                if (propValue.gam) {
                    otherProps.mbShowForHiddenGraphs = (propValue.gam === "true");
                }
                if (propValue.igf) {
                    otherProps.mbInheritFromGridGraph = (propValue.igf === "true");
                }
                if (propValue.scm) {
                    otherProps.mbInSingleColumnMode = (propValue.scm === "true");
                }
                if (propValue.cid) {
                    otherProps.mpColumnIDs = propValue.cid.split(",");
                }
                if (propValue.tcid) {
                    otherProps.mpColumnIDsInTreeMode = propValue.tcid.split(",");
                }
                
                
                
                if (propValue.co) {
                    otherProps.mpColumnPositions = propValue.co.split(",");
                }
                if (propValue.sc) {
                    otherProps.mpSortKey = propValue.sc;
                }
                if (propValue.so) {
                    otherProps.mbSortDescend = (propValue.so !== "false");
                }

                if (propValue.rh) {
                    otherProps.mRowHeight = parseFloat(propValue.rh);
                }

                
                otherProps.mRowHeight = otherProps.mRowHeight > 27 ? otherProps.mRowHeight : 27;

                setDimensionWithDPI.call(this);

            },

            preBuildRendering: function preBR() {
                console.log("in preb in MC");
                if (this._super) {
                    this._super();
                }

                var m = this.model;

                if (!m) {
                    m.err = mstrmojo.desc(8426, 'No model provided');
                    return;
                }

                
                this.isAndroidTab = $D.isAndroid ? !!mstrApp.isTablet() : false;

                this.isAndroidPhone = $D.isAndroid && !this.isAndroidTab;

                var propValue = m.vp || {};

                var isReport = this.controller && (this.controller instanceof mstrmojo.android.controllers.XtabController);
                var fullScreen = this.isFullScreenWidget || isReport;
                
                this.enableSmoothScroll = ( this.isAndroidPhone && fullScreen) ? true : getBoolValue(propValue.ss);

                

                if (propValue.mcs) {
                    this.metricColumnsSpacing = parseInt(propValue.mcs);
                } else {
                    this.metricColumnsSpacing = this.isAndroidPhone ? (mstrApp.isLandscape() ? NORMAL : COMPACT) : -1;
                }

                if (this.enableSmoothScroll) {
                    this.leftWidth = this.getWidth() / 3;
                    this.rightWidth = this.getWidth() / 3 * 2;
                } else {
                    this.leftWidth = this.getWidth();
                    this.rightWidth = 0;
                    this.scrollerConfig.hScroll = false;
                }
            },

            buildRendering: function () {
                var that = this;
                var backup = mstrmojo.string.apply;
                mstrmojo.string.apply = function (tmpl, obj) {
                    if (!tmpl) {
                        return "";
                    }
                    return tmpl.replace(/\{([^\}]+)\}/gm,
                        function tokenRepl(token, prop) {
                            var s = token.replace(/@/g, 'that.');
                            var res = eval(s);
                            return res === undefined ? '' : res;
                        }
                    );
                };

                if (this._super) {
                    this._super();
                }

                mstrmojo.string.apply = backup;
            },

            
            buildRows: function buildRows() {
                if (this.rowsNeedRebuild) {
                    if (this.isTreeMode) {
                        
                        this.rows = getTreeNodeRows.call(this);
                    } else {
                        buildNonTreeRows.call(this);
                    }

                    this.rowsNeedRebuild = false;
                }
            },

            pushToReusePool: function pushToReusePool(beginCnt, endCnt) {
                var bCnt = beginCnt != undefined ? beginCnt : this.startCnt;
                var eCnt = endCnt != undefined ? endCnt : this.endCnt;

                var rowInfo = null;
                for (var i = bCnt; i < eCnt; i++) {
                    rowInfo = this.rows[i];
                    this.rowsReusePool.push(rowInfo.rowRef);
                    rowInfo.rowRef = {};
                }
            },

            popFromReusePool: function popFromReusePool() {
                var rowRef = this.rowsReusePool.pop();
                return rowRef || {};
            },

            
            reRenderChart: function reRenderChart(scrollTo, rowCount, adjustOffsetY) {

                this.pushToReusePool();

                this.buildRows();

                var rowOffsetHeight = this.rowOffsetHeight;

                if (!rowCount) {
                    rowCount = 0;
                }

                this.firstRowIdxOnScrn = parseInt(this.startCnt + scrollTo.y / rowOffsetHeight) - rowCount;
                this.getCurrRenderRowCount();

                if (adjustOffsetY == undefined) {
                    adjustOffsetY = scrollTo.y % rowOffsetHeight;
                }
                scrollTo.y = (this.firstRowIdxOnScrn - this.startCnt) * rowOffsetHeight + adjustOffsetY;

                
                this.lastScrollPosition.y = scrollTo.y;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;

                
                var rows = this.rows;
                for (var i = this.startCnt; i < this.endCnt; i++) {
                    rows[i].rowRef = this.popFromReusePool();
                }

                if (!this.enableSmoothScroll) {
                    this._leftChart.reRenderRows(scrollTo);
                } else {
                    this._leftChart.reRenderRows(scrollTo);
                    this._rightChart.reRenderRows(scrollTo);
                }
            },

            reRenderChartWhenScrollDone: function reRenderChartwsd(scrollTo) {

                var oldStartCnt = this.startCnt;
                var oldEndCnt = this.endCnt;

                var rowOffsetHeight = this.rowOffsetHeight;
                this.firstRowIdxOnScrn = parseInt(this.startCnt + scrollTo.y / rowOffsetHeight);
                this.getCurrRenderRowCount();

                var firstRowToRemove, lastRowToRemove, firstRowToRender, lastRowToRender;
                if (this.startCnt < oldEndCnt && this.startCnt > oldStartCnt) {
                    firstRowToRemove = oldStartCnt;
                    lastRowToRemove = this.startCnt;
                    firstRowRemain = this.startCnt;
                    lastRowRemain = oldEndCnt;
                    firstRowToRender = oldEndCnt;
                    lastRowToRender = this.endCnt;

                } else if (oldStartCnt < this.endCnt && oldStartCnt > this.startCnt) {
                    firstRowToRemove = this.endCnt;
                    lastRowToRemove = oldEndCnt;
                    firstRowRemain = oldStartCnt;
                    lastRowRemain = this.endCnt;
                    firstRowToRender = this.startCnt;
                    lastRowToRender = oldStartCnt;
                } else {
                    firstRowToRemove = oldStartCnt;
                    lastRowToRemove = oldEndCnt;
                    firstRowRemain = 0;
                    lastRowRemain = 0;
                    firstRowToRender = this.startCnt;
                    lastRowToRender = this.endCnt;
                }

                
                
                
                

                this.pushToReusePool(firstRowToRemove, lastRowToRemove);

                scrollTo.y = (this.firstRowIdxOnScrn - this.startCnt) * rowOffsetHeight + scrollTo.y % rowOffsetHeight;

                
                this.lastScrollPosition.y = scrollTo.y;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;

                
                var rows = this.rows;
                for (var i = firstRowToRender; i < lastRowToRender; i++) {
                    rows[i].rowRef = this.popFromReusePool();
                }

                if (!this.enableSmoothScroll) {
                    this._leftChart.reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender);
                } else {
                    this._leftChart.reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender);
                    this._rightChart.reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender);
                }
            },

            reRenderChartWithAnchor: function reRenderChartWithAnchor(anchorRowTreeNode, anchorRowIdxOnScrn) {

                this.pushToReusePool();

                this.buildRows();

                var rowOffsetHeight = this.rowOffsetHeight;

                var anchorRowIdx = -1;
                for (var i = 0; i < this.rows.length; i++) {
                    if (this.rows[i].treeNode.treePath == anchorRowTreeNode.treePath) {
                        anchorRowIdx = i;
                        break;
                    }
                }

                this.firstRowIdxOnScrn = anchorRowIdx - anchorRowIdxOnScrn;
                if (this.firstRowIdxOnScrn < 0) {
                    this.firstRowIdxOnScrn = 0;
                }

                this.getCurrRenderRowCount();

                scrollTo.y = (this.firstRowIdxOnScrn - this.startCnt) * rowOffsetHeight;

                
                this.lastScrollPosition.y = scrollTo.y;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;

                
                var rows = this.rows;
                for (var i = this.startCnt; i < this.endCnt; i++) {
                    rows[i].rowRef = this.popFromReusePool();
                }

                if (!this.enableSmoothScroll) {
                    this._leftChart.reRenderRows(scrollTo);
                } else {
                    this._leftChart.reRenderRows(scrollTo);
                    this._rightChart.reRenderRows(scrollTo);
                }
            },

            supportsIncFetch: false,

            pageSize: 0,

            getCurrRenderRowCount: function getCRRC() {

                var maxRenderRowCount = this.pageSize * PAGE_COUNT;

                if (this.rows.length <= maxRenderRowCount) {
                    this.partialRender = false;
                    this.startCnt = 0;
                    this.endCnt = this.rows.length;
                } else {
                    this.partialRender = true;
                    this.startCnt = Math.round(this.firstRowIdxOnScrn - this.pageSize * (PAGE_COUNT - 1) / 2)
                    if (this.startCnt < 0) {
                        this.startCnt = 0;
                    }
                    this.endCnt = this.startCnt + maxRenderRowCount;
                    if (this.endCnt > this.rows.length) {
                        this.endCnt = this.rows.length;
                    }
                }
                
            },

            getChartWithScrollBar: function () {
                if (this.enableSmoothScroll) {
                    return this._rightChart;
                } else {
                    return this._leftChart;
                }
            },

            updateWindowRatio: function updateWindowRatio() {
                
                var chart = this.getChartWithScrollBar(),
                    scroller = chart._scroller;

                scroller.chartTableRenderRatio = (this.endCnt - this.startCnt) / this.rows.length;
                scroller.topUnRenderedRatio = this.startCnt / this.rows.length;
                
                chart.updateScroller();

            },

            initValues: function initValues() {
                
                
                

                this.prevSelected = {
                    mrow: -2,
                    mcol: -1
                };

                if (this.isTreeMode) {
                    initTree.call(this);
                }

                this.treeColumnIdx = -1;

                
                this.minPageSize = Math.ceil((this.getHeight() / this.otherProps.mRowHeight) * 3 / PAGE_COUNT);
                this.pageSize = this.minPageSize;

                this.rowsNeedRebuild = true;
                this.rows = [];
                this.dockedHeaderRows = [];
                this.dockedHeaderReplaceRows = [];
                this.rowsReusePool = [];
                this.unselectedRemainCells = [];

                this.errorMsg.style.display = 'none';

                
                
                
                
                
            },

            postBuildRendering: function postBR() {

                var me = this,
                    model = me.model;
                var err = model.err || model.eg;

                if (err) {
                    me.renderErrorMessage(err);
                    return;
                }

                if (me.controller && me.controller.view && me.controller.view.model) {
                    if (!me.mcStatus && me.controller.view.model.mcStatus) {
                        
                        me.mcStatus = me.controller.view.model.mcStatus;
                    }
                }

                me.initValues();

                me.highlightEntireRow = me.isTreeMode || me.isAllAttrSelectable;

                getUITheme.call(me);

                convertDataToModels.call(me);

                if (me.otherProps.mbInheritFromGridGraph) {
                    me.selectedClass = "sc_" + me.model.k; 
                } else {
                    me.selectedClass = "";
                }

                err = model.err || model.eg;

                if (err) {
                    me.renderErrorMessage(err);
                    return;
                }

                if (this._super) {
                    this._super();
                }

                
                me.renderLegend();

                me.getCurrRenderRowCount();

                me.restoreMCStatus();

                if (!me.enableSmoothScroll) {
                    me.itemsContainerNode.style.display = 'none';
                    var props = {
                        placeholder: me.leftChart,
                        colInfos: me.colInfos,
                        theme: me.theme,
                        isTreeMode: me.isTreeMode,
                        showMinLabel: me.showMinLabel,
                        width: me.leftWidth + "px",
                        height: (me.getHeight() - me.legendHeight) + "px",
                        textSpan: me.textSpan,
                        textCanvas: me.textCanvas,
                        headerCssClass: me.headerCssClass,
                        valueCssClass: me.valueCssClass,
                        isAndroidTab: me.isAndroidTab,
                        widget: me,
                        treeColumnIdx: me.treeColumnIdx,
                        backgroundColor: me.backgroundColor,
                        domRefName: LEFT_CHART_ROW,
                        showScrollbars: true
                    };
                    var w = new mstrmojo.VisMicroChartTable(props);
                    w.render();
                    me._leftChart = w;
                    w.parent = me;

                    me.replaceScrollerUpdate(w);
                } else {
                    var props = {
                        placeholder: me.leftChart,
                        colInfos: me.colInfos.slice(0, this.attrColumnCount),
                        theme: me.theme,
                        isTreeMode: me.isTreeMode,
                        showMinLabel: me.showMinLabel,
                        width: me.leftWidth + "px",
                        height: (me.getHeight() - me.legendHeight) + "px",
                        textSpan: me.textSpan,
                        textCanvas: me.textCanvas,
                        headerCssClass: me.headerCssClass,
                        valueCssClass: me.valueCssClass,
                        isAndroidTab: me.isAndroidTab,
                        widget: me,
                        treeColumnIdx: me.treeColumnIdx,
                        backgroundColor: me.backgroundColor,
                        domRefName: LEFT_CHART_ROW,
                        showScrollbars: false,
                        zIndex: 1
                    };
                    var w = new mstrmojo.VisMicroChartTable(props);
                    w.render();
                    me._leftChart = w;
                    w.parent = me;
                    me.leftChart = w.domNode;

                    

                    var props = {
                        placeholder: me.rightChart,
                        colInfos: me.colInfos.slice(this.attrColumnCount),
                        theme: me.theme,
                        isTreeMode: me.isTreeMode,
                        showMinLabel: me.showMinLabel,
                        width: me.rightWidth + "px",
                        height: (me.getHeight() - me.legendHeight) + "px",
                        textSpan: me.textSpan,
                        textCanvas: me.textCanvas,
                        headerCssClass: me.headerCssClass,
                        valueCssClass: me.valueCssClass,
                        isAndroidTab: me.isAndroidTab,
                        widget: me,
                        treeColumnIdx: me.treeColumnIdx,
                        backgroundColor: me.backgroundColor,
                        domRefName: RIGHT_CHART_ROW,
                        showScrollbars: true
                    };
                    var w2 = new mstrmojo.VisMicroChartTable(props);
                    w2.render();
                    me._rightChart = w2;
                    w2.parent = me;
                    me.rightChart = w2.domNode;

                    me.replaceScrollerUpdate(w2);

                    if (this.theme == DEFAULT_LIGHT_THEME || this.theme == CUSTOM_LIGHT_THEME) {
                        me.dropShadowDiv.style.backgroundImage = "-webkit-gradient(linear, left top, right top, color-stop(0, rgba(0,0,0,0.25)), color-stop(1, rgba(0,0,0,0)))";
                    } else {
                        me.dropShadowDiv.style.backgroundImage = "-webkit-gradient(linear, left top, right top, color-stop(0, rgba(0,0,0,0.5)), color-stop(1, rgba(0,0,0,0)))";
                    }

                    w2.addSyncScroller(w);
                    w.addSyncScroller(w2);

                    me.scrollerConfig.scrollEl = me.rightChart;
                    me.updateScroller();

                    var scrollTo = null;
                    if (this.mcStatus && this.mcStatus.hScrollPos != undefined) {
                        var xPos = Math.min(this.mcStatus.hScrollPos * this.rightWidth, this.rightWidth + this.leftWidth - this.getWidth());
                        scrollTo = this._scroller.origin = {
                            x: xPos,
                            y: 0
                        }
                    }
                    setScrollerPosition.call(me, scrollTo);

                    
                    var headerHeight = Math.max(me._leftChart.headerTableOffsetHeight, me._rightChart.headerTableOffsetHeight);
                    me._leftChart.headerTable.style.height = headerHeight + "px";
                    me._rightChart.headerTable.style.height = headerHeight + "px";
                    me._leftChart.updateHeaderTableOffsetH();
                    me._rightChart.updateHeaderTableOffsetH();

                }
                me.rowOffsetHeight = (me.otherProps.mbHideTextColumns && this.enableSmoothScroll) ? w2.rowOffsetHeight : w.rowOffsetHeight;

                if (me.isTreeMode) {
                    if (me.mcStatus && me.mcStatus.dHRowIdxList) {
                        
                        me._leftChart.initDHs();
                        if (me._rightChart) {
                            me._rightChart.initDHs();
                        }
                        me.addRowsToDH(me.mcStatus.dHRowIdxList);
                        if (me.mcStatus.dHReplaceRowIdxList.length > 0) {
                            me.addRowsToDH(me.mcStatus.dHReplaceRowIdxList, true);
                            var pastOffset = me.mcStatus.scrollTo.y % me.rowOffsetHeight;
                            
                            me.shiftDockedHeaderWithRow(-pastOffset);
                        }

                    } else {
                        me.initDockedHeaders();
                    }
                }

                
                me.removeMCStatus();

                me.getDefaultHighlightRow();
                me.updateSelectedStatus(me.tree);
                me.updateHighlightForCurrRenderRows();

                me.chartTableMaxHeight = me.getHeight() - me._leftChart.headerTableOffsetHeight;
                if (me.legendDis) {
                    me.chartTableMaxHeight -= me.legendHeight;
                }

                
                
                me.pageSize = Math.max(Math.min(parseInt(me.chartTableMaxHeight / me.rowOffsetHeight) + 1, 20), me.minPageSize);
                setChartTableHeight.call(me);

                
                var xtabModel = me.xtabModel,
                    docModel = (xtabModel && xtabModel.docModel);
                if (docModel) {
                    me._infoWClosedListener = me.xtabModel.docModel.attachEventListener('infoWindowClosed', this.id, function (evt) {
                        var infoWindowK = evt.psKey;
                        
                        if (!me.hasNonifwTarget && me.selectorTargets && me.selectorTargets[infoWindowK]) {

                            window.setTimeout(function () {
                                if (me.isTreeMode) {
                                    var treeNode = me.lastSelectedObj[me.lastSelectedObj.length - 1];
                                    if(treeNode && treeNode.treePath){
                                        
                                        me.closedIfwAttr = treeNode.treePath;
                                        me.currSelectedObj = [];
                                        
                                        me.updateSelectedStatus(me.tree);
                                        me.updateHighlightForCurrRenderRows();
                                        me.lastSelectedObj = [];
                                    }
                                } else {
                                    if (me.isAllAttrSelectable) {
                                        
                                        me.closedIfwAttr = me.prevSelected.mrow;

                                        me.clearPreHighlightRowStatus();
                                        
                                        me.updateUnselectedRemainCells();

                                        
                                        me.updateSelectedStatus(me.tree);
                                        me.updateHighlightForCurrRenderRows();
                                    } else {
                                        var mcol = me.prevSelected && me.prevSelected.mcol;
                                        var id = me.colInfos[mcol] && me.colInfos[mcol].order;
                                        id = id.split(":")[0];

                                        
                                        me.closedIfwAttr = id;

                                        var ctlMatrix = me.ctlMatrix[id];
                                        var ctlMatrixCG = me.ctlMatrix[id + ":CG"];
                                        var selectedIdxBackup = ctlMatrix.selectedIdx;
                                        var selectedIdxCGBackup = ctlMatrixCG && ctlMatrixCG.selectedIdx;
                                        ctlMatrix.selectedIdx = {};
                                        if (ctlMatrixCG) {
                                            ctlMatrixCG.selectedIdx = {};
                                        }

                                        
                                        me.updateSelectedStatus();
                                        me.updateHighlightForCurrRenderRows();

                                        ctlMatrix.selectedIdx = selectedIdxBackup;
                                        if (ctlMatrixCG) {
                                            ctlMatrixCG.selectedIdx = selectedIdxCGBackup;
                                        }
                                    }

                                }
                            }, 10);

                        }
                    });
                }

                this.renderTextTooltip();

                
                
            },

            renderTextTooltip: function renderTextTooltip() {
                
                var props = {
                    placeholder: this.textTooltip,
                    boundary: this.domNode
                };
                this._textTooltip = new mstrmojo.VisTextTooltip(props);
                this._textTooltip.render();

                this._textTooltip.toggle(false);
            },

            
            replaceScrollerUpdate: function replaceScrollerUpdate(chartTable) {

                chartTable._scroller.updateScrollBars = function updateScrollBars(viewportCoords, scrollBarContainerElement) {
                    var scrollEl = this.scrollEl;

                    
                    if (!this.showScrollbars || !scrollEl) {
                        
                        return;
                    }

                    var bars = this._scrollBarEls;

                    var chartTableRenderRatio = this.chartTableRenderRatio || 1;
                    var topUnRenderedRatio = this.topUnRenderedRatio || 0;

                    
                    if (!bars) {
                        var me = this;
                        bars = this._scrollBarEls = {
                            x: 'hScroll',
                            y: 'vScroll'
                        };

                        
                        $forEachHash(bars, function (scroll, axis) {
                            
                            if (me[scroll]) {
                                
                                var bar = document.createElement('div');
                                bar.className = 'mstrmojo-touch-scrollBar ' + axis + 'Axis';

                                
                                (scrollBarContainerElement || scrollEl.parentNode).appendChild(bar);
                                bars[axis] = bar;
                            } else {
                                
                                delete bars[axis];
                            }
                        });
                    }

                    
                    if (!viewportCoords) {
                        
                        var parentNode = this.scrollEl.parentNode;
                        viewportCoords = {
                            top: 0,
                            right: parentNode.clientWidth,
                            bottom: parentNode.clientHeight,
                            left: 0
                        };
                    }

                    
                    var offset = 9,
                        scrollBarCoords = {
                            x: {
                                left: viewportCoords.left,
                                top: viewportCoords.bottom - offset,
                                x: viewportCoords.right - viewportCoords.left,
                                d: 'Width'
                            },
                            y: {
                                left: viewportCoords.right - offset,
                                top: viewportCoords.top,
                                x: viewportCoords.bottom - viewportCoords.top,
                                d: 'Height'
                            }
                        };

                    var me = this;
                    
                    $forEachHash(bars, function (bar, axis) {
                        var barStyle = bar.style,
                            coords = scrollBarCoords[axis],
                            dimension = coords.d,
                            parentNode = bar.parentNode,
                            x = coords.x;

                        
                        var left = coords.left,
                            top = coords.top + x * topUnRenderedRatio,
                            ratio = x / scrollEl['offset' + dimension] * chartTableRenderRatio,
                            length = Math.min(Math.round(x * ratio), x);

                        
                        bar.baseLeft = left;
                        bar.baseTop = top;
                        bar.ratio = ratio;
                        bar.viewportSize = $M.round(x * chartTableRenderRatio);
                        bar.length = length;

                        
                        barStyle.left = left + 'px';
                        barStyle.top = top + 'px';
                        barStyle[dimension.toLowerCase()] = length + 'px';

                        var isX = (axis === 'x'),
                            direction = isX ? 'hScroll' : 'vScroll';
                        if (me[direction]) {
                            
                            var origin = me.origin,
                                position = origin && origin[axis] || 0,
                                viewportSize = bar.viewportSize,
                                minScale = 6 / length,
                                minPosition = bar['base' + ((isX) ? 'Left' : 'Top')],
                                maxPosition = minPosition + viewportSize - length,
                                newPosition = $M.round(minPosition + (ratio * position));

                            
                            if (newPosition < minPosition) {
                                newPosition = minPosition - position;
                                length += position;
                            } else if (newPosition > maxPosition) {
                                var delta = (position - me.offset[axis].end) * ratio;
                                newPosition = $M.min(maxPosition + delta, viewportSize + minPosition - 6) - 1;
                                length -= delta;
                            }

                            
                            var v = 0,
                                translate = [v, v, v],
                                scale = [1, 1, 1],
                                idx = (isX) ? 0 : 1;

                            translate[idx] = (newPosition - minPosition);
                            scale[idx] = $M.min($M.max(length / bar.length, minScale), 1);

                            $D.translate(bar, translate[0], translate[1], translate[2], ' scale3d(' + scale.join(',') + ')');
                            

                        }
                    });
                }

            },

            setElementDimension: function setElementDimension(e, width) {
                var paddingWidth = 0;

                var compStyle = mstrmojo.css.getComputedStyle(e);
                if (compStyle.paddingLeft) {
                    paddingWidth += parseFloat(compStyle.paddingLeft);
                }
                if (compStyle.paddingRight) {
                    paddingWidth += parseFloat(compStyle.paddingRight);
                }

                e.style.width = (width - paddingWidth) + 'px';

            },

            setColorByTheme: function setColorByTheme() {
                var bulletProps = this.bulletProps;
                if (this.theme == DEFAULT_DARK_THEME) {
                    this.bandColor1 = "#494949";
                    this.bandColor2 = "#595959";
                    this.bandColor3 = "#727272";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = 2;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = "#00BDFF";
                } else if (this.theme == DEFAULT_LIGHT_THEME) {
                    this.bandColor1 = "#A5A5A5";
                    this.bandColor2 = "#B3B3B3";
                    this.bandColor3 = "#C4C4C4";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = 2;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = "#00BDFF";
                } else {
                    this.bandColor1 = bulletProps.mwBand1 || "#999999";
                    this.bandColor2 = bulletProps.mwBand2 || "#BBBBBB";
                    this.bandColor3 = bulletProps.mwBand3 || "#DEDEDE";

                    this.refLinePosColor = bulletProps.mwRefLineCol;
                    this.refLineNegColor = bulletProps.mwRefLineCol;
                    this.blueBarPosColor = bulletProps.mwPosCol;
                    this.blueBarNegColor = bulletProps.mwNegCol;
                }
            },

            renderLegend: function renderLgd() {
                var bulletProps = this.bulletProps;

                this.setColorByTheme();

                this.legendDis = this.showGauge && this.bulletProps.mbShowLegend;
                if (this.legendDis) {
                    this.legend.className += " " + this.valueCssClass;

                    
                    
                    

                    this.legend.style.display = "block";
                    this.legend.style.fontSize = Math.round(11 * zf) + "pt";
                    this.setElementDimension(this.legend, this.getWidth());

                    if (bulletProps.mstrBand1) {
                        this.legendLowFont.innerHTML = bulletProps.mstrBand1;
                    }
                    this.legendLowBand.style.backgroundColor = this.bandColor1;

                    if (bulletProps.mstrBand2) {
                        this.legendMidFont.innerHTML = bulletProps.mstrBand2;
                    }
                    this.legendMidBand.style.backgroundColor = this.bandColor2;

                    if (bulletProps.mstrBand3) {
                        this.legendHighFont.innerHTML = bulletProps.mstrBand3;
                    }
                    this.legendHighBand.style.backgroundColor = this.bandColor3;

                    var lowWidth = this.legendLow.offsetWidth,
                        midWidth = this.legendMid.offsetWidth,
                        highWidth = this.legendHigh.offsetWidth;

                    if (lowWidth + midWidth + highWidth > this.getWidth()) {
                        
                        if (lowWidth + midWidth > this.getWidth()) {
                            this.legendLow.style.width = this.width;
                            if (midWidth + highWidth > this.getWidth()) {
                                this.legendMid.style.width = this.width;
                                this.legendHigh.style.width = this.width;
                            } else {
                                this.legendMid.style.width = (this.getWidth() - highWidth) + "px";
                            }
                        } else {
                            this.legendLow.style.width = (this.getWidth() - midWidth) + "px";
                            this.legendHigh.style.width = this.width;
                        }
                    }
                    this.legendHeight = this.legend.firstChild.offsetHeight;
                    this.legend.style.height = this.legendHeight + "px";

                } else {
                    this.legend.style.display = "none";
                    this.legendHeight = 0;
                }
            },

            showChartTooltip: function showChartTooltip(touchedChart, touch) {
                var me = this;
                var wasNoTooltip = this.tooltip.style["display"] === "none" || !(this.tooltip.style["display"]);
                touchedChart.showTooltip(touch.pageX, touch.pageY);
                var nowHasTooltip = this.tooltip.style["display"] === "block";
                this.tooltipShow = nowHasTooltip;
                
                if (wasNoTooltip && nowHasTooltip) {
                    var touchManager = mstrmojo.touchManager;
                    this._touchListener = touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                        if (!isTouchedOnWidget.call(me, evt.touch)) {
                            hideTooltipGlobal.call(me, evt.touch); 
                        }
                    });
                }

            },

            touchSelectBegin: function touchSelectBegin(touch) {
                if (touch.evt.ctrlKey) { 
                    this.touchMultiBegin(touch);
                    return;
                }

                var me = this;

                hideTooltipGlobal.call(me);

                var td = mstrmojo.dom.findAncestorByAttr(touch.target, "mcol", true, this.domNode);
                if (td && td.node) {
                    var mrow = td.node.getAttribute("mrow");
                    var mcol = td.node.getAttribute("mcol");

                    if (mrow == -1) {
                        
                        this.showTextTooltip(td.node, mcol, true);

                    } else {
                        var tr = td.node.parentNode;
                        var rowInfo = null;
                        if (tr.getAttribute("rowType") == DOCKED_HEADER) {
                            var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, mrow);
                            if (dockedHeaderIdx >= 0) {
                                rowInfo = this.dockedHeaderRows[dockedHeaderIdx];
                            } else {
                                dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, mrow);
                                rowInfo = this.dockedHeaderReplaceRows[dockedHeaderIdx];
                            }
                        } else {
                            rowInfo = this.rows[mrow];
                        }

                        var colInfo = this.colInfos[mcol];
                        if (colInfo.type == CHART) {
                            var touchedChart = rowInfo && rowInfo.rowRef && rowInfo.rowRef[mcol];
                            if (touchedChart) {
                                this.showChartTooltip(touchedChart, touch);
                                this.currSelectedWidget = { mrow: mrow, mcol: mcol };
                            }
                        } else if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_VALUE || colInfo.type == METRIC_NAME) {
                            this.showTextTooltip(td.node, mcol);
                        }
                    }

                }
            },

            showTextTooltip: function showTextTooltip(e, mcol, onHeader) {
                if (onHeader) {
                    var colInfo = this.colInfos[mcol],
                        text = colInfo.title;
                    if (colInfo.titleOverflow && this._textTooltip) {
                        this._textTooltip.updateContent(e, onHeader ? 'title' : 'content', text);

                    }
                } else {
                    var text = e.innerText;
                    var tmpLength = this.getTextWidthByCanvas(text, e, true);
                    if (tmpLength > e.offsetWidth && this._textTooltip) {
                        this._textTooltip.updateContent(e, onHeader ? 'title' : 'content', text);

                    }
                }

            },

            hideTextTooltip: function hideTextTooltip() {
                if (this._textTooltip) {
                    this._textTooltip.toggle(false);
                }
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                if (touch.evt.ctrlKey) {
                    this.touchMultiEnd(touch);
                    return;
                }
                this.currSelectedWidget = null;
                this.hideTextTooltip();
            },

            touchSelectMove: function touchSelectMove(touch) {
                if (touch.evt.ctrlKey) {
                    this.touchMultiMove(touch);
                    return;
                }

                if (!this.currSelectedWidget) {
                    return;
                }

                
                this.tooltip.style.display = "none";

                var target = touch.target;

                var mcol = -1,
                    colInfo = null;

                var targetFound = true;
                var td = mstrmojo.dom.findAncestorByAttr(target, "mcol", true, this.domNode);
                td = td && td.node;
                if (td) {
                    mcol = td.getAttribute("mcol");
                    colInfo = this.colInfos[mcol];
                    
                    if (colInfo.order == "GaugeChart") {
                        
                        
                        targetFound = false;
                    }
                } else {
                    
                    targetFound = false;
                }

                if (targetFound === false) {
                    target = document.elementFromPoint(touch.pageX, touch.pageY);
                    
                    td = mstrmojo.dom.findAncestorByAttr(target, "mcol", true, this.domNode);
                    td = td && td.node;
                    if (!td) {
                        return;
                    }
                    mcol = td.getAttribute("mcol");
                    colInfo = this.colInfos[mcol];
                }

                var mrow = td.getAttribute("mrow");
                var tr = td.parentNode;

                
                var rowInfo = null;
                if (tr.getAttribute("rowType") == DOCKED_HEADER) {
                    var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, mrow);
                    if (dockedHeaderIdx >= 0) {
                        rowInfo = this.dockedHeaderRows[dockedHeaderIdx];
                    } else {
                        dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, mrow);
                        rowInfo = this.dockedHeaderReplaceRows[dockedHeaderIdx];
                    }
                } else {
                    rowInfo = this.rows[mrow];
                }

                var touchedChart = rowInfo && rowInfo.rowRef && rowInfo.rowRef[mcol];
                var tooltipShown;
                if (touchedChart) {
                    if (colInfo.order == "LineChart" || colInfo.order == "BarChart") {
                        if (mrow == this.currSelectedWidget.mrow && mcol == this.currSelectedWidget.mcol) {
                            tooltipShown = touchedChart.showTooltip(touch.pageX, touch.pageY);
                            this.currSelectedWidget = { mrow: mrow, mcol: mcol };
                        }
                    } else {
                        if (mcol == this.currSelectedWidget.mcol && mrow != this.currSelectedWidget.mrow) {
                            tooltipShown = touchedChart.showTooltip(touch.pageX, touch.pageY);
                            this.currSelectedWidget = { mrow: mrow, mcol: mcol };
                        }
                    }
                }

                if (tooltipShown) {
                    this.tooltipShow = true;
                }
                console.log("tooltip show:" + this.tooltipShow);
                if (this.tooltipShow) {
                    this.tooltip.style.display = "block";
                }

            },

            touchSwipeBegin: function touchSwipeBegin(touch) {
                hideTooltipGlobal.call(this);
                
                if (isScrollableElementTouched.call(this, touch) && this._super) {
                    this._super(touch);
                } else {
                    this._touchCanceled = true;
                }

            },

            touchSwipeMove: function touchSwipeMove(touch) {
                
                if (!this._touchCanceled && this._super) {
                    this._super(touch);
                }
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                
                if (!this._touchCanceled && this._super) {
                    this._super(touch);
                }
            },

            getColIdx: function getColIdx(order) {
                var colInfos = this.colInfos,
                    colCount = colInfos.length;
                for (var i = 0; i < colCount; i++) {
                    var target = colInfos[i].order.split(":")[0];
                    if (target + ":CG" == colInfos[i].order) {
                        target = target + ":CG";
                    }
                    if (order == target) {
                        return colInfos[i].colIdx || i;
                    }
                }
                return -1;
            },

            buildLeftParent: function buildLeftParent(node, mrow, mcol) {
                var colInfos = this.colInfos,
                    colCount = colInfos.length;

                if (!this.isKPI) {
                    
                    if (mrow == -1) { 
                        var gts = this.model.gts;
                        var metricIndex = mstrmojo.array.find(gts.col, 'n', 'Metrics');
                        node._e = gts.col[metricIndex].es[colInfos[mcol].order] || {id: "", n: ""};
                        node.v = node._e.n;
                    } else {
                        var rows = this.model.gts.row;
                        var currNode = node;

                        for (var i = colCount - 1; i >= 0; i--) {
                            var colInfo = colInfos[i];
                            if (colInfo.type == CHART) {
                                continue;
                            }
                            if (colInfo.type == ATTR_NAME) {
                                var nodeLP = {};
                                var index = mstrmojo.array.find(rows, 'id', colInfo.order.split(":")[0]);
                                nodeLP.titleInfo = rows[index];
                                nodeLP._e = this.rows[mrow].model.elms[colInfo.order] || {id: "", n: ""};
                                nodeLP.v = nodeLP._e.n;
                                nodeLP.axis = ROW_AXIS;

                                currNode._lp = nodeLP;
                                currNode = nodeLP;
                            }
                        }
                    }
                } else {
                    
                    if (mcol == 0) {
                        
                        var gts = this.model.gts;
                        var metricIndex = mstrmojo.array.find(gts.col, 'n', 'Metrics');
                        node._e = gts.col[metricIndex].es[mrow] || {id: "", n: ""};
                        node.v = node._e.n;
                    } else {
                        var rows = this.model.gts.row;
                        var currNode = node;
                        for (var i = 0; i < rows.length; i++) {
                            var nodeLP = {};
                            nodeLP.titleInfo = rows[i];
                            var idx = rows[i].es.length;
                            nodeLP._e = rows[i].es[idx - 1] || {id: "", n: ""};
                            nodeLP.v = nodeLP._e.n;
                            nodeLP.axis = ROW_AXIS;

                            currNode._lp = nodeLP;
                            currNode = nodeLP;
                        }
                    }
                }
            },

            getModelK: function getModelK() {
                var k = this.model && this.model.k;

                return k;
            },

            addSCObjToList: function addSCObjToList(scObjList, rowH, n, id) {
                var scObj = {};
                scObj.sc = rowH.sc;
                scObj.es = n;
                scObj.eid = id;
                scObjList.push(scObj);
            },

            getSelectionObjForTreeMode: function getSelectionObjForTreeMode(touchedObj) {
                var attrIdxArray = this.attrMapIdx;
                var me = this,
                    model = me.model,
                    gts = model.gts,
                    rows = gts.row;

                var scObjList = [];
                var actionType = 0;
                var selectedAll = false;

                var treeNode = touchedObj.treeNode;
                var treePath = treeNode.treePath;
                var treePathArray = treePath.split("_");
                var treeLevel = treePathArray.length - 1;
                var isAttrSelectable = this.isAttrSelectable(treeLevel);

                if (this.closedIfwAttr == treePath) {
                    
                    return null;
                }

                if (isAttrSelectable) {
                    
                    var isTappedNodeSelected = this.lastSelectedObj && this.lastSelectedObj[treeLevel] && (this.lastSelectedObj[treeLevel].treePath == treePath);

                    if (!isTappedNodeSelected) {
                        
                        this.currSelectedObj = this.getSelectedTreeNodeListFromTreePath(treePathArray);

                        var useFirstAttr = false;
                        var parentTreeNode = this.currSelectedObj[treeLevel];
                        for (var i = treeLevel + 1; i < this.lastSelectedObj.length; i++) {
                            var thisLevelSelectable = this.isAttrSelectable(i);
                            var thisLevelSelected = !!this.lastSelectedObj[i];

                            if (!thisLevelSelectable || !thisLevelSelected) {
                                
                                useFirstAttr = true;
                                this.currSelectedObj[i] = null;
                                parentTreeNode = parentTreeNode.childrenTreeNodeList[0];
                                continue;
                            }

                            
                            if (!useFirstAttr) {
                                
                                var attrID = this.lastSelectedObj[i].id;
                                var treeNodeList = parentTreeNode.childrenTreeNodeList;
                                for (var j = 0; j < treeNodeList.length; j++) {
                                    if (attrID == treeNodeList[j].id) {
                                        
                                        this.currSelectedObj[i] = treeNodeList[j];
                                        break;
                                    }
                                }
                                if (j == treeNodeList.length) {
                                    
                                    useFirstAttr = true;
                                }
                            }

                            if (useFirstAttr) {
                                this.currSelectedObj[i] = parentTreeNode.childrenTreeNodeList[0];
                            }

                            
                            parentTreeNode = this.currSelectedObj[i];
                        }

                        selectedAll = false;
                        
                        for (var i = 0; i < this.currSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];
                            if (treeNode) {
                                var attrIdx = attrIdxArray[i];
                                rowH = rows[attrIdx];

                                this.addSCObjToList(scObjList, rowH, treeNode.n, treeNode.id);
                            } else {
                                
                                continue;
                            }
                        }
                    } else {
                        
                        for (var i = treeLevel; i < this.lastSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];

                            if (!treeNode) {
                                continue;
                            }

                            var attrIdx = attrIdxArray[i];
                            rowH = rows[attrIdx];

                            var unselectable = rowH.sc && !(rowH.sc.all === "false" || rowH.sc.all === false);

                            if (treeNode && !unselectable) {
                                
                                
                                break;

                            } else {
                                
                                this.addSCObjToList(scObjList, rowH, treeNode.n, "OA:(All)");
                                this.currSelectedObj[i] = null;
                            }
                        }

                        
                        if (i == treeLevel) {
                            return {at: 0};
                        }

                        
                        while (this.currSelectedObj.length > 0 && !this.currSelectedObj[this.currSelectedObj.length - 1]) {
                            this.currSelectedObj.pop();
                        }

                        
                        for (; i < this.currSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];
                            if (treeNode) {
                                var attrIdx = attrIdxArray[i];
                                rowH = rows[attrIdx];

                                this.addSCObjToList(scObjList, rowH, treeNode.n, treeNode.id);
                            } else {
                                
                                continue;
                            }
                        }
                        
                        
                        
                        

                        selectedAll = true;

                    }
                }

                if (scObjList.length > 0) {
                    actionType = actionType | SELECTOR_ACTION;

                    var hasInfoWOnNode = this.hasInfoWOnNode(rows[attrIdxArray[treeLevel]]);
                    
                    var anchorNode = selectedAll ? null : hasInfoWOnNode ? touchedObj.node : null;

                    return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode};
                }

                return null;

            },

            
            hasInfoWOnNode: function hasInfoWOnNode(rowH, onlyIfW) {
                var xtabModel = this.xtabModel,
                    docModel = (xtabModel && xtabModel.docModel);
                if (docModel) {
                    var layouts = docModel.defn && docModel.defn.layouts,
                        layout = null;
                    var i;
                    
                    if (layouts) {
                        for (i in layouts) {
                            if (layouts[i].loaded) {
                                layout = layouts[i];
                                break;
                            }
                        }
                    }
                    var units = layout && layout.units;
                    if (units && rowH) {
                        var tksList = rowH.sc.tks.split("\x1E");
                        for (var j = 0; j < tksList.length; j++) {
                            var unit = units[tksList[j]];
                            if (unit) {
                                if (this.isChildOfIfw(units, unit)) {
                                    if (!onlyIfW) {
                                        return true;
                                    }
                                } else {
                                    if (onlyIfW) {
                                        return false;
                                    }
                                }
                            }
                        }

                    }
                }

                return onlyIfW ? true : false;
            },

            getSelectionObjForNonTreeMode: function getSelectionObjForNonTreeMode(touchedObj) {
                var mcol = touchedObj.mcol,
                    mrow = touchedObj.mrow,
                    colInfos = this.colInfos;
                var attrIdxArray = this.attrMapIdx;
                var me = this,
                    model = me.model,
                    gts = model.gts,
                    rows = gts.row;

                var scObjList = [];
                var actionType = 0;
                var selectedAll = false;

                var id = colInfos[mcol].order;

                if (this.isAllAttrSelectable) {
                    

                    
                    
                    
                    

                    id = id.split(":")[0];

                    var hasTapRemainCell = this.updateUnselectedRemainCells({mrow: mrow, mcol: mcol});
                    if (hasTapRemainCell) {
                        return null;
                    }

                    if (mrow == this.prevSelected.mrow) { 
                        
                        if (mrow >= 0) {
                            
                            for (var key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                if (!obj.sc || !obj.sc.tks) { 
                                    continue;
                                }
                                
                                if (obj.sc.all === "false" || obj.sc.all === false) {
                                    var i = 0;
                                    var colInfos = this.colInfos;
                                    var colCount = colInfos.length;
                                    for (; i < colCount; i++) {
                                        if (key == colInfos[i].order.split(":")[0]) {
                                            break;
                                        }
                                    }
                                    this.unselectedRemainCells.push({mrow: mrow, mcol: i});
                                    continue;
                                }

                                var selectedIdx = obj.map[mrow];
                                var elementId = obj.es[selectedIdx].id;
                                if (!elementId || elementId.substring(0, 1) === "D") {
                                    
                                    continue;
                                }
                                ;
                                selectedAll = true;
                                this.addSCObjToList(scObjList, obj, "", "OA:(All)");
                            }
                            if (scObjList.length > 0) {
                                this.clearPreHighlightRowStatus();
                                this.prevSelected = {mrow: -2, mcol: -1};
                                this.updateUnselectedRemainCells();

                                actionType = actionType | SELECTOR_ACTION;
                                
                                var anchorNode = selectedAll ? null : touchedObj.node;
                                return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode};
                            } else {
                                this.unselectedRemainCells = [];
                            }

                            
                            return {at: actionType};
                        }
                    } else {
                        this.updateUnselectedRemainCells();
                        this.unselectedRemainCells = [];
                    }

                    if (touchedObj.mrow == -1) {
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    } else {
                        if (this.ctlMatrix) {
                            this.clearPreHighlightRowStatus();

                            for (var key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                if (!obj.sc) { 
                                    continue;
                                }
                                if (!obj.sc.tks || (obj.sc.tks == "")) {
                                    
                                    continue;
                                }
                                var selectedIdx = obj.map[mrow];
                                if (obj.es[selectedIdx]) {
                                    var elementId = obj.es[selectedIdx].id;
                                    if (!elementId || elementId.substring(0, 1) === "D") {
                                        
                                        continue;
                                    }
                                    ;

                                    this.addSCObjToList(scObjList, obj, "", elementId);
                                }

                            }
                            if (scObjList.length > 0) {
                                this.rows[mrow].selected[-1] = true;
                                this.prevSelected = {mrow: mrow, mcol: -1};

                                actionType = actionType | SELECTOR_ACTION;
                                
                                var anchorNode = selectedAll ? null : touchedObj.node;
                                return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode };
                            }
                        }
                    }

                } else {
                    
                    var isCG = false;
                    if (id.indexOf(":CG") === id.length - 3 && id.length >= 3) {
                        isCG = true;
                    }
                    id = id.split(":")[0];

                    
                    
                    
                    

                    if (this.ctlMatrix && this.ctlMatrix[id]) {
                        var ctlMatrix = this.ctlMatrix[id];
                        var ctlMatrixCG = this.ctlMatrix[id + ":CG"];

                        if (ctlMatrix.sc && ctlMatrix.sc.tks != "") {
                            
                            var elementId = "";
                            var isAll = false;

                            if (mrow == -1) {
                                
                                
                                
                                
                                
                                
                                
                                
                            } else {
                                var selectedIdx = ctlMatrix.map[mrow];
                                if (ctlMatrix.es[selectedIdx]) {
                                    elementId = ctlMatrix.es[selectedIdx].id;
                                    if (!elementId || elementId.substring(0, 1) === "D") {
                                        
                                        return;
                                    }
                                }

                                var sameAsLastSelected = function () {
                                    var result = ctlMatrix.selectedIdx[selectedIdx];
                                    if (ctlMatrixCG) {
                                        
                                        if (ctlMatrixCG.selectedIdx[-1]) {
                                            
                                            return result;
                                        } else {
                                            return result && ctlMatrixCG.selectedIdx[ctlMatrixCG.map[mrow]];
                                        }
                                    }
                                    return result;
                                }
                                if (sameAsLastSelected()) {
                                    
                                    var canSelectAll = !(ctlMatrix.sc.all === "false" || ctlMatrix.sc.all === false);
                                    if (canSelectAll) {
                                        elementId = "OA:(All)";
                                        selectedAll = true;
                                        ctlMatrix.selectedIdx = {};
                                        if (ctlMatrixCG) {
                                            ctlMatrixCG.selectedIdx = {};
                                        }
                                        this.prevSelected = {mrow: -2, mcol: -1};
                                    } else {
                                        return null;
                                    }

                                } else {
                                    
                                    ctlMatrix.selectedIdx = {};
                                    ctlMatrix.selectedIdx[selectedIdx] = true;

                                    if (ctlMatrixCG) {
                                        ctlMatrixCG.selectedIdx = {};
                                        if (isCG) {
                                            
                                            
                                            ctlMatrixCG.selectedIdx[ctlMatrixCG.map[mrow]] = true;
                                            if (ctlMatrixCG.map[mrow] < ctlMatrixCG.es.length) {
                                                
                                                elementId = ctlMatrixCG.es[ctlMatrixCG.map[mrow]].id;
                                            }
                                        } else {
                                            
                                            

                                            ctlMatrixCG.selectedIdx[-1] = true;
                                        }
                                    }

                                    
                                    this.prevSelected = {mrow: mrow, mcol: mcol};
                                }
                            }
                            var scObj = {};
                            scObj.sc = ctlMatrix.sc;
                            scObj.eid = elementId;
                            scObjList.push(scObj);
                        }
                    }

                    if (scObjList.length > 0) {
                        actionType = actionType | SELECTOR_ACTION;
                        
                        var anchorNode = selectedAll ? null : touchedObj.node;
                        return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode};
                    }
                }

                return null;

            },

            getLinkDrillObjForTreeMode: function getLinkDrillObjForTreeMode(touchedObj) {

                var actionType = 0;
                var linkDrillNode = null;

                var model = this.model,
                    gts = model.gts,
                    rowHs = gts.row;
                var mcol = touchedObj.mcol,
                    mrow = touchedObj.mrow,
                    colInfos = this.colInfos;

                var treeNode = touchedObj.treeNode;
                var treePath = treeNode.treePath;
                var treePathArray = treePath.split("_");
                var treeLevel = treePathArray.length - 1;
                var attrIdxArray = this.attrMapIdx;

                
                var id = null;
                var colInfo = colInfos[mcol];
                var colType = colInfo && colInfo.type;
                if (colType == ATTR_NAME) {
                    if (mrow == -1) {
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    } else {
                        
                        var rowH = rowHs[attrIdxArray[treeLevel]];
                        if (rowH.lm && rowH.lm[0] && rowH.lm[0].links) {
                            linkDrillNode = {};
                            linkDrillNode.titleInfo = rowH;
                            var treeNode = getTreeNode(this.tree, treePath);
                            linkDrillNode._e = treeNode.es[0] || {n: "", id: ""};
                            linkDrillNode.v = linkDrillNode._e.n;
                        }
                    }

                } else if (colType == METRIC_VALUE) {
                    if (colInfo.lm) {
                        

                        id = colInfo.order;
                        
                        var mix = parseInt(id); 

                        var metricH = gts.col[0];

                        if (metricH) {
                            
                            linkDrillNode = {};
                            linkDrillNode.mix = mix;
                            linkDrillNode.titleInfo = metricH;

                            if (mrow == -1) {
                                
                                linkDrillNode._e = metricH.es[mix] || {n: "", id: ""};
                                linkDrillNode.v = linkDrillNode._e.n;
                            } else {
                                
                                
                                var currNode = linkDrillNode;
                                var treeNode = this.tree;
                                for (var i = 0; i < treePathArray.length; i++) {
                                    var idx = treePathArray[i];
                                    treeNode = treeNode.childrenTreeNodeList[idx];

                                    var attrIdx = attrIdxArray[i];
                                    rowH = rowHs[attrIdx];

                                    var nodeLP = {};
                                    nodeLP.titleInfo = rowH;
                                    nodeLP._e = treeNode.es[0] || {n: "", id: ""};
                                    nodeLP.v = nodeLP._e.n;

                                    currNode._lp = nodeLP;
                                    currNode.axis = ROW_AXIS;
                                    currNode = nodeLP;
                                }
                            }
                        }
                    }

                }

                if (linkDrillNode) {
                    this.highlightEntireRow = false;
                    actionType = actionType | HYPERLINK_ACTION;
                    return {at: actionType, k: this.getModelK(), node: linkDrillNode};
                }
            },

            getLinkDrillObjForNonTreeMode: function getLinkDrillObjForNonTreeMode(touchedObj) {
                var actionType = 0;

                var model = this.model,
                    gts = model.gts,
                    rowHs = gts.row;
                var mcol = touchedObj.mcol,
                    mrow = touchedObj.mrow,
                    colInfos = this.colInfos;

                var node = touchedObj.node, titleInfo;
                this.highlightEntireRow = false;
                var attrIdxArray = this.attrMapIdx;
                var colInfo = colInfos[mcol];

                if (!this.isKPI) {
                    
                    if (linkCount === 1 && attrCount === 1 && mrow != -1) {
                        
                        for (var key in colInfos) {
                            var colInf = colInfos[key];
                            if (colInf.lm && colInf.type == ATTR_NAME) {
                                
                                
                                this.highlightEntireRow = true;
                                var titleInfo = colInf.lm;
                                actionType = titleInfo && titleInfo.at || HYPERLINK_ACTION;
                                node._e = this.rows[mrow].model.elms[colInf.order] || { id: "", n: "" };
                                node.v = node._e.n;
                                break;
                            }
                        }

                    }

                    if (!this.highlightEntireRow) {

                        if (colInfo.type == CHART) {
                            return null;
                        }

                        var titleInfo = colInfo.lm;
                        if (titleInfo) {
                            actionType = titleInfo && titleInfo.at;

                            if (colInfo.type == ATTR_NAME) {
                                
                                if (mrow === -1) { 
                                    
                                    node._e = {};
                                    node._e.onTitle = true;
                                    node._e.id = titleInfo.id;
                                    node._e.n = titleInfo.n;
                                    node.v = titleInfo.n;
                                } else { 
                                    node._e = this.rows[mrow].model.elms[colInfo.order] || { id: "", n: "" };
                                    node.v = node._e.n;
                                }
                            } else if (colInfo.type == METRIC_VALUE) { 
                                node.mix = colInfo.order;
                                node.axis = ROW_AXIS;

                                this.buildLeftParent(node, mrow, mcol);
                                actionType = this.rows[mrow == -1 ? 0 : mrow].model.refv[colInfo.order].at || HYPERLINK_ACTION;
                            }
                        }
                    }
                } else {
                    
                    if (colInfo.type == CHART) {
                        return null;
                    }
                    var titleInfo = colInfo.lm;
                    var metricIdx = this.rows[mrow].model.metricIdx;
                    if (titleInfo && titleInfo.lm && titleInfo.lm[metricIdx] && titleInfo.lm[metricIdx].links) {

                        node.mix = "" + metricIdx;
                        node.axis = ROW_AXIS;

                        this.buildLeftParent(node, metricIdx, mcol);
                        actionType = this.rows[mrow].model.refv[0].at || HYPERLINK_ACTION;
                    } else {
                        titleInfo = null;
                    }

                }

                if (titleInfo) {
                    node.titleInfo = titleInfo;
                    actionType = actionType | HYPERLINK_ACTION;

                    return {at: actionType, mcol: mcol, mrow: mrow, k: this.getModelK(), node: node};
                }

                return null;
            },

            getActionObj: function getActionObj(touchedObj) {
                var actionObjList = [];

                if (touchedObj.mrow == -1) {
                    
                    return null;
                }

                var actionObj = null;

                
                if (this.isTreeMode) {
                    actionObj = this.getSelectionObjForTreeMode(touchedObj);
                } else {
                    actionObj = this.getSelectionObjForNonTreeMode(touchedObj);
                }

                if (actionObj) {
                    actionObjList.push(actionObj);
                    return actionObjList;
                } else {
                    
                    if (this.isTreeMode) {
                        actionObj = this.getLinkDrillObjForTreeMode(touchedObj);
                    } else {
                        actionObj = this.getLinkDrillObjForNonTreeMode(touchedObj);
                    }
                    actionObjList.push(actionObj);
                }
                return actionObjList;
            },

            
            getDefaultHighlightRow: function getDHR() {
                var attrIdxArray = this.attrMapIdx;
                var rows = this.model.gts.row;

                if (!this.isTreeMode) {

                    if (this.isAllAttrSelectable) {
                        
                        

                        var isAllSelected = false;
                        var resultSet = null,
                            controlMatrix = null;
                        var hasOnlyIfwTarget = true;
                        var colInfos = this.colInfos,
                            colCount = colInfos.length;

                        for (var i = 0; i < colCount; i++) {
                            var colInfo = colInfos[i],
                                id = colInfo.order;
                            var trueId = id.split(":")[0];
                            if (id != trueId + ":CG") {
                                
                                id = trueId;
                            }
                            controlMatrix = this.ctlMatrix[id];
                            if (controlMatrix) {
                                if (!this.hasInfoWOnNode(controlMatrix, true)) {
                                    hasOnlyIfwTarget = false;
                                }
                                
                                
                                if (controlMatrix.selectedIdx[-1]) {
                                    
                                    isAllSelected = true;
                                    this.prevSelected = {
                                        mrow: -1,
                                        mcol: i
                                    };
                                    
                                } else {
                                    colInfo.selected = false;
                                }

                                if (!isAllSelected) {
                                    if (!resultSet) {
                                        
                                        resultSet = {};
                                        for (var j = 0; j < controlMatrix.map.length; j++) {
                                            if (controlMatrix.selectedIdx[controlMatrix.map[j]]) {
                                                resultSet[j] = true;
                                            }
                                            ;
                                        }
                                        ;
                                    } else { 
                                        for (var j in resultSet) {
                                            if (!controlMatrix.selectedIdx[controlMatrix.map[j]]) { 
                                                delete resultSet[j];
                                            }
                                            ;
                                        }
                                        ;
                                    }
                                    ;
                                }
                                ;
                            }
                        }

                        if (hasOnlyIfwTarget) {
                            
                            for (key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                obj.selectedIdx = {};
                            }
                        }
                        if (hasOnlyIfwTarget || isAllSelected || !resultSet || Object.keys(resultSet).length !== 1) {
                            
                        } else {
                            console.log("xiawang: The selected row is:" + JSON.stringify(resultSet));
                            var selectedRow = parseInt(Object.keys(resultSet)[0]);
                            this.prevSelected = {
                                mrow: selectedRow,
                                mcol: -1
                            };

                            if (this.rows[selectedRow]) {
                                this.rows[selectedRow].selected[-1] = true;
                            }

                            
                            for (key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                obj.selectedIdx = {};
                            }
                        }
                    } else {
                        
                        var hasOnlyIfwTarget = true;
                        for (key in this.ctlMatrix) {
                            var controlMatrix = this.ctlMatrix[key];
                            var checkThisAttr = false;
                            for (var sIdx in controlMatrix.selectedIdx) {
                                checkThisAttr = true;
                            }
                            if (checkThisAttr && !this.hasInfoWOnNode(controlMatrix, true)) {
                                hasOnlyIfwTarget = false;
                                break;
                            }
                        }

                        if (hasOnlyIfwTarget) {
                            
                            for (key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                obj.selectedIdx = {};
                            }
                        }
                    }

                } else {
                    
                    
                    if (this.currSelectedObj && this.currSelectedObj.length <= 0) {
                        var resultSet = null,
                            controlMatrix = null;

                        this.currSelectedObj = [];

                        var findTreeNodeByAttrElemIdx = function (treeNodeList, attrElemIdx) {
                            var treeNodeCount = treeNodeList.length;
                            for (var i = 0; i < treeNodeCount; i++) {
                                var treeNode = treeNodeList[i];
                                if (treeNode.attrElemIdx == attrElemIdx) {
                                    return treeNode;
                                }
                            }
                            return null;
                        };

                        var me = this;

                        var findCurrSelectedObjByAttrElemIdx = function (tree, level) {
                            var id = me.attrIDArray[level];
                            controlMatrix = me.ctlMatrix[id];

                            var treeNodeList = tree.childrenTreeNodeList;
                            var treeNodeCount = treeNodeList.length;
                            if (treeNodeCount <= 0) {
                                return;
                            }

                            var treeNode = null;
                            if (controlMatrix) {
                                for (var key in controlMatrix.selectedIdx) {
                                    treeNode = findTreeNodeByAttrElemIdx(treeNodeList, key);
                                }

                                if (treeNode) {
                                    me.currSelectedObj[level] = treeNode;
                                    findCurrSelectedObjByAttrElemIdx(treeNode, level + 1);

                                    return true;
                                }

                            } else {
                                
                                me.currSelectedObj[level] = null;
                                for (var i = 0; i < treeNodeCount; i++) {
                                    var find = findCurrSelectedObjByAttrElemIdx(treeNodeList[i], level + 1);
                                    if (find) {
                                        return true;
                                    }
                                }

                            }

                            return false;

                        };

                        findCurrSelectedObjByAttrElemIdx(this.tree, 0);

                        
                        while (this.currSelectedObj.length > 0 && !this.currSelectedObj[this.currSelectedObj.length - 1]) {
                            this.currSelectedObj.pop();
                        }

                        
                        var hasOnlyIfwTarget = true;
                        for (var i = 0; i < this.currSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];
                            if (treeNode) {
                                var attrIdx = attrIdxArray[i];
                                rowH = rows[attrIdx];
                                if (!this.hasInfoWOnNode(rowH, true)) {
                                    hasOnlyIfwTarget = false;
                                    break;
                                }
                            } else {
                                
                                continue;
                            }
                        }
                        if (hasOnlyIfwTarget) {
                            this.currSelectedObj = [];
                        }

                        this.lastSelectedObj = $HASH.clone(this.currSelectedObj);
                        return;

                    }
                }
            },

            
            updateSelectedStatus: function updateSS(tree) {
                if (this.isTreeMode) {
                    this.updateTreeSelection(tree);
                } else if (!this.isAllAttrSelectable || this.unselectedRemainCells.length > 0) {

                    if (!this.ctlMatrix) {
                        return;
                    }
                    
                    var update = function (key) {
                        var pureId = key.split(":")[0],
                            ctlMatrix = this.ctlMatrix[pureId],
                            ctlMatrixCG = this.ctlMatrix[pureId + ":CG"];

                        
                        
                        var colInfos = this.colInfos,
                            selectedIdx = ctlMatrix.selectedIdx,
                            colIdx = ctlMatrix.colIdx;
                        
                        
                        
                        
                        
                        
                        

                        
                        if (ctlMatrixCG && !ctlMatrixCG.selectedIdx[-1]) {
                            
                            
                            
                            ctlMatrix = ctlMatrixCG;
                        }
                        var map = ctlMatrix.map,
                            rows = this.rows,
                            rowCount = rows.length,
                            selectedIdx = ctlMatrix.selectedIdx,
                            colIdx = this.ctlMatrix[key].colIdx,
                            assAttr = colInfos[colIdx].associateAttr;

                        for (var i = 0; i < rowCount; i++) {
                            var rowInfo = rows[i];
                            if (selectedIdx[map[i]]) {
                                rowInfo.selected[colIdx] = true;
                                
                                for (var idx in assAttr) {
                                    rowInfo.selected[assAttr[idx]] = true;
                                }
                            } else {
                                rowInfo.selected[colIdx] = false;
                                for (var idx in assAttr) {
                                    rowInfo.selected[assAttr[idx]] = false;
                                }
                            }
                        }
                    }

                    for (var key in this.ctlMatrix) {

                        update.call(this, key);
                    }
                }

            },

            hasOnlyInfoWindowTarget: function hasOnlyInfoWindowTarget() {

            },

            performAction: function performAction(actionObjList) {
                this.hasNonifwTarget = this.hasNoninfowindowTarget(actionObjList[0]);

                if (this._super) {
                    this._super(actionObjList);
                }

            },

            
            clearPreHighlightRowStatus: function clearPreHighlightRowStatus(pass) {
                var mrow = this.prevSelected.mrow,
                    mcol = this.prevSelected.mcol;

                if (mrow == -2) {
                    
                    return;
                }
                if (mcol == -1) {
                    
                    this.rows[mrow].selected[-1] = false;
                } else {
                    
                    if (mrow == -1) {
                        
                        for (var i = 0; i < this.colInfos.length; i++) {
                            var colInfo = this.colInfos[i];
                            if (colInfo.selected) {
                                colInfo.selected = false;
                            }
                        }
                        
                    } else {
                        this.rows[mrow].selected[mcol] = false;
                    }

                }

            },

            updateUnselectedRemainCells: function uurc(tappedCell) {
                var hasTapRemainCell = false;

                for (var i = this.unselectedRemainCells.length - 1; i >= 0; i--) {
                    cell = this.unselectedRemainCells[i];

                    var id = order[cell.mcol];

                    var isCG = false;
                    if (id.indexOf(":CG") === id.length - 3
                        && id.length >= 3) {
                        isCG = true;
                    } else {
                        id = id.split(":")[0];
                    }

                    var obj = this.ctlMatrix[id];
                    
                    var anotherObj = undefined;
                    if (isCG) {
                        anotherObj = this.ctlMatrix[id.split(":")[0]];
                    } else {
                        anotherObj = this.ctlMatrix[id + ":CG"];
                    }
                    if (obj.sc && obj.sc.tks != "") {

                        if (anotherObj && !anotherObj.sc) {
                            anotherObj = undefined;
                        }

                        var selectedIdx = obj.map[cell.mrow];
                        elementId = obj.es[selectedIdx].id;
                        if (!elementId || elementId.substring(0, 1) === "D") {
                            
                            
                            continue;
                        } else {
                            if (obj.selectedIdx[selectedIdx]) {
                                if (tappedCell) {
                                    if (cell.mcol == tappedCell.mcol) {
                                        
                                        var tappedID = order[cell.mcol].split(":")[0];
                                        var tappedCtlMatrix = this.ctlMatrix[tappedID];
                                        var tappedIdx = tappedCtlMatrix.sc && tappedCtlMatrix.map[tappedCell.mrow];
                                        if (tappedIdx == selectedIdx) {
                                            hasTapRemainCell = true;
                                        }
                                    }
                                    continue;

                                }
                                
                                obj.selectedIdx = {};

                            } else {
                                obj.selectedIdx = {};
                                
                                obj.selectedIdx[selectedIdx] = true;
                                if (anotherObj) {
                                    if (elementId.indexOf("BE") === 0 || elementId.indexOf("Z") === 0) {
                                        
                                    } else {
                                        
                                        anotherObj.selectedIdx = {};
                                        anotherObj.selectedIdx[selectedIdx] = true;
                                    }
                                }
                            }

                        }
                    }

                }

                return hasTapRemainCell;

            },

            highlightCellsByRowInfo: function highlightCellsByRowInfo(rowInfo) {
                var rowRef = rowInfo.rowRef;
                if (!rowRef) {
                    return;
                }

                var trL = rowRef[LEFT_CHART_ROW];
                var trR = rowRef[RIGHT_CHART_ROW];

                var tdsL = trL && trL.childNodes;
                var tdsR = trR && trR.childNodes;
                var tdsLLen = tdsL && tdsL.length || 0,
                    tdsRLen = tdsR && tdsR.length || 0;

                var colCount = tdsLLen + tdsRLen;

                for (var i = 0; i < colCount; i++) {
                    var td = i < tdsLLen ? tdsL[i] : tdsR[i - tdsLLen];
                    if (rowInfo.selected[i]) {
                        this.highlightCell(td);
                    } else {
                        this.unHighlightCell(td);
                    }
                }
            },

            setSelectedStyle: function setSelectedStyle(level) {
                if (level == 0) {
                    this.selectedStyle = "background-color:#015DE6;color:#FFFFFF;";
                } else if (level == 1) {
                    this.selectedStyle = "background-color:rgba(1,93,230, 0.7);color:#FFFFFF;";
                } else {
                    this.selectedStyle = "background-color:rgba(1,93,230, 0.5);color:#FFFFFF;";
                }

            },

            highlightTreeArrow: function highlightTreeArrow(rowInfo) {
                if (this.treeColumnIdx > -1 && this._leftChart) {
                    this._leftChart.setTreeArrow(rowInfo, 'white');
                }
            },

            unHighlightTreeArrow: function unHighlightTreeArrow(rowInfo) {
                if (this.treeColumnIdx > -1 && this._leftChart) {
                    this._leftChart.setTreeArrow(rowInfo);
                }
            },

            highlightCell: function highlightCell(td, isHeaderTable) {
                
                if (isHeaderTable) {
                    setNodeCssText(td, TH_SELECTED_CSS + this.selectedStyle);
                } else {
                    setNodeCssText(td, TD_SELECTED_CSS + this.selectedStyle);
                }
                if (this.selectedClass && this.selectedClass.length > 0) {
                    $CSS.addClass(td, this.selectedClass);
                }

            },

            unHighlightCell: function unHighlightCell(td, isHeaderTable) {
                
                if (isHeaderTable) {
                    setNodeCssText(td, DEFAULT_TH_CSS);
                } else {
                    setNodeCssText(td, DEFAULT_TD_CSS);
                }
                if (this.selectedClass && this.selectedClass.length > 0) {
                    $CSS.removeClass(td, this.selectedClass);
                }
            },

            highlightForLD: function highlightForLD(mrow, mcol, node) {
                if (this.highlightEntireRow && !this.isTreeMode) {
                    this.highlightRowByRowInfo(this.rows[mrow]);
                } else {
                    if (node) {
                        this.highlightCell(node);
                    }

                    var colInfo = this.colInfos[mcol],
                        aAttr = colInfo.associateAttr;
                    var siblings = node.parentNode.childNodes;
                    for (var idx in aAttr) {
                        this.highlightCell(siblings[aAttr[idx]]);

                        if (this.treeColumnIdx == idx) {
                            this.highlightTreeArrow(this.rows[mrow]);
                        }
                    }
                }

            },

            highlightRowByRowInfo: function highlightRowByRowInfo(rowInfo) {
                var rowRef = rowInfo.rowRef;
                if (!rowRef) {
                    return;
                }
                var level = rowInfo.treeNode ? rowInfo.treeNode.level : 0;
                this.setSelectedStyle(level);
                if (rowRef[LEFT_CHART_ROW]) {
                    this.highlightRow(rowRef[LEFT_CHART_ROW]);
                }
                if (rowRef[RIGHT_CHART_ROW]) {
                    this.highlightRow(rowRef[RIGHT_CHART_ROW]);
                }

                
                this.highlightTreeArrow(rowInfo);

            },

            highlightRow: function highlightRow(tr) {
                var tds = tr.childNodes;
                for (var i = 0; i < tds.length; i++) {
                    
                    setNodeCssText(tds[i], TD_SELECTED_CSS + this.selectedStyle);

                    if (this.selectedClass && this.selectedClass.length > 0) {
                        $CSS.addClass(tds[i], this.selectedClass);
                    }
                }
            },

            unHighlightRowByRowInfo: function unHighlightRowByRowInfo(rowInfo) {
                var rowRef = rowInfo.rowRef;
                if (!rowRef) {
                    return;
                }
                if (rowRef[LEFT_CHART_ROW]) {
                    this.unHighlightRow(rowRef[LEFT_CHART_ROW]);
                }
                if (rowRef[RIGHT_CHART_ROW]) {
                    this.unHighlightRow(rowRef[RIGHT_CHART_ROW]);
                }

                
                this.unHighlightTreeArrow(rowInfo);

            },

            unHighlightRow: function unHighlightRow(tr) {
                var tds = tr.childNodes;
                for (var i = 0; i < tds.length; i++) {
                    
                    setNodeCssText(tds[i], DEFAULT_TD_CSS);
                    if (this.selectedClass && this.selectedClass.length > 0) {
                        $CSS.removeClass(tds[i], this.selectedClass);
                    }
                }
            },

            
            isAttrSelectable: function isAttrSelectable(treeLevel) {
                var attrID = this.attrIDArray[treeLevel];
                var ctlMatrix = this.ctlMatrix[attrID];
                if (ctlMatrix) {
                    return true;
                }
                return false;
            },

            
            updateTreeSelection: function updateTreeSelection(tree) {
                
                this.selectOrClearTreeNodes(tree, true, 0);
                
                this.selectOrClearTreeNodes(tree, false, 0);
            },

            findTheTreeNodeWithSameID: function findTheTreeNodeWithSameID(treeNodeList, id) {
                var treeNodeCount = treeNodeList.length;
                for (var i = 0; i < treeNodeCount; i++) {
                    var treeNode = treeNodeList[i];
                    if (treeNode.id == id) {
                        return treeNode;
                    }
                }
                return null;
            },

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

            selectOrClearTreeNodes: function selectOrClearTreeNodes(treeNode, clear, treeLevel) {
                if (!treeNode) {
                    return;
                }
                if (clear && this.lastSelectedObj.length <= treeLevel) {
                    
                    return;
                }
                if (!clear && this.currSelectedObj.length <= treeLevel) {
                    
                    return;
                }

                var tappedTreeNode = null;

                if (clear) {
                    tappedTreeNode = this.lastSelectedObj[treeLevel];
                } else {
                    tappedTreeNode = this.currSelectedObj[treeLevel];
                }

                var treeNodeList = treeNode.childrenTreeNodeList,
                    treeNodeCount = treeNodeList.length;

                if (tappedTreeNode) {

                    treeNode = this.findTheTreeNodeWithSameID(treeNodeList, tappedTreeNode.id);

                    if (treeNode) {
                        
                        treeNode.selected = clear ? false : true;
                        this.selectOrClearTreeNodes(treeNode, clear, treeLevel + 1);
                    }
                } else {
                    for (var i = 0; i < treeNodeCount; i++) {
                        this.selectOrClearTreeNodes(treeNodeList[i], clear, treeLevel + 1);
                    }
                }

            },

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

            updateHighlightForCurrRenderRows: function updateHighlightForCurrRenderRows() {
                
                var rows = this.rows;
                var rowCount = rows.length,
                    rowInfo = null;
                for (var i = this.startCnt; i < this.endCnt; i++) {
                    rowInfo = rows[i];
                    if (this.isTreeMode) {
                        
                        if (rowInfo.treeNode.selected) {
                            this.highlightRowByRowInfo(rowInfo);
                        } else {
                            this.unHighlightRowByRowInfo(rowInfo);
                        }
                    } else {
                        
                        if (this.isAllAttrSelectable) {
                            if (rowInfo.selected[-1]) {
                                
                                this.highlightRowByRowInfo(rowInfo);
                            } else {
                                this.unHighlightRowByRowInfo(rowInfo);
                            }
                        } else {
                            this.highlightCellsByRowInfo(rowInfo);
                        }

                        if (this.unselectedRemainCells.length > 0) {
                            this.highlightCellsByRowInfo(rowInfo);
                        }
                    }
                }

                if (this.isTreeMode) {
                    
                    rows = this.dockedHeaderRows;
                    rowCount = rows.length;
                    for (var i = 0; i < rowCount; i++) {
                        rowInfo = rows[i];
                        if (rowInfo.treeNode.selected) {
                            this.highlightRowByRowInfo(rowInfo);
                        } else {
                            this.unHighlightRowByRowInfo(rowInfo);
                        }
                    }
                    rows = this.dockedHeaderReplaceRows;
                    rowCount = rows.length;
                    for (var i = 0; i < rowCount; i++) {
                        rowInfo = rows[i];
                        if (rowInfo.treeNode.selected) {
                            this.highlightRowByRowInfo(rowInfo);
                        } else {
                            this.unHighlightRowByRowInfo(rowInfo);
                        }
                    }
                }

            },

            
            getSelectedTreeNodeListFromTreePath: function getSelectedTreeNodeListFromTreePath(treePathArray) {
                if (!treePathArray) {
                    return [];
                }
                var treeNodeList = [];
                var treeNode = this.tree;
                for (var i = 0; i < treePathArray.length; i++) {
                    var treeNodeIdx = treePathArray[i];
                    treeNode = treeNode.childrenTreeNodeList[treeNodeIdx];
                    if (!treeNode) {
                        break;
                    }
                    if (this.isAttrSelectable(i)) {
                        treeNodeList[i] = treeNode;
                    } else {
                        treeNodeList[i] = null;
                    }

                }
                return treeNodeList;
            },

            multiTap: true,

            touchTap: function (touch) {
                var widget = this;

                if (widget.tooltip.style["display"] === "block") {
                    hideTooltipGlobal.call(this);
                    return;
                }

                var td = mstrmojo.dom.findAncestorByAttr(touch.target, "mcol", true, this.domNode);
                if (!td) {
                    this._leftChart.dockedHeaderReplaceDiv.style.display = 'none';
                    touch.target = document.elementFromPoint(touch.pageX, touch.pageY);
                    td = mstrmojo.dom.findAncestorByAttr(touch.target, "mcol", true, this.domNode);
                    this._leftChart.dockedHeaderReplaceDiv.style.display = '';
                }
                if (td && td.node) {
                    
                    var mrow = parseInt(td.node.getAttribute("mrow"));
                    var mcol = parseInt(td.node.getAttribute("mcol"));

                    if (mrow == -1) {
                        
                        
                        return;
                    }

                    if (this.isTreeMode) {

                        if (mrow >= 0) {
                            
                            var rowInfo = this.rows[mrow];
                            var treeNode = rowInfo && rowInfo.treeNode;
                            if (touch.count == 2 || ( touch.count == 1 && mcol == this.treeColumnIdx)) {
                                

                                
                                if (!treeNode.isLeaf) {

                                    this.rowsNeedRebuild = true;

                                    var rowType = td.node.parentNode.getAttribute("rowType");

                                    if (treeNode.needExpand) {
                                        
                                        collapseTreeNodeAndSetScrlPos.call(this, rowInfo, rowType);
                                    } else {
                                        
                                        expandTreeNodeAndSetScrlPos.call(this, rowInfo, rowType);
                                    }
                                }
                                return;
                            }
                        }

                        
                        var touchedObj = {node: td.node, treeNode: treeNode, mcol: mcol, mrow: mrow};
                        var actionObjList = this.getActionObj(touchedObj);
                        var actionObj = actionObjList && actionObjList[0];
                        if (actionObj) {

                            if (actionObj.at & SELECTOR_ACTION) {
                                

                                
                                var doHighlight = !(this.isAndroidPhone && actionObj.anchor);
                                if (doHighlight) {
                                    this.updateSelectedStatus(this.tree);
                                    this.updateHighlightForCurrRenderRows();

                                    this.lastSelectedObj = $HASH.clone(this.currSelectedObj);
                                }

                            } else if (actionObj.at & HYPERLINK_ACTION) {
                                
                                this.highlightForLD(mrow, mcol, td.node);
                            }

                            this.performAction(actionObjList);
                            
                            return;
                        }

                    } else {
                        
                        var actionObjList = this.getActionObj({mcol: mcol, mrow: mrow, node: td.node});
                        var actionObj = actionObjList && actionObjList[0];
                        if (actionObj) {

                            if (actionObj.at & SELECTOR_ACTION) {
                                
                                var doHighlight = !(this.isAndroidPhone && actionObj.anchor);
                                if (doHighlight) {
                                    this.updateSelectedStatus();
                                    this.updateHighlightForCurrRenderRows();
                                }

                            } else if (actionObj.at & HYPERLINK_ACTION) {
                                this.highlightForLD(mrow, mcol, td.node);
                            }

                            this.performAction(actionObjList);
                            return;
                        }

                    }

                    
                    var me = this;
                    var tr = td.node.parentNode;
                    var rowInfo = null;
                    if (tr.getAttribute("rowType") == DOCKED_HEADER) {
                        var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, mrow);
                        if (dockedHeaderIdx >= 0) {
                            rowInfo = this.dockedHeaderRows[dockedHeaderIdx];
                        } else {
                            dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, mrow);
                            rowInfo = this.dockedHeaderReplaceRows[dockedHeaderIdx];
                        }
                    } else {
                        rowInfo = this.rows[mrow];
                    }

                    var touchedChart = rowInfo && rowInfo.rowRef && rowInfo.rowRef[mcol];
                    if (touchedChart) {
                        this.showChartTooltip(touchedChart, touch);
                    }

                }

            },

            
            shouldTouchBubble: function shouldTouchBubble(touch) {
                var isVertical = touch.isVertical;
                return isVertical ? this._super(touch) : this.enableSmoothScroll && isScrollableElementTouched.call(this, touch) ? false : true;
            },
            
            
            
            
            
            
            
            

            multiTouch: true,

            touchMultiBegin: function (touch) {
                
                
                
                
                hideTooltipGlobal.call(this);
                this.initTouchObj = touch;
                var touch1;
                var touch2;
                if (touch.evt.touches
                    && touch.evt.touches.length == 2) {
                    touch1 = touch.evt.touches[0];
                    touch2 = touch.evt.touches[1];
                } else {
                    touch1 = touch;
                    touch2 = {
                        pageX: 100,
                        pageY: 100,
                        target: touch.target
                    };
                }
                var xDiff = touch1.pageX - touch2.pageX;
                var yDiff = touch1.pageY - touch2.pageY;
                this.initDiffDiff = xDiff * xDiff + yDiff * yDiff;

                this.relScaleFactor = 1;

                var td1 = mstrmojo.dom.findAncestorByAttr(touch1.target, "mrow", true, this.domNode);
                var td2 = mstrmojo.dom.findAncestorByAttr(touch2.target, "mrow", true, this.domNode);
                if (td1 && td1.value && td2 && td2.value) {
                    this.centerRowIdx = Math.round(( parseInt(td1.value) + parseInt(td2.value) ) / 2);
                } else {
                    this.centerRowIdx = this.firstRowIdxOnScrn;
                }

                
                
                
            },

            touchMultiMove: function (touch) {
                
                
                
                var touch1;
                var touch2;
                if (touch.evt.touches
                    && touch.evt.touches.length == 2) {
                    touch1 = touch.evt.touches[0];
                    touch2 = touch.evt.touches[1];
                } else {
                    touch1 = touch;
                    touch2 = {
                        pageX: 100,
                        pageY: 100
                    };
                }
                var xDiff = touch1.pageX - touch2.pageX;
                var yDiff = touch1.pageY - touch2.pageY;
                this.curDiffDiff = xDiff * xDiff + yDiff * yDiff;
            },

            touchMultiEnd: function (touch) {
                if (this.isTreeMode) {
                    if (this.curDiffDiff > this.initDiffDiff) {
                        this.onPinchOpen();
                    } else if (this.curDiffDiff < this.initDiffDiff) {
                        this.onPinchClose();
                    }
                }

            },

            onPinchOpen: function onPinchOpen() {
                var currLowestLevel = getLowestLevelOnScreen.call(this);
                var levelToExpand = currLowestLevel;
                if (levelToExpand >= this.maxTreeLevel) {
                    
                    levelToExpand = this.maxTreeLevel - 1;
                }

                var anchorRowTreeNode = this.rows[this.centerRowIdx].treeNode;
                var anchorRowIdxOnScrn = this.centerRowIdx - this.firstRowIdxOnScrn;

                expandOrCollapseTreeAndSetScrlPos.call(this, levelToExpand, anchorRowTreeNode, anchorRowIdxOnScrn);
            },

            onPinchClose: function onPinchClose() {
                var currLowestLevel = getLowestLevelOnScreen.call(this);
                var levelToExpand = currLowestLevel - 2;
                if (levelToExpand < -1) {
                    
                    
                    levelToExpand = -1;
                }

                var anchorRowTreeNode = this.rows[this.centerRowIdx].treeNode;

                if (anchorRowTreeNode.level > levelToExpand + 1) {
                    
                    anchorRowTreeNode = getParentTreeNodeAtLevel(this.tree, anchorRowTreeNode.treePath, levelToExpand + 1);
                }
                var anchorRowIdxOnScrn = this.centerRowIdx - this.firstRowIdxOnScrn;

                expandOrCollapseTreeAndSetScrlPos.call(this, levelToExpand, anchorRowTreeNode, anchorRowIdxOnScrn);

            },

            
            destroyChartWidget: function destroyChartWidget() {

                if (this.rows && this.rows.length > 0 && this.rowsReusePool) {
                    this.pushToReusePool();
                }

                if (this.dockedHeaderRows && this.dockedHeaderReplaceRows) {
                    this.clearDockedHeader();
                }

                if (this.rowsReusePool && this.rowsReusePool.length > 0) {
                    var rows = this.rowsReusePool,
                        rowCount = rows.length,
                        colInfos = this.colInfos,
                        colCount = colInfos.length;

                    for (var i = 0; i < rowCount; i++) {
                        var rowRef = rows[i];

                        if (rowRef[LEFT_CHART_ROW]) {
                            delete rowRef[LEFT_CHART_ROW];
                        }
                        if (rowRef[RIGHT_CHART_ROW]) {
                            delete rowRef[RIGHT_CHART_ROW];
                        }

                        for (var j = 0; j < colCount; j++) {
                            var w = rowRef[colInfos[j].colIdx];
                            if (w && w.destroy) {
                                w.destroy();
                                delete rowRef[colInfos[j].colIdx];
                            }
                        }
                    }
                    this.rowsReusePool = [];
                }

            },

            destroy: function destroy() {
                console.log("in destroy");
                
                var listener = this._touchListener;
                if (listener) {
                    
                    mstrmojo.touchManager.detachEventListener(listener);
                    delete this._touchListener;
                }

                if (this._infoWClosedListener) {
                    mstrmojo.touchManager.detachEventListener(this._infoWClosedListener);
                    delete this._infoWClosedListener;
                }

                this.destroyChartWidget();

                if (this._leftChart) {
                    this._leftChart.destroy();
                    delete this._leftChart;
                }

                if (this._rightChart) {
                    this._rightChart.destroy();
                    delete this._rightChart;
                }

                if (this.rows) {
                    delete this.rows;
                }

                if (this.rowsReusePool) {
                    delete this.rowsReusePool;
                }

                if (this.selectorTargets) {
                    delete this.selectorTargets;
                }

                this._super();
            }



        });

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.DynamicClassFactory",
                         "mstrmojo._CanSupportTransaction",
                         "mstrmojo._IsEditableXtab",
                         "mstrmojo.AndroidInteractiveGridXtab",
                         "mstrmojo.DocXtabModel",
                         "mstrmojo.DocInteractiveGridXtab",
                         "mstrmojo.AndroidVisTimeSeries",
                         "mstrmojo.DocVisTimeSeries",
                         "mstrmojo.VisMicroChart",
                         "mstrmojo.maps.AndroidRptMap",
                         "mstrmojo.maps.AndroidMapModel",
                         "mstrmojo.maps.AndroidDocMap",
                         "mstrmojo.ImageCarousel",
                         "mstrmojo.PhotoUploader",
                         "mstrmojo.AndroidVisMap",
                         "mstrmojo.VisHeatMap");

    var VIS_LIST = {'AndroidImageMapStyle':{'s':'ImageMapVisualizationDataStyle','c':'AndroidVisMap'},'MicroChartsVisualizationStyle':{'s':'MicroChartVisualizationDataStyle','c':'VisMicroChart'},'TimeSeriesAjaxVisualizationStyle':{'dc':'DocVisTimeSeries','s':'TimeSeriesVisualizationDataStyle','c':'AndroidVisTimeSeries'},'ImageViewerVisualizationStyle':{'s':'VisualizationDataStyle','c':'ImageCarousel'},'AndroidPhotoUploaderStyle':{'s':'VisualizationDataStyle','c':'PhotoUploader'},'HeatMapVisualizationStyle':{'s':'HeatMapVisualizationDataStyle','c':'VisHeatMap'},'AndroidMapStyle':{'dc':'maps.AndroidDocMap','s':'MapVisualizationDataStyle','c':'maps.AndroidRptMap','m':'maps.AndroidMapModel'},'InteractiveGridAjaxVisualizationStyle':{'dc':'DocInteractiveGridXtab','s':'InteractiveGridDataStyle','c':'AndroidInteractiveGridXtab','m':'DocXtabModel'}};

    mstrmojo.AndroidVisList = mstrmojo.provide(

        'mstrmojo.AndroidVisList',

        {
            getVis: function getVis(styleName) {
                return VIS_LIST[styleName] || null;
            },

            getVisClass: function getVisClass(cls, defn) {
                
                if (defn.txi && defn.t === 115) {
                    cls = mstrmojo.DynamicClassFactory.newComponent(cls, [ mstrmojo._CanSupportTransaction, mstrmojo._IsEditableXtab ]);
                }

                return cls;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocSelector",
                         "mstrmojo.Button",
                         "mstrmojo.base64",
                         "mstrmojo.Dialog");

    mstrmojo.requiresDescs(1442, 2140, 5369, 8233, 8232, 8313, 8322);

    var SUBMIT = 8,
        RECALCULATE = 16,
        DISCARD = 4,
        
        DISPLAY_MSG = 1,


        REEXECUTE_DOCUMENT = 8,
        EXECUTE_OBJECT = 16,
        FORCE_LIVE_EXECUTION = 0x10000000,
        INVALID_CLIENT_CACHE = 0x20000000,
        AUTO_ANSWER_PROMPT = 0x40000000,
        useMojoDialog = window.mstrConfig && !window.mstrConfig.simpleDialog,
        SUBMIT_ERROR_VALIDATION_FAILURE = 0x800424E3,
        SUBMIT_ERROR_NO_CHANGE = 0x800424E4;

    var $NIB = mstrmojo.Button.newInteractiveButton;
   
    function confirmMsg(msg, okFn, cancelFn, okText, cancelText) {
        if (useMojoDialog) {
            var buttons = [$NIB(
                    okText || mstrmojo.desc(1442),
                    okFn || null,
                    null
                ), $NIB(
                    cancelText || mstrmojo.desc(2140),
                    cancelFn || null,
                    null
                )];
            
            mstrmojo.confirm(msg, mstrApp.useBinaryFormat ? buttons.reverse() : buttons);
        } else {
            
            if (mstrmojo.confirm(msg)) {
                if (okFn) {
                    okFn();
                }
            } else if (cancelFn) {
                cancelFn();
            }
        }
    }

    function alertMsg(msg, okFn) {
        if (useMojoDialog) {
            mstrmojo.alert(msg, okFn);
        } else {
            mstrmojo.alert(msg);
            if (okFn) {
                okFn();
            }
        }
    }

    
    mstrmojo.DocActionSelector = mstrmojo.declare(

        mstrmojo.DocSelector,

        null,

        
        {
            scriptClass: 'mstrmojo.DocActionSelector',

            extCls: 'mstrmojo-ActionSelector',

            
            type: SUBMIT,

            
            targets: null,

            initControlInfo: function initControlInfo() {
                var defn = this.node.defn;
                this.aa = parseInt(defn.aa, 10);
                this.dpTxt = defn.dpTxt || {8: mstrmojo.desc(5369), 4: mstrmojo.desc(8233), 16: mstrmojo.desc(8232)}[this.aa] || '';
                this.dpCfm = defn.dpCfm;
                this.sac = parseInt(defn.sac, 10);
                this.msg = defn.msg;
                this.rsid = defn.rsid;
                this.rst = defn.rst;

                this.node.data.elms = [{
                    n: this.dpTxt,
                    v: this.dpTxt
                }];

                this._super();
            },

            selectorControlChange: function selectorControlChange(w) {
                
                
                
                
                if (w.selectedIndex !== 0) {
                    return;
                }
                this.executeAction();
                w.select([]);
            },

            executeAction: function executeAction() {
                var aa = this.aa,
                    me = this;

                if (aa === SUBMIT) {
                    if (this.dpCfm) {
                        confirmMsg(mstrmojo.desc(8313), function () {
                            me.onControllerCheck();
                        });
                    } else {
                        me.onControllerCheck();
                    }
                } else if (aa === DISCARD) {
                    if (this.dpCfm) {
                        confirmMsg(mstrmojo.desc(8322), function () {
                            me.onDiscard();
                        });
                    } else {
                        me.onDiscard();
                    }
                } else {
                    this.onRecalculate();
                }
            },

            onControllerCheck: function onControllerCheck() {
                
                this.onCommit();
            },

            
            onCommit: function onCommit() {
                var me = this,
                    md = this.model,
                    ctl = me.controller,
                    useBinaryMode = mstrApp.useBinaryFormat;

                
                if (!useBinaryMode && !this.validateRequiredObjects()) {
                    alertMsg(mstrmojo.desc(9200)); 
                    return;
                }

                
                var executeActions = function (res) {
                    if ((me.sac & INVALID_CLIENT_CACHE) > 0) {
                        ctl.invalidClientCache();
                    }

                    if ((me.sac & EXECUTE_OBJECT) > 0) {
                        var params = {
                            did: me.rsid,
                            objType: me.rst,
                            forceExec: (me.sac & FORCE_LIVE_EXECUTION) > 0
                        };

                        if ((me.sac & AUTO_ANSWER_PROMPT) > 0) {
                            params.linkAnswers = '<hl mid="' + md.mid + '" srct="2" aopam="1"><prms></prms></hl>';
                        }

                        ctl.onExecuteNewObject(me, params);

                    } else if ((me.sac & REEXECUTE_DOCUMENT) > 0) {
                        ctl.onReExecute(me);

                    } else {
                    	
                        if (mstrApp.isMobile) {
                            
                            ctl.generateActionToolbar();
                        }
                    	
                        
                        md.transactionUpdate(res);
                    }
                };

                
                mstrmojo.mask.show('Running');
                
                md.sendTransactionActions(this.ck, SUBMIT, md.newCallback({
                    success: function (res) {
                        
                        mstrmojo.mask.hide();
                    	
                        
                        if(md.txrcd || res.offln) {
                            ctl.offlineTransactionsSubmitted(me.ck);
                        }
                        
                        if (res.offln) {
                            if(useBinaryMode && !me.networkToastShowed) {
                                me.networkToastShowed = true;
                                mstrmojo.toast(mstrmojo.desc(9258, 'No Network Connectivity') + '. ' + mstrmojo.desc(9259, 'Transaction will be submitted when connectivity is resumed.'));
                            }
                            md.transactionUpdate(res);
                        } else {
                            
                            if ((me.sac & DISPLAY_MSG) > 0 && me.msg) {
                                
                            	if (useBinaryMode) {
                                    mstrmojo.toast(me.msg);
                                    
                                    window.setTimeout(function () {
                                        executeActions(res);
                                    }, 100);
                                } else {
                                    alertMsg(me.msg, function () {
                                        executeActions(res);
                                    });
                                }
                            } else {
                                executeActions(res);
                            }
                        }
                    },

                    failure: function (res) {
                        var alertDialog = mstrmojo.all.mojoAlertx9;
                        if (alertDialog) {
                            alertDialog.destroy();
                        }
                        
                        mstrmojo.mask.hide();
                    	
                        
                        if(md.txrcd) {
                            ctl.offlineTransactionsSubmitted(me.ck);
                        }
                        
                        var errCode = 0x100000000 + parseInt(res.code, 10);
                        if (errCode === SUBMIT_ERROR_VALIDATION_FAILURE) {
                            
                            if (useBinaryMode) {
                                me.validateRequiredObjects();
                            }
                            alertMsg(mstrmojo.desc(9200, 'You have some required inputs that are not modified.'));

                        } else if (errCode === SUBMIT_ERROR_NO_CHANGE) {
                            var msg = mstrmojo.desc(9201, "You haven't made any changes to submit.");
                            if (useBinaryMode) {
                                mstrmojo.toast(msg);
                            } else {
                                alertMsg(msg);
                            }

                        } else {
                            
                            alertMsg(mstrmojo.base64.decodeHttpHeader(res.message), function () {
                                
                                if (!useBinaryMode) {
                                    me.controller.onReExecute(me, true);
                                }
                            });
                        }
                    }
                }));
            },

            
            onDiscard: function onDiscard() {
                var me = this,
                    md = this.model,
                    ctl = me.controller;

                md.txDiscardTargets = this.getTxTargets();

                md.sendTransactionActions(this.ck, DISCARD, {
                    success: function (res) {
                        md.transactionUpdate(res);
                        ctl.transactionDiscarded(me.ck);
                    },

                    
                    complete: function () {
                        delete md.txDiscardTargets;
                        
                        
                        if (mstrApp.isMobile) {
                            
                            ctl.generateActionToolbar();
                        }
                    }
                });
            },

            
            onRecalculate: function onRecalculate() {
                this.model.sendTransactionActions(this.ck, RECALCULATE);
            },

            
            getTxTargets: function getTxTargets() {
                var keys = this.tks.split('\u001E'),
                    i,
                    len,
                    key,
                    wid,
                    w,
                    j,
                    res = {};

                for (i = 0, len = keys.length; i < len; i++) {
                    
                    key = keys[i];

                    
                    wid = 1;

                    do {
                        
                        w = this.model.getUnitInstance(key, wid++);
                        
                        if (w && w.checkRequiredObjects) {
                            if (w.isPanelStack) {
                                
                                for (j in w.txWidgets) {
                                    res[w.txWidgets[j].id] = 1;
                                }
                            } else { 
                                res[w.id] = 1;
                            }
                        } else {
                            break;
                        }
                    } while (true);
                }
                return res;
            },

            
            validateRequiredObjects: function validateRequiredObjects() {
                var flag = true,
                    id;

                for (id in this.getTxTargets()) {
                    flag = mstrmojo.all[id].checkRequiredObjects() && flag;
                }

                return flag;
            }
        }
    );
}());


(function () {

    mstrmojo.requiresCls("mstrmojo.form",
                         "mstrmojo.hash",
                         "mstrmojo.date",
                         "mstrmojo.dom",
                         "mstrmojo.NumberFormat",
                         "mstrmojo.Button");

    var $DESC = mstrmojo.desc,
        $NIB = mstrmojo.Button.newInteractiveButton,
        $D = mstrmojo.date,
        _DT = function () {
            return mstrmojo.locales.datetime;
        };

    
    function toPage(me, params) {
        mstrmojo.form.send(params, null, "post");
    }

    
    function openHistoryPage(me, relNum) {
        var m = me.model;
        toPage(me, {
            evt: 3124,
            src: mstrApp.name + '.' + mstrApp.pageName + '.3124',
            relativePageNumber: relNum,
            messageID: m.mid,
            rwb: m.bs
        });
    }

    
    function toMode(doc, mode) {
        var m = doc.model;
        var conf = {
            evt: 2048001,            
            messageID: m.mid,
            rwb: m.bs
        };
        
        if (mode < 50 || mode === 2048) {
            conf.visMode = 0;
            conf.currentViewMedia = mode;
        } else {
            conf.visMode = mode;
            conf.currentViewMedia = 1;
        }
        toPage(doc, conf);
    }

    
    function handleClose(me) {
        var prevViewMedia = mstrApp.prevViewMedia;

        if ((!prevViewMedia && prevViewMedia !== 0) || prevViewMedia === -1) {
            
            openHistoryPage(me, -1);
        } else {
            
            if (prevViewMedia === 0) {
                
                me.designViewMode();
            } else {
                
                toMode(me, prevViewMedia);
            }
        }
    }

    
    function reload(doc, reprompt, refresh, regen) {
        var m = doc.model;
        toPage(doc, {
            evt: 2048030,        
            src: m.bp + '.2048030',
            rePrompt: reprompt,
            fresh: refresh,
            regenerate: regen,

            rwb: m.bs
        });
    }

    
    function updateZoomValue(doc, bSuppressEvt) {
        var m = doc.model,
            ztp = (m && m.ztp) || 0,
            zf = (m && m.zf) || 1,
            newid = ztp + ':' + zf,
            ops = doc.zoomOptions,
            newv;
        if (ops) {
            var idx = mstrmojo.array.find(ops, 'dssid', newid);
            if (idx > -1) {
                newv = ops[idx];
            }
        }
        if (!newv) {
            newv = {
                n: parseInt(zf * 100, 10) + '%',
                dssid: newid,
                f: zf,
                tp: ztp
            };
        }
        if (bSuppressEvt === true) {
            doc.zoomValue = newv;
        } else {
            doc.set('zoomValue', newv);
        }
    }

    
    function prompt2save(me, title, msg, fn, params, saveParam) {
        var m = me.model,
            dty = m && m.dty;
        if (!dty) {
            fn(me, params);
            return;
        }

        var btnHalo = '#666';

        mstrmojo.confirm(msg, [ $NIB($DESC(1442), function () {
            
            mstrmojo.requiresCls("mstrmojo.Serializer");

            
            me.save(saveParam);
        }, btnHalo), $NIB($DESC(2140), null, btnHalo) ], title);
    }
    
    
    function forceSaveAs(me) {
    	
        var m = me.model;

        m.showDialogBeforeSave = false;
        mstrmojo.xhr.request('POST', mstrConfig.taskURL, {
            success: function () {},
            failure: function (res) {
                mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
            }
        }, {
            taskId: 'setPreference',
            prefs: 'askBeforeSaveChanges' + '\u001E' + '2'
        });
      
    }

    
    var EXP_HTML = -1,
        EXP_PDF = 3,
        EXP_EXCEL = 4,
        EXP_FLASH = 7;

    mstrmojo._DocOIVMMethods = {
        
        staticViewMode: function svm() {
            toMode(this, 1);
        },

        interactiveViewMode: function ivm() {
            toMode(this, 2);
        },

        editableMode: function evm() {
            toMode(this, 4);
        },

        flashViewMode: function fvm() {
            toMode(this, 8);
        },

        IVEMode: function ive() {
            toMode(this, 2048);
        },
        
        IVEHelp: function ive() {
            var helpUrl = (mstrApp.helpUrl || '../help/')  + 'WebUser/WebHelp/Lang_' + (mstrApp.helpLocaleId ? mstrApp.helpLocaleId : mstrApp.localeId) + '/MicroStrategy_Web_Help.htm#';
            
            window.open(helpUrl + "about_interactive_visual_data_exploration.htm", "_blank");
            return true;
        },
        
        remainExpressViewMode: function remainExpress() {
            
        },

        
        designViewMode: function dvm() {
            toPage(this, {
                evt: 3104,    
                rwDesignMode: 1,
                messageID: this.model.mid,
                rwb: this.model.bs
            });
        },

        convertToDoc: function ctd() {
            var me = this;
            mstrmojo.confirm($DESC(8127), [ $NIB($DESC(1442), function () {
                me.designViewMode();
            }, null), $NIB($DESC(2140), null, null) ]);
        },

        
        
        saveAs: function(evt){
        	this.save();
        },
        
        
        save: function save(param) {
            var m = this.model;
            toPage(this,
                    mstrmojo.hash.copy(param,
                    {
                        evt: 3102,                            
                        applyChanges: false,
                        executionMode: 2,
                        parentFolderID: m.sfid || m.pfid,    
                        saveFromDesignMode: false,
                        rwb: m.bs                            
                    }));
        },
        
        dSave: function dSave() {
            var me = this,
                m = me.model,
                isnew = m && m.isnew,
                isRWReadonly = m && m.isRWReadonly; 
            maxLen = 60;
            truncateName = m.n;
            if(truncateName.length > maxLen){
                truncateName = truncateName.substr(0,maxLen - 1) + "...";
            }
            if (isnew || isRWReadonly) {
                this.save();

            } else {
            	
                var _showDialogBeforeSave = mstrApp.features["ask-before-save-changes"],
                    btnHalo = '#666';
                if (_showDialogBeforeSave) {
                    var id = 'dialogBeforeSave',
                        fnDestroy = function () {
                            mstrmojo.all.dialogBeforeSave.destroy();
                        };
                    mstrmojo.insert({
                        scriptClass: 'mstrmojo.Dialog',
                        id: id,
                        title: $DESC(5728),
                        cssText: 'min-width:475px;max-width:600px;',
                        btnAlignment: 'right',
                        buttons: [ 
                          $NIB($DESC(1442), function () {
                            var p = mstrmojo.all[id];

                            
                            if (p.t.ctrlChk.checked) {
                                me.setDontAskAgain();
                                mstrApp.features["ask-before-save-changes"] = false;
                            }

                            
                            me.directSave();

                            
                            fnDestroy();

                          }, btnHalo), 
                          $NIB($DESC(218), function () {
                            var p = mstrmojo.all[id];

                            
                            if (p.t.ctrlChk.checked) {
                                forceSaveAs(me);
                            }

                            
                            me.save();

                            
                            fnDestroy();

                          }, btnHalo),
                          $NIB($DESC(2140), fnDestroy, btnHalo) ],
                        children: [{
                            scriptClass: "mstrmojo.Table",
                            alias: "t",
                            rows: 2,
                            cols: 1,
                            children: [{
                                scriptClass: 'mstrmojo.Label',
                                text: $DESC(11165).replace(/##/, "<b>" + truncateName + "</b>"),
                                visible: true,
                                cssText: 'height:60px;',
                                slot: '0,0'
                            }, {
                                scriptClass: 'mstrmojo.CheckBox',
                                label: $DESC(211),
                                alias: 'ctrlChk',
                                visible: true,
                                checked: false,
                                slot: '1,0'
                            }]
                        }]
                    }).render();
                } else {
                    me.directSave();
                }
            }
        },

        setDontAskAgain: function setDontAskAgain() {
            
            var me = this,
                m = me.model;

            m.showDialogBeforeSave = false;
            mstrmojo.xhr.request('POST', mstrConfig.taskURL, {
                success: function () {},
                failure: function (res) {
                    mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                }
            }, {
                taskId: 'setPreference',
                prefs: 'askBeforeSaveChanges' + '\u001E' + '0'
            });
            
        },

        directSave: function directSave() {
            var me = this,
                m = me.model;
            var name = mstrmojo.string.decodeHtmlString(m.n);
            mstrmojo.xhr.request('POST', mstrConfig.taskURL, {
                success: function () {
                	mstrmojo.alert($DESC(3336).replace('##', m.n)); 
                },
                failure: function () {
                    mstrmojo.alert($DESC(4107));
                }
            }, {
                taskId: 'saveRW',
                msgID: m.mid,
                folderID: m.sfid || m.pfid,
                objName: name,
                objDesc: m.desc,
                saveAsFlags: 1,
                taskEnv: "xhr",
                taskContentType: "json"
            });
        },

        
        browseParent: function pFldr() {
            var m = this.model,
                params = {evt: 3010};            

            if (!m.pfh) {
                params.evt = 2001;                
                params.folderID = m.pfid;
                
                if (m.sysFolder) {
                    params.systemFolder = m.sysFolder;
                }
            }

            
            toPage(this, params);
        },

        
        close: function cl() {
            handleClose(this);
        },

        
        openPage: function opPg(relNum) {
            openHistoryPage(this, relNum);
        },

        saveToInbox: function inbox() {
            var me = this;
            mstrApp.serverRequest({
                taskId: "addDocToHistoryList",
                rwb: me.model.bs
            }, {
                success: function () {
                    var f = me.model.features;
                    if (f) {
                        if (f.set) {
                            f.set("enable-add-history-list", false);
                        } else {
                            f["enable-add-history-list"] = false;
                        }
                    }
                    mstrmojo.alert($DESC(8047));    
                }
            });
        },

		ShowSharingEditor: function ShowSharingEditor() {
			var $ID = "sharingEditor",
				sharingEditor = mstrmojo.all[$ID],
				me = this,
			    m = me.model,
			    SAVE_AS_SHARE_EDITOR = 11,
			    isBlankDoc = m.isBlankDocument,
			    openSharingEditor = function(oi) {
			    	if (sharingEditor) {
			            sharingEditor.set("oi", oi);
			            sharingEditor.objectName = m.n;
			            sharingEditor.href = null;
			            sharingEditor.mid = m.n;
			    	} else {
						sharingEditor = new mstrmojo.SharingEditor({
			                guestModeEnabled: mstrApp.guestModeEnabled,
			                mid: m.mid,
			                id: $ID,
			                oi: oi,
			                href: null,
			                isLinkDirty: true,
			                viewMode: 1,    
			                lastState: 0
			            });			    	
			    	}
			    	sharingEditor.open();
			    },
				cb = {
					success: function (res) {
		                openSharingEditor(res.objects[0]);
		            },
		            failure: function (res) {
		                mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
		            }
				};
			if (isBlankDoc){
				var btnHalo = '#666';
                mstrmojo.confirm(mstrmojo.desc(9932), [ $NIB($DESC(1442), function () {
                	me.save({
                        saveAsOrigin: SAVE_AS_SHARE_EDITOR
                    });
                }, btnHalo), $NIB($DESC(2140), null, btnHalo) ], mstrmojo.desc(8101));
			}else {
				mstrmojo.xhr.request('POST', mstrConfig.taskURL, cb, {
	            taskId: 'getObjectInfo',
	            objectIDs: m.oid,
	            objectTypes: 55,
	            includeACL: !!mstrApp.features["web-use-sharing-editor"],
	            sessionState: mstrApp.sessionState
				});
			}
	        
		},

        createPersonalView: function ctPV() {
            var me = this,
                m = me.model,
                isnew = m && m.isnew;

            if (isnew) {
                var btnHalo = '#666';
                mstrmojo.confirm(mstrmojo.desc(2510), [ $NIB($DESC(1442), function () {
                    mstrmojo.requiresCls("mstrmojo.Serializer");

                    me.save({
                        saveAsOrigin: 10
                    });
                }, btnHalo), $NIB($DESC(2140), null, btnHalo) ], mstrmojo.desc(9173));

            } else {
                var n = m.n,
                    pvdid = 'mstrPVD',
                    params = {
                        scriptClass: 'mstrmojo.PersonalViewSaveAs',
                        id: pvdid,
                        objectType: 55,
                        objectSubType: 0x3701
                    },
                    dlg = mstrmojo.all[pvdid] || mstrmojo.insert(params);

                if (n) {
                    var d = $D.getDateJson(new Date());
                    n += ' ' + $D.formatDateInfo(d, _DT().DATEOUTPUTFORMAT) +
                         ' ' + $D.formatTimeInfo(d, _DT().TIMEOUTPUTFORMAT);
                    dlg.set('name', n);
                }
                dlg.msgID = this.model.mid;
                dlg.open();
            }
        },

        reprompt: function rpmpt() {
            reload(this, true, false, false);
        },

        refresh: function rfsh() {
            reload(this, false, false, false);
        },

        rerun: function rerun() {
            reload(this, false, true, false);
        },
        
        toggleAutoRefresh: function(e) {
            var widget = e.src,
                controller = this.model.controller,
                enabled = controller.isAutoRefreshEnabled();
            
            controller[(enabled?'stop':'start')+'AutoRefresh']();
            widget.set('iconClass',(enabled?'tbStart':'tbStop')+'AutoRefresh');
            widget.domNode.setAttribute('title',enabled?'*Resume Auto Refresh*':'*Pause Auto Refresh*');
        },

        docVisualizationModeAJAX: function vizAjax() {
            toMode(this, 51);
        },

        docVisualizationModeFlash: function vizFlash() {
            toMode(this, 50);
        },

        sendNow: function sndNow() {
            prompt2save(this, mstrmojo.desc(2331, 'Send Now'), mstrmojo.desc(2513, 'You must save the report/document before you can send it.'), toPage, {            
                evt: 3037,
                objectType: 55,
                objectSubType: 14081,
                messageID: this.model.mid
            }, { 
                saveAsOrigin: 2
            });
        },

        scheduleHL: function scHL() {
            prompt2save(this, $DESC(5017, 'Subscribe to History List'), $DESC(2510, 'You must save the report/document before you can subscribe to it.'),  toPage, {
                evt: 3128,
                objectType: 55,
                objectSubType: 14081,
                messageID: this.model.mid
            }, { 
                saveAsOrigin: 3
            });
        },

        
        zoomValue: null,

        
        zoom: function zoom(dssid) {
            
            var nf = mstrmojo.NumberFormat.getInstance(mstrConfig.decimalSep, mstrConfig.thousandsSep);

            
            var parts = (dssid !== null) ? String(dssid).split(":") : [],
                ztp = parseInt(parts[0], 10),
                zfStr = parts[1],
                zf = nf.parse(zfStr);
            if (isNaN(ztp) || (!ztp && isNaN(zf))) {
                return;
            }

            var model = this.model;

            
            if (ztp === 1 || ztp === 2) {

                
                var lv = this.selected,
                    l = (lv && lv.docLayout) || null,
                    d = l && (l.containerNode || l.domNode),
                    docEl = d && d.ownerDocument.documentElement,
                    currzf = (model && model.zf) || 1;

                
                var fnFitDimension = function (dim) {
                    var x = d && d['offset' + dim];
                    if (!x) {
                        return 1;
                    }

                    
                    var xWin = Math.max(1, docEl['client' + dim]); 
                    return Math.min(4, Math.max(0.1, Number(currzf * xWin / x).toFixed(2)));
                };

                
                zf = fnFitDimension('Width');

                
                if (ztp === 2) {
                    
                    zf = Math.min(zf, fnFitDimension('Height'));
                }

                
                zfStr = nf.format(zf);
            }

            
            var newid = ztp + ':' + zfStr;
            if (newid !== (this.zoomValue && this.zoomValue.dssid)) {
                var me = this;

                model.getDataService().setDocZoom({
                    zoomType: ztp,
                    zoomFactor: zfStr
                }, {
                    success: function (res) {
                        
                        model.zf = res.zf;
                        model.ztp = res.ztp;

                        
                        model.replaceLayout(res.currlaykey, res);

                        
                        model.raiseEvent({
                            name: 'rebuildLayout'
                        });

                        
                        updateZoomValue(me, false);
                        me = null;
                    },
                    failureName: 'zoom.set'
                });
            }
        },

        
        exportCmd: function exportCmd(mode, gridKey) {

            var m = this.model,
                exEvt = (parseInt(mode, 10) === EXP_HTML) ? 3130 : 3132,                
                exOptions = m.exopt,                                                    
                promptUC = m.huc && mode === EXP_FLASH,                                 
                promptUser = exOptions.s && (mode === EXP_EXCEL || mode === EXP_PDF) && !gridKey,   
                bGbAll = false,                                                         
                bMulti = false;                                                         

            
            if (promptUser) {

                
                if (!!(m.defn && m.defn.layouts && m.defn.layouts.length > 1)) {
                    
                    bMulti = true;

                } else {
                    
                    var lyt = this.selected,
                        gb = lyt && lyt.gb && lyt.children[1];

                    
                    bGbAll = (!gb || gb.areUnitsSetToAll());

                    
                    if (bGbAll) {
                        
                        promptUser = false;
                    }
                }
            }

            
            var fnExport = function () {
                
                var params = {
                    evt: exEvt,
                    src: mstrApp.name + '.' + exEvt
                };

                
                if (exEvt === 3132) {
                    params.executionMode = mode;
                    if (gridKey != null) {
                        params.gridKey = gridKey;
                    }
                }

                
                if (!promptUser) {
                    
                    params.rwb = m.bs;

                } else {
                    
                    var s = mstrmojo.Serializer;

                    
                    var evts = [ [ 2048062, m.bp + '.2048062', 'mode', exOptions.m, 'range', exOptions.r ], [] ];

                    
                    mstrmojo.hash.forEach(params, function (v, k) {
                        
                        if (k === 'executionMode') {
                            
                            evts[1] = evts[1].concat([ k, v ]);
                        } else {
                            
                            evts[1].push(v);
                        }
                    });

                    
                    params.evt = 1024001;
                    params.src = m.bp + '.1024001';
                    params.events = s.serializeValueGroup(evts);
                    params['1024001'] = 1;
                    params.messageId = m.mid;
                }

                
                params.name = Date.parse(new Date());

                
                var exFn = function () {
                    mstrmojo.form.send(params, null, null, (exOptions.n) ? '_blank' : 'mstrExportWindow');
                };

                
                if (!mstrmojo.dom.isIE || mode !== EXP_FLASH) {
                    
                    exFn();
                } else {
                    
                    mstrmojo.alert(exOptions.ds[5873], exFn);  
                }
            };

            var ds = exOptions.ds,  
                btnHalo = '#666',   
                fnPrompt;

            if (promptUser || promptUC) {
                
                fnPrompt = function () {
                    var id = 'mojoExOpx9',
                        fnDestroy = function () {
                            mstrmojo.all.mojoExOpx9.destroy();
                        };

                    mstrmojo.insert({
                        scriptClass: 'mstrmojo.Dialog',
                        id: id,
                        title: ds[971],
                        cssText: 'min-width:225px;max-width:325px;',
                        btnAlignment: 'right',
                        buttons: [
                            $NIB(ds[1442], function () {
                                
                                mstrmojo.requiresCls("mstrmojo.Serializer");

                                
                                var p = mstrmojo.all[id];
                                if (bMulti) {
                                    exOptions.r = p.ctrlLyt.selected;
                                }
                                if (!bGbAll) {
                                    exOptions.m = (p.ctrlChk.checked) ? 0 : 1;
                                }

                                
                                fnDestroy();

                                
                                fnExport();

                            }, btnHalo),
                            $NIB(ds[2140], fnDestroy, btnHalo)
                        ],
                        children: [{
                            
                            scriptClass: 'mstrmojo.Label',
                            text: ds[7482],
                            visible: promptUC
                        }, {
                            
                            scriptClass: 'mstrmojo.DropDownList',
                            title: ds[246],
                            cssClass: 'field',
                            cssDisplay: 'block',
                            alias: 'ctrlLyt',
                            visible: !!bMulti,
                            idx: exOptions.r,
                            options: [{
                                n: ds[5137],
                                v: 0
                            }, {
                                n: ds[5138],
                                v: 1
                            }]
                        }, {
                            
                            scriptClass: 'mstrmojo.CheckBox',
                            label: ds[5165],
                            cssClass: 'field',
                            cssDisplay: 'block',
                            alias: 'ctrlChk',
                            visible: !!!bGbAll && promptUser,
                            checked: (exOptions.m === 0)
                        }]
                    }).render();
                };
            }

            
            if (mode === EXP_EXCEL && ds['3809'] !== undefined && !gridKey) {
                
                mstrmojo.confirm(ds['3809'], [
                    $NIB(ds[1442], fnPrompt || fnExport, btnHalo),
                    $NIB(ds[2140], null, btnHalo)
                ]);

            
            } else if (fnPrompt) {
                
                fnPrompt();

            
            } else {
                fnExport();

            }
        },

        printPDF: function prntPDF() {
            this.exportCmd(EXP_PDF);
        },

        openHome: function openHome(me) {
            toPage(me, {
                evt: 3010,
                src: mstrApp.name
            });
        },

        updateZoom: function updateZoom() {
            updateZoomValue(this, false);
        },

        __onmixin__: function __onmixin__() {
            
            updateZoomValue(this, true);
        },
        
        resetSelections: function resetSelections() {
        	var me = this,
        		m = me.model;
        	m.getDataService().resetSelections(null, false, {
        		success: function(res) {
        			if (res.disablePU) {
        				m.loadLayout(res);
        				return;
        			}
        			
        			if (res.pukeys) {
        				
        				var pu = m.partialUpdate(res.data, m.getUnitDefinitions(res.pukeys)),
        					dc = m.getLayoutDataCache(m.getCurrentLayoutKey());
        				
        				
        				mstrmojo.hash.forEach(pu.upd, function(v, uid) {
        					var w = mstrmojo.all[uid];
        					
        					if (w && w.defn && w.defn.t == mstrmojo.EnumRWUnitType.PANELSTACK) {
        						var psd = dc && dc[uid] && dc[uid].data,
        							selKey = psd && psd.selKey;
        						
        						
        						if (selKey && w.selectedKey != selKey) {
        							w.defn.set('selKey', selKey);
        						}
        						
        						w.setDirtyChildren();
        					}
        				});
        			}
        			
        			
        			var layouts = me.getLayouts(),
        				len = (layouts && layouts.length) || 0,
        				curlaykey = m.getCurrentLayoutKey();
        			for (var i = 0; i < len; i++) {
        				var layout = layouts[i];
        				if (layout.defn && layout.defn.loaded && curlaykey != layout.k) {
        					layout.defn.loaded = false;
        				}
        			}
        		}
        	});
        }
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.StackContainer",
                         "mstrmojo._IsRwDocument",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._HasLayout",
                         "mstrmojo._HasPopup",
                         "mstrmojo._DocOIVMMethods",
                         "mstrmojo.array",
                         "mstrmojo.css");
    
    
    mstrmojo.Doc = mstrmojo.declare(
        
        mstrmojo.StackContainer,

        [ mstrmojo._HasBuilder, mstrmojo._IsRwDocument, mstrmojo._HasLayout, mstrmojo._HasPopup],

        
        {
            scriptClass: "mstrmojo.Doc",

            cssClass: "mstrmojo-Doc",

            methods: {"*": "mstrmojo._DocOIVMMethods"},

            markupSlots: {
                containerNode: function () { return this.domNode; },
                popupNode: function () { return this.domNode; },
                drillLinkMenuNode: function () { return this.domNode; }
            },

            layoutConfig: {
                h: {
                    containerNode: '100%'
                },
                w: {
                    containerNode: '100%'
                }
            },

            getLayouts: function () {
                return this.children;
            },

            buildChildren: function buildChildren(noAddChildren) {
                
                if (this._super(false)) {
                    
                    var k = this.model.getSelectedKey(this.node),
                        i = (k !== null) ? mstrmojo.array.find(this.children, "k", k) : -1,
                        ch = (i > -1) ? this.children[i] : null;

                    if (ch) {
                        
                        this.set("selected", ch);
                    }
                    return true;
                }

                return false;
            },

            restoreLayoutState: function restoreLayoutState(selectedChild) {
                
                this._super(selectedChild);

                
                
                
                var childZoom = selectedChild.zf;
                if ((this.zf !== childZoom || this.model.zf !== childZoom) && this.updateZoom) {
                    this.zf = this.model.zf = childZoom;
                    this.updateZoom();
                }
            },

            
            _set_selected: function _set_selected(prop, layout) {

                
                if (!this.selected) {
                    
                    return this._super(prop, layout);
                }

                
                if (layout) {
                    var me = this,
                        _super = this._super,
                        newKey = layout.k;

                    
                    this.getNewLayout({ layoutKey: newKey }, this.children, (newKey !== this.model.currlaykey), {
                        success: function (newLayout) {
                            
                            var old = me.selected;
                            _super.call(me, prop, newLayout);

                            
                            me.raiseEvent({
                                name: 'selectedChange',
                                prop: 'selected',
                                value: newLayout,
                                valueWas: old
                            });
                        }
                    });
                }

                return true;
            },

            onLayoutRebuilt: function onLayoutRebuilt(layout) {
                this._set_selected('selected', layout, true);
            },

            replaceLayout: function replaceLayout(oldLayout, newLayoutNode) {
                
                var idx = this.removeChildren(oldLayout);
                oldLayout.destroy();

                
                var c = this.builder.build([ newLayoutNode ], this.model);

                
                this.addChildren(c, idx);

                return c[0];
            },

            
            getSelectedLayoutWidget: function getSelectedLayout() {
                
                
                return this.selected;
            },

            xtabCellMenuRef: "mstrmojo.XtabCellMenu",

            openXtabCellMenu: function (config) {
                if (config) {
                    config.opener = this;
                    
                    if (this._lockInfoWinContainer)	{ 
                    	this._lockInfoWinContainer(config);
                    }
                }
                
                this.openPopup("xtabCellMenuRef", config);
            },

            closeXtabCellMenu: function closeXtabCellMenu() {
                this.closePopup();
            },

            drillLinkMenuRef: "mstrmojo.DrillLinkMenu",

            
            openDrillLinkMenu: function openDrillLinkMenu(config) {
                if (config) {
                    config.opener = this;
                }
                
                this.openPopup("drillLinkMenuRef", config);
            },

            
            closeDrillLinkMenu: function closeDrillLinkMenu() {
                this.closePopup();
            },

            
            goToLink: function goToLink(link) {
                if (link) {
                    
                    window.open(link.url, (link.target || '_self'));
                }
            },

            
            selectorMenuRef: "mstrmojo.SelectorMenu",
            fpMenuRef: "mstrmojo.FilterPanelMenu",

            openPopupMenu: function openPopupMenu(mnRef, config) {
                if (config) {
                    config.opener = this;
                }
                
                this.openPopup(mnRef, config);
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.EnumRWUnitType",
                         "mstrmojo.DocLayout",
                         "mstrmojo.DocLayoutHoriz",
                         "mstrmojo.DocSection",
                         "mstrmojo.DocSubsection",
                         "mstrmojo.DocTextfield",
                         "mstrmojo.DocXtabModel",
                         "mstrmojo.DocVisModel",
                         "mstrmojo.XtabBase",
                         "mstrmojo.DocPortlet",
                         "mstrmojo.DocResizablePortlet",
                         "mstrmojo.DocXtabGraph",                        
                         "mstrmojo.DocGridGraph",
                         "mstrmojo.DocLine",
                         "mstrmojo.DocImage",
                         "mstrmojo.DocHTMLContainer",
                         "mstrmojo.DocRectangle",
                         "mstrmojo.DocRoundRectangle",
                         "mstrmojo.DocPanel",
                         "mstrmojo.DocSelector",
                         "mstrmojo.DocActionSelector",
                         "mstrmojo._HasDocLink",
                         "mstrmojo.DocVisualization",
                         "mstrmojo.DynamicClassFactory",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsDocXtab",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo.DocInfoWindow",
                         "mstrmojo._CanSupportTransaction",
                         "mstrmojo._IsEditableXtab",
                         "mstrmojo._IsEditableTextfield",
                         "mstrmojo.DocSelectorViewFactory",
                         "mstrmojo._HasHoverButton",
                         "mstrmojo.hash");

    var $HASH = mstrmojo.hash;

    
    var en = mstrmojo.EnumRWUnitType,
        clsMap = {};

    clsMap[en.LAYOUT] = {n: "Layout"};
    clsMap[en.HEADER] =
        clsMap[en.FOOTER] =
        clsMap[en.PAGEHEADER] =
        clsMap[en.PAGEFOOTER] =
        clsMap[en.DETAILS] =        { n: "Section", scriptClass: "mstrmojo.DocSection" };
    clsMap[en.SUBSECTION] =         { n: "SubSection", scriptClass: "mstrmojo.DocSubsection" };
    clsMap[en.TEXTFIELD] =          { n: "Textfield", scriptClass: "mstrmojo.DocTextfield" };
    clsMap[en.GRID] =               { n: "Xtab", scriptClass: "mstrmojo.DocXtab" };
    clsMap[en.GRAPH] =              { n: "XtabGraph", scriptClass: "mstrmojo.DocXtabGraph" };
    clsMap[en.GRIDGRAPH] =          { n: "GridGraph", scriptClass: "mstrmojo.DocGridGraph" };
    clsMap[en.SELECTOR] =           { n: "Selector", scriptClass: "mstrmojo.DocSelector" };
    clsMap[en.LINE] =               { n: "Line", scriptClass: "mstrmojo.DocLine" };
    clsMap[en.IMAGE] =              { n: "Image", scriptClass: "mstrmojo.DocImage" };
    clsMap[en.HTMLCONTAINER] =      { n: "HTMLContainer", scriptClass: "mstrmojo.HTMLContainer" };
    clsMap[en.RECTANGLE] =          { n: "Rectangle", scriptClass: "mstrmojo.DocRectangle" };
    clsMap[en.ROUNDEDRECTANGLE] =   { n: "RoundedRectangle", scriptClass: "mstrmojo.DocRoundRectangle" };
    clsMap[en.PANEL] =              { n: "Panel", scriptClass: "mstrmojo.DocPanel" };
    clsMap[en.VISUALIZATION] =      { n: "Visualization", scriptClass: "mstrmojo.DocVisualization" };
    clsMap[en.MOJOVISUALIZATION] =   {n: "MojoVisualization"};

    
    var linkClsMap = {};

    var $CFC = mstrmojo.DynamicClassFactory.newComponent;

    var _EH = mstrmojo.elementHelper;

    
    function getPortletButtonHandler(action) {
        return function () {
            return this.parent.parent['on' + action]();
        };
    }

    
    var fMx = getPortletButtonHandler('maximize'),
        
        fRs = getPortletButtonHandler('restore'),
        
        fMn = getPortletButtonHandler('minimize'),
        
        fCo = getPortletButtonHandler('collapse'),
        
        fEx = getPortletButtonHandler('expand');

    
    mstrmojo.DocXtab = $CFC(mstrmojo.XtabBase, [mstrmojo._Formattable, mstrmojo._IsDocXtab], {
        scriptClass: 'mstrmojo.DocXtab'
    });

    
    var getPopupDelegate = function (widget, openMenu) {
        var w = widget && widget.parent;
        while (w) {
            if (w[openMenu]) {
                return w;
            }
            w = w.parent;
        }
        return null;
    };

    
    function createResizeButton(t, c, fn, bds, cds) {
        return mstrmojo.Button.newIconButton(t, c, fn, null, {
            ds: bds,
            visible: (cds !== bds)
        });
    }

    
    function getLinkDrillingClass(clazz, type, useHover) {
        var className = clsMap[type].n + (useHover ? 'Hover' : ''),
            Cls = linkClsMap[className];

        
        if (!Cls) {
            
            Cls = linkClsMap[className] = $CFC(clazz, [ mstrmojo._HasDocLink ].concat(this.getLinkDrillMixins(useHover)));
        }

        
        return Cls;
    }


    
    mstrmojo.DocBuilder = mstrmojo.declare(
        
        mstrmojo.Obj,

        
        null,

        
        {
            
            scriptClass: "mstrmojo.DocBuilder",

            
            visList: null,

            destroy: function destroy() {
                var selectorFactory = this.selectorFactory;
                if (selectorFactory) {
                    selectorFactory.destroy();
                }

                this._super();
            },

            
            classMap: clsMap,

            
            build: function build(nodes, model) {
                var arr = [],
                    mthMap = this.classMap,
                    len = ((nodes && nodes.length) || 0),
                    i;

                for (i = 0; i < len; i++) {
                    
                    var node = nodes[i],
                        nodeDefn = node && node.defn,
                        nodeData = node && node.data,
                        t = (nodeDefn && nodeDefn.t) || mstrmojo.EnumRWUnitType.LAYOUT,       
                        config = mthMap[t];                                                   

                    
                    var isDocButton = (t === en.TEXTFIELD && ((nodeDefn && nodeDefn.dpst)));
                    if (isDocButton) {
                        
                        config = mthMap[t + 'B'];
                    }

                    
                    var fn = (config && config.n) ? 'new' + config.n : '',
                        w;

                    
                    if (this[fn]) {
                        
                        w = this[fn](model, node);

                    } else if (config && config.scriptClass) {

                        
                        var Cls = config.cls;
                        if (!Cls) {
                            
                            Cls = $HASH.walk(config.scriptClass, window);
                        }

                        
                        if (t === en.TEXTFIELD || t === en.IMAGE) {

                            
                            var dataDlRef = nodeData.dl,
                                defnDlRef = nodeDefn.dl,
                                hasLinks = (dataDlRef && dataDlRef.items && dataDlRef.items.length) || (defnDlRef && defnDlRef.items && defnDlRef.items.length > 0);

                            
                            if (hasLinks || nodeData.url || nodeDefn.url || nodeDefn.ifw) {
                                
                                
                                Cls = getLinkDrillingClass.call(this, Cls, t + (isDocButton ? "B" : ""), hasLinks);

                            } else if ((t === en.TEXTFIELD) && nodeDefn.txi) {
                                Cls = $CFC(Cls, [ mstrmojo._CanSupportTransaction, mstrmojo._IsEditableTextfield ]);

                            }
                        }

                        
                        if (Cls) {
                            
                            

                            
                            w = new Cls({
                                id: node.id,
                                node: node,
                                controller: this.parent.controller,
                                model: model
                            });
                        }
                    }

                    
                    if (w) {
                        
                        w.k = node.k;
                        w.formatResolver = model.formatResolver;
                        w.builder = this;
                        w.tooltip = nodeData.tooltip || nodeDefn.tooltip || '';

                        
                        if (!w.defn) {
                            
                            w.defn = nodeDefn;
                        }

                        w.disposables.push(w.defn);

                        
                        if (w.update) {
                            w.update(node);
                        }

                        
                        if ((nodeDefn.ttl !== undefined && t !== en.PANEL) || nodeDefn.qsm) {
                            w = this.createPortlet(t, node, w);
                        }

                        arr.push(w);
                    }
                }
                return arr;
            },

            
            createPortlet: function createPortlet(t, node, w) {
                var defn = node.defn,
                    ds = defn.ds,
                    resizable = (defn.iifp || !(t === en.PANELSTACK || (defn.ttl === undefined && defn.qsm) || t === en.SELECTOR)),
                    hasGraph = (t === en.GRAPH || t === en.GRIDGRAPH),
                    children = [],
                    $NIB = mstrmojo.Button.newIconButton,
                    leftToolbarNodeCssClass = '',
                    toolbarNodeCssClass = '',
                    buttonbarNodeClass = '',
                    isExportGrid = (t === en.GRID || hasGraph || t === en.VISUALIZATION) && parseInt(defn.eo, 10) !== 2,
                    toolbarNode = [],
                    tbCssClass = 'mstrmojo-oivmSprite ',
                    hasTitlebarMenuButton = false; 

                
                if (defn.qsm) {
                    leftToolbarNodeCssClass = 'qks';

                    
                    var fnQuickSwitchBtn = function (title, css, qsm) {
                        return $NIB(title, tbCssClass + css, function () {
                            return this.parent.parent.content.quickSwitch();
                        }, {
                            visible: 'this.parent.parent.defn.qsm !== this.qsm'
                        }, {
                            qsm : qsm
                        });
                    };

                    
                    children.push({
                        scriptClass: 'mstrmojo.ToolBar',
                        slot: 'leftToolbarNode',
                        alias: 'leftToolbar',
                        cssClass: (!resizable) ? 'grouped' : '',
                        children: [ fnQuickSwitchBtn(mstrmojo.desc(3547, 'View: Grid'), 'tbGrid', 1), fnQuickSwitchBtn(mstrmojo.desc(3548, 'View: Graph'), 'tbGraph', 2) ]
                    });
                }

                if (isExportGrid) {
                    var tb = this.getPortletExportGridToolbar(w.k);
                    if (tb) {
                        toolbarNodeCssClass = tb.css;

                        toolbarNode = tb.node;

                        children.push(toolbarNode);
                    }
                }

                
                if (resizable) {
                    if (defn.iifp) {
                        leftToolbarNodeCssClass = 'wrap';

                        
                        children.push({
                            scriptClass: 'mstrmojo.ToolBar',
                            slot: 'leftToolbarNode',
                            alias: 'leftToolbar',
                            children: [ createResizeButton(mstrmojo.desc(8973, 'Collapse'), 'co', fCo, 1, ds),
                                        createResizeButton(mstrmojo.desc(8972, 'Expand'), 'ex', fEx, 0, ds) ]
                        });
                    } else {
                        var btns = [ createResizeButton(mstrmojo.desc(4539, 'Minimize'), 'mn', fMn, 1, ds),
                                     createResizeButton(mstrmojo.desc(4540, 'Restore'), 'rs', fRs, 0, ds),
                                     createResizeButton(mstrmojo.desc(4541, 'Maximize'), 'mx', fMx, 2, ds) ];

                        if (isExportGrid) {
                            toolbarNode.children = (toolbarNode.children || []).concat(btns);

                        } else {
                            toolbarNodeCssClass = 'resize';

                            
                            children.push({
                                scriptClass: 'mstrmojo.ToolBar',
                                slot: 'toolbarNode',
                                alias: 'rightToolbar',
                                children: btns
                            });
                        }
                    }
                }

                
                w.slot = 'contentNode';
                w.alias = 'content';
                w.title = defn.ttl || '';

                
                if (defn.sec) {
                    
                    if (defn.style !== mstrmojo.DocSelectorViewFactory.STYLES.SCROLLER && !defn.sos) {
                        var nodeData = node.data,
                            es = nodeData.elms,
                            ces = nodeData.ces;

                        
                        if (ces && es && es.length) {
                            
                            w.count = _EH.buildElemsCountStr(ces, es);
                        }
                    }
                }

                
                children.push(w);

                
                if (t === en.PANELSTACK) {
                    var fnNewNavButton = function (title, css, binding, dir) {
                            return $NIB(title, tbCssClass + css, function () {
                                
                                return this.parent.parent.content.switchToPanel(dir);
                            }, {
                                enabled: 'this.parent.parent.' + binding
                            });
                        },
                        rTb = [],
                        lTb = [],
                        hasPanelNav = !!node.sw,
                        isInfoWindow = !!defn.ifw,
                        isFilterPanel = !!defn.ifp;

                    if (hasPanelNav) {
                        
                        lTb.push(fnNewNavButton(mstrmojo.desc(1058, 'Previous'), 'tbPrev', 'prevEnabled', -1));   

                        
                        rTb.push(fnNewNavButton(mstrmojo.desc(2917, 'Next'), 'tbNext', 'nextEnabled', 1));   
                    }

                    
                    if (isInfoWindow) {
                        
                        rTb.push($NIB(mstrmojo.desc(2102, 'Close'), tbCssClass + 'mstrmojo-DocInfoWindow-close', function () {
                            this.parent.parent.parent.close();
                        }));
                    }

                    if (isFilterPanel) { 
                        buttonbarNodeClass = 'ifp';

                        children.push({
                            scriptClass: 'mstrmojo.HBox',
                            slot: 'buttonbarNode',
                            alias: 'buttonbar',
                            cssClass: 'buttonBox',
                            children: [{
                                scriptClass: 'mstrmojo.Button',
                                alias: 'applyNow',
                                title: mstrmojo.desc(2164, 'Apply'),
                                text: mstrmojo.desc(2164, 'Apply'),
                                cssClass: 'mstrmojo-FilterPanel-Btn apply',
                                bindings: {
                                    visible: function () {
                                        return !defn.cas;
                                    },
                                    enabled: function () {
                                        return this.parent.parent.applyEnabled;
                                    }
                                },
                                onclick: function onclick() {
                                    if (w && w.applyBufferedSlices) {
                                        w.applyBufferedSlices();
                                    }
                                }
                            }]
                        });

                        rTb.push({
                            scriptClass: 'mstrmojo.Button',
                            cssClass: 'mstrmojo-oivmSprite tbDown',
                            alias: 'btnMenu',
                            onclick: function onclick() {
                                this.openPopupMenu();
                            },
                            openPopupMenu: function () {
                                var dl = getPopupDelegate(this, 'openPopupMenu');
                                if (dl) {
                                    dl.openPopupMenu('mstrmojo.FilterPanelMenu', {
                                        openerButton: this,
                                        fps: w,
                                        cmPos: this.cmPos
                                    });
                                }
                            }
                        });
                        hasTitlebarMenuButton = true;
                    }

                    
                    if (isInfoWindow || isFilterPanel) {
                        var boxCss = [];
                        if (hasPanelNav) {
                            boxCss[0] = 'pst-l';
                        }

                        if (isFilterPanel) {
                            boxCss.push('ifp');
                        }

                        lTb.push({
                            scriptClass: 'mstrmojo.Box',
                            cssClass: boxCss.join(' ')
                        });
                    }

                    if (isInfoWindow || hasPanelNav || isFilterPanel) {
                        var ifwCss = isInfoWindow ? 'ifw ' : '',
                            ifpCss = isFilterPanel ? 'ifp ' : '',
                            casCss = !defn.cas ? 'cas ' : '';

                        toolbarNodeCssClass = (hasPanelNav ? 'pst-r ' : '') + ifwCss + ifpCss + casCss;
                        leftToolbarNodeCssClass = (hasPanelNav ? 'pst-l ' : '') + ifwCss + ifpCss + casCss;
                        children.push({
                            scriptClass: 'mstrmojo.ToolBar',
                            slot: 'leftToolbarNode',
                            alias: 'leftToolbar',
                            children: lTb
                        });
                        children.push({
                            scriptClass: 'mstrmojo.ToolBar',
                            slot: 'toolbarNode',
                            alias: 'rightToolbar',
                            children: rTb
                        });
                    }
                }

                
                if (t === en.SELECTOR && w.spm) { 
                    toolbarNodeCssClass = 'spm';

                    
                    children.push({
                        scriptClass: 'mstrmojo.ToolBar',
                        slot: 'toolbarNode',   
                        alias: 'rightToolbar',
                        children: [{
                            scriptClass: 'mstrmojo.Button',
                            cssClass: 'mstrmojo-oivmSprite tbDown',
                            alias: 'btnMenu',
                            onclick: function onclick() {
                                this.openPopupMenu();
                            },
                            openPopupMenu: function () {
                                var dl = getPopupDelegate(this, 'openPopupMenu');
                                if (dl) {
                                    dl.openPopupMenu('mstrmojo.SelectorMenu', {
                                        openerButton: this,
                                        selector: w,
                                        cmPos: this.cmPos
                                    });
                                }
                            }
                        }]
                    });
                    hasTitlebarMenuButton = true;
                }

                
                var Cls = 'Doc' + (resizable ? 'Resizable' : '') + 'Portlet',
                    props = {
                        defn: w.defn,
                        model: w.model,
                        children: children,
                        title: w.title,
                        count: w.count,
                        floatingTitle: (defn.ttl === undefined && defn.qsm),
                        leftToolbarNodeClass: leftToolbarNodeCssClass,
                        loadDataOnResize: hasGraph,
                        toolbarNodeClass: toolbarNodeCssClass,
                        buttonbarNodeClass: buttonbarNodeClass,
                        attachContextMenuEvent: hasTitlebarMenuButton
                    };

                if (t === en.PANELSTACK) {
                    props.bindings = {
                        title: 'this.children[0].title' 
                    };

                    
                    
                    
                    if (node.sw) {
                        props.bindings.prevEnabled = function () {
                            return this.children[0].hasPreviousPanel;
                        };
                        props.bindings.nextEnabled = function () {
                            return this.children[0].hasNextPanel;
                        };
                    }

                    
                    if (defn.ifp) {
                        props.bindings.applyEnabled = function () {
                            return this.children[0].applyEnabled;
                        };
                    }
                }

                return new mstrmojo[Cls](props);
            },

            getPortletExportGridToolbar: mstrmojo.emptyFn,

            
            getLayoutViewerClass: function getLayoutViewerClass(node) {
                return mstrmojo.DocLayoutViewer;
            },

            
            newLayout: function newLayout(model, node) {

                
                var chs = [],
                    nodeData = node.data,
                    nodeDefn = node.defn,
                    LayoutViewerCls = this.getLayoutViewerClass(node),
                    dlv = new LayoutViewerCls({
                        n: nodeDefn.title,    
                        model: model,
                        node: node,
                        controller: this.parent.controller,
                        tbc: nodeDefn.tbc,
                        slot: 'containerNode',
                        visible: false,        
                        ifs: nodeData.ifs,    
                        gb: nodeData.gbys     
                    });

                
                var defn = dlv.defn = $HASH.copy(nodeDefn);
                defn.fmts = $HASH.copy(nodeDefn.fmts);

                



                var fnHeaders = function (headers, slot) {
                    var cnt = headers.length;
                    if (cnt) {
                        var h, f;
                        for (h = 0; h < cnt; h++) {
                            f = this.build([headers[h]], model)[0];
                            f.slot = slot;
                            chs.push(f);
                        }
                    }
                };

                fnHeaders.call(this, model.getFixedHeaders(node), 'fixedHeaderNode');

                
                var LayoutCls = mstrmojo['DocLayout' + ((nodeDefn.horiz) ? 'Horiz' : '')];

                
                chs.push(new LayoutCls({
                    slot: "layout",
                    id: node.id,
                    k: node.k,
                    minHeight: nodeData.mh,
                    formatResolver: model.formatResolver,
                    rules: nodeDefn.rules,
                    builder: this,
                    node: node,
                    defn: nodeDefn,
                    model: model
                }));

                
                fnHeaders.call(this, model.getFixedFooters(node), 'fixedFooterNode');

                
                dlv.addChildren(chs);

                return dlv;
            },

            newSection: function (model, node) {
                
                var cls = (node.defn.horiz && node.data.subsections.length > 1) ? 'DocSectionHoriz' : 'DocSection';
                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            newHTMLContainer: function (model, node) {
                
                var cls = (node.defn.ht === 0) ? 'DocHTMLContainer' : 'DocTextfield';
                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            adjustMojoVisualizationClass: function adjustMojoVisualizationClass(className) {
                
                return className;
            },

            newMojoVisualization: function (model, node) {
                var visList = this.visList,
                    nodeData = node.data,
                    visInfo = visList.getVis(nodeData.visName);

                
                if (!visInfo) {
                    
                    var className = nodeData.className;
                    if (!className) {
                        
                        return this.newXtab(model, node);
                    }

                    
                    visInfo = {
                        dc: className
                    };
                }

                
                var viewClassName = (visInfo.dc !== undefined) ? visInfo.dc : visInfo.c;

                
                viewClassName = this.adjustMojoVisualizationClass(viewClassName);

                
                mstrmojo.requiresCls('mstrmojo.' + viewClassName);

                var ViewClass = $HASH.walk(viewClassName, mstrmojo),                 
                    ModelClass = $HASH.walk(visInfo.m || "DocVisModel", mstrmojo);  

                
                if (!ViewClass || !ModelClass) {
                    throw new Error('Missing visualization class.');
                }

                
                ViewClass = visList.getVisClass(ViewClass, node.defn);

                
                var vis = new ViewClass($HASH.copy(nodeData.extProps, {
                    id: node.id,
                    node: node,
                    n: node.defn.title,    
                    controller: this.parent.controller,
                    gb: nodeData.gbys                       
                }));

                
                vis.setModel(new ModelClass({
                    xtab: vis,
                    controller: this.parent.controller,
                    docModel: model
                }));

                
                vis.model.set('data', nodeData);

                
                
                
                if (!!node.data.sdp) {
                    var sdpKey;
                    for (sdpKey in node.data.sdp) {
                        node.data.sdp[sdpKey].defn = {}; 
                        var obj = this.newXtab(model, node.data.sdp[sdpKey]);

                        
                        obj.setModel(new ModelClass({
                            xtab: obj,
                            controller: this.parent.controller,
                            docModel: model,
                            data: node.data.sdp[sdpKey]
                        }));
                        obj.k = sdpKey; 
                    }
                }

                
                return vis;
            },

            newInfoWindow: function newInfoWindow(cfg) {
                return new mstrmojo.DocInfoWindow(cfg);
            },

            newRoundedRectangle: function newRoundedRectangle(model, node) {
                var $D = mstrmojo.dom,
                    cls = ($D.supports($D.cssFeatures.ROUND_CORNERS)) ? 'DocRectangle' : 'DocRoundRectangle';

                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            newSelector: function newSelector(model, node) {
                var cls = (node.defn.ct === '4' ? 'DocActionSelector' : 'DocSelector');
                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    controller: this.parent.controller,
                    model: model
                });
            },

            newXtab: function newXtab(model, node) {
                var txi = node.defn.txi, xtab,
                    Cls = mstrmojo.DocXtab;

                if (txi) {
                    Cls = $CFC(mstrmojo.DocXtab, [ mstrmojo._CanSupportTransaction, mstrmojo._IsEditableXtab ], {
                        scriptClass: 'mstrmojo.DocXtab'
                    });
                }

                xtab = new Cls({
                    id: node.id,
                    node: node,
                    controller: this.parent.controller
                });

                xtab.model = new mstrmojo.DocXtabModel({
                    xtab: xtab,
                    docModel: model
                });

                return xtab;
            },

            getLinkDrillMixins: function getLinkDrillMixins(useHover) {
                return useHover ? [ mstrmojo._HasHoverButton ] : [];
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.DocBuilder",
                         "mstrmojo.MobileDocLayoutViewer",
                         "mstrmojo.MobileDocXtabGraph",
                         "mstrmojo._XtabSeamlessIncrementalFetch",
                         "mstrmojo._HasScrollbox",
                         "mstrmojo.MobileXtab",
                         "mstrmojo.graph.MobileDocXtabCanvasGraph",
                         "mstrmojo.DynamicClassFactory",
                         "mstrmojo.android.DocSelectorViewFactory",
                         "mstrmojo.android.DocPanelStack",
                         "mstrmojo.android.AndroidDocPanel",
                         "mstrmojo.android.ui.DocButton",
                         "mstrmojo.android.HTMLContainer",
                         "mstrmojo._HasRelativeUrls",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsDocXtab",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo._IsInteractiveGrid",
                         "mstrmojo.android.AndroidDICConfig",
                         "mstrmojo.AndroidVisList",
                         "mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.maps.AndroidDocMap",
                         "mstrmojo.maps.MapInfoWindowLayoutViewer",
                         "mstrmojo.android.ui._IsTouchLink",
                         "mstrmojo._HasDrillLinks");


    var $CFC = mstrmojo.DynamicClassFactory.newComponent,
        $HRU = mstrmojo._HasRelativeUrls,
        $FREE = mstrmojo.Obj.free,
        $EN = mstrmojo.EnumRWUnitType,
        $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash;

    
    mstrmojo.DocXtab = $CFC(mstrmojo.MobileXtab, [ mstrmojo._Formattable, mstrmojo._IsSelectorTarget, mstrmojo._IsDocXtab ], {
        scriptClass: 'mstrmojo.DocXtab',
        
        scrollerConfig: {
            scrollPast: false
        }
    });

    
    var mapSuperPkg = (!!mstrMobileApp && !!mstrMobileApp.useNativeMap && mstrMobileApp.useNativeMap()) ? 'androidmap' : 'jsmap';
    mstrmojo.maps.AndroidDocLayoutMap = $CFC(mstrmojo.maps[mapSuperPkg].AndroidDocMap, null, {
        scriptClass: 'mstrmojo.maps.AndroidDocLayoutMap'
    });

    
    mstrmojo.MobileDocImage = $CFC(mstrmojo.DocImage, [ $HRU ], {
        scriptClass: 'mstrmojo.MobileDocImage',
        relativeUrls: [ 'v' ]
    });

    mstrmojo.MobileDocHTMLContainer = $CFC(mstrmojo.DocHTMLContainer, [ $HRU ], {
        scriptClass: 'mstrmojo.MobileDocHTMLContainer',
        relativeUrls: [ 'v' ]
    });

    
    var fh = mstrmojo.DocLayout.prototype.formatHandlers.domNode;
    $ARR.removeItem(fh, 'border');
    $ARR.removeItem(fh, 'background-color');

    
    mstrmojo.MobileDocBuilder = mstrmojo.declare(
        
        mstrmojo.DocBuilder,

        
        null,

        
        {
            scriptClass: "mstrmojo.MobileDocBuilder",

            init: function init(props) {
                this._super(props);

                if (!this.destroyObjects) {
                    this.destroyObjects = [];
                }

                
                this.selectorFactory = new mstrmojo.android.DocSelectorViewFactory();

                var clsMap = this.classMap;

                
                clsMap[$EN.GRAPH] = (mstrApp.onMobileDevice() && mstrApp.useBinaryFormat) ? {
                    n: 'graph.MobileDocXtabCanvasGraph',
                    scriptClass: 'mstrmojo.graph.MobileDocXtabCanvasGraph'
                } : {
                    n: 'MobileDocXtabGraph',
                    scriptClass: 'mstrmojo.MobileDocXtabGraph'
                };

                
                clsMap[$EN.IMAGE] = {
                    n: 'MobileDocImage',
                    scriptClass: 'mstrmojo.MobileDocImage'
                };

                
                clsMap[$EN.PANELSTACK] = {
                    n: 'PanelStack',
                    scriptClass: 'mstrmojo.android.DocPanelStack'
                };

                
                clsMap[$EN.PANEL] = {
                    n: 'Panel',
                    scriptClass: 'mstrmojo.android.AndroidDocPanel'
                };

                
                clsMap[$EN.TEXTFIELD + 'B'] = {
                    n: 'Button',
                    scriptClass: 'mstrmojo.android.ui.DocButton'
                };
            },

            visList: mstrmojo.AndroidVisList,

            
            getLayoutViewerClass: function getLayoutViewerClass(node) {
                
                if (node.defn.iw) {
                    
                    var className = 'MapInfoWindowLayoutViewer';

                    
                    if (mstrApp.onMobileDevice()) {
                        
                        className = 'Mobile' + className;
                    }

                    
                    return mstrmojo.maps[className];
                }

                
                return mstrmojo.MobileDocLayoutViewer;
            },

            
            newLayout: function newLayout(model, node) {
                var vis = node.defn.visName;

                
                if (vis) {
                    
                    var groupByInfo = node.data.gbys;

                    
                    
                    
                    var layoutModel = model,
                        layoutNode = $HASH.clone(node);

                    
                    var visGrid = mstrmojo.Vis.getVisGrid(model, node, node.defn.visGK);
                    if (visGrid) {
                        node.data = visGrid.data;

                        if (node.defn.vp && Object.keys(node.defn.vp).length > 0) { 
                            visGrid.data.vp = node.defn.vp;
                        }

                        
                        node.data.layoutModel = layoutModel;
                        node.data.layoutNode = layoutNode;

                        
                        node.data.gbys = groupByInfo;
                    }

                    
                    node.defn = model.makeObservable(node.defn);

                    this.destroyObjects.push(node.defn);

                    
                    var visObj = this.visList.getVis(vis),
                        viewClassName = (visObj.dc !== undefined) ? visObj.dc : visObj.c,
                        xtab,
                        xtabModel;

                    
                    
                    
                    try {

                        
                        if (/AndroidDocMap/.test(viewClassName)) {
                            
                            viewClassName = 'maps.AndroidDocLayoutMap';
                        }

                        var ViewClass = $HASH.walk(viewClassName, mstrmojo),                
                            ModelClass = $HASH.walk(visObj.m || "DocVisModel", mstrmojo),  
                            controller = this.parent.controller;                            

                        
                        xtab = new ViewClass({
                            id: (visGrid && visGrid.id) || node.id,
                            node: node,
                            n: node.defn.title,             
                            controller: controller,
                            gb: node.data.gbys,             
                            isFullScreenWidget: true        
                        });

                        
                        xtabModel = new ModelClass({
                            xtab: xtab,
                            controller: controller,
                            docModel: model
                        });

                        
                        xtab.setModel(xtabModel);

                    } catch (e) {
                        
                        xtab = $FREE(xtab);
                        xtabModel = $FREE(xtabModel);

                        throw e;
                    }

                    return xtab;
                }

                return this._super(model, node);
            },

            
            newHTMLContainer: function (model, node) {
                
                var clsName = (node.defn.ht === 0) ? 'MobileDocHTMLContainer' : 'android.HTMLContainer',
                    Cls = mstrmojo.hash.walk(clsName, mstrmojo);

                
                return new Cls({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            getLinkDrillMixins: function getLinkDrillMixins(useHover) {
                
                return [ mstrmojo.android.ui._IsTouchLink, mstrmojo._HasDrillLinks ];
            },

            createPortlet: function createPortlet(t, node, w) {
                
                if (node.defn.ifw) {
                    
                    var selPanelKey = w.selectedKey,
                        selPanelDef = (w.model.getUnitDefinitions(selPanelKey) || {})[selPanelKey],
                        selPanelTitle = selPanelDef && selPanelDef.ttl;

                    w.defn.ttl = ((w.titleSrc === w.TTL_SRC_PANEL) ? selPanelTitle : w.defn.ttl) || '';

                    if (!mstrApp.isTablet()) {
                        
                        w.title = w.defn.ttl;

                        
                        return w;
                    }
                }

                return this._super(t, node, w);
            },

            destroy: function destroy() {
                var destroyObjects = this.destroyObjects,
                    i;
                if (destroyObjects) {
                    for (i = 0; i < destroyObjects.length; i++) {
                        if (destroyObjects[i].destroy) {
                            destroyObjects[i].destroy();
                        }
                    }
                }
                this._super();
            }
        }
    );

}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Doc",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._IsRwDocument",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.DocModel");
    
    var $A = mstrmojo.array,
        $AFE = $A.forEach;
    
        
        
    function isInfoWindowLayout(l){
        return (typeof l.defn.iw !== "undefined" && l.defn.iw);
    }
    
    
    mstrmojo.maps.jsmap.AndroidMapDoc = mstrmojo.declare(
        
        mstrmojo.Doc,
        
        null,
        
        
        {
            scriptClass: "mstrmojo.maps.jsmap.AndroidMapDoc",
            
            cssClass: 'mstrmojo-Doc',
            
            
            addChild: function(view) {
                
                view.height = this.height;
                view.width = this.width;
                
                
                view.visible = true;
            
                
                this.addChildren([ view ]);
            },
            
            buildChildren: function buildChildren(noAddChildren) {
                
                
                this._layouts = this._super(true);
            },
            
            
            getLoadingPlaceholder: function(view) {
                var n = view.n || "";
                return new mstrmojo.Label({
                    cssClass: 'pre-loader',
                    n: n,
                    k: view.k,
                    isPreloader: true,
                    t: "foo"
                });
            },
                                    
            
            cleanUpLastWidget: function cleanUpLastWidget(destroy) {
                this._super(false);
            },
            
            
            
            selectLayout: function selectLayout(layout, updateServer,callback) {
                this._super(layout, updateServer,callback);
                
                return layout;
            },
                        
            
            replaceView: function replaceView (view, targetView) {
                
                view.slot = targetView.slot;
                
                
                this.removeChildren(targetView, true);
                targetView.unrender();
                targetView.destroy();
                
                
                this.addChild(view);                
                return view;
            },

            replaceLayout: function replaceLayout(oldLayout, newLayoutNode) {
                
                var layouts = this._layouts || [],
                    idx = $A.find(layouts, 'k', oldLayout.k);
                    
                
                if ( idx >=0 ) {
                    oldLayout.unrender();
                    oldLayout.destroy();
                }
                                
                
                var c = this.builder.build([ newLayoutNode ], this.model)[0];
                
                
                
                if ( idx >=0 ) {
                    layouts[idx] = c;
                } else {
                    layouts.push(c);
                }
                
                
                this._layouts = layouts;
                
                
                return c;
            },
            
            onLayoutRebuilt: function onLayoutRebuilt(layout) {
                
                this.replaceView(layout, this.currentView);
                this.currentView = layout;
                layout.set("visible",true);
            },
                        
            
            destroy: function destroy(ignoreDom) {
                $AFE(this._layouts, function (lyt) {
                    lyt.destroy(ignoreDom);
                });
                
                this._super(ignoreDom);
            }            
            
                        
        }
    );
    
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Doc",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._IsRwDocument",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.DocModel");
    
    var $A = mstrmojo.array,
        $AFE = $A.forEach;
    
        
        
    function isInfoWindowLayout(l){
        return (typeof l.defn.iw !== "undefined" && l.defn.iw);
    }
    
    
    mstrmojo.maps.androidmap.InfoWindowDoc = mstrmojo.declare(
        
        mstrmojo.Doc,
        
        null,
        
        
        {
            scriptClass: "mstrmojo.maps.androidmap.InfoWindowDoc",
            
            cssClass: 'mstrmojo-Doc',
            
            
            addChild: function(view) {
                
                view.height = this.height;
                view.width = this.width;
                
                
                view.visible = true;
            
                
                this.addChildren([ view ]);
            },
            
            buildChildren: function buildChildren(noAddChildren) {
                
                
                this._super(true);
                this._layouts = this.getLayouts();
            },
            
            
            getLoadingPlaceholder: function(view) {
                var n = view.n || "";
                return new mstrmojo.Label({
                    cssClass: 'pre-loader',
                    n: n,
                    k: view.k,
                    isPreloader: true,
                    t: "foo"
                });
            },
                                    
            
            cleanUpLastWidget: function cleanUpLastWidget(destroy) {
                this._super(false);
            },
            
            
            
            selectLayout: function selectLayout(layout, updateServer,callback) {
                this._super(layout, updateServer,callback);
                
                return layout;
            },
                        
            
            replaceView: function replaceView (view, targetView) {
                
                view.slot = targetView.slot;
                
                
                this.removeChildren(targetView, true);
                targetView.unrender();
                targetView.destroy();
                
                
                this.addChild(view);                
                return view;
            },

            replaceLayout: function replaceLayout(oldLayout, newLayoutNode) {
                
                var layouts = this._layouts || [],
                    idx = $A.find(layouts, 'k', oldLayout.k);
                    
                
                if ( idx >=0 ) {
                    oldLayout.unrender();
                    oldLayout.destroy();
                }
                                
                
                var c = this.builder.build([ newLayoutNode ], this.model)[0];
                
                
                
                if ( idx >=0 ) {
                    layouts[idx] = c;
                } else {
                    layouts.push(c);
                }
                
                
                this._layouts = layouts;
                
                
                return c;
            },
            
            onLayoutRebuilt: function onLayoutRebuilt(layout) {
                
                this.replaceView(layout, this.currentView);
                this.currentView = layout;
                layout.set("visible",true);
            },
                        
            
            destroy: function destroy(ignoreDom) {
                $AFE(this._layouts, function (lyt) {
                    lyt.destroy(ignoreDom);
                });
                
                this._super(ignoreDom);
            }            
            
                        
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.DocumentController",
                         "mstrmojo.maps.jsmap.InfoWindow",
                         "mstrmojo.maps.jsmap.AndroidMapDoc",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.MobileDocBuilder");

    var $HASH = mstrmojo.hash;

    
    mstrmojo.maps.jsmap.DocInfoWindowController = mstrmojo.declare(

        mstrmojo.android.controllers.DocumentController,

        null,

        
        {
            scriptClass: 'mstrmojo.maps.jsmap.DocInfoWindowController',

            initModel: function initModel() {
                var params = this._startParams,
                    model = this._super(params);

                
                var docParams = params.docParams;
                if (docParams) {
                    
                    model.st = docParams.st;
                    model.n = docParams.ttl;
                }

                return model;
            },

            restart: function start(params) {
                
                var rootContainer = mstrApp.rootView.rootContainer;
                rootContainer.render();

                var model = this.model = this.initModel(),
                    doc = this.doc;

                $HASH.copy($HASH.copy(params.docParams, {
                    controller: this,
                    model: model,
                    renderMode: 'normal',
                    placeholder: rootContainer.domNode
                }), doc);

                if (doc.hasRendered) {
                    doc.unrender();
                }

                doc.removeChildren();
                doc.render();

                this.loadLayout(params, true);
            },

            start: function start(params) {
                
                this.model = this.initModel();

                
                this.view = this.doc = this.createView(null, params);

                
                if (params.model.vp.lyt !== '') {
                    this.loadLayout(params);
                } else {
                    this.loadPanelStack(params);
                }
            },

            createView: function createView(res, params) {
                
                var doc = new mstrmojo.maps.jsmap.AndroidMapDoc($HASH.copy(params.docParams, {
                    controller: this,
                    model: this.model,
                    renderMode: 'normal',
                    placeholder: mstrApp.rootView.rootContainer.domNode
                }));

                
                doc.builder = new mstrmojo.MobileDocBuilder({
                    parent: doc
                });

                
                
                

                
                doc.render();

                return doc;
            },

            loadPanelStack: function loadPanelStack() {
                var controller = this,
                    docModel = this.model,
                    elemID = docModel.gts.row[0].id,
                    sc = this.sc;

                docModel.getDataService().setDocSelectorElements(sc.ck, elemID, sc.ckey, sc.include, {
                    success: function (res) {
                        var id = elemID + '_ifw',
                            w = mstrmojo.all[id],
                            psId = '*l' + res.currlaykey + '*k' + sc.tks + '*t' + docModel.buildTime;

                        if (w) {
                            w.destroy();
                        }

                        controller.doc.builder.newInfoWindow({
                            id: id,
                            parent: controller,
                            builder: controller.builder,
                            model: docModel,
                            psKey: controller.sc.tks,
                            psId: psId
                        }).render();

                    },
                    submission: mstrmojo.emptyFn,
                    complete: mstrmojo.emptyFn
                });
            },

            loadLayout: function loadLayout(params, reload) {
                var d = this.model = params.model,
                    doc = this.doc,
                    initialIdx = params.rowIndex,
                    layouts = doc.getLayouts(),
                    lyt = d.vp.lyt,
                    layout = layouts[mstrmojo.array.find(layouts, 'k', lyt)];  

                if (reload) {
                    layout.defn.loaded = false;
                }

                
                
                
                doc.selectLayout(layout, true, {
                    success: function () {
                        var sep = '\x1F',
                            dssXmlTypeAttribute = '12', 
                            attribute = d.gts.row[0],
                            attrID = attribute.id,
                            elemID = attribute.es[initialIdx].id,
                            
                            gbIDs = attrID + sep + dssXmlTypeAttribute + sep + elemID,
                            taskParams = { layoutKey: lyt, groupByIDs: gbIDs };

                        doc.getNewLayout(taskParams, doc.getLayouts(), false, {
                            complete: function () {
                                mstrApp.hideMessage();
                                var mapJs = window.mapInfoJSInterface;
                                if (mapJs !== undefined) {
                                    mapJs.setWaitScreenVisibility(false);
                                }
                            },
                            submisson: function () {
                                mstrApp.showMessage();
                            },
                            success: function (res) {
                                doc.gb = res.gb;
                                doc.currentView = doc.replaceView(res, mstrApp.rootView.rootContainer);
                                res.set('visible', true);
                            }
                        }, true);
                    }
                });

                
                
            },

            
            update: function update(idx) {
                var doc = this.doc,
                    
                    gb = doc.gb.groupbys[0],
                    key = gb.k,
                    
                    elemID = gb.unit.elms[parseInt(idx, 10) + 1].v;

                doc.controller.onGroupBy(this, {
                    groupbyKey: key,
                    elementId: elemID
                }, {
                    complete: function () {
                        var mapJs = window.mapInfoJSInterface;
                        if (mapJs !== undefined) {
                            mapJs.setWaitScreenVisibility(false);
                        }
                    }
                });
            }
        }
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.MobileDocBuilder");
    
    mstrmojo.InfoWindowDocBuilder = mstrmojo.declare(
        mstrmojo.MobileDocBuilder,
        null,
        {
            scriptClass: 'mstrmojo.InfoWindowDocBuilder',
            
            createPortlet: function createPortlet(t, node, w) {
                
                return mstrmojo.DocBuilder.prototype.createPortlet.call(this, t, node, w);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.android.ui.RootView",
                         "mstrmojo.android.ui.ViewSwitcher",
                         "mstrmojo.android.ui.ActionBar",
                         "mstrmojo.android.ui.FolderView",
                         "mstrmojo.android.ui.ResultSetView",
                         "mstrmojo.android.ui.DocumentView",
                         "mstrmojo.graph.MobileXtabCanvasGraph",
                         "mstrmojo.android.ui.PromptsView",
                         "mstrmojo.android.ui.PropertiesView",
                         "mstrmojo.android.ui.SettingsView",
                         "mstrmojo.AndroidXtabStandalone",
                         "mstrmojo.MobileDocBuilder",
                         "mstrmojo.MobileGraph",
                         "mstrmojo.hash",
                         "mstrmojo.android.ui.NoProjectsView");

    
    mstrmojo.android.factories.ViewFactory = mstrmojo.declare(

        mstrmojo.Obj,

        null,

        
        {
            scriptClass: 'mstrmojo.android.factories.ViewFactory',

            
            newRootView: function newRootView(params) {
                return new mstrmojo.android.ui.RootView(params);
            },

            
            newActionBarView: function newActionBarView(params) {
                return new mstrmojo.android.ui.ActionBar(params);
            },

            
            newSwitcherView: function newSwitcherView(params) {
                return new mstrmojo.android.ui.ViewSwitcher(params);
            },

            
            newFolderView: function newFolderView(params) {
                return new mstrmojo.android.ui.FolderView(params);
            },

            
            newResultSetView: function newResultSetView(params) {
                return new mstrmojo.android.ui.ResultSetView(params);
            },

            
            newXtabView: function newXtabView(params) {
                var viz = params.viz,
                    clazz = mstrmojo.hash.walk( (viz) ? viz.c : 'AndroidXtabStandalone', mstrmojo );
                return new clazz(params);
            },

            
            newDocumentView: function newDocumentView(params) {
                var doc = new mstrmojo.android.ui.DocumentView(mstrmojo.hash.copy(params, {
                    cssClass: 'mstrmojo-DocumentView'
                }));

                
                doc.builder = new mstrmojo.MobileDocBuilder({
                    parent: doc
                });

                return doc;
            },

            
            newGraphView: function newGraphView(params) {
                var Clazz = (mstrApp.onMobileDevice() && mstrApp.useBinaryFormat) ? mstrmojo.graph.MobileXtabCanvasGraph : mstrmojo.MobileGraph;
                return new Clazz(params);
            },

            
            newPromptsView: function newPromptsView(params) {
                return new mstrmojo.android.ui.PromptsView(params);
            },

            
            newPropertiesView: function newPropertiesView(params) {
                return new mstrmojo.android.ui.PropertiesView(params);
            },

            
            newSettingsView: function newSettingsView(params) {
                return new mstrmojo.android.ui.SettingsView(params);
            },

            
            newCalendarDialogView: mstrmojo.emptyFn,

            
            newNoProjectsView: function newNoProjectsView(params) {
                return new mstrmojo.android.ui.NoProjectsView(params);
            },

            
            newHeatMapEditorView: function (params) {
                return new mstrmojo.VisHeatMapPopup(params);
            },

            
            newView: function newView(type, params) {
                return this['new' + type + 'View'](params);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.factories.ViewFactory",
                         "mstrmojo.android.medium.ui.ActionBar",
                         "mstrmojo.android.medium.ui.ResultSetView",
                         "mstrmojo.android.medium.ui.HomeScreenView",
                         "mstrmojo.android.medium.ui.TransactionView",
                         "mstrmojo.android.medium.ui.TxEditDoc",
                         "mstrmojo.android.medium.ui.TxTypeList",
                         "mstrmojo.android.medium.ui.CalendarDialog");

    
    mstrmojo.android.medium.factories.ViewFactory = mstrmojo.declare(

        mstrmojo.android.factories.ViewFactory,

        null,

        
        {
            scriptClass: 'mstrmojo.android.medium.factories.ViewFactory',

            
            newActionBarView: function newActionBarView(params) {
                return new mstrmojo.android.medium.ui.ActionBar(params);
            },

            
            newResultSetView: function newResultSetView(params) {
                return new mstrmojo.android.medium.ui.ResultSetView(params);
            },
            
            
            newHomeScreenView: function newHomeScreenView(params) {
                return new mstrmojo.android.medium.ui.HomeScreenView(params);
            },
            
            
            newTransactionsView: function newTransactionsView(params) {
                return new mstrmojo.android.medium.ui.TransactionView(params);
            }, 

            
            newTransactionsEditDocView: function newTransactionsEditDocView(params) {
                return new mstrmojo.android.medium.ui.TxEditDoc(params);
            },
            
            
            newTransactionsTypeListView: function newTransactionsTypeListView(params) {
                return new mstrmojo.android.medium.ui.TxTypeList(params);
            },
            
            
            newCalendarDialogView: function newCalendarDialogView(params) {
                return new mstrmojo.android.medium.ui.CalendarDialog(params);
            }           
            
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.DocumentController",
                         "mstrmojo.maps.androidmap.InfoWindowDoc",
                         "mstrmojo.maps.androidmap.AndroidDocMapInfoWindow",
                         "mstrmojo.InfoWindowDocBuilder",
                         "mstrmojo.Overlay",
                         "mstrmojo.hash",
                         "mstrmojo.array");

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array;

    function prepareLayout(res) {
        var dm = this.model,
            key = res.key,
            doc = this.doc,
            layout = {};         

        dm.replaceLayout(key, res);

        
        
        dm.currlaykey = key;

        
        if (res.isSelected) {
            
            layout.zf = res.zf;

            
            doc.selectLayout(layout, false);
        }

        
        return (doc.rebuildLayout(key, doc.getLayouts()));
    }

    
    mstrmojo.maps.androidmap.DocInfoWindowController = mstrmojo.declare(

        mstrmojo.android.controllers.DocumentController,

        null,

        
        {
            scriptClass: "mstrmojo.maps.androidmap.DocInfoWindowController",

            initModel: function initModel() {
                var params = this._startParams,
                    model = this._super(params);

                
                var docParams = params.docParams;
                if (docParams) {
                    
                    model.st = docParams.st;
                    model.n = docParams.ttl;
                }

                return model;
            },

            destroy: function destroy() {
                
                var widget = this.widget;
                if (widget) {
                    
                    widget.destroy();
                }

                
                this.doc.destroy();

                this._super();
            },

            renderLayout: function renderLayout(res, width, height) {
                var layoutRes = prepareLayout.call(this, res),
                    node = layoutRes.node,
                    w = node.defn.fmts.width,
                    h = node.defn.fmts.height || node.data.mh, 
                    overlay = new mstrmojo.Overlay({
                        parent: this,
                        children: [ layoutRes ]
                    });

                
                overlay.set('width', w);
                overlay.set('height', h);

                
                var cn = document.getElementById('mainInfoWindow');

                
                cn.style.visibility = 'visible';

                
                if (!cn.firstChild) {
                    
                    cn.appendChild(document.createElement('div'));
                }

                overlay.placeholder = cn.firstChild;
                overlay.render();

                window.setTimeout(function () {
                    overlay.setDimensions(height || '300px', width || '400px');
                }, 500);

                
                this.widget = overlay;
            },

            start: function start(params) {
                
                this.model = this.initModel();

                
                this.view = this.doc = this.createView(null, params);

                
                if (mapProxy && mapProxy.registerInfoWindow) {
                    mapProxy.registerInfoWindow(this.id);
                }
            },

            createView: function createView(res, params) {
                
                var doc = new mstrmojo.maps.androidmap.InfoWindowDoc($HASH.copy(params.docParams, {
                    controller: this,
                    model: this.model,
                    renderMode: 'normal',
                    placeholder: mstrApp.rootView.rootContainer.domNode
                }));

                
                doc.builder = new mstrmojo.InfoWindowDocBuilder({
                    parent: doc
                });

                
                
                

                
                doc.render();

                return doc;
            },

            findSelectorTarget: function findSelectorTarget(sc) {
                var targetKeys = sc && sc.tks;
                if (targetKeys) {
                    var model = this.model;
                    $ARR.forEach(targetKeys.split('\u001E'), function (target) {
                        var defn = model.getTargetDefn(target);
                        if (defn[target].ifw) {
                            return target;
                        }
                    });
                }
            },

            renderPanelStack: function renderPanelStack(res, width, height) {
                var d = this.gridProps,
                    dm = this.model,
                    sc = this.getInfoWindowSelectorControl(d);

                
                var tgtDefs = dm.getTargetDefn(res.pukeys || sc.tks);

                
                
                
                dm.updateDataCache(res.data, tgtDefs);

                
                var firstInfoWinKey = this.findSelectorTarget(sc);
                if (firstInfoWinKey) {
                    
                    

                    var id = firstInfoWinKey + "_ifw",
                        w = mstrmojo.all[id],
                        psId = "*l" + res.currlaykey + "*k" + firstInfoWinKey + "*x1*t" + dm.buildTime;

                    
                    if (w) {
                        w.destroy();
                    }

                    var ifw = new mstrmojo.maps.androidmap.AndroidDocMapInfoWindow({
                        id: id,
                        parent: this,
                        builder: this.doc.builder,
                        model: dm,
                        psKey: firstInfoWinKey,
                        psId: psId
                    });

                    
                    var cn = document.getElementById('mainInfoWindow');
                    cn.style.visibility = 'visible';
                    if (!cn.firstChild) {
                        cn.appendChild(document.createElement('div'));
                    }
                    ifw.placeholder = cn.firstChild;
                    ifw.render();

                    
                    this.widget = ifw;
                }
            },

            getInfoWindowSelectorControl: function getInfoWindowSelectorControl(d) {
                
                var sc = this.sc = this.sc || d.gts.row[0].sc;
                return sc;
            }
        }
    );
}());

  
(function() {

    mstrmojo.requiresCls( "mstrmojo.Obj",
                          "mstrmojo.maps.jsmap.InfoWindowController",
                          "mstrmojo.maps.jsmap.DocInfoWindowController"
);

    function startController(params) {
        
    }
    
    
    mstrmojo.maps.jsmap.InfoWindowRootController = mstrmojo.declare(
            
        mstrmojo.Obj,
        
        null,

        
        {
            scriptClass: "mstrmojo.maps.jsmap.InfoWindowRootController",
            
            start: function start(params) {   
                var controllerClass = ( params.isDoc ) ? mstrmojo.maps.jsmap.DocInfoWindowController : mstrmojo.maps.jsmap.InfoWindowController;
                
                
                this.spawn( new controllerClass(params), params);
            },
            
            
            spawn: function spawn(controller, startParams) {
                
                this.nextController = controller;
                controller.prevController = this;
                
                
                controller.start(startParams);
            }
                        
        });
})();

(function() {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.Container",
                         "mstrmojo.Label",
                         "mstrmojo.hash", 
                         "mstrmojo.func",
                         "mstrmojo.dom",
                         "mstrmojo.maps.jsmap.InfoWindow",
                         "mstrmojo.maps.jsmap.InfoWindowController",
                         "mstrmojo.MobileDoc",
                         "mstrmojo.MobileDocBuilder",
                         "mstrmojo.DocModel",
                         "mstrmojo.android.ViewFactory",
                         "mstrmojo.MobileConfiguration",
                         "mstrmojo._CanMakeServerProxyRequests"
                     );
    
    var $DOM = mstrmojo.dom;

    function handleError(res, app) {
        var msg = [],
            map = {
                name: 'Exception',
                message: 'Error',
                sourceURL: 'Source URL',
                fileName: 'File',
                lineNumber: 'Line',
                line: 'Line',
                method: 'Method'
            };
        
        
        res = res || {};

        
        mstrmojo.hash.forEach(map, function (v, n) {
            if (n in res) {
                msg.push(v + ': ' + res[n]); 
            }
        });
        
        
        if (res.getResponseHeader) {
            
            msg.push('XHR: ' + res.getResponseHeader('X-MSTR-TaskFailureMsg'));
        }
        
        
        msg = msg.join('\n');
        
        
        if (app && app.rootView) {
            
            app.rootView.hideMessage();
        }
        
        if (!res.handledError && msg.length > 0) {
            mstrmojo.alert(msg);
            res.handledError = true;
        }
        
        mstrmojo.dbg(res.stack || msg);
    }
    
    function onWindowError(errMsg, fName, lineNum) {
        handleError({ 
            message: errMsg, 
            fileName: fName, 
            lineNumber: lineNum 
        });
    }
    
    function _getDocParams(dd) { 
        return {
            ab: dd.ab,
            did: dd.did,
            st: dd.st,
            ttl: dd.ttl
        };
    }
    
    function _getDocModel(dd) {
        return {
            mid: dd.mid,
            bs: dd.bs,
            defn: dd.defn,
            data: dd.data
        };
    }

    
    mstrmojo.maps.jsmap.InfoWindowApp = mstrmojo.declare(
        mstrmojo.Obj,
        
        [mstrmojo._CanMakeServerProxyRequests],  

        
        {
            scriptClass: "mstrmojo.maps.jsmap.InfoWindowApp",
            
            init: function init(props){
                this._super(props);
                var fn = window.onerror;
                window.onerror = (fn) ? mstrmojo.func.composite([ onWindowError, fn ]) : onWindowError;

                
                this.handleError = handleError;
            },
            
            
            start: function start() {
                
                
                
                if ( !this.onMobileDevice() ) {
                    mstrMobileApp.saveConfiguration( mstrMobileApp.getConfiguration() );
                }
                
            	mstrMobileApp.setBinaryFormat(this.getConfiguration().getBinaryMode());
            	this.useBinaryFormat = mstrMobileApp.useBinaryFormat();  
                                
                
                var vw = this.rootView = new mstrmojo.Container({
                    id: "rootView",
                    placeholder:this.placeholder,
                    markupString: '<div id="{@id}" style="{@cssText}">' +
                                    '<div></div>' +
                                    '<div></div>' +
                                  '</div>',
                    markupSlots: {
                        containerNode: function() { return this.domNode.firstChild; },
                        msgNode: function() { return this.domNode.lastChild;}
                    },
                    children: [
                    {
                        scriptClass: 'mstrmojo.Container',
                        slot: "containerNode",
                        alias: "rootContainer",
                        markupString: '<div></div>'
                    },                    
                    {
                        scriptClass: 'mstrmojo.Label',
                        alias: 'msg',
                        slot: "msgNode",
                        text: 'Loading...',
                        visible: true
                    }],    
                    showMessage: function(text) {
                        var msg = text || this.msg.text,
                            msgNode = msg.domNode,
                            msgNodeStyle = msgNode.style;                        
                        
                        msgNode.innerText = msg;
                        
                        msgNodeStyle.display = 'block';
                        msgNodeStyle.opacity = 1;
                    },
                    hideMessage: function hideMessage() {
                        this.msg.domNode.style.opacity = 0;
                    }
                });
                
                
                vw.render();

                
                var ctlr = this.rootController = new mstrmojo.maps.jsmap.InfoWindowRootController({
                        id: "rootController",
                        firstView: vw
                    }),
                    docParams,
                    docModel;
                                
                if ( this.isDoc ) {
                    var dd = this.getDocData();
                    
                    docParams = _getDocParams(dd);
                    docModel = _getDocModel(dd);
                }
                                                    
                
                ctlr.start( { 
                    placeholder: this.placeholder,
                    rowIndex: this.rowIndex,
                    isDoc: this.isDoc,
                    docParams: docParams,
                    docModel: docModel,
                    model: this.getModel(),
                    sc: this.sc
                } );
            },
            
            
            loadNewDoc: function( rowIndex ) {
                var dd = this.getDocData(),
                    docParams = _getDocParams(dd),
                    docModel = _getDocModel(dd);

                this.rootController.nextController.restart( {   
                    placeholder: this.placeholder,
                    rowIndex: rowIndex,
                    isDoc: true,
                    docParams: docParams,
                    docModel: docModel,
                    model: this.getModel()
                } );
            },
            
            getDocData: function() {
            	return eval('(' + mapDataObj.getDocData() + ')');
            },
            getModel: function() {
            	return eval('(' + mapDataObj.getGridData() + ')');
            },
            
            
            getConfiguration: function getConfiguration() {
                if (!this._cfg) {
                    this._cfg = new mstrmojo.MobileConfiguration();
                }
                
                return this._cfg;
            },

            
            showMessage: function showMessage(msg) {
                this.rootView.showMessage(msg);
            },
            
            
            hideMessage: function hideMessage() {
                this.rootView.hideMessage();
            },

            update: function(rowIndex) {
                this.rootController.nextController.update(rowIndex);
            },
            
                        
            onMobileDevice: function onMobileDevice() { 
                return !mstrApp.isHosted();
            },
            
            
            isTouchApp: function isTouchApp() {
                return ($DOM.isIPad || $DOM.isAndroid || mstrApp.onMobileDevice());
            },
            
            
            onerror: function onerror(res) {
                handleError(res, this);
            },
            
            isHosted: function isHosted() {
            	return mstrMobileApp.isProxy;
            }
            

            
        });
    

}());

  
(function() {

    mstrmojo.requiresCls( "mstrmojo.Obj",
                          "mstrmojo.maps.androidmap.DocInfoWindowController"
);

    function startController(params) {
        
    }
    
    
    mstrmojo.maps.androidmap.InfoWindowRootController = mstrmojo.declare(
            
        mstrmojo.Obj,
        
        null,

        
        {
            scriptClass: "mstrmojo.maps.androidmap.InfoWindowRootController",
            
            start: function start(params) {
                
                this.spawn( new mstrmojo.maps.androidmap.DocInfoWindowController(params), params);
            },
            
            
            spawn: function spawn(controller, startParams) {
                
                this.nextController = controller;
                controller.prevController = this;
                
                
                controller.start(startParams);
            },
            
            destroy: function destroy() {
                this.nextController.destroy();
                this._super();
            }
                        
        });
})();

(function() {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.Container",
                         "mstrmojo.Label",
                         "mstrmojo.hash", 
                         "mstrmojo.func",
                         "mstrmojo.dom",
                         "mstrmojo.android.Dialog",
                         "mstrmojo.MobileDoc",
                         "mstrmojo.MobileDocBuilder",
                         "mstrmojo.DocModel",
                         "mstrmojo.MobileConfiguration",
                         "mstrmojo._CanSupportOfflineTransactions",
                         "mstrmojo._CanMakeServerProxyRequests"
                     );
    
    var $DOM = mstrmojo.dom,
    	dialogs = [];

    function handleError(res, app) {
        var msg = [],
            map = {
                name: 'Exception',
                message: 'Error',
                sourceURL: 'Source URL',
                fileName: 'File',
                lineNumber: 'Line',
                line: 'Line',
                method: 'Method'
            };
        
        
        res = res || {};

        
        mstrmojo.hash.forEach(map, function (v, n) {
            if (n in res) {
                msg.push(v + ': ' + res[n]); 
            }
        });
        
        
        if (res.getResponseHeader) {
            
            msg.push('XHR: ' + res.getResponseHeader('X-MSTR-TaskFailureMsg'));
        }
        
        
        msg = msg.join('\n');
        
        
        if (app && app.rootView) {
            
            app.rootView.hideMessage();
        }
        
        if (!res.handledError && msg.length > 0) {
            mstrmojo.alert(msg);
            res.handledError = true;
        }
        
        mstrmojo.dbg(res.stack || msg);
    }
    
    function onWindowError(errMsg, fName, lineNum) {
        handleError({ 
            message: errMsg, 
            fileName: fName, 
            lineNumber: lineNum 
        });
    }
    
    function _getDocParams(dd) { 
        return {
            ab: dd.ab,
            did: dd.did,
            st: dd.st,
            ttl: dd.ttl
        };
    }
    
    function _getDocModel(dd) {
        return {
            mid: dd.mid,
            bs: dd.bs,
            ci: dd.ci,
            defn: dd.defn,
            currlaykey: dd.currlaykey,
            data: dd.data
        };
    }

    
    mstrmojo.maps.androidmap.InfoWindowApp = mstrmojo.declare(
        mstrmojo.Obj,
        
        [mstrmojo._CanSupportOfflineTransactions],

        
        {
            scriptClass: "mstrmojo.maps.androidmap.InfoWindowApp",
            
            init: function init(props){
                this._super(props);
                var fn = window.onerror;
                window.onerror = (fn) ? mstrmojo.func.composite([ onWindowError, fn ]) : onWindowError;

                
                this.handleError = handleError;
            },
            
            
            start: function start() {
                
                var descriptors = eval(String(mstrMobileApp.getResourceBundleJson()));
                
                if (descriptors && descriptors !== "") {
                    mstrmojo.populateDescriptors(descriptors);
                }
                
                
                
                if ( !this.onMobileDevice() ) {
                    mstrMobileApp.saveConfiguration( mstrMobileApp.getConfiguration() );
                }
                
            	mstrMobileApp.setBinaryFormat(this.getConfiguration().getBinaryMode());
            	this.useBinaryFormat = mstrMobileApp.useBinaryFormat();  
            	
            	mstrApp.oflnTxModel = new mstrmojo.OfflineTransactionModel();
                                
                
                var vw = this.rootView = new mstrmojo.Container({
                    id: "rootView",
                    placeholder:this.placeholder,
                    markupString: '<div id="{@id}" style="{@cssText}">' +
                                    '<div></div>' +
                                    '<div></div>' +
                                  '</div>',
                    markupMethods: {
                        onvisibleChange: function () { this.domNode.style.display = (this.visible) ? 'block' : 'none'; }
                    },                                     
                    markupSlots: {
                        containerNode: function() { return this.domNode.firstChild; },
                        msgNode: function() { return this.domNode.lastChild;}
                    },
                    children: [
                    {
                        scriptClass: 'mstrmojo.Container',
                        slot: "containerNode",
                        alias: "rootContainer",
                        markupString: '<div></div>'
                    },                    
                    {
                        scriptClass: 'mstrmojo.Label',
                        alias: 'msg',
                        slot: "msgNode",
                        text: 'Loading...',
                        visible: true
                    }],    
                    getContentDimensions: function getContentDimensions() {
                        var contentChild = this.containerNode;
                        return {
                            h: parseInt(contentChild.height, 10),
                            w: parseInt(contentChild.width, 10)
                        };
                    },
                    showMessage: function(text) {
                        var msg = text || this.msg.text,
                            msgNode = this.msg.domNode,
                            msgNodeStyle = msgNode.style;                        
                        
                        msgNode.innerText = msg;
                        
                        msgNodeStyle.display = 'block';
                        msgNodeStyle.opacity = 1;
                    },
                    hideMessage: function hideMessage() {
                        this.msg.domNode.style.opacity = 0;
                    }
                });
                
                
                vw.render();

                
                var ctlr = this.rootController = new mstrmojo.maps.androidmap.InfoWindowRootController({
                        id: "rootController",
                        firstView: vw
                    }),
                    dd = this.getDocData(),
                    docParams = _getDocParams(dd),
                    docModel = _getDocModel(dd);

                ctlr.start({ 
                    placeholder: vw.id,
                    parent: this,
                    docParams: docParams,
                    docModel: docModel,
                    gridProps: this.getGridProp(),
                    sc: this.sc
                } );
                
                vw.set('visible', false);
            },
            
            onLink: function onLink(params) {
                if(mapProxy && mapProxy.sendControllerAction) {
                    mapProxy.sendControllerAction('onLink', JSON.stringify(params));
                }
            },
            
            onDrill: function(params) {
                if(mapProxy && mapProxy.sendControllerAction) {
                    mapProxy.sendControllerAction('onDrill', JSON.stringify(params));
                }
            },
            
            clearContent: function clearContent() {
                
                var iw = document.getElementById('mainInfoWindow');
                iw.style.visibility = 'hidden';
            },
            
            loadNewDoc: function() {
                mstrmojo.hash.forEach(mstrmojo.all, function(item) {
                    item.destroy();
                });
                this.start();
            },
            
            
            
            
            getDocData: function() {
            	return eval('(' + mapDataObj.getDocData() + ')');
            },
            
            getGridProp: function() {
            	return eval('(' + mapDataObj.getGridProp() + ')');
            },
            
            
            getConfiguration: function getConfiguration() {
                if (!this._cfg) {
                    this._cfg = new mstrmojo.MobileConfiguration();
                }
                
                return this._cfg;
            },

            
            showMessage: function showMessage(msg) {
                this.rootView.showMessage(msg);
            },
            
            
            hideMessage: function hideMessage() {
                this.rootView.hideMessage();
            },

                        
            onMobileDevice: function onMobileDevice() { 
                return !mstrApp.isHosted();
            },
            
            
            isTouchApp: function isTouchApp() {
                return ($DOM.isIPad || $DOM.isAndroid || mstrApp.onMobileDevice());
            },
            
            
            onerror: function onerror(res) {
                handleError(res, this);
            },
            
            getScreenDimensions: function getScreenDimensions() {
                
                
                
                var deviceDimensions = String(mstrMobileApp.getScreenDimensions()).split('|');
                return {
                    h: parseInt(deviceDimensions[0], 10), 
                    w: parseInt(deviceDimensions[1], 10)
                };
            },            
            
            
            showDialog: function showDialog(dialogConfig) {
            	
            	if(mapProxy && mapProxy.fullScreenInfoWindow) {
            		mapProxy.fullScreenInfoWindow();
            	}
            	
                
                dialogConfig.scriptClass = dialogConfig.scriptClass || 'mstrmojo.android.Dialog';
                
                var me = this,
                	cfg = mstrmojo.func.wrapMethods(dialogConfig, {
                    
                    onClose: function () {
                		if(mapProxy && mapProxy.restoreInfoWindow) {
                    		mapProxy.restoreInfoWindow();
                    	}
                        dialogs.pop();
                    }
                });
                
                var d = dialogs[dialogs.push(mstrmojo.insert(cfg)) - 1];
                d.render();





                return d;
            },
            
            
            showPopup: function showPopup(popupConfig, anchor) {
                
                popupConfig.scriptClass = popupConfig.scriptClass || 'mstrmojo.android.Popup';
                
                
                if (anchor) {
                    
                    popupConfig.anchor = anchor;
                }
                
                
                return this.showDialog(popupConfig);
            },
            
            
            closeDialog: function closeDialog(noForwarding) {
            	
                if (dialogs.length) {
                    dialogs[dialogs.length - 1].close();
                    return true;
                }
                return false;
            },            
            
            doAfterAnimation: function doAfterAnimation(foo) {
                foo();
            },
            
       	    serverRequest: function serverRequest(params, callback, config) {
	       	    if(callback && callback.proxy) {
		       	    
	       		    var arr = [params, {}, config, callback.proxy];
	       		    mapProxy.sendDocModelCommand(JSON.stringify({method: 'anonymous', params: arr}));
	       	    }
       	    },
       	    
            isHosted: function isHosted() {
                return mstrMobileApp.isProxy;
            },
       	    
       	    closeAllDialogs: mstrmojo.emptyFn,
            
            isHosted: function isHosted() {
            	return mstrMobileApp.isProxy;
            }

            
        });
    

}());
